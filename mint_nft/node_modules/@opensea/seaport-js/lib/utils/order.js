"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.shouldUseMatchForFulfill = exports.generateRandomSalt = exports.mapOrderAmountsFromUnitsToFill = exports.mapOrderAmountsFromFilledStatus = exports.totalItemsAmount = exports.areAllCurrenciesSame = exports.mapInputItemToOfferItem = exports.deductFees = exports.feeToConsiderationItem = void 0;
const ethers_1 = require("ethers");
const utils_1 = require("ethers/lib/utils");
const constants_1 = require("../constants");
const item_1 = require("./item");
const merkletree_1 = require("./merkletree");
const multiplyBasisPoints = (amount, basisPoints) => ethers_1.BigNumber.from(amount)
    .mul(ethers_1.BigNumber.from(basisPoints))
    .div(constants_1.ONE_HUNDRED_PERCENT_BP);
const feeToConsiderationItem = ({ fee, token, baseAmount, baseEndAmount = baseAmount, }) => {
    return {
        itemType: token === ethers_1.ethers.constants.AddressZero ? constants_1.ItemType.NATIVE : constants_1.ItemType.ERC20,
        token,
        identifierOrCriteria: "0",
        startAmount: multiplyBasisPoints(baseAmount, fee.basisPoints).toString(),
        endAmount: multiplyBasisPoints(baseEndAmount, fee.basisPoints).toString(),
        recipient: fee.recipient,
    };
};
exports.feeToConsiderationItem = feeToConsiderationItem;
const deductFees = (items, fees) => {
    if (!fees) {
        return items;
    }
    const totalBasisPoints = fees.reduce((accBasisPoints, fee) => accBasisPoints + fee.basisPoints, 0);
    return items.map((item) => (Object.assign(Object.assign({}, item), { startAmount: (0, item_1.isCurrencyItem)(item)
            ? ethers_1.BigNumber.from(item.startAmount)
                .sub(multiplyBasisPoints(item.startAmount, totalBasisPoints))
                .toString()
            : item.startAmount, endAmount: (0, item_1.isCurrencyItem)(item)
            ? ethers_1.BigNumber.from(item.endAmount)
                .sub(multiplyBasisPoints(item.endAmount, totalBasisPoints))
                .toString()
            : item.endAmount })));
};
exports.deductFees = deductFees;
const mapInputItemToOfferItem = (item) => {
    var _a, _b, _c, _d, _e, _f, _g, _h;
    if ("itemType" in item) {
        // Convert this to a criteria based item
        if ("identifiers" in item || "criteria" in item) {
            const root = "criteria" in item
                ? item.criteria
                : new merkletree_1.MerkleTree(item.identifiers).getRoot();
            return {
                itemType: item.itemType === constants_1.ItemType.ERC721
                    ? constants_1.ItemType.ERC721_WITH_CRITERIA
                    : constants_1.ItemType.ERC1155_WITH_CRITERIA,
                token: item.token,
                identifierOrCriteria: root,
                startAmount: (_a = item.amount) !== null && _a !== void 0 ? _a : "1",
                endAmount: (_c = (_b = item.endAmount) !== null && _b !== void 0 ? _b : item.amount) !== null && _c !== void 0 ? _c : "1",
            };
        }
        if ("amount" in item || "endAmount" in item) {
            return {
                itemType: item.itemType,
                token: item.token,
                // prevent undefined for fungible items
                identifierOrCriteria: (_d = item.identifier) !== null && _d !== void 0 ? _d : "0",
                // @ts-ignore
                startAmount: item.amount,
                // @ts-ignore
                endAmount: (_f = (_e = item.endAmount) !== null && _e !== void 0 ? _e : item.amount) !== null && _f !== void 0 ? _f : "1",
            };
        }
        return {
            itemType: item.itemType,
            token: item.token,
            identifierOrCriteria: item.identifier,
            startAmount: "1",
            endAmount: "1",
        };
    }
    // Item is a currency
    return {
        itemType: item.token && item.token !== ethers_1.ethers.constants.AddressZero
            ? constants_1.ItemType.ERC20
            : constants_1.ItemType.NATIVE,
        token: (_g = item.token) !== null && _g !== void 0 ? _g : ethers_1.ethers.constants.AddressZero,
        identifierOrCriteria: "0",
        startAmount: item.amount,
        endAmount: (_h = item.endAmount) !== null && _h !== void 0 ? _h : item.amount,
    };
};
exports.mapInputItemToOfferItem = mapInputItemToOfferItem;
const areAllCurrenciesSame = ({ offer, consideration, }) => {
    const allItems = [...offer, ...consideration];
    const currencies = allItems.filter(item_1.isCurrencyItem);
    return currencies.every(({ itemType, token }) => itemType === currencies[0].itemType &&
        token.toLowerCase() === currencies[0].token.toLowerCase());
};
exports.areAllCurrenciesSame = areAllCurrenciesSame;
const totalItemsAmount = (items) => {
    const initialValues = {
        startAmount: ethers_1.BigNumber.from(0),
        endAmount: ethers_1.BigNumber.from(0),
    };
    return items
        .map(({ startAmount, endAmount }) => ({
        startAmount,
        endAmount,
    }))
        .reduce(({ startAmount: totalStartAmount, endAmount: totalEndAmount }, { startAmount, endAmount }) => ({
        startAmount: totalStartAmount.add(startAmount),
        endAmount: totalEndAmount.add(endAmount),
    }), {
        startAmount: ethers_1.BigNumber.from(0),
        endAmount: ethers_1.BigNumber.from(0),
    });
};
exports.totalItemsAmount = totalItemsAmount;
/**
 * Maps order offer and consideration item amounts based on the order's filled status
 * After applying the fraction, we can view this order as the "canonical" order for which we
 * check approvals and balances
 */
const mapOrderAmountsFromFilledStatus = (order, { totalFilled, totalSize }) => {
    if (totalFilled.eq(0) || totalSize.eq(0)) {
        return order;
    }
    // i.e if totalFilled is 3 and totalSize is 4, there are 1 / 4 order amounts left to fill.
    const basisPoints = totalSize
        .sub(totalFilled)
        .mul(constants_1.ONE_HUNDRED_PERCENT_BP)
        .div(totalSize);
    return {
        parameters: Object.assign(Object.assign({}, order.parameters), { offer: order.parameters.offer.map((item) => (Object.assign(Object.assign({}, item), { startAmount: multiplyBasisPoints(item.startAmount, basisPoints).toString(), endAmount: multiplyBasisPoints(item.endAmount, basisPoints).toString() }))), consideration: order.parameters.consideration.map((item) => (Object.assign(Object.assign({}, item), { startAmount: multiplyBasisPoints(item.startAmount, basisPoints).toString(), endAmount: multiplyBasisPoints(item.endAmount, basisPoints).toString() }))) }),
        signature: order.signature,
    };
};
exports.mapOrderAmountsFromFilledStatus = mapOrderAmountsFromFilledStatus;
const multiplyDivision = (amount, numerator, denominator) => ethers_1.BigNumber.from(amount).mul(ethers_1.BigNumber.from(numerator)).div(denominator);
/**
 * Maps order offer and consideration item amounts based on the units needed to fulfill
 * After applying the fraction, we can view this order as the "canonical" order for which we
 * check approvals and balances
 * Returns the numerator and denominator as well, converting this to an AdvancedOrder
 */
const mapOrderAmountsFromUnitsToFill = (order, { unitsToFill, totalSize, }) => {
    const unitsToFillBn = ethers_1.BigNumber.from(unitsToFill);
    if (unitsToFillBn.lte(0)) {
        throw new Error("Units to fill must be greater than 1");
    }
    const maxUnits = (0, item_1.getMaximumSizeForOrder)(order);
    if (totalSize.eq(0)) {
        totalSize = maxUnits;
    }
    return {
        parameters: Object.assign(Object.assign({}, order.parameters), { offer: order.parameters.offer.map((item) => (Object.assign(Object.assign({}, item), { startAmount: multiplyDivision(item.startAmount, unitsToFillBn, totalSize).toString(), endAmount: multiplyDivision(item.endAmount, unitsToFillBn, totalSize).toString() }))), consideration: order.parameters.consideration.map((item) => (Object.assign(Object.assign({}, item), { startAmount: multiplyDivision(item.startAmount, unitsToFillBn, totalSize).toString(), endAmount: multiplyDivision(item.endAmount, unitsToFillBn, totalSize).toString() }))) }),
        signature: order.signature,
    };
};
exports.mapOrderAmountsFromUnitsToFill = mapOrderAmountsFromUnitsToFill;
const generateRandomSalt = (domain) => {
    if (domain) {
        return `0x${Buffer.from((0, utils_1.concat)([
            (0, utils_1.keccak256)((0, utils_1.toUtf8Bytes)(domain)).slice(0, 10),
            Uint8Array.from(Array(20).fill(0)),
            (0, utils_1.randomBytes)(8),
        ])).toString("hex")}`;
    }
    return `0x${Buffer.from((0, utils_1.randomBytes)(8)).toString("hex").padStart(64, "0")}`;
};
exports.generateRandomSalt = generateRandomSalt;
const shouldUseMatchForFulfill = () => true;
exports.shouldUseMatchForFulfill = shouldUseMatchForFulfill;
//# sourceMappingURL=order.js.map