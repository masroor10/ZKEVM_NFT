"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.balanceOf = void 0;
const ethers_1 = require("ethers");
const ERC1155_1 = require("../abi/ERC1155");
const ERC20_1 = require("../abi/ERC20");
const ERC721_1 = require("../abi/ERC721");
const constants_1 = require("../constants");
const item_1 = require("./item");
const balanceOf = (owner, item, multicallProvider, criteria) => __awaiter(void 0, void 0, void 0, function* () {
    if ((0, item_1.isErc721Item)(item.itemType)) {
        const contract = new ethers_1.Contract(item.token, ERC721_1.ERC721ABI, multicallProvider);
        if (item.itemType === constants_1.ItemType.ERC721_WITH_CRITERIA) {
            return criteria
                ? contract
                    .ownerOf(criteria.identifier)
                    .then((ownerOf) => ethers_1.BigNumber.from(Number(ownerOf.toLowerCase() === owner.toLowerCase())))
                : contract.balanceOf(owner);
        }
        return contract
            .ownerOf(item.identifierOrCriteria)
            .then((ownerOf) => ethers_1.BigNumber.from(Number(ownerOf.toLowerCase() === owner.toLowerCase())));
    }
    else if ((0, item_1.isErc1155Item)(item.itemType)) {
        const contract = new ethers_1.Contract(item.token, ERC1155_1.ERC1155ABI, multicallProvider);
        if (item.itemType === constants_1.ItemType.ERC1155_WITH_CRITERIA) {
            if (!criteria) {
                // We don't have a good way to determine the balance of an erc1155 criteria item unless explicit
                // identifiers are provided, so just assume the offerer has sufficient balance
                const startAmount = ethers_1.BigNumber.from(item.startAmount);
                const endAmount = ethers_1.BigNumber.from(item.endAmount);
                return startAmount.gt(endAmount) ? startAmount : endAmount;
            }
            return contract.balanceOf(owner, criteria.identifier);
        }
        return contract.balanceOf(owner, item.identifierOrCriteria);
    }
    if ((0, item_1.isErc20Item)(item.itemType)) {
        const contract = new ethers_1.Contract(item.token, ERC20_1.ERC20ABI, multicallProvider);
        return contract.balanceOf(owner);
    }
    return multicallProvider.getBalance(owner);
});
exports.balanceOf = balanceOf;
//# sourceMappingURL=balance.js.map