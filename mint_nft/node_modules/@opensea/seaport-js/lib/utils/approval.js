"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.getApprovalActions = exports.approvedItemAmount = void 0;
const ethers_1 = require("ethers");
const ERC20_1 = require("../abi/ERC20");
const ERC721_1 = require("../abi/ERC721");
const constants_1 = require("../constants");
const item_1 = require("./item");
const usecase_1 = require("./usecase");
const approvedItemAmount = (owner, item, operator, multicallProvider) => __awaiter(void 0, void 0, void 0, function* () {
    if ((0, item_1.isErc721Item)(item.itemType) || (0, item_1.isErc1155Item)(item.itemType)) {
        // isApprovedForAll check is the same for both ERC721 and ERC1155, defaulting to ERC721
        const contract = new ethers_1.Contract(item.token, ERC721_1.ERC721ABI, multicallProvider);
        return contract.isApprovedForAll(owner, operator).then((isApprovedForAll) => 
        // Setting to the max int to consolidate types and simplify
        isApprovedForAll ? constants_1.MAX_INT : ethers_1.BigNumber.from(0));
    }
    else if (item.itemType === constants_1.ItemType.ERC20) {
        const contract = new ethers_1.Contract(item.token, ERC20_1.ERC20ABI, multicallProvider);
        return contract.allowance(owner, operator);
    }
    // We don't need to check approvals for native tokens
    return constants_1.MAX_INT;
});
exports.approvedItemAmount = approvedItemAmount;
/**
 * Get approval actions given a list of insufficent approvals.
 */
function getApprovalActions(insufficientApprovals, exactApproval, signer) {
    return insufficientApprovals
        .filter((approval, index) => index === insufficientApprovals.length - 1 ||
        insufficientApprovals[index + 1].token !== approval.token)
        .map(({ token, operator, itemType, identifierOrCriteria, requiredApprovedAmount, }) => {
        const isErc1155 = (0, item_1.isErc1155Item)(itemType);
        if ((0, item_1.isErc721Item)(itemType) || isErc1155) {
            // setApprovalForAll check is the same for both ERC721 and ERC1155, defaulting to ERC721
            const contract = new ethers_1.Contract(token, ERC721_1.ERC721ABI, signer);
            return {
                type: "approval",
                token,
                identifierOrCriteria,
                itemType,
                operator,
                transactionMethods: (0, usecase_1.getTransactionMethods)(contract.connect(signer), exactApproval && !isErc1155 ? "approve" : "setApprovalForAll", [
                    operator,
                    exactApproval && !isErc1155 ? identifierOrCriteria : true,
                ]),
            };
        }
        else {
            const contract = new ethers_1.Contract(token, ERC20_1.ERC20ABI, signer);
            return {
                type: "approval",
                token,
                identifierOrCriteria,
                itemType,
                transactionMethods: (0, usecase_1.getTransactionMethods)(contract.connect(signer), "approve", [operator, exactApproval ? requiredApprovedAmount : constants_1.MAX_INT]),
                operator,
            };
        }
    });
}
exports.getApprovalActions = getApprovalActions;
//# sourceMappingURL=approval.js.map