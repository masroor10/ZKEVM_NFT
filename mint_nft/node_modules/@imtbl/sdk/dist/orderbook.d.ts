/// <reference types="node" />
declare enum Environment {
    PRODUCTION = "production",
    SANDBOX = "sandbox"
}
declare class ImmutableConfiguration {
    readonly environment: Environment;
    readonly apiKey?: string;
    constructor(options: {
        environment: Environment;
        apiKey?: string;
    });
}
interface ModuleConfiguration<T> {
    baseConfig: ImmutableConfiguration;
    overrides?: T;
}

declare type Bytes = ArrayLike<number>;
declare type BytesLike = Bytes | string;
interface Hexable {
    toHexString(): string;
}

declare type BigNumberish = BigNumber | Bytes | bigint | string | number;
declare class BigNumber implements Hexable {
    readonly _hex: string;
    readonly _isBigNumber: boolean;
    constructor(constructorGuard: any, hex: string);
    fromTwos(value: number): BigNumber;
    toTwos(value: number): BigNumber;
    abs(): BigNumber;
    add(other: BigNumberish): BigNumber;
    sub(other: BigNumberish): BigNumber;
    div(other: BigNumberish): BigNumber;
    mul(other: BigNumberish): BigNumber;
    mod(other: BigNumberish): BigNumber;
    pow(other: BigNumberish): BigNumber;
    and(other: BigNumberish): BigNumber;
    or(other: BigNumberish): BigNumber;
    xor(other: BigNumberish): BigNumber;
    mask(value: number): BigNumber;
    shl(value: number): BigNumber;
    shr(value: number): BigNumber;
    eq(other: BigNumberish): boolean;
    lt(other: BigNumberish): boolean;
    lte(other: BigNumberish): boolean;
    gt(other: BigNumberish): boolean;
    gte(other: BigNumberish): boolean;
    isNegative(): boolean;
    isZero(): boolean;
    toNumber(): number;
    toBigInt(): bigint;
    toString(): string;
    toHexString(): string;
    toJSON(key?: string): any;
    static from(value: any): BigNumber;
    static isBigNumber(value: any): value is BigNumber;
}

declare type Deferrable<T> = {
    [K in keyof T]: T[K] | Promise<T[K]>;
};
declare class Description<T = any> {
    constructor(info: {
        [K in keyof T]: T[K];
    });
}

declare type Network = {
    name: string;
    chainId: number;
    ensAddress?: string;
    _defaultProvider?: (providers: any, options?: any) => any;
};
declare type Networkish = Network | string | number;

declare type AccessList = Array<{
    address: string;
    storageKeys: Array<string>;
}>;
declare type AccessListish = AccessList | Array<[string, Array<string>]> | Record<string, Array<string>>;
interface Transaction {
    hash?: string;
    to?: string;
    from?: string;
    nonce: number;
    gasLimit: BigNumber;
    gasPrice?: BigNumber;
    data: string;
    value: BigNumber;
    chainId: number;
    r?: string;
    s?: string;
    v?: number;
    type?: number | null;
    accessList?: AccessList;
    maxPriorityFeePerGas?: BigNumber;
    maxFeePerGas?: BigNumber;
}

declare type ConnectionInfo = {
    url: string;
    headers?: {
        [key: string]: string | number;
    };
    user?: string;
    password?: string;
    allowInsecureAuthentication?: boolean;
    allowGzip?: boolean;
    throttleLimit?: number;
    throttleSlotInterval?: number;
    throttleCallback?: (attempt: number, url: string) => Promise<boolean>;
    skipFetchSetup?: boolean;
    fetchOptions?: Record<string, string>;
    errorPassThrough?: boolean;
    timeout?: number;
};
interface OnceBlockable {
    once(eventName: "block", handler: () => void): void;
}

declare type TransactionRequest = {
    to?: string;
    from?: string;
    nonce?: BigNumberish;
    gasLimit?: BigNumberish;
    gasPrice?: BigNumberish;
    data?: BytesLike;
    value?: BigNumberish;
    chainId?: number;
    type?: number;
    accessList?: AccessListish;
    maxPriorityFeePerGas?: BigNumberish;
    maxFeePerGas?: BigNumberish;
    customData?: Record<string, any>;
    ccipReadEnabled?: boolean;
};
interface TransactionResponse extends Transaction {
    hash: string;
    blockNumber?: number;
    blockHash?: string;
    timestamp?: number;
    confirmations: number;
    from: string;
    raw?: string;
    wait: (confirmations?: number) => Promise<TransactionReceipt>;
}
declare type BlockTag = string | number;
interface _Block {
    hash: string;
    parentHash: string;
    number: number;
    timestamp: number;
    nonce: string;
    difficulty: number;
    _difficulty: BigNumber;
    gasLimit: BigNumber;
    gasUsed: BigNumber;
    miner: string;
    extraData: string;
    baseFeePerGas?: null | BigNumber;
}
interface Block extends _Block {
    transactions: Array<string>;
}
interface BlockWithTransactions extends _Block {
    transactions: Array<TransactionResponse>;
}
interface Log {
    blockNumber: number;
    blockHash: string;
    transactionIndex: number;
    removed: boolean;
    address: string;
    data: string;
    topics: Array<string>;
    transactionHash: string;
    logIndex: number;
}
interface TransactionReceipt {
    to: string;
    from: string;
    contractAddress: string;
    transactionIndex: number;
    root?: string;
    gasUsed: BigNumber;
    logsBloom: string;
    blockHash: string;
    transactionHash: string;
    logs: Array<Log>;
    blockNumber: number;
    confirmations: number;
    cumulativeGasUsed: BigNumber;
    effectiveGasPrice: BigNumber;
    byzantium: boolean;
    type: number;
    status?: number;
}
interface FeeData {
    lastBaseFeePerGas: null | BigNumber;
    maxFeePerGas: null | BigNumber;
    maxPriorityFeePerGas: null | BigNumber;
    gasPrice: null | BigNumber;
}
interface EventFilter {
    address?: string;
    topics?: Array<string | Array<string> | null>;
}
interface Filter extends EventFilter {
    fromBlock?: BlockTag;
    toBlock?: BlockTag;
}
interface FilterByBlockHash extends EventFilter {
    blockHash?: string;
}
declare abstract class ForkEvent extends Description {
    readonly expiry: number;
    readonly _isForkEvent?: boolean;
    static isForkEvent(value: any): value is ForkEvent;
}
declare type EventType = string | Array<string | Array<string>> | EventFilter | ForkEvent;
declare type Listener = (...args: Array<any>) => void;
declare abstract class Provider implements OnceBlockable {
    abstract getNetwork(): Promise<Network>;
    abstract getBlockNumber(): Promise<number>;
    abstract getGasPrice(): Promise<BigNumber>;
    getFeeData(): Promise<FeeData>;
    abstract getBalance(addressOrName: string | Promise<string>, blockTag?: BlockTag | Promise<BlockTag>): Promise<BigNumber>;
    abstract getTransactionCount(addressOrName: string | Promise<string>, blockTag?: BlockTag | Promise<BlockTag>): Promise<number>;
    abstract getCode(addressOrName: string | Promise<string>, blockTag?: BlockTag | Promise<BlockTag>): Promise<string>;
    abstract getStorageAt(addressOrName: string | Promise<string>, position: BigNumberish | Promise<BigNumberish>, blockTag?: BlockTag | Promise<BlockTag>): Promise<string>;
    abstract sendTransaction(signedTransaction: string | Promise<string>): Promise<TransactionResponse>;
    abstract call(transaction: Deferrable<TransactionRequest>, blockTag?: BlockTag | Promise<BlockTag>): Promise<string>;
    abstract estimateGas(transaction: Deferrable<TransactionRequest>): Promise<BigNumber>;
    abstract getBlock(blockHashOrBlockTag: BlockTag | string | Promise<BlockTag | string>): Promise<Block>;
    abstract getBlockWithTransactions(blockHashOrBlockTag: BlockTag | string | Promise<BlockTag | string>): Promise<BlockWithTransactions>;
    abstract getTransaction(transactionHash: string): Promise<TransactionResponse>;
    abstract getTransactionReceipt(transactionHash: string): Promise<TransactionReceipt>;
    abstract getLogs(filter: Filter): Promise<Array<Log>>;
    abstract resolveName(name: string | Promise<string>): Promise<null | string>;
    abstract lookupAddress(address: string | Promise<string>): Promise<null | string>;
    abstract on(eventName: EventType, listener: Listener): Provider;
    abstract once(eventName: EventType, listener: Listener): Provider;
    abstract emit(eventName: EventType, ...args: Array<any>): boolean;
    abstract listenerCount(eventName?: EventType): number;
    abstract listeners(eventName?: EventType): Array<Listener>;
    abstract off(eventName: EventType, listener?: Listener): Provider;
    abstract removeAllListeners(eventName?: EventType): Provider;
    addListener(eventName: EventType, listener: Listener): Provider;
    removeListener(eventName: EventType, listener: Listener): Provider;
    abstract waitForTransaction(transactionHash: string, confirmations?: number, timeout?: number): Promise<TransactionReceipt>;
    readonly _isProvider: boolean;
    constructor();
    static isProvider(value: any): value is Provider;
}

interface TypedDataDomain {
    name?: string;
    version?: string;
    chainId?: BigNumberish;
    verifyingContract?: string;
    salt?: BytesLike;
}
interface TypedDataField {
    name: string;
    type: string;
}
interface TypedDataSigner {
    _signTypedData(domain: TypedDataDomain, types: Record<string, Array<TypedDataField>>, value: Record<string, any>): Promise<string>;
}
declare abstract class Signer {
    readonly provider?: Provider;
    abstract getAddress(): Promise<string>;
    abstract signMessage(message: Bytes | string): Promise<string>;
    abstract signTransaction(transaction: Deferrable<TransactionRequest>): Promise<string>;
    abstract connect(provider: Provider): Signer;
    readonly _isSigner: boolean;
    constructor();
    getBalance(blockTag?: BlockTag): Promise<BigNumber>;
    getTransactionCount(blockTag?: BlockTag): Promise<number>;
    estimateGas(transaction: Deferrable<TransactionRequest>): Promise<BigNumber>;
    call(transaction: Deferrable<TransactionRequest>, blockTag?: BlockTag): Promise<string>;
    sendTransaction(transaction: Deferrable<TransactionRequest>): Promise<TransactionResponse>;
    getChainId(): Promise<number>;
    getGasPrice(): Promise<BigNumber>;
    getFeeData(): Promise<FeeData>;
    resolveName(name: string): Promise<string>;
    checkTransaction(transaction: Deferrable<TransactionRequest>): Deferrable<TransactionRequest>;
    populateTransaction(transaction: Deferrable<TransactionRequest>): Promise<TransactionRequest>;
    _checkProvider(operation?: string): void;
    static isSigner(value: any): value is Signer;
}

interface PopulatedTransaction {
    to?: string;
    from?: string;
    nonce?: number;
    gasLimit?: BigNumber;
    gasPrice?: BigNumber;
    data?: string;
    value?: BigNumber;
    chainId?: number;
    type?: number;
    accessList?: AccessList;
    maxFeePerGas?: BigNumber;
    maxPriorityFeePerGas?: BigNumber;
    customData?: Record<string, any>;
    ccipReadEnabled?: boolean;
}

declare type FormatFunc = (value: any) => any;
declare type FormatFuncs = {
    [key: string]: FormatFunc;
};
declare type Formats = {
    transaction: FormatFuncs;
    transactionRequest: FormatFuncs;
    receipt: FormatFuncs;
    receiptLog: FormatFuncs;
    block: FormatFuncs;
    blockWithTransactions: FormatFuncs;
    filter: FormatFuncs;
    filterLog: FormatFuncs;
};
declare class Formatter {
    readonly formats: Formats;
    constructor();
    getDefaultFormats(): Formats;
    accessList(accessList: Array<any>): AccessList;
    number(number: any): number;
    type(number: any): number;
    bigNumber(value: any): BigNumber;
    boolean(value: any): boolean;
    hex(value: any, strict?: boolean): string;
    data(value: any, strict?: boolean): string;
    address(value: any): string;
    callAddress(value: any): string;
    contractAddress(value: any): string;
    blockTag(blockTag: any): string;
    hash(value: any, strict?: boolean): string;
    difficulty(value: any): number;
    uint256(value: any): string;
    _block(value: any, format: any): Block;
    block(value: any): Block;
    blockWithTransactions(value: any): Block;
    transactionRequest(value: any): any;
    transactionResponse(transaction: any): TransactionResponse;
    transaction(value: any): any;
    receiptLog(value: any): any;
    receipt(value: any): TransactionReceipt;
    topics(value: any): any;
    filter(value: any): any;
    filterLog(value: any): any;
    static check(format: {
        [name: string]: FormatFunc;
    }, object: any): any;
    static allowNull(format: FormatFunc, nullValue?: any): FormatFunc;
    static allowFalsish(format: FormatFunc, replaceValue: any): FormatFunc;
    static arrayOf(format: FormatFunc): FormatFunc;
}

declare class Event {
    readonly listener: Listener;
    readonly once: boolean;
    readonly tag: string;
    _lastBlockNumber: number;
    _inflight: boolean;
    constructor(tag: string, listener: Listener, once: boolean);
    get event(): EventType;
    get type(): string;
    get hash(): string;
    get filter(): Filter;
    pollable(): boolean;
}
interface EnsResolver {
    readonly name: string;
    readonly address: string;
    getAddress(coinType?: 60): Promise<null | string>;
    getContentHash(): Promise<null | string>;
    getText(key: string): Promise<null | string>;
}
interface EnsProvider {
    resolveName(name: string): Promise<null | string>;
    lookupAddress(address: string): Promise<null | string>;
    getResolver(name: string): Promise<null | EnsResolver>;
}
interface Avatar {
    url: string;
    linkage: Array<{
        type: string;
        content: string;
    }>;
}
declare class Resolver$1 implements EnsResolver {
    readonly provider: BaseProvider;
    readonly name: string;
    readonly address: string;
    readonly _resolvedAddress: null | string;
    _supportsEip2544: null | Promise<boolean>;
    constructor(provider: BaseProvider, address: string, name: string, resolvedAddress?: string);
    supportsWildcard(): Promise<boolean>;
    _fetch(selector: string, parameters?: string): Promise<null | string>;
    _fetchBytes(selector: string, parameters?: string): Promise<null | string>;
    _getAddress(coinType: number, hexBytes: string): string;
    getAddress(coinType?: number): Promise<string>;
    getAvatar(): Promise<null | Avatar>;
    getContentHash(): Promise<string>;
    getText(key: string): Promise<string>;
}
declare class BaseProvider extends Provider implements EnsProvider {
    _networkPromise: Promise<Network>;
    _network: Network;
    _events: Array<Event>;
    formatter: Formatter;
    _emitted: {
        [eventName: string]: number | "pending";
    };
    _pollingInterval: number;
    _poller: NodeJS.Timer;
    _bootstrapPoll: NodeJS.Timer;
    _lastBlockNumber: number;
    _maxFilterBlockRange: number;
    _fastBlockNumber: number;
    _fastBlockNumberPromise: Promise<number>;
    _fastQueryDate: number;
    _maxInternalBlockNumber: number;
    _internalBlockNumber: Promise<{
        blockNumber: number;
        reqTime: number;
        respTime: number;
    }>;
    readonly anyNetwork: boolean;
    disableCcipRead: boolean;
    /**
     *  ready
     *
     *  A Promise<Network> that resolves only once the provider is ready.
     *
     *  Sub-classes that call the super with a network without a chainId
     *  MUST set this. Standard named networks have a known chainId.
     *
     */
    constructor(network: Networkish | Promise<Network>);
    _ready(): Promise<Network>;
    get ready(): Promise<Network>;
    static getFormatter(): Formatter;
    static getNetwork(network: Networkish): Network;
    ccipReadFetch(tx: Transaction, calldata: string, urls: Array<string>): Promise<null | string>;
    _getInternalBlockNumber(maxAge: number): Promise<number>;
    poll(): Promise<void>;
    resetEventsBlock(blockNumber: number): void;
    get network(): Network;
    detectNetwork(): Promise<Network>;
    getNetwork(): Promise<Network>;
    get blockNumber(): number;
    get polling(): boolean;
    set polling(value: boolean);
    get pollingInterval(): number;
    set pollingInterval(value: number);
    _getFastBlockNumber(): Promise<number>;
    _setFastBlockNumber(blockNumber: number): void;
    waitForTransaction(transactionHash: string, confirmations?: number, timeout?: number): Promise<TransactionReceipt>;
    _waitForTransaction(transactionHash: string, confirmations: number, timeout: number, replaceable: {
        data: string;
        from: string;
        nonce: number;
        to: string;
        value: BigNumber;
        startBlock: number;
    }): Promise<TransactionReceipt>;
    getBlockNumber(): Promise<number>;
    getGasPrice(): Promise<BigNumber>;
    getBalance(addressOrName: string | Promise<string>, blockTag?: BlockTag | Promise<BlockTag>): Promise<BigNumber>;
    getTransactionCount(addressOrName: string | Promise<string>, blockTag?: BlockTag | Promise<BlockTag>): Promise<number>;
    getCode(addressOrName: string | Promise<string>, blockTag?: BlockTag | Promise<BlockTag>): Promise<string>;
    getStorageAt(addressOrName: string | Promise<string>, position: BigNumberish | Promise<BigNumberish>, blockTag?: BlockTag | Promise<BlockTag>): Promise<string>;
    _wrapTransaction(tx: Transaction, hash?: string, startBlock?: number): TransactionResponse;
    sendTransaction(signedTransaction: string | Promise<string>): Promise<TransactionResponse>;
    _getTransactionRequest(transaction: Deferrable<TransactionRequest>): Promise<Transaction>;
    _getFilter(filter: Filter | FilterByBlockHash | Promise<Filter | FilterByBlockHash>): Promise<Filter | FilterByBlockHash>;
    _call(transaction: TransactionRequest, blockTag: BlockTag, attempt: number): Promise<string>;
    call(transaction: Deferrable<TransactionRequest>, blockTag?: BlockTag | Promise<BlockTag>): Promise<string>;
    estimateGas(transaction: Deferrable<TransactionRequest>): Promise<BigNumber>;
    _getAddress(addressOrName: string | Promise<string>): Promise<string>;
    _getBlock(blockHashOrBlockTag: BlockTag | string | Promise<BlockTag | string>, includeTransactions?: boolean): Promise<Block | BlockWithTransactions>;
    getBlock(blockHashOrBlockTag: BlockTag | string | Promise<BlockTag | string>): Promise<Block>;
    getBlockWithTransactions(blockHashOrBlockTag: BlockTag | string | Promise<BlockTag | string>): Promise<BlockWithTransactions>;
    getTransaction(transactionHash: string | Promise<string>): Promise<TransactionResponse>;
    getTransactionReceipt(transactionHash: string | Promise<string>): Promise<TransactionReceipt>;
    getLogs(filter: Filter | FilterByBlockHash | Promise<Filter | FilterByBlockHash>): Promise<Array<Log>>;
    getEtherPrice(): Promise<number>;
    _getBlockTag(blockTag: BlockTag | Promise<BlockTag>): Promise<BlockTag>;
    getResolver(name: string): Promise<null | Resolver$1>;
    _getResolver(name: string, operation?: string): Promise<string>;
    resolveName(name: string | Promise<string>): Promise<null | string>;
    lookupAddress(address: string | Promise<string>): Promise<null | string>;
    getAvatar(nameOrAddress: string): Promise<null | string>;
    perform(method: string, params: any): Promise<any>;
    _startEvent(event: Event): void;
    _stopEvent(event: Event): void;
    _addEventListener(eventName: EventType, listener: Listener, once: boolean): this;
    on(eventName: EventType, listener: Listener): this;
    once(eventName: EventType, listener: Listener): this;
    emit(eventName: EventType, ...args: Array<any>): boolean;
    listenerCount(eventName?: EventType): number;
    listeners(eventName?: EventType): Array<Listener>;
    off(eventName: EventType, listener?: Listener): this;
    removeAllListeners(eventName?: EventType): this;
}

declare class JsonRpcSigner extends Signer implements TypedDataSigner {
    readonly provider: JsonRpcProvider;
    _index: number;
    _address: string;
    constructor(constructorGuard: any, provider: JsonRpcProvider, addressOrIndex?: string | number);
    connect(provider: Provider): JsonRpcSigner;
    connectUnchecked(): JsonRpcSigner;
    getAddress(): Promise<string>;
    sendUncheckedTransaction(transaction: Deferrable<TransactionRequest>): Promise<string>;
    signTransaction(transaction: Deferrable<TransactionRequest>): Promise<string>;
    sendTransaction(transaction: Deferrable<TransactionRequest>): Promise<TransactionResponse>;
    signMessage(message: Bytes | string): Promise<string>;
    _legacySignMessage(message: Bytes | string): Promise<string>;
    _signTypedData(domain: TypedDataDomain, types: Record<string, Array<TypedDataField>>, value: Record<string, any>): Promise<string>;
    unlock(password: string): Promise<boolean>;
}
declare class UncheckedJsonRpcSigner extends JsonRpcSigner {
    sendTransaction(transaction: Deferrable<TransactionRequest>): Promise<TransactionResponse>;
}
declare class JsonRpcProvider extends BaseProvider {
    readonly connection: ConnectionInfo;
    _pendingFilter: Promise<number>;
    _nextId: number;
    _eventLoopCache: Record<string, Promise<any>>;
    get _cache(): Record<string, Promise<any>>;
    constructor(url?: ConnectionInfo | string, network?: Networkish);
    static defaultUrl(): string;
    detectNetwork(): Promise<Network>;
    _uncachedDetectNetwork(): Promise<Network>;
    getSigner(addressOrIndex?: string | number): JsonRpcSigner;
    getUncheckedSigner(addressOrIndex?: string | number): UncheckedJsonRpcSigner;
    listAccounts(): Promise<Array<string>>;
    send(method: string, params: Array<any>): Promise<any>;
    prepareRequest(method: string, params: any): [string, Array<any>];
    perform(method: string, params: any): Promise<any>;
    _startEvent(event: Event): void;
    _startPending(): void;
    _stopEvent(event: Event): void;
    static hexlifyTransaction(transaction: TransactionRequest, allowExtra?: {
        [key: string]: boolean;
    }): {
        [key: string]: string | AccessList;
    };
}

declare type ExternalProvider = {
    isMetaMask?: boolean;
    isStatus?: boolean;
    host?: string;
    path?: string;
    sendAsync?: (request: {
        method: string;
        params?: Array<any>;
    }, callback: (error: any, response: any) => void) => void;
    send?: (request: {
        method: string;
        params?: Array<any>;
    }, callback: (error: any, response: any) => void) => void;
    request?: (request: {
        method: string;
        params?: Array<any>;
    }) => Promise<any>;
};
declare type JsonRpcFetchFunc = (method: string, params?: Array<any>) => Promise<any>;
declare class Web3Provider extends JsonRpcProvider {
    readonly provider: ExternalProvider;
    readonly jsonRpcFetchFunc: JsonRpcFetchFunc;
    constructor(provider: ExternalProvider | JsonRpcFetchFunc, network?: Networkish);
    send(method: string, params: Array<any>): Promise<any>;
}

interface OrderbookOverrides {
    provider?: JsonRpcProvider | Web3Provider;
    seaportContractAddress?: string;
    zoneContractAddress?: string;
    chainName?: string;
    apiEndpoint?: string;
}
interface OrderbookModuleConfiguration {
    seaportContractAddress: string;
    zoneContractAddress: string;
    apiEndpoint: string;
    chainName: string;
    provider: JsonRpcProvider | Web3Provider;
}

declare enum OrderType {
    FULL_OPEN = 0,
    PARTIAL_OPEN = 1,
    FULL_RESTRICTED = 2,
    PARTIAL_RESTRICTED = 3
}
declare enum ItemType {
    NATIVE = 0,
    ERC20 = 1,
    ERC721 = 2,
    ERC1155 = 3,
    ERC721_WITH_CRITERIA = 4,
    ERC1155_WITH_CRITERIA = 5
}

type OfferItem = {
    itemType: ItemType;
    token: string;
    identifierOrCriteria: string;
    startAmount: string;
    endAmount: string;
};
type ConsiderationItem = {
    itemType: ItemType;
    token: string;
    identifierOrCriteria: string;
    startAmount: string;
    endAmount: string;
    recipient: string;
};
type OrderParameters = {
    offerer: string;
    zone: string;
    orderType: OrderType;
    startTime: BigNumberish;
    endTime: BigNumberish;
    zoneHash: string;
    salt: string;
    offer: OfferItem[];
    consideration: ConsiderationItem[];
    totalOriginalConsiderationItems: BigNumberish;
    conduitKey: string;
};
type OrderComponents = OrderParameters & {
    counter: BigNumberish;
};

type ApiRequestOptions = {
    readonly method: 'GET' | 'PUT' | 'POST' | 'DELETE' | 'OPTIONS' | 'HEAD' | 'PATCH';
    readonly url: string;
    readonly path?: Record<string, any>;
    readonly cookies?: Record<string, any>;
    readonly headers?: Record<string, any>;
    readonly query?: Record<string, any>;
    readonly formData?: Record<string, any>;
    readonly body?: any;
    readonly mediaType?: string;
    readonly responseHeader?: string;
    readonly errors?: Record<number, string>;
};

interface OnCancel {
    readonly isResolved: boolean;
    readonly isRejected: boolean;
    readonly isCancelled: boolean;
    (cancelHandler: () => void): void;
}
declare class CancelablePromise<T> implements Promise<T> {
    readonly [Symbol.toStringTag]: string;
    private _isResolved;
    private _isRejected;
    private _isCancelled;
    private readonly _cancelHandlers;
    private readonly _promise;
    private _resolve?;
    private _reject?;
    constructor(executor: (resolve: (value: T | PromiseLike<T>) => void, reject: (reason?: any) => void, onCancel: OnCancel) => void);
    then<TResult1 = T, TResult2 = never>(onFulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | null, onRejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | null): Promise<TResult1 | TResult2>;
    catch<TResult = never>(onRejected?: ((reason: any) => TResult | PromiseLike<TResult>) | null): Promise<T | TResult>;
    finally(onFinally?: (() => void) | null): Promise<T>;
    cancel(): void;
    get isCancelled(): boolean;
}

type Resolver<T> = (options: ApiRequestOptions) => Promise<T>;
type Headers = Record<string, string>;
type OpenAPIConfig = {
    BASE: string;
    VERSION: string;
    WITH_CREDENTIALS: boolean;
    CREDENTIALS: 'include' | 'omit' | 'same-origin';
    TOKEN?: string | Resolver<string>;
    USERNAME?: string | Resolver<string>;
    PASSWORD?: string | Resolver<string>;
    HEADERS?: Headers | Resolver<Headers>;
    ENCODE_PATH?: (path: string) => string;
};

declare abstract class BaseHttpRequest {
    readonly config: OpenAPIConfig;
    constructor(config: OpenAPIConfig);
    abstract request<T>(options: ApiRequestOptions): CancelablePromise<T>;
}

/**
 * The name of chain
 */
type ChainName = string;

type Fee$1 = {
    /**
     * Fee payable to recipient upon settlement
     */
    amount: string;
    /**
     * Fee type
     */
    fee_type: Fee$1.fee_type;
    /**
     * Wallet address of fee recipient
     */
    recipient: string;
};
declare namespace Fee$1 {
    /**
     * Fee type
     */
    enum fee_type {
        ROYALTY = "ROYALTY",
        MAKER_ECOSYSTEM = "MAKER_ECOSYSTEM",
        TAKER_ECOSYSTEM = "TAKER_ECOSYSTEM",
        PROTOCOL = "PROTOCOL"
    }
}

type ERC20Item$1 = {
    /**
     * Token type user is offering, which in this case is ERC20
     */
    item_type: 'ERC20';
    /**
     * Address of ERC20 token
     */
    contract_address: string;
    /**
     * A string representing the starting price at which the user is willing to sell the token. This value is provided in the smallest unit of the token (e.g., wei for Ethereum).
     */
    start_amount: string;
};

type ERC721Item$1 = {
    /**
     * Token type user is offering, which in this case is ERC721
     */
    item_type: 'ERC721';
    /**
     * Address of ERC721 token
     */
    contract_address: string;
    /**
     * ID of ERC721 token
     */
    token_id: string;
};

type NativeItem$1 = {
    /**
     * Token type user is offering, which in this case is the native IMX token
     */
    item_type: 'NATIVE';
    /**
     * A string representing the starting price at which the user is willing to sell the token. This value is provided in the smallest unit of the token (e.g., wei for Ethereum).
     */
    start_amount: string;
};

type Item = (NativeItem$1 | ERC20Item$1 | ERC721Item$1);

type ProtocolData = {
    /**
     * The Order type
     */
    order_type: ProtocolData.order_type;
    /**
     * Immutable zone address
     */
    zone_address: string;
    /**
     * big.Int or uint256 string for order counter
     */
    counter: string;
    /**
     * Immutable Seaport contract address
     */
    seaport_address: string;
    /**
     * Immutable Seaport contract version
     */
    seaport_version: string;
};
declare namespace ProtocolData {
    /**
     * The Order type
     */
    enum order_type {
        FULL_RESTRICTED = "FULL_RESTRICTED"
    }
}

type CreateListingRequestBody = {
    account_address: string;
    order_hash: string;
    /**
     * Buy item for listing should either be NATIVE or ERC20 item
     */
    buy: Array<Item>;
    /**
     * Buy fees should only include maker marketplace fees and should be no more than two entries as more entires will incur more gas. It is best practice to have this as few as possible.
     */
    fees: Array<Fee$1>;
    /**
     * Time after which the Order is considered expired
     */
    end_at: string;
    protocol_data: ProtocolData;
    /**
     * A random value added to the create Order request
     */
    salt: string;
    /**
     * Sell item for listing should be an ERC721 item
     */
    sell: Array<Item>;
    /**
     * Digital signature generated by the user for the specific Order
     */
    signature: string;
    /**
     * Time after which Order is considered active
     */
    start_at: string;
};

type FulfillmentDataRequest = {
    order_id: string;
    fees: Array<Fee$1>;
};

/**
 * The chain details
 */
type Chain = {
    /**
     * The id of chain
     */
    id: string;
    /**
     * The name of chain
     */
    name: string;
};

/**
 * The Order status
 */
declare enum OrderStatus {
    PENDING = "PENDING",
    ACTIVE = "ACTIVE",
    INACTIVE = "INACTIVE",
    FILLED = "FILLED",
    CANCELLED = "CANCELLED",
    EXPIRED = "EXPIRED"
}

type Order$1 = {
    account_address: string;
    buy: Array<Item>;
    fees: Array<Fee$1>;
    chain: Chain;
    /**
     * Time the Order is created
     */
    created_at: string;
    /**
     * Time after which the Order is considered expired
     */
    end_at: string;
    /**
     * Global Order identifier
     */
    id: string;
    protocol_data: ProtocolData;
    /**
     * A random value added to the create Order request
     */
    salt: string;
    sell: Array<Item>;
    /**
     * Digital signature generated by the user for the specific Order
     */
    signature: string;
    /**
     * Time after which Order is considered active
     */
    start_at: string;
    status: OrderStatus;
    /**
     * Time the Order is last updated
     */
    updated_at: string;
};

type FulfillmentDataResult = {
    extra_data: string;
    order: Order$1;
};

type ListingResult$1 = {
    result: Order$1;
};

/**
 * Pagination properties
 */
type Page$1 = {
    /**
     * First item as an encoded string
     */
    previous_cursor: string | null;
    /**
     * Last item as an encoded string
     */
    next_cursor: string | null;
};

type ListListingsResult$1 = {
    page: Page$1;
    result: Array<Order$1>;
};

/**
 * The metadata related to the transaction in which the activity occurred
 */
type TradeBlockchainMetadata = {
    /**
     * The transaction hash of the trade
     */
    transaction_hash: string;
    /**
     * EVM block number (uint64 as string)
     */
    block_number: string;
    /**
     * Transaction index in a block (uint32 as string)
     */
    transaction_index: string;
    /**
     * The log index of the fulfillment event in a block (uint32 as string)
     */
    log_index: string;
};

type Trade$1 = {
    buy: Array<Item>;
    buyer_address: string;
    buyer_fees: Array<Fee$1>;
    chain: Chain;
    order_id: string;
    blockchain_metadata: TradeBlockchainMetadata;
    /**
     * Time the on-chain trade event is indexed by the order book system
     */
    indexed_at: string;
    /**
     * Global Trade identifier
     */
    id: string;
    sell: Array<Item>;
    seller_address: string;
    maker_address: string;
    taker_address: string;
};

type ListTradeResult = {
    page: Page$1;
    result: Array<Trade$1>;
};

/**
 * Encoded page cursor to retrieve previous or next page. Use the value returned in the response.
 */
type PageCursor = string;

/**
 * Maximum number of items to return
 */
type PageSize = number;

type TradeResult$1 = {
    result: Trade$1;
};

declare class OrdersService {
    readonly httpRequest: BaseHttpRequest;
    constructor(httpRequest: BaseHttpRequest);
    /**
     * List all listings
     * List all listings
     * @returns ListListingsResult OK response.
     * @throws ApiError
     */
    listListings({ chainName, status, sellItemContractAddress, buyItemContractAddress, sellItemTokenId, pageSize, sortBy, sortDirection, pageCursor, }: {
        chainName: ChainName;
        /**
         * Order status to filter by
         */
        status?: OrderStatus;
        /**
         * Sell item contract address to filter by
         */
        sellItemContractAddress?: string;
        /**
         * Buy item contract address to filter by
         */
        buyItemContractAddress?: string;
        /**
         * Sell item token identifier to filter by
         */
        sellItemTokenId?: string;
        /**
         * Maximum number of orders to return per page
         */
        pageSize?: PageSize;
        /**
         * Order field to sort by
         */
        sortBy?: 'created_at' | 'updated_at' | 'buy_item_amount';
        /**
         * Ascending or descending direction for sort
         */
        sortDirection?: 'asc' | 'desc';
        /**
         * Page cursor to retrieve previous or next page. Use the value returned in the response.
         */
        pageCursor?: PageCursor;
    }): CancelablePromise<ListListingsResult$1>;
    /**
     * Create a listing
     * Create a listing
     * @returns ListingResult Created response.
     * @throws ApiError
     */
    createListing({ chainName, requestBody, }: {
        chainName: ChainName;
        requestBody: CreateListingRequestBody;
    }): CancelablePromise<ListingResult$1>;
    /**
     * Get a single listing by ID
     * Get a single listing by ID
     * @returns ListingResult OK response.
     * @throws ApiError
     */
    getListing({ chainName, listingId, }: {
        chainName: ChainName;
        /**
         * Global Order identifier
         */
        listingId: string;
    }): CancelablePromise<ListingResult$1>;
    /**
     * Retrieve fulfillment data for orders
     * Retrieve signed fulfillment data based on the list of order IDs and corresponding fees.
     * @returns any Successful response
     * @throws ApiError
     */
    fulfillmentData({ chainName, requestBody, }: {
        chainName: ChainName;
        requestBody: Array<FulfillmentDataRequest>;
    }): CancelablePromise<{
        result: Array<FulfillmentDataResult>;
    }>;
    /**
     * List all trades
     * List all trades
     * @returns ListTradeResult OK response.
     * @throws ApiError
     */
    listTrades({ chainName, accountAddress, pageSize, sortBy, sortDirection, pageCursor, }: {
        chainName: ChainName;
        accountAddress?: string;
        /**
         * Maximum number of trades to return per page
         */
        pageSize?: PageSize;
        /**
         * Trade field to sort by
         */
        sortBy?: 'indexed_at';
        /**
         * Ascending or descending direction for sort
         */
        sortDirection?: 'asc' | 'desc';
        /**
         * Page cursor to retrieve previous or next page. Use the value returned in the response.
         */
        pageCursor?: PageCursor;
    }): CancelablePromise<ListTradeResult>;
    /**
     * Get a single trade by ID
     * Get a single trade by ID
     * @returns TradeResult OK response.
     * @throws ApiError
     */
    getTrade({ chainName, tradeId, }: {
        chainName: ChainName;
        /**
         * Global Trade identifier
         */
        tradeId: string;
    }): CancelablePromise<TradeResult$1>;
}

interface ERC721Item {
    type: 'ERC721';
    contractAddress: string;
    tokenId: string;
}
interface ERC20Item {
    type: 'ERC20';
    contractAddress: string;
    amount: string;
}
interface NativeItem {
    type: 'NATIVE';
    amount: string;
}
interface RoyaltyInfo {
    recipient: string;
    amountRequired: string;
}
interface PrepareListingParams {
    makerAddress: string;
    sell: ERC721Item;
    buy: ERC20Item | NativeItem;
    orderExpiry?: Date;
}
interface PrepareListingResponse {
    actions: Action[];
    orderComponents: OrderComponents;
    orderHash: string;
}
interface CreateListingParams {
    orderComponents: OrderComponents;
    orderHash: string;
    orderSignature: string;
    makerFees: FeeValue[];
}
type ListListingsParams = Omit<Parameters<typeof OrdersService.prototype.listListings>[0], 'chainName'>;
type ListTradesParams = Omit<Parameters<typeof OrdersService.prototype.listTrades>[0], 'chainName'>;
declare enum FeeType {
    MAKER_ECOSYSTEM = "MAKER_ECOSYSTEM",
    TAKER_ECOSYSTEM = "TAKER_ECOSYSTEM",
    PROTOCOL = "PROTOCOL",
    ROYALTY = "ROYALTY"
}
interface FeeValue {
    recipient: string;
    amount: string;
}
interface Fee extends FeeValue {
    type: FeeType;
}
declare enum TransactionPurpose {
    APPROVAL = "APPROVAL",
    FULFILL_ORDER = "FULFILL_ORDER"
}
declare enum SignablePurpose {
    CREATE_LISTING = "CREATE_LISTING"
}
declare enum ActionType {
    TRANSACTION = "TRANSACTION",
    SIGNABLE = "SIGNABLE"
}
type TransactionBuilder = () => Promise<PopulatedTransaction>;
interface TransactionAction {
    type: ActionType.TRANSACTION;
    purpose: TransactionPurpose;
    buildTransaction: TransactionBuilder;
}
interface SignableAction {
    type: ActionType.SIGNABLE;
    purpose: SignablePurpose;
    message: {
        domain: TypedDataDomain;
        types: Record<string, TypedDataField[]>;
        value: Record<string, any>;
    };
}
type Action = TransactionAction | SignableAction;
interface FulfillOrderResponse {
    actions: Action[];
    /**
     * User MUST submit the fulfillment transaction before the expiration
     * Submitting after the expiration will result in a on chain revert
     */
    expiration: string;
    order: Order;
}
interface CancelOrderResponse {
    unsignedCancelOrderTransaction: PopulatedTransaction;
}
interface Order {
    id: string;
    accountAddress: string;
    buy: (ERC20Item | NativeItem)[];
    sell: ERC721Item[];
    fees: Fee[];
    chain: {
        id: string;
        name: string;
    };
    createdAt: string;
    updatedAt: string;
    /**
     * Time after which the Order is considered active
     */
    startAt: string;
    /**
     * Time after which the Order is expired
     */
    endAt: string;
    protocolData: {
        orderType: 'FULL_RESTRICTED';
        zoneAddress: string;
        counter: string;
        seaportAddress: string;
        seaportVersion: string;
    };
    salt: string;
    signature: string;
    status: OrderStatus;
}
interface ListingResult {
    result: Order;
}
interface ListListingsResult {
    page: Page;
    result: Order[];
}
interface Page {
    /**
     * First item as an encoded string
     */
    previousCursor: string | null;
    /**
     * Last item as an encoded string
     */
    nextCursor: string | null;
}
interface Trade {
    id: string;
    orderId: string;
    chain: {
        id: string;
        name: string;
    };
    buy: (ERC20Item | NativeItem)[];
    sell: ERC721Item[];
    buyerFees: Fee[];
    sellerAddress: string;
    buyerAddress: string;
    makerAddress: string;
    takerAddress: string;
    /**
     * Time the on-chain event was indexed by the Immutable order book service
     */
    indexedAt: string;
    blockchainMetadata: {
        /**
         * The transaction hash of the trade
         */
        transactionHash: string;
        /**
         * EVM block number (uint64 as string)
         */
        blockNumber: string;
        /**
         * Transaction index in a block (uint32 as string)
         */
        transactionIndex: string;
        /**
         * The log index of the fulfillment event in a block (uint32 as string)
         */
        logIndex: string;
    };
}
interface TradeResult {
    result: Trade;
}
interface ListTradesResult {
    page: Page;
    result: Trade[];
}

/**
 * zkEVM orderbook SDK
 * @constructor
 * @param {OrderbookModuleConfiguration} config - Configuration for Immutable services.
 */
declare class Orderbook {
    private apiClient;
    private seaport;
    private orderbookConfig;
    constructor(config: ModuleConfiguration<OrderbookOverrides>);
    /**
     * Return the configuration for the orderbook module.
     * @return {OrderbookModuleConfiguration} The configuration for the orderbook module.
     */
    config(): OrderbookModuleConfiguration;
    /**
     * Get an order by ID
     * @param {string} listingId - The listingId to find.
     * @return {ListingResult} The returned order result.
     */
    getListing(listingId: string): Promise<ListingResult>;
    /**
     * Get a trade by ID
     * @param {string} tradeId - The tradeId to find.
     * @return {TradeResult} The returned order result.
     */
    getTrade(tradeId: string): Promise<TradeResult>;
    /**
     * List orders. This method is used to get a list of orders filtered by conditions specified
     * in the params object.
     * @param {ListListingsParams} listOrderParams - Filtering, ordering and page parameters.
     * @return {ListListingsResult} The paged orders.
     */
    listListings(listOrderParams: ListListingsParams): Promise<ListListingsResult>;
    /**
     * List trades. This method is used to get a list of trades filtered by conditions specified
     * in the params object
     * @param {ListTradesParams} listTradesParams - Filtering, ordering and page parameters.
     * @return {ListTradesResult} The paged trades.
     */
    listTrades(listTradesParams: ListTradesParams): Promise<ListTradesResult>;
    /**
     * Get required transactions and messages for signing prior to creating a listing
     * through the createListing method
     * @param {PrepareListingParams} prepareListingParams - Details about the listing to be created.
     * @return {PrepareListingResponse} PrepareListingResponse includes
     * the unsigned approval transaction, the typed order message for signing and
     * the order components that can be submitted to `createListing` with a signature.
     */
    prepareListing({ makerAddress, sell, buy, orderExpiry, }: PrepareListingParams): Promise<PrepareListingResponse>;
    /**
     * Create an order
     * @param {CreateListingParams} createListingParams - create an order with the given params.
     * @return {ListingResult} The result of the order created in the Immutable services.
     */
    createListing(createListingParams: CreateListingParams): Promise<ListingResult>;
    /**
     * Get unsigned transactions that can be submitted to fulfil an open order. If the approval
     * transaction exists it must be signed and submitted to the chain before the fulfilment
     * transaction can be submitted or it will be reverted.
     * @param {string} listingId - The listingId to fulfil.
     * @param {string} fulfillerAddress - The address of the account fulfilling the order.
     * @return {FulfillOrderResponse} Approval and fulfilment transactions.
     */
    fulfillOrder(listingId: string, takerAddress: string, takerFees: FeeValue[]): Promise<FulfillOrderResponse>;
    /**
     * Get an unsigned cancel order transaction. Orders can only be cancelled by
     * the account that created them.
     * @param {string} listingId - The listingId to cancel.
     * @param {string} accountAddress - The address of the account cancelling the order.
     * @return {CancelOrderResponse} The unsigned cancel order transaction
     */
    cancelOrder(listingId: string, accountAddress: string): Promise<CancelOrderResponse>;
}

declare const constants: {
    estimatedFulfillmentGasGwei: number;
};

export { Action, ActionType, CancelOrderResponse, CreateListingParams, ERC20Item, ERC721Item, Fee, FeeType, FeeValue, FulfillOrderResponse, ListListingsParams, ListListingsResult, ListTradesParams, ListTradesResult, ListingResult, NativeItem, Order, OrderStatus, Orderbook, Page, PrepareListingParams, PrepareListingResponse, RoyaltyInfo, SignableAction, SignablePurpose, Trade, TradeResult, TransactionAction, TransactionBuilder, TransactionPurpose, constants };
