import globalAxios from 'axios';

/* tslint:disable */
/* eslint-disable */
/**
 * Immutable zkEVM API
 * Immutable Multi Rollup API
 *
 * The version of the OpenAPI document: 1.0.0
 * Contact: support@immutable.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
// Some imports not used depending on template conditions
// @ts-ignore
const BASE_PATH = "https://api.sandbox.immutable.com".replace(/\/+$/, "");
/**
 *
 * @export
 * @class BaseAPI
 */
class BaseAPI {
    basePath;
    axios;
    configuration;
    constructor(configuration, basePath = BASE_PATH, axios = globalAxios) {
        this.basePath = basePath;
        this.axios = axios;
        if (configuration) {
            this.configuration = configuration;
            this.basePath = configuration.basePath || this.basePath;
        }
    }
}
/**
 *
 * @export
 * @class RequiredError
 * @extends {Error}
 */
class RequiredError extends Error {
    field;
    name = "RequiredError";
    constructor(field, msg) {
        super(msg);
        this.field = field;
    }
}

/* tslint:disable */
/* eslint-disable */
/**
 * Immutable zkEVM API
 * Immutable Multi Rollup API
 *
 * The version of the OpenAPI document: 1.0.0
 * Contact: support@immutable.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
/**
 *
 * @export
 */
const DUMMY_BASE_URL = 'https://example.com';
/**
 *
 * @throws {RequiredError}
 * @export
 */
const assertParamExists = function (functionName, paramName, paramValue) {
    if (paramValue === null || paramValue === undefined) {
        throw new RequiredError(paramName, `Required parameter ${paramName} was null or undefined when calling ${functionName}.`);
    }
};
/**
 *
 * @export
 */
const setApiKeyToObject = async function (object, keyParamName, configuration) {
    if (configuration && configuration.apiKey) {
        const localVarApiKeyValue = typeof configuration.apiKey === 'function'
            ? await configuration.apiKey(keyParamName)
            : await configuration.apiKey;
        object[keyParamName] = localVarApiKeyValue;
    }
};
/**
 *
 * @export
 */
const setBearerAuthToObject = async function (object, configuration) {
    if (configuration && configuration.accessToken) {
        const accessToken = typeof configuration.accessToken === 'function'
            ? await configuration.accessToken()
            : await configuration.accessToken;
        object["Authorization"] = "Bearer " + accessToken;
    }
};
function setFlattenedQueryParams(urlSearchParams, parameter, key = "") {
    if (typeof parameter === "object") {
        if (Array.isArray(parameter)) {
            parameter.forEach(item => setFlattenedQueryParams(urlSearchParams, item, key));
        }
        else {
            Object.keys(parameter).forEach(currentKey => setFlattenedQueryParams(urlSearchParams, parameter[currentKey], `${key}${key !== '' ? '.' : ''}${currentKey}`));
        }
    }
    else {
        if (urlSearchParams.has(key)) {
            urlSearchParams.append(key, parameter);
        }
        else {
            urlSearchParams.set(key, parameter);
        }
    }
}
/**
 *
 * @export
 */
const setSearchParams = function (url, ...objects) {
    const searchParams = new URLSearchParams(url.search);
    setFlattenedQueryParams(searchParams, objects);
    url.search = searchParams.toString();
};
/**
 *
 * @export
 */
const serializeDataIfNeeded = function (value, requestOptions, configuration) {
    const nonString = typeof value !== 'string';
    const needsSerialization = nonString && configuration && configuration.isJsonMime
        ? configuration.isJsonMime(requestOptions.headers['Content-Type'])
        : nonString;
    return needsSerialization
        ? JSON.stringify(value !== undefined ? value : {})
        : (value || "");
};
/**
 *
 * @export
 */
const toPathString = function (url) {
    return url.pathname + url.search + url.hash;
};
/**
 *
 * @export
 */
const createRequestFunction = function (axiosArgs, globalAxios, BASE_PATH, configuration) {
    return (axios = globalAxios, basePath = BASE_PATH) => {
        const axiosRequestArgs = { ...axiosArgs.options, url: (configuration?.basePath || basePath) + axiosArgs.url };
        return axios.request(axiosRequestArgs);
    };
};

/* tslint:disable */
/* eslint-disable */
/**
 * Immutable zkEVM API
 * Immutable Multi Rollup API
 *
 * The version of the OpenAPI document: 1.0.0
 * Contact: support@immutable.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
/**
 * ActivitiesApi - axios parameter creator
 * @export
 */
const ActivitiesApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * Get a single activity by ID
         * @summary Get a single activity by ID
         * @param {string} chainName The name of chain
         * @param {string} activityId The id of activity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getActivity: async (chainName, activityId, options = {}) => {
            // verify required parameter 'chainName' is not null or undefined
            assertParamExists('getActivity', 'chainName', chainName);
            // verify required parameter 'activityId' is not null or undefined
            assertParamExists('getActivity', 'activityId', activityId);
            const localVarPath = `/v1/chains/{chain_name}/activities/{activity_id}`
                .replace(`{${"chain_name"}}`, encodeURIComponent(String(chainName)))
                .replace(`{${"activity_id"}}`, encodeURIComponent(String(activityId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List all activities
         * @summary List all activities
         * @param {string} chainName The name of chain
         * @param {string} [contractAddress] The contract address of NFT or ERC20 Token
         * @param {string} [tokenId] An &#x60;uint256&#x60; token id as string
         * @param {string} [accountAddress] The account address activity contains
         * @param {ActivityType} [activityType] The activity type
         * @param {string} [fromIndexedAt] From indexed at including given date
         * @param {string} [toIndexedAt] To indexed at including given date
         * @param {string} [transactionHash] The transaction hash of activity
         * @param {string} [pageCursor] Encoded page cursor to retrieve previous or next page. Use the value returned in the response.
         * @param {number} [pageSize] Maximum number of items to return
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listActivities: async (chainName, contractAddress, tokenId, accountAddress, activityType, fromIndexedAt, toIndexedAt, transactionHash, pageCursor, pageSize, options = {}) => {
            // verify required parameter 'chainName' is not null or undefined
            assertParamExists('listActivities', 'chainName', chainName);
            const localVarPath = `/v1/chains/{chain_name}/activities`
                .replace(`{${"chain_name"}}`, encodeURIComponent(String(chainName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (contractAddress !== undefined) {
                localVarQueryParameter['contract_address'] = contractAddress;
            }
            if (tokenId !== undefined) {
                localVarQueryParameter['token_id'] = tokenId;
            }
            if (accountAddress !== undefined) {
                localVarQueryParameter['account_address'] = accountAddress;
            }
            if (activityType !== undefined) {
                localVarQueryParameter['activity_type'] = activityType;
            }
            if (fromIndexedAt !== undefined) {
                localVarQueryParameter['from_indexed_at'] = (fromIndexedAt instanceof Date) ?
                    fromIndexedAt.toISOString() :
                    fromIndexedAt;
            }
            if (toIndexedAt !== undefined) {
                localVarQueryParameter['to_indexed_at'] = (toIndexedAt instanceof Date) ?
                    toIndexedAt.toISOString() :
                    toIndexedAt;
            }
            if (transactionHash !== undefined) {
                localVarQueryParameter['transaction_hash'] = transactionHash;
            }
            if (pageCursor !== undefined) {
                localVarQueryParameter['page_cursor'] = pageCursor;
            }
            if (pageSize !== undefined) {
                localVarQueryParameter['page_size'] = pageSize;
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
/**
 * ActivitiesApi - functional programming interface
 * @export
 */
const ActivitiesApiFp = function (configuration) {
    const localVarAxiosParamCreator = ActivitiesApiAxiosParamCreator(configuration);
    return {
        /**
         * Get a single activity by ID
         * @summary Get a single activity by ID
         * @param {string} chainName The name of chain
         * @param {string} activityId The id of activity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getActivity(chainName, activityId, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getActivity(chainName, activityId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * List all activities
         * @summary List all activities
         * @param {string} chainName The name of chain
         * @param {string} [contractAddress] The contract address of NFT or ERC20 Token
         * @param {string} [tokenId] An &#x60;uint256&#x60; token id as string
         * @param {string} [accountAddress] The account address activity contains
         * @param {ActivityType} [activityType] The activity type
         * @param {string} [fromIndexedAt] From indexed at including given date
         * @param {string} [toIndexedAt] To indexed at including given date
         * @param {string} [transactionHash] The transaction hash of activity
         * @param {string} [pageCursor] Encoded page cursor to retrieve previous or next page. Use the value returned in the response.
         * @param {number} [pageSize] Maximum number of items to return
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listActivities(chainName, contractAddress, tokenId, accountAddress, activityType, fromIndexedAt, toIndexedAt, transactionHash, pageCursor, pageSize, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listActivities(chainName, contractAddress, tokenId, accountAddress, activityType, fromIndexedAt, toIndexedAt, transactionHash, pageCursor, pageSize, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    };
};
/**
 * ActivitiesApi - factory interface
 * @export
 */
const ActivitiesApiFactory = function (configuration, basePath, axios) {
    const localVarFp = ActivitiesApiFp(configuration);
    return {
        /**
         * Get a single activity by ID
         * @summary Get a single activity by ID
         * @param {string} chainName The name of chain
         * @param {string} activityId The id of activity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getActivity(chainName, activityId, options) {
            return localVarFp.getActivity(chainName, activityId, options).then((request) => request(axios, basePath));
        },
        /**
         * List all activities
         * @summary List all activities
         * @param {string} chainName The name of chain
         * @param {string} [contractAddress] The contract address of NFT or ERC20 Token
         * @param {string} [tokenId] An &#x60;uint256&#x60; token id as string
         * @param {string} [accountAddress] The account address activity contains
         * @param {ActivityType} [activityType] The activity type
         * @param {string} [fromIndexedAt] From indexed at including given date
         * @param {string} [toIndexedAt] To indexed at including given date
         * @param {string} [transactionHash] The transaction hash of activity
         * @param {string} [pageCursor] Encoded page cursor to retrieve previous or next page. Use the value returned in the response.
         * @param {number} [pageSize] Maximum number of items to return
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listActivities(chainName, contractAddress, tokenId, accountAddress, activityType, fromIndexedAt, toIndexedAt, transactionHash, pageCursor, pageSize, options) {
            return localVarFp.listActivities(chainName, contractAddress, tokenId, accountAddress, activityType, fromIndexedAt, toIndexedAt, transactionHash, pageCursor, pageSize, options).then((request) => request(axios, basePath));
        },
    };
};
/**
 * ActivitiesApi - object-oriented interface
 * @export
 * @class ActivitiesApi
 * @extends {BaseAPI}
 */
class ActivitiesApi extends BaseAPI {
    /**
     * Get a single activity by ID
     * @summary Get a single activity by ID
     * @param {ActivitiesApiGetActivityRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActivitiesApi
     */
    getActivity(requestParameters, options) {
        return ActivitiesApiFp(this.configuration).getActivity(requestParameters.chainName, requestParameters.activityId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * List all activities
     * @summary List all activities
     * @param {ActivitiesApiListActivitiesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActivitiesApi
     */
    listActivities(requestParameters, options) {
        return ActivitiesApiFp(this.configuration).listActivities(requestParameters.chainName, requestParameters.contractAddress, requestParameters.tokenId, requestParameters.accountAddress, requestParameters.activityType, requestParameters.fromIndexedAt, requestParameters.toIndexedAt, requestParameters.transactionHash, requestParameters.pageCursor, requestParameters.pageSize, options).then((request) => request(this.axios, this.basePath));
    }
}

/* tslint:disable */
/* eslint-disable */
/**
 * Immutable zkEVM API
 * Immutable Multi Rollup API
 *
 * The version of the OpenAPI document: 1.0.0
 * Contact: support@immutable.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
/**
 * ChainsApi - axios parameter creator
 * @export
 */
const ChainsApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * List supported chains
         * @summary List supported chains
         * @param {string} [pageCursor] Encoded page cursor to retrieve previous or next page. Use the value returned in the response.
         * @param {number} [pageSize] Maximum number of items to return
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listChains: async (pageCursor, pageSize, options = {}) => {
            const localVarPath = `/v1/chains`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (pageCursor !== undefined) {
                localVarQueryParameter['page_cursor'] = pageCursor;
            }
            if (pageSize !== undefined) {
                localVarQueryParameter['page_size'] = pageSize;
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
/**
 * ChainsApi - functional programming interface
 * @export
 */
const ChainsApiFp = function (configuration) {
    const localVarAxiosParamCreator = ChainsApiAxiosParamCreator(configuration);
    return {
        /**
         * List supported chains
         * @summary List supported chains
         * @param {string} [pageCursor] Encoded page cursor to retrieve previous or next page. Use the value returned in the response.
         * @param {number} [pageSize] Maximum number of items to return
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listChains(pageCursor, pageSize, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listChains(pageCursor, pageSize, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    };
};
/**
 * ChainsApi - factory interface
 * @export
 */
const ChainsApiFactory = function (configuration, basePath, axios) {
    const localVarFp = ChainsApiFp(configuration);
    return {
        /**
         * List supported chains
         * @summary List supported chains
         * @param {string} [pageCursor] Encoded page cursor to retrieve previous or next page. Use the value returned in the response.
         * @param {number} [pageSize] Maximum number of items to return
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listChains(pageCursor, pageSize, options) {
            return localVarFp.listChains(pageCursor, pageSize, options).then((request) => request(axios, basePath));
        },
    };
};
/**
 * ChainsApi - object-oriented interface
 * @export
 * @class ChainsApi
 * @extends {BaseAPI}
 */
class ChainsApi extends BaseAPI {
    /**
     * List supported chains
     * @summary List supported chains
     * @param {ChainsApiListChainsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChainsApi
     */
    listChains(requestParameters = {}, options) {
        return ChainsApiFp(this.configuration).listChains(requestParameters.pageCursor, requestParameters.pageSize, options).then((request) => request(this.axios, this.basePath));
    }
}

/* tslint:disable */
/* eslint-disable */
/**
 * Immutable zkEVM API
 * Immutable Multi Rollup API
 *
 * The version of the OpenAPI document: 1.0.0
 * Contact: support@immutable.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
/**
 * CollectionsApi - axios parameter creator
 * @export
 */
const CollectionsApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * Get collection by contract address
         * @summary Get collection by contract address
         * @param {string} contractAddress The address contract
         * @param {string} chainName The name of chain
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCollection: async (contractAddress, chainName, options = {}) => {
            // verify required parameter 'contractAddress' is not null or undefined
            assertParamExists('getCollection', 'contractAddress', contractAddress);
            // verify required parameter 'chainName' is not null or undefined
            assertParamExists('getCollection', 'chainName', chainName);
            const localVarPath = `/v1/chains/{chain_name}/collections/{contract_address}`
                .replace(`{${"contract_address"}}`, encodeURIComponent(String(contractAddress)))
                .replace(`{${"chain_name"}}`, encodeURIComponent(String(chainName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List all collections
         * @summary List all collections
         * @param {string} chainName The name of chain
         * @param {string} [pageCursor] Encoded page cursor to retrieve previous or next page. Use the value returned in the response.
         * @param {number} [pageSize] Maximum number of items to return
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listCollections: async (chainName, pageCursor, pageSize, options = {}) => {
            // verify required parameter 'chainName' is not null or undefined
            assertParamExists('listCollections', 'chainName', chainName);
            const localVarPath = `/v1/chains/{chain_name}/collections`
                .replace(`{${"chain_name"}}`, encodeURIComponent(String(chainName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (pageCursor !== undefined) {
                localVarQueryParameter['page_cursor'] = pageCursor;
            }
            if (pageSize !== undefined) {
                localVarQueryParameter['page_size'] = pageSize;
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List collections by NFT owner account address
         * @summary List collections by NFT owner
         * @param {string} accountAddress Account address
         * @param {string} chainName The name of chain
         * @param {string} [pageCursor] Encoded page cursor to retrieve previous or next page. Use the value returned in the response.
         * @param {number} [pageSize] Maximum number of items to return
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listCollectionsByNFTOwner: async (accountAddress, chainName, pageCursor, pageSize, options = {}) => {
            // verify required parameter 'accountAddress' is not null or undefined
            assertParamExists('listCollectionsByNFTOwner', 'accountAddress', accountAddress);
            // verify required parameter 'chainName' is not null or undefined
            assertParamExists('listCollectionsByNFTOwner', 'chainName', chainName);
            const localVarPath = `/v1/chains/{chain_name}/accounts/{account_address}/collections`
                .replace(`{${"account_address"}}`, encodeURIComponent(String(accountAddress)))
                .replace(`{${"chain_name"}}`, encodeURIComponent(String(chainName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (pageCursor !== undefined) {
                localVarQueryParameter['page_cursor'] = pageCursor;
            }
            if (pageSize !== undefined) {
                localVarQueryParameter['page_size'] = pageSize;
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Refresh collection metadata
         * @summary Refresh collection metadata
         * @param {string} contractAddress The address contract
         * @param {string} chainName The name of chain
         * @param {RefreshCollectionMetadataRequest} refreshCollectionMetadataRequest The request body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        refreshCollectionMetadata: async (contractAddress, chainName, refreshCollectionMetadataRequest, options = {}) => {
            // verify required parameter 'contractAddress' is not null or undefined
            assertParamExists('refreshCollectionMetadata', 'contractAddress', contractAddress);
            // verify required parameter 'chainName' is not null or undefined
            assertParamExists('refreshCollectionMetadata', 'chainName', chainName);
            // verify required parameter 'refreshCollectionMetadataRequest' is not null or undefined
            assertParamExists('refreshCollectionMetadata', 'refreshCollectionMetadataRequest', refreshCollectionMetadataRequest);
            const localVarPath = `/v1/chains/{chain_name}/collections/{contract_address}/refresh-metadata`
                .replace(`{${"contract_address"}}`, encodeURIComponent(String(contractAddress)))
                .replace(`{${"chain_name"}}`, encodeURIComponent(String(chainName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ImmutableApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "X-Immutable-API-Key", configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = serializeDataIfNeeded(refreshCollectionMetadataRequest, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
/**
 * CollectionsApi - functional programming interface
 * @export
 */
const CollectionsApiFp = function (configuration) {
    const localVarAxiosParamCreator = CollectionsApiAxiosParamCreator(configuration);
    return {
        /**
         * Get collection by contract address
         * @summary Get collection by contract address
         * @param {string} contractAddress The address contract
         * @param {string} chainName The name of chain
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCollection(contractAddress, chainName, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCollection(contractAddress, chainName, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * List all collections
         * @summary List all collections
         * @param {string} chainName The name of chain
         * @param {string} [pageCursor] Encoded page cursor to retrieve previous or next page. Use the value returned in the response.
         * @param {number} [pageSize] Maximum number of items to return
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listCollections(chainName, pageCursor, pageSize, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listCollections(chainName, pageCursor, pageSize, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * List collections by NFT owner account address
         * @summary List collections by NFT owner
         * @param {string} accountAddress Account address
         * @param {string} chainName The name of chain
         * @param {string} [pageCursor] Encoded page cursor to retrieve previous or next page. Use the value returned in the response.
         * @param {number} [pageSize] Maximum number of items to return
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listCollectionsByNFTOwner(accountAddress, chainName, pageCursor, pageSize, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listCollectionsByNFTOwner(accountAddress, chainName, pageCursor, pageSize, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Refresh collection metadata
         * @summary Refresh collection metadata
         * @param {string} contractAddress The address contract
         * @param {string} chainName The name of chain
         * @param {RefreshCollectionMetadataRequest} refreshCollectionMetadataRequest The request body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async refreshCollectionMetadata(contractAddress, chainName, refreshCollectionMetadataRequest, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.refreshCollectionMetadata(contractAddress, chainName, refreshCollectionMetadataRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    };
};
/**
 * CollectionsApi - factory interface
 * @export
 */
const CollectionsApiFactory = function (configuration, basePath, axios) {
    const localVarFp = CollectionsApiFp(configuration);
    return {
        /**
         * Get collection by contract address
         * @summary Get collection by contract address
         * @param {string} contractAddress The address contract
         * @param {string} chainName The name of chain
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCollection(contractAddress, chainName, options) {
            return localVarFp.getCollection(contractAddress, chainName, options).then((request) => request(axios, basePath));
        },
        /**
         * List all collections
         * @summary List all collections
         * @param {string} chainName The name of chain
         * @param {string} [pageCursor] Encoded page cursor to retrieve previous or next page. Use the value returned in the response.
         * @param {number} [pageSize] Maximum number of items to return
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listCollections(chainName, pageCursor, pageSize, options) {
            return localVarFp.listCollections(chainName, pageCursor, pageSize, options).then((request) => request(axios, basePath));
        },
        /**
         * List collections by NFT owner account address
         * @summary List collections by NFT owner
         * @param {string} accountAddress Account address
         * @param {string} chainName The name of chain
         * @param {string} [pageCursor] Encoded page cursor to retrieve previous or next page. Use the value returned in the response.
         * @param {number} [pageSize] Maximum number of items to return
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listCollectionsByNFTOwner(accountAddress, chainName, pageCursor, pageSize, options) {
            return localVarFp.listCollectionsByNFTOwner(accountAddress, chainName, pageCursor, pageSize, options).then((request) => request(axios, basePath));
        },
        /**
         * Refresh collection metadata
         * @summary Refresh collection metadata
         * @param {string} contractAddress The address contract
         * @param {string} chainName The name of chain
         * @param {RefreshCollectionMetadataRequest} refreshCollectionMetadataRequest The request body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        refreshCollectionMetadata(contractAddress, chainName, refreshCollectionMetadataRequest, options) {
            return localVarFp.refreshCollectionMetadata(contractAddress, chainName, refreshCollectionMetadataRequest, options).then((request) => request(axios, basePath));
        },
    };
};
/**
 * CollectionsApi - object-oriented interface
 * @export
 * @class CollectionsApi
 * @extends {BaseAPI}
 */
class CollectionsApi extends BaseAPI {
    /**
     * Get collection by contract address
     * @summary Get collection by contract address
     * @param {CollectionsApiGetCollectionRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CollectionsApi
     */
    getCollection(requestParameters, options) {
        return CollectionsApiFp(this.configuration).getCollection(requestParameters.contractAddress, requestParameters.chainName, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * List all collections
     * @summary List all collections
     * @param {CollectionsApiListCollectionsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CollectionsApi
     */
    listCollections(requestParameters, options) {
        return CollectionsApiFp(this.configuration).listCollections(requestParameters.chainName, requestParameters.pageCursor, requestParameters.pageSize, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * List collections by NFT owner account address
     * @summary List collections by NFT owner
     * @param {CollectionsApiListCollectionsByNFTOwnerRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CollectionsApi
     */
    listCollectionsByNFTOwner(requestParameters, options) {
        return CollectionsApiFp(this.configuration).listCollectionsByNFTOwner(requestParameters.accountAddress, requestParameters.chainName, requestParameters.pageCursor, requestParameters.pageSize, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Refresh collection metadata
     * @summary Refresh collection metadata
     * @param {CollectionsApiRefreshCollectionMetadataRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CollectionsApi
     */
    refreshCollectionMetadata(requestParameters, options) {
        return CollectionsApiFp(this.configuration).refreshCollectionMetadata(requestParameters.contractAddress, requestParameters.chainName, requestParameters.refreshCollectionMetadataRequest, options).then((request) => request(this.axios, this.basePath));
    }
}

/* tslint:disable */
/* eslint-disable */
/**
 * Immutable zkEVM API
 * Immutable Multi Rollup API
 *
 * The version of the OpenAPI document: 1.0.0
 * Contact: support@immutable.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
/**
 * MetadataApi - axios parameter creator
 * @export
 */
const MetadataApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * Get a single metadata by ID
         * @summary Get a single metadata by ID
         * @param {string} chainName The name of chain
         * @param {string} contractAddress The address of metadata contract
         * @param {string} metadataId The id of the metadata
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMetadata: async (chainName, contractAddress, metadataId, options = {}) => {
            // verify required parameter 'chainName' is not null or undefined
            assertParamExists('getMetadata', 'chainName', chainName);
            // verify required parameter 'contractAddress' is not null or undefined
            assertParamExists('getMetadata', 'contractAddress', contractAddress);
            // verify required parameter 'metadataId' is not null or undefined
            assertParamExists('getMetadata', 'metadataId', metadataId);
            const localVarPath = `/v1/chains/{chain_name}/collections/{contract_address}/metadata/{metadata_id}`
                .replace(`{${"chain_name"}}`, encodeURIComponent(String(chainName)))
                .replace(`{${"contract_address"}}`, encodeURIComponent(String(contractAddress)))
                .replace(`{${"metadata_id"}}`, encodeURIComponent(String(metadataId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Refresh shared metadata for a collection
         * @param {string} chainName The name of chain
         * @param {string} contractAddress Contract address
         * @param {RefreshMetadataByIDRequest} refreshMetadataByIDRequest NFT Metadata Refresh Request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        refreshMetadataByID: async (chainName, contractAddress, refreshMetadataByIDRequest, options = {}) => {
            // verify required parameter 'chainName' is not null or undefined
            assertParamExists('refreshMetadataByID', 'chainName', chainName);
            // verify required parameter 'contractAddress' is not null or undefined
            assertParamExists('refreshMetadataByID', 'contractAddress', contractAddress);
            // verify required parameter 'refreshMetadataByIDRequest' is not null or undefined
            assertParamExists('refreshMetadataByID', 'refreshMetadataByIDRequest', refreshMetadataByIDRequest);
            const localVarPath = `/v1/chains/{chain_name}/collections/{contract_address}/metadata/refresh-metadata`
                .replace(`{${"chain_name"}}`, encodeURIComponent(String(chainName)))
                .replace(`{${"contract_address"}}`, encodeURIComponent(String(contractAddress)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ImmutableApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "X-Immutable-API-Key", configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = serializeDataIfNeeded(refreshMetadataByIDRequest, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
/**
 * MetadataApi - functional programming interface
 * @export
 */
const MetadataApiFp = function (configuration) {
    const localVarAxiosParamCreator = MetadataApiAxiosParamCreator(configuration);
    return {
        /**
         * Get a single metadata by ID
         * @summary Get a single metadata by ID
         * @param {string} chainName The name of chain
         * @param {string} contractAddress The address of metadata contract
         * @param {string} metadataId The id of the metadata
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMetadata(chainName, contractAddress, metadataId, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getMetadata(chainName, contractAddress, metadataId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Refresh shared metadata for a collection
         * @param {string} chainName The name of chain
         * @param {string} contractAddress Contract address
         * @param {RefreshMetadataByIDRequest} refreshMetadataByIDRequest NFT Metadata Refresh Request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async refreshMetadataByID(chainName, contractAddress, refreshMetadataByIDRequest, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.refreshMetadataByID(chainName, contractAddress, refreshMetadataByIDRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    };
};
/**
 * MetadataApi - factory interface
 * @export
 */
const MetadataApiFactory = function (configuration, basePath, axios) {
    const localVarFp = MetadataApiFp(configuration);
    return {
        /**
         * Get a single metadata by ID
         * @summary Get a single metadata by ID
         * @param {string} chainName The name of chain
         * @param {string} contractAddress The address of metadata contract
         * @param {string} metadataId The id of the metadata
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMetadata(chainName, contractAddress, metadataId, options) {
            return localVarFp.getMetadata(chainName, contractAddress, metadataId, options).then((request) => request(axios, basePath));
        },
        /**
         * Refresh shared metadata for a collection
         * @param {string} chainName The name of chain
         * @param {string} contractAddress Contract address
         * @param {RefreshMetadataByIDRequest} refreshMetadataByIDRequest NFT Metadata Refresh Request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        refreshMetadataByID(chainName, contractAddress, refreshMetadataByIDRequest, options) {
            return localVarFp.refreshMetadataByID(chainName, contractAddress, refreshMetadataByIDRequest, options).then((request) => request(axios, basePath));
        },
    };
};
/**
 * MetadataApi - object-oriented interface
 * @export
 * @class MetadataApi
 * @extends {BaseAPI}
 */
class MetadataApi extends BaseAPI {
    /**
     * Get a single metadata by ID
     * @summary Get a single metadata by ID
     * @param {MetadataApiGetMetadataRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MetadataApi
     */
    getMetadata(requestParameters, options) {
        return MetadataApiFp(this.configuration).getMetadata(requestParameters.chainName, requestParameters.contractAddress, requestParameters.metadataId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Refresh shared metadata for a collection
     * @param {MetadataApiRefreshMetadataByIDRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MetadataApi
     */
    refreshMetadataByID(requestParameters, options) {
        return MetadataApiFp(this.configuration).refreshMetadataByID(requestParameters.chainName, requestParameters.contractAddress, requestParameters.refreshMetadataByIDRequest, options).then((request) => request(this.axios, this.basePath));
    }
}

/* tslint:disable */
/* eslint-disable */
/**
 * Immutable zkEVM API
 * Immutable Multi Rollup API
 *
 * The version of the OpenAPI document: 1.0.0
 * Contact: support@immutable.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
/**
 * NftOwnersApi - axios parameter creator
 * @export
 */
const NftOwnersApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * List NFT owners by token ID
         * @summary List NFT owners by token ID
         * @param {string} contractAddress The address of contract
         * @param {string} tokenId An &#x60;uint256&#x60; token id as string
         * @param {string} chainName The name of chain
         * @param {string} [pageCursor] Encoded page cursor to retrieve previous or next page. Use the value returned in the response.
         * @param {number} [pageSize] Maximum number of items to return
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listNFTOwners: async (contractAddress, tokenId, chainName, pageCursor, pageSize, options = {}) => {
            // verify required parameter 'contractAddress' is not null or undefined
            assertParamExists('listNFTOwners', 'contractAddress', contractAddress);
            // verify required parameter 'tokenId' is not null or undefined
            assertParamExists('listNFTOwners', 'tokenId', tokenId);
            // verify required parameter 'chainName' is not null or undefined
            assertParamExists('listNFTOwners', 'chainName', chainName);
            const localVarPath = `/v1/chains/{chain_name}/collections/{contract_address}/nfts/{token_id}/owners`
                .replace(`{${"contract_address"}}`, encodeURIComponent(String(contractAddress)))
                .replace(`{${"token_id"}}`, encodeURIComponent(String(tokenId)))
                .replace(`{${"chain_name"}}`, encodeURIComponent(String(chainName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (pageCursor !== undefined) {
                localVarQueryParameter['page_cursor'] = pageCursor;
            }
            if (pageSize !== undefined) {
                localVarQueryParameter['page_size'] = pageSize;
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
/**
 * NftOwnersApi - functional programming interface
 * @export
 */
const NftOwnersApiFp = function (configuration) {
    const localVarAxiosParamCreator = NftOwnersApiAxiosParamCreator(configuration);
    return {
        /**
         * List NFT owners by token ID
         * @summary List NFT owners by token ID
         * @param {string} contractAddress The address of contract
         * @param {string} tokenId An &#x60;uint256&#x60; token id as string
         * @param {string} chainName The name of chain
         * @param {string} [pageCursor] Encoded page cursor to retrieve previous or next page. Use the value returned in the response.
         * @param {number} [pageSize] Maximum number of items to return
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listNFTOwners(contractAddress, tokenId, chainName, pageCursor, pageSize, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listNFTOwners(contractAddress, tokenId, chainName, pageCursor, pageSize, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    };
};
/**
 * NftOwnersApi - factory interface
 * @export
 */
const NftOwnersApiFactory = function (configuration, basePath, axios) {
    const localVarFp = NftOwnersApiFp(configuration);
    return {
        /**
         * List NFT owners by token ID
         * @summary List NFT owners by token ID
         * @param {string} contractAddress The address of contract
         * @param {string} tokenId An &#x60;uint256&#x60; token id as string
         * @param {string} chainName The name of chain
         * @param {string} [pageCursor] Encoded page cursor to retrieve previous or next page. Use the value returned in the response.
         * @param {number} [pageSize] Maximum number of items to return
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listNFTOwners(contractAddress, tokenId, chainName, pageCursor, pageSize, options) {
            return localVarFp.listNFTOwners(contractAddress, tokenId, chainName, pageCursor, pageSize, options).then((request) => request(axios, basePath));
        },
    };
};
/**
 * NftOwnersApi - object-oriented interface
 * @export
 * @class NftOwnersApi
 * @extends {BaseAPI}
 */
class NftOwnersApi extends BaseAPI {
    /**
     * List NFT owners by token ID
     * @summary List NFT owners by token ID
     * @param {NftOwnersApiListNFTOwnersRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NftOwnersApi
     */
    listNFTOwners(requestParameters, options) {
        return NftOwnersApiFp(this.configuration).listNFTOwners(requestParameters.contractAddress, requestParameters.tokenId, requestParameters.chainName, requestParameters.pageCursor, requestParameters.pageSize, options).then((request) => request(this.axios, this.basePath));
    }
}

/* tslint:disable */
/* eslint-disable */
/**
 * Immutable zkEVM API
 * Immutable Multi Rollup API
 *
 * The version of the OpenAPI document: 1.0.0
 * Contact: support@immutable.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
/**
 * NftsApi - axios parameter creator
 * @export
 */
const NftsApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * Get NFT by token ID
         * @summary Get NFT by token ID
         * @param {string} contractAddress The address of NFT contract
         * @param {string} tokenId An &#x60;uint256&#x60; token id as string
         * @param {string} chainName The name of chain
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getNFT: async (contractAddress, tokenId, chainName, options = {}) => {
            // verify required parameter 'contractAddress' is not null or undefined
            assertParamExists('getNFT', 'contractAddress', contractAddress);
            // verify required parameter 'tokenId' is not null or undefined
            assertParamExists('getNFT', 'tokenId', tokenId);
            // verify required parameter 'chainName' is not null or undefined
            assertParamExists('getNFT', 'chainName', chainName);
            const localVarPath = `/v1/chains/{chain_name}/collections/{contract_address}/nfts/{token_id}`
                .replace(`{${"contract_address"}}`, encodeURIComponent(String(contractAddress)))
                .replace(`{${"token_id"}}`, encodeURIComponent(String(tokenId)))
                .replace(`{${"chain_name"}}`, encodeURIComponent(String(chainName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List NFTs by contract address
         * @summary List NFTs by contract address
         * @param {string} contractAddress Contract address
         * @param {string} chainName The name of chain
         * @param {string} [pageCursor] Encoded page cursor to retrieve previous or next page. Use the value returned in the response.
         * @param {number} [pageSize] Maximum number of items to return
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listNFTs: async (contractAddress, chainName, pageCursor, pageSize, options = {}) => {
            // verify required parameter 'contractAddress' is not null or undefined
            assertParamExists('listNFTs', 'contractAddress', contractAddress);
            // verify required parameter 'chainName' is not null or undefined
            assertParamExists('listNFTs', 'chainName', chainName);
            const localVarPath = `/v1/chains/{chain_name}/collections/{contract_address}/nfts`
                .replace(`{${"contract_address"}}`, encodeURIComponent(String(contractAddress)))
                .replace(`{${"chain_name"}}`, encodeURIComponent(String(chainName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (pageCursor !== undefined) {
                localVarQueryParameter['page_cursor'] = pageCursor;
            }
            if (pageSize !== undefined) {
                localVarQueryParameter['page_size'] = pageSize;
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List NFTs by account address
         * @summary List NFTs by account address
         * @param {string} accountAddress Account address
         * @param {string} chainName The name of chain
         * @param {string} [contractAddress] The address of contract
         * @param {string} [pageCursor] Encoded page cursor to retrieve previous or next page. Use the value returned in the response.
         * @param {number} [pageSize] Maximum number of items to return
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listNFTsByAccountAddress: async (accountAddress, chainName, contractAddress, pageCursor, pageSize, options = {}) => {
            // verify required parameter 'accountAddress' is not null or undefined
            assertParamExists('listNFTsByAccountAddress', 'accountAddress', accountAddress);
            // verify required parameter 'chainName' is not null or undefined
            assertParamExists('listNFTsByAccountAddress', 'chainName', chainName);
            const localVarPath = `/v1/chains/{chain_name}/accounts/{account_address}/nfts`
                .replace(`{${"account_address"}}`, encodeURIComponent(String(accountAddress)))
                .replace(`{${"chain_name"}}`, encodeURIComponent(String(chainName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (contractAddress !== undefined) {
                localVarQueryParameter['contract_address'] = contractAddress;
            }
            if (pageCursor !== undefined) {
                localVarQueryParameter['page_cursor'] = pageCursor;
            }
            if (pageSize !== undefined) {
                localVarQueryParameter['page_size'] = pageSize;
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
/**
 * NftsApi - functional programming interface
 * @export
 */
const NftsApiFp = function (configuration) {
    const localVarAxiosParamCreator = NftsApiAxiosParamCreator(configuration);
    return {
        /**
         * Get NFT by token ID
         * @summary Get NFT by token ID
         * @param {string} contractAddress The address of NFT contract
         * @param {string} tokenId An &#x60;uint256&#x60; token id as string
         * @param {string} chainName The name of chain
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getNFT(contractAddress, tokenId, chainName, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getNFT(contractAddress, tokenId, chainName, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * List NFTs by contract address
         * @summary List NFTs by contract address
         * @param {string} contractAddress Contract address
         * @param {string} chainName The name of chain
         * @param {string} [pageCursor] Encoded page cursor to retrieve previous or next page. Use the value returned in the response.
         * @param {number} [pageSize] Maximum number of items to return
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listNFTs(contractAddress, chainName, pageCursor, pageSize, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listNFTs(contractAddress, chainName, pageCursor, pageSize, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * List NFTs by account address
         * @summary List NFTs by account address
         * @param {string} accountAddress Account address
         * @param {string} chainName The name of chain
         * @param {string} [contractAddress] The address of contract
         * @param {string} [pageCursor] Encoded page cursor to retrieve previous or next page. Use the value returned in the response.
         * @param {number} [pageSize] Maximum number of items to return
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listNFTsByAccountAddress(accountAddress, chainName, contractAddress, pageCursor, pageSize, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listNFTsByAccountAddress(accountAddress, chainName, contractAddress, pageCursor, pageSize, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    };
};
/**
 * NftsApi - factory interface
 * @export
 */
const NftsApiFactory = function (configuration, basePath, axios) {
    const localVarFp = NftsApiFp(configuration);
    return {
        /**
         * Get NFT by token ID
         * @summary Get NFT by token ID
         * @param {string} contractAddress The address of NFT contract
         * @param {string} tokenId An &#x60;uint256&#x60; token id as string
         * @param {string} chainName The name of chain
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getNFT(contractAddress, tokenId, chainName, options) {
            return localVarFp.getNFT(contractAddress, tokenId, chainName, options).then((request) => request(axios, basePath));
        },
        /**
         * List NFTs by contract address
         * @summary List NFTs by contract address
         * @param {string} contractAddress Contract address
         * @param {string} chainName The name of chain
         * @param {string} [pageCursor] Encoded page cursor to retrieve previous or next page. Use the value returned in the response.
         * @param {number} [pageSize] Maximum number of items to return
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listNFTs(contractAddress, chainName, pageCursor, pageSize, options) {
            return localVarFp.listNFTs(contractAddress, chainName, pageCursor, pageSize, options).then((request) => request(axios, basePath));
        },
        /**
         * List NFTs by account address
         * @summary List NFTs by account address
         * @param {string} accountAddress Account address
         * @param {string} chainName The name of chain
         * @param {string} [contractAddress] The address of contract
         * @param {string} [pageCursor] Encoded page cursor to retrieve previous or next page. Use the value returned in the response.
         * @param {number} [pageSize] Maximum number of items to return
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listNFTsByAccountAddress(accountAddress, chainName, contractAddress, pageCursor, pageSize, options) {
            return localVarFp.listNFTsByAccountAddress(accountAddress, chainName, contractAddress, pageCursor, pageSize, options).then((request) => request(axios, basePath));
        },
    };
};
/**
 * NftsApi - object-oriented interface
 * @export
 * @class NftsApi
 * @extends {BaseAPI}
 */
class NftsApi extends BaseAPI {
    /**
     * Get NFT by token ID
     * @summary Get NFT by token ID
     * @param {NftsApiGetNFTRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NftsApi
     */
    getNFT(requestParameters, options) {
        return NftsApiFp(this.configuration).getNFT(requestParameters.contractAddress, requestParameters.tokenId, requestParameters.chainName, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * List NFTs by contract address
     * @summary List NFTs by contract address
     * @param {NftsApiListNFTsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NftsApi
     */
    listNFTs(requestParameters, options) {
        return NftsApiFp(this.configuration).listNFTs(requestParameters.contractAddress, requestParameters.chainName, requestParameters.pageCursor, requestParameters.pageSize, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * List NFTs by account address
     * @summary List NFTs by account address
     * @param {NftsApiListNFTsByAccountAddressRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NftsApi
     */
    listNFTsByAccountAddress(requestParameters, options) {
        return NftsApiFp(this.configuration).listNFTsByAccountAddress(requestParameters.accountAddress, requestParameters.chainName, requestParameters.contractAddress, requestParameters.pageCursor, requestParameters.pageSize, options).then((request) => request(this.axios, this.basePath));
    }
}

/* tslint:disable */
/* eslint-disable */
/**
 * Immutable zkEVM API
 * Immutable Multi Rollup API
 *
 * The version of the OpenAPI document: 1.0.0
 * Contact: support@immutable.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
/**
 * OrdersApi - axios parameter creator
 * @export
 */
const OrdersApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * Create a listing
         * @summary Create a listing
         * @param {string} chainName
         * @param {CreateListingRequestBody} createListingRequestBody
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createListing: async (chainName, createListingRequestBody, options = {}) => {
            // verify required parameter 'chainName' is not null or undefined
            assertParamExists('createListing', 'chainName', chainName);
            // verify required parameter 'createListingRequestBody' is not null or undefined
            assertParamExists('createListing', 'createListingRequestBody', createListingRequestBody);
            const localVarPath = `/v1/chains/{chain_name}/orders/listings`
                .replace(`{${"chain_name"}}`, encodeURIComponent(String(chainName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter['Content-Type'] = 'application/json';
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = serializeDataIfNeeded(createListingRequestBody, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve signed fulfillment data based on the list of order IDs and corresponding fees.
         * @summary Retrieve fulfillment data for orders
         * @param {string} chainName
         * @param {Array<FulfillmentDataRequest>} fulfillmentDataRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fulfillmentData: async (chainName, fulfillmentDataRequest, options = {}) => {
            // verify required parameter 'chainName' is not null or undefined
            assertParamExists('fulfillmentData', 'chainName', chainName);
            // verify required parameter 'fulfillmentDataRequest' is not null or undefined
            assertParamExists('fulfillmentData', 'fulfillmentDataRequest', fulfillmentDataRequest);
            const localVarPath = `/v1/chains/{chain_name}/orders/fulfillment-data`
                .replace(`{${"chain_name"}}`, encodeURIComponent(String(chainName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter['Content-Type'] = 'application/json';
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = serializeDataIfNeeded(fulfillmentDataRequest, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a single listing by ID
         * @summary Get a single listing by ID
         * @param {string} chainName
         * @param {string} listingId Global Order identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getListing: async (chainName, listingId, options = {}) => {
            // verify required parameter 'chainName' is not null or undefined
            assertParamExists('getListing', 'chainName', chainName);
            // verify required parameter 'listingId' is not null or undefined
            assertParamExists('getListing', 'listingId', listingId);
            const localVarPath = `/v1/chains/{chain_name}/orders/listings/{listing_id}`
                .replace(`{${"chain_name"}}`, encodeURIComponent(String(chainName)))
                .replace(`{${"listing_id"}}`, encodeURIComponent(String(listingId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a single trade by ID
         * @summary Get a single trade by ID
         * @param {string} chainName
         * @param {string} tradeId Global Trade identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTrade: async (chainName, tradeId, options = {}) => {
            // verify required parameter 'chainName' is not null or undefined
            assertParamExists('getTrade', 'chainName', chainName);
            // verify required parameter 'tradeId' is not null or undefined
            assertParamExists('getTrade', 'tradeId', tradeId);
            const localVarPath = `/v1/chains/{chain_name}/trades/{trade_id}`
                .replace(`{${"chain_name"}}`, encodeURIComponent(String(chainName)))
                .replace(`{${"trade_id"}}`, encodeURIComponent(String(tradeId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List all listings
         * @summary List all listings
         * @param {string} chainName
         * @param {OrderStatus} [status] Order status to filter by
         * @param {string} [sellItemContractAddress] Sell item contract address to filter by
         * @param {string} [buyItemContractAddress] Buy item contract address to filter by
         * @param {string} [sellItemTokenId] Sell item token identifier to filter by
         * @param {number} [pageSize] Maximum number of orders to return per page
         * @param {'created_at' | 'updated_at' | 'buy_item_amount'} [sortBy] Order field to sort by
         * @param {'asc' | 'desc'} [sortDirection] Ascending or descending direction for sort
         * @param {string} [pageCursor] Page cursor to retrieve previous or next page. Use the value returned in the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listListings: async (chainName, status, sellItemContractAddress, buyItemContractAddress, sellItemTokenId, pageSize, sortBy, sortDirection, pageCursor, options = {}) => {
            // verify required parameter 'chainName' is not null or undefined
            assertParamExists('listListings', 'chainName', chainName);
            const localVarPath = `/v1/chains/{chain_name}/orders/listings`
                .replace(`{${"chain_name"}}`, encodeURIComponent(String(chainName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (status !== undefined) {
                localVarQueryParameter['status'] = status;
            }
            if (sellItemContractAddress !== undefined) {
                localVarQueryParameter['sell_item_contract_address'] = sellItemContractAddress;
            }
            if (buyItemContractAddress !== undefined) {
                localVarQueryParameter['buy_item_contract_address'] = buyItemContractAddress;
            }
            if (sellItemTokenId !== undefined) {
                localVarQueryParameter['sell_item_token_id'] = sellItemTokenId;
            }
            if (pageSize !== undefined) {
                localVarQueryParameter['page_size'] = pageSize;
            }
            if (sortBy !== undefined) {
                localVarQueryParameter['sort_by'] = sortBy;
            }
            if (sortDirection !== undefined) {
                localVarQueryParameter['sort_direction'] = sortDirection;
            }
            if (pageCursor !== undefined) {
                localVarQueryParameter['page_cursor'] = pageCursor;
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List all trades
         * @summary List all trades
         * @param {string} chainName
         * @param {string} [accountAddress]
         * @param {number} [pageSize] Maximum number of trades to return per page
         * @param {'indexed_at'} [sortBy] Trade field to sort by
         * @param {'asc' | 'desc'} [sortDirection] Ascending or descending direction for sort
         * @param {string} [pageCursor] Page cursor to retrieve previous or next page. Use the value returned in the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listTrades: async (chainName, accountAddress, pageSize, sortBy, sortDirection, pageCursor, options = {}) => {
            // verify required parameter 'chainName' is not null or undefined
            assertParamExists('listTrades', 'chainName', chainName);
            const localVarPath = `/v1/chains/{chain_name}/trades`
                .replace(`{${"chain_name"}}`, encodeURIComponent(String(chainName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (accountAddress !== undefined) {
                localVarQueryParameter['account_address'] = accountAddress;
            }
            if (pageSize !== undefined) {
                localVarQueryParameter['page_size'] = pageSize;
            }
            if (sortBy !== undefined) {
                localVarQueryParameter['sort_by'] = sortBy;
            }
            if (sortDirection !== undefined) {
                localVarQueryParameter['sort_direction'] = sortDirection;
            }
            if (pageCursor !== undefined) {
                localVarQueryParameter['page_cursor'] = pageCursor;
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
/**
 * OrdersApi - functional programming interface
 * @export
 */
const OrdersApiFp = function (configuration) {
    const localVarAxiosParamCreator = OrdersApiAxiosParamCreator(configuration);
    return {
        /**
         * Create a listing
         * @summary Create a listing
         * @param {string} chainName
         * @param {CreateListingRequestBody} createListingRequestBody
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createListing(chainName, createListingRequestBody, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createListing(chainName, createListingRequestBody, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieve signed fulfillment data based on the list of order IDs and corresponding fees.
         * @summary Retrieve fulfillment data for orders
         * @param {string} chainName
         * @param {Array<FulfillmentDataRequest>} fulfillmentDataRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async fulfillmentData(chainName, fulfillmentDataRequest, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.fulfillmentData(chainName, fulfillmentDataRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get a single listing by ID
         * @summary Get a single listing by ID
         * @param {string} chainName
         * @param {string} listingId Global Order identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getListing(chainName, listingId, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getListing(chainName, listingId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get a single trade by ID
         * @summary Get a single trade by ID
         * @param {string} chainName
         * @param {string} tradeId Global Trade identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTrade(chainName, tradeId, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTrade(chainName, tradeId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * List all listings
         * @summary List all listings
         * @param {string} chainName
         * @param {OrderStatus} [status] Order status to filter by
         * @param {string} [sellItemContractAddress] Sell item contract address to filter by
         * @param {string} [buyItemContractAddress] Buy item contract address to filter by
         * @param {string} [sellItemTokenId] Sell item token identifier to filter by
         * @param {number} [pageSize] Maximum number of orders to return per page
         * @param {'created_at' | 'updated_at' | 'buy_item_amount'} [sortBy] Order field to sort by
         * @param {'asc' | 'desc'} [sortDirection] Ascending or descending direction for sort
         * @param {string} [pageCursor] Page cursor to retrieve previous or next page. Use the value returned in the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listListings(chainName, status, sellItemContractAddress, buyItemContractAddress, sellItemTokenId, pageSize, sortBy, sortDirection, pageCursor, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listListings(chainName, status, sellItemContractAddress, buyItemContractAddress, sellItemTokenId, pageSize, sortBy, sortDirection, pageCursor, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * List all trades
         * @summary List all trades
         * @param {string} chainName
         * @param {string} [accountAddress]
         * @param {number} [pageSize] Maximum number of trades to return per page
         * @param {'indexed_at'} [sortBy] Trade field to sort by
         * @param {'asc' | 'desc'} [sortDirection] Ascending or descending direction for sort
         * @param {string} [pageCursor] Page cursor to retrieve previous or next page. Use the value returned in the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listTrades(chainName, accountAddress, pageSize, sortBy, sortDirection, pageCursor, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listTrades(chainName, accountAddress, pageSize, sortBy, sortDirection, pageCursor, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    };
};
/**
 * OrdersApi - factory interface
 * @export
 */
const OrdersApiFactory = function (configuration, basePath, axios) {
    const localVarFp = OrdersApiFp(configuration);
    return {
        /**
         * Create a listing
         * @summary Create a listing
         * @param {string} chainName
         * @param {CreateListingRequestBody} createListingRequestBody
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createListing(chainName, createListingRequestBody, options) {
            return localVarFp.createListing(chainName, createListingRequestBody, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve signed fulfillment data based on the list of order IDs and corresponding fees.
         * @summary Retrieve fulfillment data for orders
         * @param {string} chainName
         * @param {Array<FulfillmentDataRequest>} fulfillmentDataRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fulfillmentData(chainName, fulfillmentDataRequest, options) {
            return localVarFp.fulfillmentData(chainName, fulfillmentDataRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a single listing by ID
         * @summary Get a single listing by ID
         * @param {string} chainName
         * @param {string} listingId Global Order identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getListing(chainName, listingId, options) {
            return localVarFp.getListing(chainName, listingId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a single trade by ID
         * @summary Get a single trade by ID
         * @param {string} chainName
         * @param {string} tradeId Global Trade identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTrade(chainName, tradeId, options) {
            return localVarFp.getTrade(chainName, tradeId, options).then((request) => request(axios, basePath));
        },
        /**
         * List all listings
         * @summary List all listings
         * @param {string} chainName
         * @param {OrderStatus} [status] Order status to filter by
         * @param {string} [sellItemContractAddress] Sell item contract address to filter by
         * @param {string} [buyItemContractAddress] Buy item contract address to filter by
         * @param {string} [sellItemTokenId] Sell item token identifier to filter by
         * @param {number} [pageSize] Maximum number of orders to return per page
         * @param {'created_at' | 'updated_at' | 'buy_item_amount'} [sortBy] Order field to sort by
         * @param {'asc' | 'desc'} [sortDirection] Ascending or descending direction for sort
         * @param {string} [pageCursor] Page cursor to retrieve previous or next page. Use the value returned in the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listListings(chainName, status, sellItemContractAddress, buyItemContractAddress, sellItemTokenId, pageSize, sortBy, sortDirection, pageCursor, options) {
            return localVarFp.listListings(chainName, status, sellItemContractAddress, buyItemContractAddress, sellItemTokenId, pageSize, sortBy, sortDirection, pageCursor, options).then((request) => request(axios, basePath));
        },
        /**
         * List all trades
         * @summary List all trades
         * @param {string} chainName
         * @param {string} [accountAddress]
         * @param {number} [pageSize] Maximum number of trades to return per page
         * @param {'indexed_at'} [sortBy] Trade field to sort by
         * @param {'asc' | 'desc'} [sortDirection] Ascending or descending direction for sort
         * @param {string} [pageCursor] Page cursor to retrieve previous or next page. Use the value returned in the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listTrades(chainName, accountAddress, pageSize, sortBy, sortDirection, pageCursor, options) {
            return localVarFp.listTrades(chainName, accountAddress, pageSize, sortBy, sortDirection, pageCursor, options).then((request) => request(axios, basePath));
        },
    };
};
/**
 * OrdersApi - object-oriented interface
 * @export
 * @class OrdersApi
 * @extends {BaseAPI}
 */
class OrdersApi extends BaseAPI {
    /**
     * Create a listing
     * @summary Create a listing
     * @param {OrdersApiCreateListingRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrdersApi
     */
    createListing(requestParameters, options) {
        return OrdersApiFp(this.configuration).createListing(requestParameters.chainName, requestParameters.createListingRequestBody, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Retrieve signed fulfillment data based on the list of order IDs and corresponding fees.
     * @summary Retrieve fulfillment data for orders
     * @param {OrdersApiFulfillmentDataRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrdersApi
     */
    fulfillmentData(requestParameters, options) {
        return OrdersApiFp(this.configuration).fulfillmentData(requestParameters.chainName, requestParameters.fulfillmentDataRequest, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Get a single listing by ID
     * @summary Get a single listing by ID
     * @param {OrdersApiGetListingRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrdersApi
     */
    getListing(requestParameters, options) {
        return OrdersApiFp(this.configuration).getListing(requestParameters.chainName, requestParameters.listingId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Get a single trade by ID
     * @summary Get a single trade by ID
     * @param {OrdersApiGetTradeRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrdersApi
     */
    getTrade(requestParameters, options) {
        return OrdersApiFp(this.configuration).getTrade(requestParameters.chainName, requestParameters.tradeId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * List all listings
     * @summary List all listings
     * @param {OrdersApiListListingsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrdersApi
     */
    listListings(requestParameters, options) {
        return OrdersApiFp(this.configuration).listListings(requestParameters.chainName, requestParameters.status, requestParameters.sellItemContractAddress, requestParameters.buyItemContractAddress, requestParameters.sellItemTokenId, requestParameters.pageSize, requestParameters.sortBy, requestParameters.sortDirection, requestParameters.pageCursor, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * List all trades
     * @summary List all trades
     * @param {OrdersApiListTradesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrdersApi
     */
    listTrades(requestParameters, options) {
        return OrdersApiFp(this.configuration).listTrades(requestParameters.chainName, requestParameters.accountAddress, requestParameters.pageSize, requestParameters.sortBy, requestParameters.sortDirection, requestParameters.pageCursor, options).then((request) => request(this.axios, this.basePath));
    }
}

/* tslint:disable */
/* eslint-disable */
/**
 * Immutable zkEVM API
 * Immutable Multi Rollup API
 *
 * The version of the OpenAPI document: 1.0.0
 * Contact: support@immutable.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
/**
 * PassportApi - axios parameter creator
 * @export
 */
const PassportApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * Create a counterfactual address for a user based on their Ethereum address
         * @summary Create a counterfactual address
         * @param {CreateCounterfactualAddressRequest} createCounterfactualAddressRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCounterfactualAddress: async (createCounterfactualAddressRequest, options = {}) => {
            // verify required parameter 'createCounterfactualAddressRequest' is not null or undefined
            assertParamExists('createCounterfactualAddress', 'createCounterfactualAddressRequest', createCounterfactualAddressRequest);
            const localVarPath = `/passport-mr/v1/counterfactual-address`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = serializeDataIfNeeded(createCounterfactualAddressRequest, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get all the Ethereum linked addresses for a user based on its userId
         * @summary Get Ethereum linked addresses for a user
         * @param {string} userId The user\&#39;s userId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLinkedAddresses: async (userId, options = {}) => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('getLinkedAddresses', 'userId', userId);
            const localVarPath = `/passport-mr/v1/users/{userId}/linked-addresses`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration);
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
/**
 * PassportApi - functional programming interface
 * @export
 */
const PassportApiFp = function (configuration) {
    const localVarAxiosParamCreator = PassportApiAxiosParamCreator(configuration);
    return {
        /**
         * Create a counterfactual address for a user based on their Ethereum address
         * @summary Create a counterfactual address
         * @param {CreateCounterfactualAddressRequest} createCounterfactualAddressRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createCounterfactualAddress(createCounterfactualAddressRequest, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createCounterfactualAddress(createCounterfactualAddressRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get all the Ethereum linked addresses for a user based on its userId
         * @summary Get Ethereum linked addresses for a user
         * @param {string} userId The user\&#39;s userId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getLinkedAddresses(userId, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getLinkedAddresses(userId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    };
};
/**
 * PassportApi - factory interface
 * @export
 */
const PassportApiFactory = function (configuration, basePath, axios) {
    const localVarFp = PassportApiFp(configuration);
    return {
        /**
         * Create a counterfactual address for a user based on their Ethereum address
         * @summary Create a counterfactual address
         * @param {CreateCounterfactualAddressRequest} createCounterfactualAddressRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCounterfactualAddress(createCounterfactualAddressRequest, options) {
            return localVarFp.createCounterfactualAddress(createCounterfactualAddressRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Get all the Ethereum linked addresses for a user based on its userId
         * @summary Get Ethereum linked addresses for a user
         * @param {string} userId The user\&#39;s userId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLinkedAddresses(userId, options) {
            return localVarFp.getLinkedAddresses(userId, options).then((request) => request(axios, basePath));
        },
    };
};
/**
 * PassportApi - object-oriented interface
 * @export
 * @class PassportApi
 * @extends {BaseAPI}
 */
class PassportApi extends BaseAPI {
    /**
     * Create a counterfactual address for a user based on their Ethereum address
     * @summary Create a counterfactual address
     * @param {PassportApiCreateCounterfactualAddressRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PassportApi
     */
    createCounterfactualAddress(requestParameters, options) {
        return PassportApiFp(this.configuration).createCounterfactualAddress(requestParameters.createCounterfactualAddressRequest, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Get all the Ethereum linked addresses for a user based on its userId
     * @summary Get Ethereum linked addresses for a user
     * @param {PassportApiGetLinkedAddressesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PassportApi
     */
    getLinkedAddresses(requestParameters, options) {
        return PassportApiFp(this.configuration).getLinkedAddresses(requestParameters.userId, options).then((request) => request(this.axios, this.basePath));
    }
}

/* tslint:disable */
/* eslint-disable */
/**
 * Immutable zkEVM API
 * Immutable Multi Rollup API
 *
 * The version of the OpenAPI document: 1.0.0
 * Contact: support@immutable.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
/**
 * TokensApi - axios parameter creator
 * @export
 */
const TokensApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * Get single ERC20 token
         * @summary Get single ERC20 token
         * @param {string} contractAddress The address of contract
         * @param {string} chainName The name of chain
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getERC20Token: async (contractAddress, chainName, options = {}) => {
            // verify required parameter 'contractAddress' is not null or undefined
            assertParamExists('getERC20Token', 'contractAddress', contractAddress);
            // verify required parameter 'chainName' is not null or undefined
            assertParamExists('getERC20Token', 'chainName', chainName);
            const localVarPath = `/v1/chains/{chain_name}/tokens/{contract_address}`
                .replace(`{${"contract_address"}}`, encodeURIComponent(String(contractAddress)))
                .replace(`{${"chain_name"}}`, encodeURIComponent(String(chainName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List ERC20 tokens
         * @summary List ERC20 tokens
         * @param {string} chainName The name of chain
         * @param {string} [pageCursor] Encoded page cursor to retrieve previous or next page. Use the value returned in the response.
         * @param {number} [pageSize] Maximum number of items to return
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listERC20Tokens: async (chainName, pageCursor, pageSize, options = {}) => {
            // verify required parameter 'chainName' is not null or undefined
            assertParamExists('listERC20Tokens', 'chainName', chainName);
            const localVarPath = `/v1/chains/{chain_name}/tokens`
                .replace(`{${"chain_name"}}`, encodeURIComponent(String(chainName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (pageCursor !== undefined) {
                localVarQueryParameter['page_cursor'] = pageCursor;
            }
            if (pageSize !== undefined) {
                localVarQueryParameter['page_size'] = pageSize;
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
/**
 * TokensApi - functional programming interface
 * @export
 */
const TokensApiFp = function (configuration) {
    const localVarAxiosParamCreator = TokensApiAxiosParamCreator(configuration);
    return {
        /**
         * Get single ERC20 token
         * @summary Get single ERC20 token
         * @param {string} contractAddress The address of contract
         * @param {string} chainName The name of chain
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getERC20Token(contractAddress, chainName, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getERC20Token(contractAddress, chainName, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * List ERC20 tokens
         * @summary List ERC20 tokens
         * @param {string} chainName The name of chain
         * @param {string} [pageCursor] Encoded page cursor to retrieve previous or next page. Use the value returned in the response.
         * @param {number} [pageSize] Maximum number of items to return
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listERC20Tokens(chainName, pageCursor, pageSize, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listERC20Tokens(chainName, pageCursor, pageSize, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    };
};
/**
 * TokensApi - factory interface
 * @export
 */
const TokensApiFactory = function (configuration, basePath, axios) {
    const localVarFp = TokensApiFp(configuration);
    return {
        /**
         * Get single ERC20 token
         * @summary Get single ERC20 token
         * @param {string} contractAddress The address of contract
         * @param {string} chainName The name of chain
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getERC20Token(contractAddress, chainName, options) {
            return localVarFp.getERC20Token(contractAddress, chainName, options).then((request) => request(axios, basePath));
        },
        /**
         * List ERC20 tokens
         * @summary List ERC20 tokens
         * @param {string} chainName The name of chain
         * @param {string} [pageCursor] Encoded page cursor to retrieve previous or next page. Use the value returned in the response.
         * @param {number} [pageSize] Maximum number of items to return
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listERC20Tokens(chainName, pageCursor, pageSize, options) {
            return localVarFp.listERC20Tokens(chainName, pageCursor, pageSize, options).then((request) => request(axios, basePath));
        },
    };
};
/**
 * TokensApi - object-oriented interface
 * @export
 * @class TokensApi
 * @extends {BaseAPI}
 */
class TokensApi extends BaseAPI {
    /**
     * Get single ERC20 token
     * @summary Get single ERC20 token
     * @param {TokensApiGetERC20TokenRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TokensApi
     */
    getERC20Token(requestParameters, options) {
        return TokensApiFp(this.configuration).getERC20Token(requestParameters.contractAddress, requestParameters.chainName, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * List ERC20 tokens
     * @summary List ERC20 tokens
     * @param {TokensApiListERC20TokensRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TokensApi
     */
    listERC20Tokens(requestParameters, options) {
        return TokensApiFp(this.configuration).listERC20Tokens(requestParameters.chainName, requestParameters.pageCursor, requestParameters.pageSize, options).then((request) => request(this.axios, this.basePath));
    }
}

/* tslint:disable */
/* eslint-disable */
/**
 * Immutable zkEVM API
 * Immutable Multi Rollup API
 *
 * The version of the OpenAPI document: 1.0.0
 * Contact: support@immutable.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
class Configuration {
    /**
     * parameter for apiKey security
     * @param name security name
     * @memberof Configuration
     */
    apiKey;
    /**
     * parameter for basic security
     *
     * @type {string}
     * @memberof Configuration
     */
    username;
    /**
     * parameter for basic security
     *
     * @type {string}
     * @memberof Configuration
     */
    password;
    /**
     * parameter for oauth2 security
     * @param name security name
     * @param scopes oauth2 scope
     * @memberof Configuration
     */
    accessToken;
    /**
     * override base path
     *
     * @type {string}
     * @memberof Configuration
     */
    basePath;
    /**
     * base options for axios calls
     *
     * @type {any}
     * @memberof Configuration
     */
    baseOptions;
    /**
     * The FormData constructor that will be used to create multipart form data
     * requests. You can inject this here so that execution environments that
     * do not support the FormData class can still run the generated client.
     *
     * @type {new () => FormData}
     */
    formDataCtor;
    constructor(param = {}) {
        this.apiKey = param.apiKey;
        this.username = param.username;
        this.password = param.password;
        this.accessToken = param.accessToken;
        this.basePath = param.basePath;
        this.baseOptions = param.baseOptions;
        this.formDataCtor = param.formDataCtor;
    }
    /**
     * Check if the given MIME is a JSON MIME.
     * JSON MIME examples:
     *   application/json
     *   application/json; charset=UTF8
     *   APPLICATION/JSON
     *   application/vnd.company+json
     * @param mime - MIME (Multipurpose Internet Mail Extensions)
     * @return True if the given MIME is JSON, false otherwise.
     */
    isJsonMime(mime) {
        const jsonMime = new RegExp('^(application\/json|[^;/ \t]+\/[^;/ \t]+[+]json)[ \t]*(;.*)?$', 'i');
        return mime !== null && (jsonMime.test(mime) || mime.toLowerCase() === 'application/json-patch+json');
    }
}

/* tslint:disable */
/* eslint-disable */
/**
 * Immutable zkEVM API
 * Immutable Multi Rollup API
 *
 * The version of the OpenAPI document: 1.0.0
 * Contact: support@immutable.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
const APIError400AllOfCodeEnum = {
    ValidationError: 'VALIDATION_ERROR'
};

/* tslint:disable */
/* eslint-disable */
/**
 * Immutable zkEVM API
 * Immutable Multi Rollup API
 *
 * The version of the OpenAPI document: 1.0.0
 * Contact: support@immutable.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
const APIError401AllOfCodeEnum = {
    UnauthorisedRequest: 'UNAUTHORISED_REQUEST'
};

/* tslint:disable */
/* eslint-disable */
/**
 * Immutable zkEVM API
 * Immutable Multi Rollup API
 *
 * The version of the OpenAPI document: 1.0.0
 * Contact: support@immutable.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
const APIError403AllOfCodeEnum = {
    AuthenticationError: 'AUTHENTICATION_ERROR'
};

/* tslint:disable */
/* eslint-disable */
/**
 * Immutable zkEVM API
 * Immutable Multi Rollup API
 *
 * The version of the OpenAPI document: 1.0.0
 * Contact: support@immutable.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
const APIError404AllOfCodeEnum = {
    ResourceNotFound: 'RESOURCE_NOT_FOUND'
};

/* tslint:disable */
/* eslint-disable */
/**
 * Immutable zkEVM API
 * Immutable Multi Rollup API
 *
 * The version of the OpenAPI document: 1.0.0
 * Contact: support@immutable.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
const APIError429AllOfCodeEnum = {
    TooManyRequestsError: 'TOO_MANY_REQUESTS_ERROR'
};

/* tslint:disable */
/* eslint-disable */
/**
 * Immutable zkEVM API
 * Immutable Multi Rollup API
 *
 * The version of the OpenAPI document: 1.0.0
 * Contact: support@immutable.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
const APIError500AllOfCodeEnum = {
    InternalServerError: 'INTERNAL_SERVER_ERROR'
};

/* tslint:disable */
/* eslint-disable */
/**
 * Immutable zkEVM API
 * Immutable Multi Rollup API
 *
 * The version of the OpenAPI document: 1.0.0
 * Contact: support@immutable.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
/**
 * The activity type
 * @export
 * @enum {string}
 */
const ActivityType = {
    Mint: 'mint',
    Burn: 'burn',
    Transfer: 'transfer',
    Sale: 'sale',
    Deposit: 'deposit',
    Withdrawal: 'withdrawal'
};

/* tslint:disable */
/* eslint-disable */
/**
 * Immutable zkEVM API
 * Immutable Multi Rollup API
 *
 * The version of the OpenAPI document: 1.0.0
 * Contact: support@immutable.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
/**
 * The collection contract type
 * @export
 * @enum {string}
 */
const CollectionContractType = {
    Erc721: 'ERC721'
};

/* tslint:disable */
/* eslint-disable */
/**
 * Immutable zkEVM API
 * Immutable Multi Rollup API
 *
 * The version of the OpenAPI document: 1.0.0
 * Contact: support@immutable.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
const ERC20ItemItemTypeEnum = {
    Erc20: 'ERC20'
};

/* tslint:disable */
/* eslint-disable */
/**
 * Immutable zkEVM API
 * Immutable Multi Rollup API
 *
 * The version of the OpenAPI document: 1.0.0
 * Contact: support@immutable.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
const ERC721ItemItemTypeEnum = {
    Erc721: 'ERC721'
};

/* tslint:disable */
/* eslint-disable */
/**
 * Immutable zkEVM API
 * Immutable Multi Rollup API
 *
 * The version of the OpenAPI document: 1.0.0
 * Contact: support@immutable.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
const FeeFeeTypeEnum = {
    Royalty: 'ROYALTY',
    MakerMarketplace: 'MAKER_MARKETPLACE',
    TakerMarketplace: 'TAKER_MARKETPLACE',
    Protocol: 'PROTOCOL'
};

/* tslint:disable */
/* eslint-disable */
/**
 * Immutable zkEVM API
 * Immutable Multi Rollup API
 *
 * The version of the OpenAPI document: 1.0.0
 * Contact: support@immutable.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
/**
 * The contract type for an NFT
 * @export
 * @enum {string}
 */
const NFTContractType = {
    Erc721: 'ERC721'
};

/* tslint:disable */
/* eslint-disable */
/**
 * Immutable zkEVM API
 * Immutable Multi Rollup API
 *
 * The version of the OpenAPI document: 1.0.0
 * Contact: support@immutable.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
const NativeItemItemTypeEnum = {
    Native: 'NATIVE'
};

/* tslint:disable */
/* eslint-disable */
/**
 * Immutable zkEVM API
 * Immutable Multi Rollup API
 *
 * The version of the OpenAPI document: 1.0.0
 * Contact: support@immutable.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
/**
 * The Order status
 * @export
 * @enum {string}
 */
const OrderStatus = {
    Pending: 'PENDING',
    Active: 'ACTIVE',
    Inactive: 'INACTIVE',
    Filled: 'FILLED',
    Cancelled: 'CANCELLED',
    Expired: 'EXPIRED'
};

/* tslint:disable */
/* eslint-disable */
/**
 * Immutable zkEVM API
 * Immutable Multi Rollup API
 *
 * The version of the OpenAPI document: 1.0.0
 * Contact: support@immutable.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
const ProtocolDataOrderTypeEnum = {
    FullRestricted: 'FULL_RESTRICTED'
};

/* tslint:disable */
/* eslint-disable */
/**
 * Immutable zkEVM API
 * Immutable Multi Rollup API
 *
 * The version of the OpenAPI document: 1.0.0
 * Contact: support@immutable.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
const SaleFeeTypeEnum = {
    Royalty: 'ROYALTY'
};

/* tslint:disable */
/* eslint-disable */
/**
 * Immutable zkEVM API
 * Immutable Multi Rollup API
 *
 * The version of the OpenAPI document: 1.0.0
 * Contact: support@immutable.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
/**
 * The contract type for a token
 * @export
 * @enum {string}
 */
const TokenContractType = {
    Erc20: 'ERC20'
};

/* tslint:disable */
/* eslint-disable */
/**
 * Immutable zkEVM API
 * Immutable Multi Rollup API
 *
 * The version of the OpenAPI document: 1.0.0
 * Contact: support@immutable.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

var index = /*#__PURE__*/Object.freeze({
    __proto__: null,
    APIError400AllOfCodeEnum: APIError400AllOfCodeEnum,
    APIError401AllOfCodeEnum: APIError401AllOfCodeEnum,
    APIError403AllOfCodeEnum: APIError403AllOfCodeEnum,
    APIError404AllOfCodeEnum: APIError404AllOfCodeEnum,
    APIError429AllOfCodeEnum: APIError429AllOfCodeEnum,
    APIError500AllOfCodeEnum: APIError500AllOfCodeEnum,
    ActivitiesApi: ActivitiesApi,
    ActivitiesApiAxiosParamCreator: ActivitiesApiAxiosParamCreator,
    ActivitiesApiFactory: ActivitiesApiFactory,
    ActivitiesApiFp: ActivitiesApiFp,
    ActivityType: ActivityType,
    ChainsApi: ChainsApi,
    ChainsApiAxiosParamCreator: ChainsApiAxiosParamCreator,
    ChainsApiFactory: ChainsApiFactory,
    ChainsApiFp: ChainsApiFp,
    CollectionContractType: CollectionContractType,
    CollectionsApi: CollectionsApi,
    CollectionsApiAxiosParamCreator: CollectionsApiAxiosParamCreator,
    CollectionsApiFactory: CollectionsApiFactory,
    CollectionsApiFp: CollectionsApiFp,
    Configuration: Configuration,
    ERC20ItemItemTypeEnum: ERC20ItemItemTypeEnum,
    ERC721ItemItemTypeEnum: ERC721ItemItemTypeEnum,
    FeeFeeTypeEnum: FeeFeeTypeEnum,
    MetadataApi: MetadataApi,
    MetadataApiAxiosParamCreator: MetadataApiAxiosParamCreator,
    MetadataApiFactory: MetadataApiFactory,
    MetadataApiFp: MetadataApiFp,
    NFTContractType: NFTContractType,
    NativeItemItemTypeEnum: NativeItemItemTypeEnum,
    NftOwnersApi: NftOwnersApi,
    NftOwnersApiAxiosParamCreator: NftOwnersApiAxiosParamCreator,
    NftOwnersApiFactory: NftOwnersApiFactory,
    NftOwnersApiFp: NftOwnersApiFp,
    NftsApi: NftsApi,
    NftsApiAxiosParamCreator: NftsApiAxiosParamCreator,
    NftsApiFactory: NftsApiFactory,
    NftsApiFp: NftsApiFp,
    OrderStatus: OrderStatus,
    OrdersApi: OrdersApi,
    OrdersApiAxiosParamCreator: OrdersApiAxiosParamCreator,
    OrdersApiFactory: OrdersApiFactory,
    OrdersApiFp: OrdersApiFp,
    PassportApi: PassportApi,
    PassportApiAxiosParamCreator: PassportApiAxiosParamCreator,
    PassportApiFactory: PassportApiFactory,
    PassportApiFp: PassportApiFp,
    ProtocolDataOrderTypeEnum: ProtocolDataOrderTypeEnum,
    SaleFeeTypeEnum: SaleFeeTypeEnum,
    TokenContractType: TokenContractType,
    TokensApi: TokensApi,
    TokensApiAxiosParamCreator: TokensApiAxiosParamCreator,
    TokensApiFactory: TokensApiFactory,
    TokensApiFp: TokensApiFp
});

var Environment;
(function (Environment) {
    Environment["PRODUCTION"] = "production";
    Environment["SANDBOX"] = "sandbox";
})(Environment || (Environment = {}));

/**
 * Custom Error class that is returned from the API when a request fails
 */
class APIError extends Error {
    code;
    details;
    link;
    traceId;
    constructor({ message, code, details, link, trace_id: traceId, }) {
        super(message);
        this.code = code;
        this.details = details;
        this.link = link;
        this.traceId = traceId;
    }
}

/* eslint-disable implicit-arrow-linebreak */
const defaultHeaders = {
    sdkVersion: 'ts-immutable-sdk-multi-rollup-api-client-0.22.0',
};
/**
 * createAPIConfiguration to create a custom Configuration
 * other than the production and sandbox defined below.
 */
const createAPIConfiguration = ({ basePath, headers: baseHeaders, }) => {
    if (!basePath.trim()) {
        throw Error('basePath can not be empty');
    }
    const headers = { ...(baseHeaders || {}), ...defaultHeaders };
    const configParams = {
        basePath,
        baseOptions: { headers },
    };
    return new index.Configuration(configParams);
};
const production = () => createAPIConfiguration({
    basePath: 'https://indexer-mr.imtbl.com',
});
const sandbox = () => createAPIConfiguration({
    basePath: 'https://api.sandbox.immutable.com',
});
class BlockchainDataConfiguration {
    apiConfig;
    baseConfig;
    constructor({ baseConfig, overrides }) {
        this.baseConfig = baseConfig;
        if (overrides) {
            this.apiConfig = createAPIConfiguration(overrides);
        }
        else {
            switch (baseConfig.environment) {
                case Environment.SANDBOX: {
                    this.apiConfig = sandbox();
                    break;
                }
                case Environment.PRODUCTION: {
                    this.apiConfig = production();
                    break;
                }
                default: {
                    this.apiConfig = sandbox();
                }
            }
        }
    }
}

/* eslint-disable @typescript-eslint/naming-convention */
/**
 * [Formats an error in the APIError shape](https://axios-http.com/docs/handling_errors)
 * @param error - The Error object thrown by the request
 * @returns APIError
 */
function formatError(error) {
    if (globalAxios.isAxiosError(error) && error.response) {
        const apiError = error.response.data;
        if (apiError.code && apiError.message) {
            return new APIError({
                code: apiError.code,
                message: apiError.message,
                details: apiError.details || null,
                link: apiError.link || '',
                trace_id: apiError.trace_id || '',
            });
        }
        return new APIError({
            code: error.code ?? error.response?.status.toString() ?? 'unknown_error_code',
            message: String(error),
            details: null,
            link: '',
            trace_id: '',
        });
    }
    return new APIError({
        code: 'unknown_error_code',
        message: String(error),
        details: null,
        link: '',
        trace_id: '',
    });
}

class BlockchainData {
    config;
    activities;
    chains;
    collections;
    nfts;
    nftOwners;
    tokens;
    constructor(moduleConfig) {
        this.config = new BlockchainDataConfiguration(moduleConfig);
        this.activities = new index.ActivitiesApi(this.config.apiConfig);
        this.chains = new index.ChainsApi(this.config.apiConfig);
        this.collections = new index.CollectionsApi(this.config.apiConfig);
        this.nfts = new index.NftsApi(this.config.apiConfig);
        this.nftOwners = new index.NftOwnersApi(this.config.apiConfig);
        this.tokens = new index.TokensApi(this.config.apiConfig);
    }
    /**
     * List all activities
     * @param request - the request object containing the parameters to be provided in the API request
     * @returns a promise that resolves with a list of activities
     * @throws {@link index.APIError}
     */
    async listActivities(request) {
        return await this.activities
            .listActivities(request)
            .then((res) => res.data)
            .catch((err) => {
            throw formatError(err);
        });
    }
    /**
     * Get a single activity by ID
     * @param request - the request object containing the parameters to be provided in the API request
     * @returns a promise that resolves with a single activity
     * @throws {@link index.APIError}
     */
    async getActivity(request) {
        return await this.activities
            .getActivity(request)
            .then((res) => res.data)
            .catch((err) => {
            throw formatError(err);
        });
    }
    /**
     * List supported chains
     * @param request - the request object containing the parameters to be provided in the API request
     * @returns a promise that resolves with a list of supported chains
     * @throws {@link index.APIError}
     */
    async listChains(request) {
        return await this.chains
            .listChains(request)
            .then((res) => res.data)
            .catch((err) => {
            throw formatError(err);
        });
    }
    /**
     * List all collections
     * @param request - the request object containing the parameters to be provided in the API request
     * @returns a promise that resolves with a list of collections
     * @throws {@link index.APIError}
     */
    async listCollections(request) {
        return await this.collections
            .listCollections(request)
            .then((res) => res.data)
            .catch((err) => {
            throw formatError(err);
        });
    }
    /**
     * List collections by NFT owner
     * @param request - the request object containing the parameters to be provided in the API request
     * @returns a promise that resolves with a list of collections
     * @throws {@link index.APIError}
     */
    async listCollectionsByNFTOwner(request) {
        return await this.collections
            .listCollectionsByNFTOwner(request)
            .then((res) => res.data)
            .catch((err) => {
            throw formatError(err);
        });
    }
    /**
     * Get collection by contract address
     * @param request - the request object containing the parameters to be provided in the API request
     * @returns a promise that resolves with a single collection
     * @throws {@link index.APIError}
     */
    async getCollection(request) {
        return await this.collections
            .getCollection(request)
            .then((res) => res.data)
            .catch((err) => {
            throw formatError(err);
        });
    }
    /**
     * Get NFT by token ID
     * @param request - the request object containing the parameters to be provided in the API request
     * @returns a promise that resolves with a single NFT
     * @throws {@link index.APIError}
     */
    async getNFT(request) {
        return await this.nfts
            .getNFT(request)
            .then((res) => res.data)
            .catch((err) => {
            throw formatError(err);
        });
    }
    /**
     * List NFTs by contract address
     * @param request - the request object containing the parameters to be provided in the API request
     * @returns a promise that resolves with a list of NFTs
     * @throws {@link index.APIError}
     */
    async listNFTs(request) {
        return await this.nfts
            .listNFTs(request)
            .then((res) => res.data)
            .catch((err) => {
            throw formatError(err);
        });
    }
    /**
     * List NFTs by account address
     * @param request - the request object containing the parameters to be provided in the API request
     * @returns a promise that resolves with a list of NFTs
     * @throws {@link index.APIError}
     */
    async listNFTsByAccountAddress(request) {
        return await this.nfts
            .listNFTsByAccountAddress(request)
            .then((res) => res.data)
            .catch((err) => {
            throw formatError(err);
        });
    }
    /**
     * List NFT owners by token ID
     * @param request - the request object containing the parameters to be provided in the API request
     * @returns a promise that resolves with a list of NFT owners
     * @throws {@link index.APIError}
     */
    async listNFTOwners(request) {
        return await this.nftOwners
            .listNFTOwners(request)
            .then((res) => res.data)
            .catch((err) => {
            throw formatError(err);
        });
    }
    /**
     * List ERC20 Token contracts
     * @param request - the request object containing the parameters to be provided in the API request
     * @returns a promise that resolves with a list of ERC20 Tokens
     * @throws {@link index.APIError}
     */
    async listTokens(request) {
        return await this.tokens
            .listERC20Tokens(request)
            .then((res) => res.data)
            .catch((err) => {
            throw formatError(err);
        });
    }
    /**
     * Get details for an ERC20 Token by contract address
     * @param request - the request object containing the parameters to be provided in the API request
     * @returns a promise that resolves with a list of ERC20 Tokens
     * @throws {@link index.APIError}
     */
    async getToken(request) {
        return await this.tokens
            .getERC20Token(request)
            .then((res) => res.data)
            .catch((err) => {
            throw formatError(err);
        });
    }
}

export { APIError, BlockchainData };
