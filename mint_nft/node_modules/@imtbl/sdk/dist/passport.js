import globalAxios$1, { isAxiosError as isAxiosError$1 } from 'axios';
import { ImmutableX, Config, generateLegacyStarkPrivateKey, createStarkSigner } from '@imtbl/core-sdk';
import { UserManager, InMemoryWebStorage, WebStorageStateStore } from 'oidc-client-ts';
import jwt_decode from 'jwt-decode';
import * as crypto from 'crypto';
import { Magic } from 'magic-sdk';
import { OpenIdExtension } from '@magic-ext/oidc';
import { BigNumber, ethers } from 'ethers';
import BN from 'bn.js';
import * as encUtils from 'enc-utils';
import { Web3Provider, JsonRpcProvider } from '@ethersproject/providers';
import { EventEmitter } from 'events';
import { walletContracts } from '@0xsequence/abi';
import { encodeSignature, decodeSignature } from '@0xsequence/config';

/* tslint:disable */
/* eslint-disable */
/**
 * Immutable X API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 3.0
 * Contact: support@immutable.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
let Configuration$1 = class Configuration {
    /**
     * parameter for apiKey security
     * @param name security name
     * @memberof Configuration
     */
    apiKey;
    /**
     * parameter for basic security
     *
     * @type {string}
     * @memberof Configuration
     */
    username;
    /**
     * parameter for basic security
     *
     * @type {string}
     * @memberof Configuration
     */
    password;
    /**
     * parameter for oauth2 security
     * @param name security name
     * @param scopes oauth2 scope
     * @memberof Configuration
     */
    accessToken;
    /**
     * override base path
     *
     * @type {string}
     * @memberof Configuration
     */
    basePath;
    /**
     * base options for axios calls
     *
     * @type {any}
     * @memberof Configuration
     */
    baseOptions;
    /**
     * The FormData constructor that will be used to create multipart form data
     * requests. You can inject this here so that execution environments that
     * do not support the FormData class can still run the generated client.
     *
     * @type {new () => FormData}
     */
    formDataCtor;
    constructor(param = {}) {
        this.apiKey = param.apiKey;
        this.username = param.username;
        this.password = param.password;
        this.accessToken = param.accessToken;
        this.basePath = param.basePath;
        this.baseOptions = param.baseOptions;
        this.formDataCtor = param.formDataCtor;
    }
    /**
     * Check if the given MIME is a JSON MIME.
     * JSON MIME examples:
     *   application/json
     *   application/json; charset=UTF8
     *   APPLICATION/JSON
     *   application/vnd.company+json
     * @param mime - MIME (Multipurpose Internet Mail Extensions)
     * @return True if the given MIME is JSON, false otherwise.
     */
    isJsonMime(mime) {
        const jsonMime = new RegExp('^(application\/json|[^;/ \t]+\/[^;/ \t]+[+]json)[ \t]*(;.*)?$', 'i');
        return mime !== null && (jsonMime.test(mime) || mime.toLowerCase() === 'application/json-patch+json');
    }
};

/* tslint:disable */
/* eslint-disable */
/**
 * Immutable zkEVM API
 * Immutable Multi Rollup API
 *
 * The version of the OpenAPI document: 1.0.0
 * Contact: support@immutable.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
// Some imports not used depending on template conditions
// @ts-ignore
const BASE_PATH$1 = "https://api.sandbox.immutable.com".replace(/\/+$/, "");
/**
 *
 * @export
 * @class BaseAPI
 */
let BaseAPI$1 = class BaseAPI {
    basePath;
    axios;
    configuration;
    constructor(configuration, basePath = BASE_PATH$1, axios = globalAxios$1) {
        this.basePath = basePath;
        this.axios = axios;
        if (configuration) {
            this.configuration = configuration;
            this.basePath = configuration.basePath || this.basePath;
        }
    }
};
/**
 *
 * @export
 * @class RequiredError
 * @extends {Error}
 */
let RequiredError$1 = class RequiredError extends Error {
    field;
    name = "RequiredError";
    constructor(field, msg) {
        super(msg);
        this.field = field;
    }
};

/* tslint:disable */
/* eslint-disable */
/**
 * Immutable zkEVM API
 * Immutable Multi Rollup API
 *
 * The version of the OpenAPI document: 1.0.0
 * Contact: support@immutable.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
/**
 *
 * @export
 */
const DUMMY_BASE_URL$1 = 'https://example.com';
/**
 *
 * @throws {RequiredError}
 * @export
 */
const assertParamExists$1 = function (functionName, paramName, paramValue) {
    if (paramValue === null || paramValue === undefined) {
        throw new RequiredError$1(paramName, `Required parameter ${paramName} was null or undefined when calling ${functionName}.`);
    }
};
/**
 *
 * @export
 */
const setApiKeyToObject = async function (object, keyParamName, configuration) {
    if (configuration && configuration.apiKey) {
        const localVarApiKeyValue = typeof configuration.apiKey === 'function'
            ? await configuration.apiKey(keyParamName)
            : await configuration.apiKey;
        object[keyParamName] = localVarApiKeyValue;
    }
};
/**
 *
 * @export
 */
const setBearerAuthToObject$1 = async function (object, configuration) {
    if (configuration && configuration.accessToken) {
        const accessToken = typeof configuration.accessToken === 'function'
            ? await configuration.accessToken()
            : await configuration.accessToken;
        object["Authorization"] = "Bearer " + accessToken;
    }
};
function setFlattenedQueryParams$1(urlSearchParams, parameter, key = "") {
    if (typeof parameter === "object") {
        if (Array.isArray(parameter)) {
            parameter.forEach(item => setFlattenedQueryParams$1(urlSearchParams, item, key));
        }
        else {
            Object.keys(parameter).forEach(currentKey => setFlattenedQueryParams$1(urlSearchParams, parameter[currentKey], `${key}${key !== '' ? '.' : ''}${currentKey}`));
        }
    }
    else {
        if (urlSearchParams.has(key)) {
            urlSearchParams.append(key, parameter);
        }
        else {
            urlSearchParams.set(key, parameter);
        }
    }
}
/**
 *
 * @export
 */
const setSearchParams$1 = function (url, ...objects) {
    const searchParams = new URLSearchParams(url.search);
    setFlattenedQueryParams$1(searchParams, objects);
    url.search = searchParams.toString();
};
/**
 *
 * @export
 */
const serializeDataIfNeeded$1 = function (value, requestOptions, configuration) {
    const nonString = typeof value !== 'string';
    const needsSerialization = nonString && configuration && configuration.isJsonMime
        ? configuration.isJsonMime(requestOptions.headers['Content-Type'])
        : nonString;
    return needsSerialization
        ? JSON.stringify(value !== undefined ? value : {})
        : (value || "");
};
/**
 *
 * @export
 */
const toPathString$1 = function (url) {
    return url.pathname + url.search + url.hash;
};
/**
 *
 * @export
 */
const createRequestFunction$1 = function (axiosArgs, globalAxios, BASE_PATH, configuration) {
    return (axios = globalAxios, basePath = BASE_PATH) => {
        const axiosRequestArgs = { ...axiosArgs.options, url: (configuration?.basePath || basePath) + axiosArgs.url };
        return axios.request(axiosRequestArgs);
    };
};

/* tslint:disable */
/* eslint-disable */
/**
 * Immutable zkEVM API
 * Immutable Multi Rollup API
 *
 * The version of the OpenAPI document: 1.0.0
 * Contact: support@immutable.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
/**
 * ActivitiesApi - axios parameter creator
 * @export
 */
const ActivitiesApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * Get a single activity by ID
         * @summary Get a single activity by ID
         * @param {string} chainName The name of chain
         * @param {string} activityId The id of activity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getActivity: async (chainName, activityId, options = {}) => {
            // verify required parameter 'chainName' is not null or undefined
            assertParamExists$1('getActivity', 'chainName', chainName);
            // verify required parameter 'activityId' is not null or undefined
            assertParamExists$1('getActivity', 'activityId', activityId);
            const localVarPath = `/v1/chains/{chain_name}/activities/{activity_id}`
                .replace(`{${"chain_name"}}`, encodeURIComponent(String(chainName)))
                .replace(`{${"activity_id"}}`, encodeURIComponent(String(activityId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL$1);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            setSearchParams$1(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: toPathString$1(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List all activities
         * @summary List all activities
         * @param {string} chainName The name of chain
         * @param {string} [contractAddress] The contract address of NFT or ERC20 Token
         * @param {string} [tokenId] An &#x60;uint256&#x60; token id as string
         * @param {string} [accountAddress] The account address activity contains
         * @param {ActivityType} [activityType] The activity type
         * @param {string} [fromIndexedAt] From indexed at including given date
         * @param {string} [toIndexedAt] To indexed at including given date
         * @param {string} [transactionHash] The transaction hash of activity
         * @param {string} [pageCursor] Encoded page cursor to retrieve previous or next page. Use the value returned in the response.
         * @param {number} [pageSize] Maximum number of items to return
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listActivities: async (chainName, contractAddress, tokenId, accountAddress, activityType, fromIndexedAt, toIndexedAt, transactionHash, pageCursor, pageSize, options = {}) => {
            // verify required parameter 'chainName' is not null or undefined
            assertParamExists$1('listActivities', 'chainName', chainName);
            const localVarPath = `/v1/chains/{chain_name}/activities`
                .replace(`{${"chain_name"}}`, encodeURIComponent(String(chainName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL$1);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (contractAddress !== undefined) {
                localVarQueryParameter['contract_address'] = contractAddress;
            }
            if (tokenId !== undefined) {
                localVarQueryParameter['token_id'] = tokenId;
            }
            if (accountAddress !== undefined) {
                localVarQueryParameter['account_address'] = accountAddress;
            }
            if (activityType !== undefined) {
                localVarQueryParameter['activity_type'] = activityType;
            }
            if (fromIndexedAt !== undefined) {
                localVarQueryParameter['from_indexed_at'] = (fromIndexedAt instanceof Date) ?
                    fromIndexedAt.toISOString() :
                    fromIndexedAt;
            }
            if (toIndexedAt !== undefined) {
                localVarQueryParameter['to_indexed_at'] = (toIndexedAt instanceof Date) ?
                    toIndexedAt.toISOString() :
                    toIndexedAt;
            }
            if (transactionHash !== undefined) {
                localVarQueryParameter['transaction_hash'] = transactionHash;
            }
            if (pageCursor !== undefined) {
                localVarQueryParameter['page_cursor'] = pageCursor;
            }
            if (pageSize !== undefined) {
                localVarQueryParameter['page_size'] = pageSize;
            }
            setSearchParams$1(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: toPathString$1(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
/**
 * ActivitiesApi - functional programming interface
 * @export
 */
const ActivitiesApiFp = function (configuration) {
    const localVarAxiosParamCreator = ActivitiesApiAxiosParamCreator(configuration);
    return {
        /**
         * Get a single activity by ID
         * @summary Get a single activity by ID
         * @param {string} chainName The name of chain
         * @param {string} activityId The id of activity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getActivity(chainName, activityId, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getActivity(chainName, activityId, options);
            return createRequestFunction$1(localVarAxiosArgs, globalAxios$1, BASE_PATH$1, configuration);
        },
        /**
         * List all activities
         * @summary List all activities
         * @param {string} chainName The name of chain
         * @param {string} [contractAddress] The contract address of NFT or ERC20 Token
         * @param {string} [tokenId] An &#x60;uint256&#x60; token id as string
         * @param {string} [accountAddress] The account address activity contains
         * @param {ActivityType} [activityType] The activity type
         * @param {string} [fromIndexedAt] From indexed at including given date
         * @param {string} [toIndexedAt] To indexed at including given date
         * @param {string} [transactionHash] The transaction hash of activity
         * @param {string} [pageCursor] Encoded page cursor to retrieve previous or next page. Use the value returned in the response.
         * @param {number} [pageSize] Maximum number of items to return
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listActivities(chainName, contractAddress, tokenId, accountAddress, activityType, fromIndexedAt, toIndexedAt, transactionHash, pageCursor, pageSize, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listActivities(chainName, contractAddress, tokenId, accountAddress, activityType, fromIndexedAt, toIndexedAt, transactionHash, pageCursor, pageSize, options);
            return createRequestFunction$1(localVarAxiosArgs, globalAxios$1, BASE_PATH$1, configuration);
        },
    };
};
/**
 * ActivitiesApi - object-oriented interface
 * @export
 * @class ActivitiesApi
 * @extends {BaseAPI}
 */
class ActivitiesApi extends BaseAPI$1 {
    /**
     * Get a single activity by ID
     * @summary Get a single activity by ID
     * @param {ActivitiesApiGetActivityRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActivitiesApi
     */
    getActivity(requestParameters, options) {
        return ActivitiesApiFp(this.configuration).getActivity(requestParameters.chainName, requestParameters.activityId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * List all activities
     * @summary List all activities
     * @param {ActivitiesApiListActivitiesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActivitiesApi
     */
    listActivities(requestParameters, options) {
        return ActivitiesApiFp(this.configuration).listActivities(requestParameters.chainName, requestParameters.contractAddress, requestParameters.tokenId, requestParameters.accountAddress, requestParameters.activityType, requestParameters.fromIndexedAt, requestParameters.toIndexedAt, requestParameters.transactionHash, requestParameters.pageCursor, requestParameters.pageSize, options).then((request) => request(this.axios, this.basePath));
    }
}

/* tslint:disable */
/* eslint-disable */
/**
 * Immutable zkEVM API
 * Immutable Multi Rollup API
 *
 * The version of the OpenAPI document: 1.0.0
 * Contact: support@immutable.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
/**
 * ChainsApi - axios parameter creator
 * @export
 */
const ChainsApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * List supported chains
         * @summary List supported chains
         * @param {string} [pageCursor] Encoded page cursor to retrieve previous or next page. Use the value returned in the response.
         * @param {number} [pageSize] Maximum number of items to return
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listChains: async (pageCursor, pageSize, options = {}) => {
            const localVarPath = `/v1/chains`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL$1);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (pageCursor !== undefined) {
                localVarQueryParameter['page_cursor'] = pageCursor;
            }
            if (pageSize !== undefined) {
                localVarQueryParameter['page_size'] = pageSize;
            }
            setSearchParams$1(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: toPathString$1(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
/**
 * ChainsApi - functional programming interface
 * @export
 */
const ChainsApiFp = function (configuration) {
    const localVarAxiosParamCreator = ChainsApiAxiosParamCreator(configuration);
    return {
        /**
         * List supported chains
         * @summary List supported chains
         * @param {string} [pageCursor] Encoded page cursor to retrieve previous or next page. Use the value returned in the response.
         * @param {number} [pageSize] Maximum number of items to return
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listChains(pageCursor, pageSize, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listChains(pageCursor, pageSize, options);
            return createRequestFunction$1(localVarAxiosArgs, globalAxios$1, BASE_PATH$1, configuration);
        },
    };
};
/**
 * ChainsApi - object-oriented interface
 * @export
 * @class ChainsApi
 * @extends {BaseAPI}
 */
class ChainsApi extends BaseAPI$1 {
    /**
     * List supported chains
     * @summary List supported chains
     * @param {ChainsApiListChainsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChainsApi
     */
    listChains(requestParameters = {}, options) {
        return ChainsApiFp(this.configuration).listChains(requestParameters.pageCursor, requestParameters.pageSize, options).then((request) => request(this.axios, this.basePath));
    }
}

/* tslint:disable */
/* eslint-disable */
/**
 * Immutable zkEVM API
 * Immutable Multi Rollup API
 *
 * The version of the OpenAPI document: 1.0.0
 * Contact: support@immutable.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
/**
 * CollectionsApi - axios parameter creator
 * @export
 */
const CollectionsApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * Get collection by contract address
         * @summary Get collection by contract address
         * @param {string} contractAddress The address contract
         * @param {string} chainName The name of chain
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCollection: async (contractAddress, chainName, options = {}) => {
            // verify required parameter 'contractAddress' is not null or undefined
            assertParamExists$1('getCollection', 'contractAddress', contractAddress);
            // verify required parameter 'chainName' is not null or undefined
            assertParamExists$1('getCollection', 'chainName', chainName);
            const localVarPath = `/v1/chains/{chain_name}/collections/{contract_address}`
                .replace(`{${"contract_address"}}`, encodeURIComponent(String(contractAddress)))
                .replace(`{${"chain_name"}}`, encodeURIComponent(String(chainName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL$1);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            setSearchParams$1(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: toPathString$1(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List all collections
         * @summary List all collections
         * @param {string} chainName The name of chain
         * @param {string} [pageCursor] Encoded page cursor to retrieve previous or next page. Use the value returned in the response.
         * @param {number} [pageSize] Maximum number of items to return
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listCollections: async (chainName, pageCursor, pageSize, options = {}) => {
            // verify required parameter 'chainName' is not null or undefined
            assertParamExists$1('listCollections', 'chainName', chainName);
            const localVarPath = `/v1/chains/{chain_name}/collections`
                .replace(`{${"chain_name"}}`, encodeURIComponent(String(chainName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL$1);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (pageCursor !== undefined) {
                localVarQueryParameter['page_cursor'] = pageCursor;
            }
            if (pageSize !== undefined) {
                localVarQueryParameter['page_size'] = pageSize;
            }
            setSearchParams$1(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: toPathString$1(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List collections by NFT owner account address
         * @summary List collections by NFT owner
         * @param {string} accountAddress Account address
         * @param {string} chainName The name of chain
         * @param {string} [pageCursor] Encoded page cursor to retrieve previous or next page. Use the value returned in the response.
         * @param {number} [pageSize] Maximum number of items to return
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listCollectionsByNFTOwner: async (accountAddress, chainName, pageCursor, pageSize, options = {}) => {
            // verify required parameter 'accountAddress' is not null or undefined
            assertParamExists$1('listCollectionsByNFTOwner', 'accountAddress', accountAddress);
            // verify required parameter 'chainName' is not null or undefined
            assertParamExists$1('listCollectionsByNFTOwner', 'chainName', chainName);
            const localVarPath = `/v1/chains/{chain_name}/accounts/{account_address}/collections`
                .replace(`{${"account_address"}}`, encodeURIComponent(String(accountAddress)))
                .replace(`{${"chain_name"}}`, encodeURIComponent(String(chainName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL$1);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (pageCursor !== undefined) {
                localVarQueryParameter['page_cursor'] = pageCursor;
            }
            if (pageSize !== undefined) {
                localVarQueryParameter['page_size'] = pageSize;
            }
            setSearchParams$1(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: toPathString$1(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Refresh collection metadata
         * @summary Refresh collection metadata
         * @param {string} contractAddress The address contract
         * @param {string} chainName The name of chain
         * @param {RefreshCollectionMetadataRequest} refreshCollectionMetadataRequest The request body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        refreshCollectionMetadata: async (contractAddress, chainName, refreshCollectionMetadataRequest, options = {}) => {
            // verify required parameter 'contractAddress' is not null or undefined
            assertParamExists$1('refreshCollectionMetadata', 'contractAddress', contractAddress);
            // verify required parameter 'chainName' is not null or undefined
            assertParamExists$1('refreshCollectionMetadata', 'chainName', chainName);
            // verify required parameter 'refreshCollectionMetadataRequest' is not null or undefined
            assertParamExists$1('refreshCollectionMetadata', 'refreshCollectionMetadataRequest', refreshCollectionMetadataRequest);
            const localVarPath = `/v1/chains/{chain_name}/collections/{contract_address}/refresh-metadata`
                .replace(`{${"contract_address"}}`, encodeURIComponent(String(contractAddress)))
                .replace(`{${"chain_name"}}`, encodeURIComponent(String(chainName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL$1);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ImmutableApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "X-Immutable-API-Key", configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            setSearchParams$1(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = serializeDataIfNeeded$1(refreshCollectionMetadataRequest, localVarRequestOptions, configuration);
            return {
                url: toPathString$1(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
/**
 * CollectionsApi - functional programming interface
 * @export
 */
const CollectionsApiFp = function (configuration) {
    const localVarAxiosParamCreator = CollectionsApiAxiosParamCreator(configuration);
    return {
        /**
         * Get collection by contract address
         * @summary Get collection by contract address
         * @param {string} contractAddress The address contract
         * @param {string} chainName The name of chain
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCollection(contractAddress, chainName, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCollection(contractAddress, chainName, options);
            return createRequestFunction$1(localVarAxiosArgs, globalAxios$1, BASE_PATH$1, configuration);
        },
        /**
         * List all collections
         * @summary List all collections
         * @param {string} chainName The name of chain
         * @param {string} [pageCursor] Encoded page cursor to retrieve previous or next page. Use the value returned in the response.
         * @param {number} [pageSize] Maximum number of items to return
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listCollections(chainName, pageCursor, pageSize, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listCollections(chainName, pageCursor, pageSize, options);
            return createRequestFunction$1(localVarAxiosArgs, globalAxios$1, BASE_PATH$1, configuration);
        },
        /**
         * List collections by NFT owner account address
         * @summary List collections by NFT owner
         * @param {string} accountAddress Account address
         * @param {string} chainName The name of chain
         * @param {string} [pageCursor] Encoded page cursor to retrieve previous or next page. Use the value returned in the response.
         * @param {number} [pageSize] Maximum number of items to return
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listCollectionsByNFTOwner(accountAddress, chainName, pageCursor, pageSize, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listCollectionsByNFTOwner(accountAddress, chainName, pageCursor, pageSize, options);
            return createRequestFunction$1(localVarAxiosArgs, globalAxios$1, BASE_PATH$1, configuration);
        },
        /**
         * Refresh collection metadata
         * @summary Refresh collection metadata
         * @param {string} contractAddress The address contract
         * @param {string} chainName The name of chain
         * @param {RefreshCollectionMetadataRequest} refreshCollectionMetadataRequest The request body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async refreshCollectionMetadata(contractAddress, chainName, refreshCollectionMetadataRequest, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.refreshCollectionMetadata(contractAddress, chainName, refreshCollectionMetadataRequest, options);
            return createRequestFunction$1(localVarAxiosArgs, globalAxios$1, BASE_PATH$1, configuration);
        },
    };
};
/**
 * CollectionsApi - object-oriented interface
 * @export
 * @class CollectionsApi
 * @extends {BaseAPI}
 */
class CollectionsApi extends BaseAPI$1 {
    /**
     * Get collection by contract address
     * @summary Get collection by contract address
     * @param {CollectionsApiGetCollectionRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CollectionsApi
     */
    getCollection(requestParameters, options) {
        return CollectionsApiFp(this.configuration).getCollection(requestParameters.contractAddress, requestParameters.chainName, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * List all collections
     * @summary List all collections
     * @param {CollectionsApiListCollectionsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CollectionsApi
     */
    listCollections(requestParameters, options) {
        return CollectionsApiFp(this.configuration).listCollections(requestParameters.chainName, requestParameters.pageCursor, requestParameters.pageSize, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * List collections by NFT owner account address
     * @summary List collections by NFT owner
     * @param {CollectionsApiListCollectionsByNFTOwnerRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CollectionsApi
     */
    listCollectionsByNFTOwner(requestParameters, options) {
        return CollectionsApiFp(this.configuration).listCollectionsByNFTOwner(requestParameters.accountAddress, requestParameters.chainName, requestParameters.pageCursor, requestParameters.pageSize, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Refresh collection metadata
     * @summary Refresh collection metadata
     * @param {CollectionsApiRefreshCollectionMetadataRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CollectionsApi
     */
    refreshCollectionMetadata(requestParameters, options) {
        return CollectionsApiFp(this.configuration).refreshCollectionMetadata(requestParameters.contractAddress, requestParameters.chainName, requestParameters.refreshCollectionMetadataRequest, options).then((request) => request(this.axios, this.basePath));
    }
}

/* tslint:disable */
/* eslint-disable */
/**
 * Immutable zkEVM API
 * Immutable Multi Rollup API
 *
 * The version of the OpenAPI document: 1.0.0
 * Contact: support@immutable.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
/**
 * NftOwnersApi - axios parameter creator
 * @export
 */
const NftOwnersApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * List NFT owners by token ID
         * @summary List NFT owners by token ID
         * @param {string} contractAddress The address of contract
         * @param {string} tokenId An &#x60;uint256&#x60; token id as string
         * @param {string} chainName The name of chain
         * @param {string} [pageCursor] Encoded page cursor to retrieve previous or next page. Use the value returned in the response.
         * @param {number} [pageSize] Maximum number of items to return
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listNFTOwners: async (contractAddress, tokenId, chainName, pageCursor, pageSize, options = {}) => {
            // verify required parameter 'contractAddress' is not null or undefined
            assertParamExists$1('listNFTOwners', 'contractAddress', contractAddress);
            // verify required parameter 'tokenId' is not null or undefined
            assertParamExists$1('listNFTOwners', 'tokenId', tokenId);
            // verify required parameter 'chainName' is not null or undefined
            assertParamExists$1('listNFTOwners', 'chainName', chainName);
            const localVarPath = `/v1/chains/{chain_name}/collections/{contract_address}/nfts/{token_id}/owners`
                .replace(`{${"contract_address"}}`, encodeURIComponent(String(contractAddress)))
                .replace(`{${"token_id"}}`, encodeURIComponent(String(tokenId)))
                .replace(`{${"chain_name"}}`, encodeURIComponent(String(chainName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL$1);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (pageCursor !== undefined) {
                localVarQueryParameter['page_cursor'] = pageCursor;
            }
            if (pageSize !== undefined) {
                localVarQueryParameter['page_size'] = pageSize;
            }
            setSearchParams$1(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: toPathString$1(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
/**
 * NftOwnersApi - functional programming interface
 * @export
 */
const NftOwnersApiFp = function (configuration) {
    const localVarAxiosParamCreator = NftOwnersApiAxiosParamCreator(configuration);
    return {
        /**
         * List NFT owners by token ID
         * @summary List NFT owners by token ID
         * @param {string} contractAddress The address of contract
         * @param {string} tokenId An &#x60;uint256&#x60; token id as string
         * @param {string} chainName The name of chain
         * @param {string} [pageCursor] Encoded page cursor to retrieve previous or next page. Use the value returned in the response.
         * @param {number} [pageSize] Maximum number of items to return
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listNFTOwners(contractAddress, tokenId, chainName, pageCursor, pageSize, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listNFTOwners(contractAddress, tokenId, chainName, pageCursor, pageSize, options);
            return createRequestFunction$1(localVarAxiosArgs, globalAxios$1, BASE_PATH$1, configuration);
        },
    };
};
/**
 * NftOwnersApi - object-oriented interface
 * @export
 * @class NftOwnersApi
 * @extends {BaseAPI}
 */
class NftOwnersApi extends BaseAPI$1 {
    /**
     * List NFT owners by token ID
     * @summary List NFT owners by token ID
     * @param {NftOwnersApiListNFTOwnersRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NftOwnersApi
     */
    listNFTOwners(requestParameters, options) {
        return NftOwnersApiFp(this.configuration).listNFTOwners(requestParameters.contractAddress, requestParameters.tokenId, requestParameters.chainName, requestParameters.pageCursor, requestParameters.pageSize, options).then((request) => request(this.axios, this.basePath));
    }
}

/* tslint:disable */
/* eslint-disable */
/**
 * Immutable zkEVM API
 * Immutable Multi Rollup API
 *
 * The version of the OpenAPI document: 1.0.0
 * Contact: support@immutable.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
/**
 * NftsApi - axios parameter creator
 * @export
 */
const NftsApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * Get NFT by token ID
         * @summary Get NFT by token ID
         * @param {string} contractAddress The address of NFT contract
         * @param {string} tokenId An &#x60;uint256&#x60; token id as string
         * @param {string} chainName The name of chain
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getNFT: async (contractAddress, tokenId, chainName, options = {}) => {
            // verify required parameter 'contractAddress' is not null or undefined
            assertParamExists$1('getNFT', 'contractAddress', contractAddress);
            // verify required parameter 'tokenId' is not null or undefined
            assertParamExists$1('getNFT', 'tokenId', tokenId);
            // verify required parameter 'chainName' is not null or undefined
            assertParamExists$1('getNFT', 'chainName', chainName);
            const localVarPath = `/v1/chains/{chain_name}/collections/{contract_address}/nfts/{token_id}`
                .replace(`{${"contract_address"}}`, encodeURIComponent(String(contractAddress)))
                .replace(`{${"token_id"}}`, encodeURIComponent(String(tokenId)))
                .replace(`{${"chain_name"}}`, encodeURIComponent(String(chainName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL$1);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            setSearchParams$1(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: toPathString$1(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List NFTs by contract address
         * @summary List NFTs by contract address
         * @param {string} contractAddress Contract address
         * @param {string} chainName The name of chain
         * @param {string} [pageCursor] Encoded page cursor to retrieve previous or next page. Use the value returned in the response.
         * @param {number} [pageSize] Maximum number of items to return
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listNFTs: async (contractAddress, chainName, pageCursor, pageSize, options = {}) => {
            // verify required parameter 'contractAddress' is not null or undefined
            assertParamExists$1('listNFTs', 'contractAddress', contractAddress);
            // verify required parameter 'chainName' is not null or undefined
            assertParamExists$1('listNFTs', 'chainName', chainName);
            const localVarPath = `/v1/chains/{chain_name}/collections/{contract_address}/nfts`
                .replace(`{${"contract_address"}}`, encodeURIComponent(String(contractAddress)))
                .replace(`{${"chain_name"}}`, encodeURIComponent(String(chainName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL$1);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (pageCursor !== undefined) {
                localVarQueryParameter['page_cursor'] = pageCursor;
            }
            if (pageSize !== undefined) {
                localVarQueryParameter['page_size'] = pageSize;
            }
            setSearchParams$1(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: toPathString$1(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List NFTs by account address
         * @summary List NFTs by account address
         * @param {string} accountAddress Account address
         * @param {string} chainName The name of chain
         * @param {string} [contractAddress] The address of contract
         * @param {string} [pageCursor] Encoded page cursor to retrieve previous or next page. Use the value returned in the response.
         * @param {number} [pageSize] Maximum number of items to return
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listNFTsByAccountAddress: async (accountAddress, chainName, contractAddress, pageCursor, pageSize, options = {}) => {
            // verify required parameter 'accountAddress' is not null or undefined
            assertParamExists$1('listNFTsByAccountAddress', 'accountAddress', accountAddress);
            // verify required parameter 'chainName' is not null or undefined
            assertParamExists$1('listNFTsByAccountAddress', 'chainName', chainName);
            const localVarPath = `/v1/chains/{chain_name}/accounts/{account_address}/nfts`
                .replace(`{${"account_address"}}`, encodeURIComponent(String(accountAddress)))
                .replace(`{${"chain_name"}}`, encodeURIComponent(String(chainName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL$1);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (contractAddress !== undefined) {
                localVarQueryParameter['contract_address'] = contractAddress;
            }
            if (pageCursor !== undefined) {
                localVarQueryParameter['page_cursor'] = pageCursor;
            }
            if (pageSize !== undefined) {
                localVarQueryParameter['page_size'] = pageSize;
            }
            setSearchParams$1(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: toPathString$1(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
/**
 * NftsApi - functional programming interface
 * @export
 */
const NftsApiFp = function (configuration) {
    const localVarAxiosParamCreator = NftsApiAxiosParamCreator(configuration);
    return {
        /**
         * Get NFT by token ID
         * @summary Get NFT by token ID
         * @param {string} contractAddress The address of NFT contract
         * @param {string} tokenId An &#x60;uint256&#x60; token id as string
         * @param {string} chainName The name of chain
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getNFT(contractAddress, tokenId, chainName, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getNFT(contractAddress, tokenId, chainName, options);
            return createRequestFunction$1(localVarAxiosArgs, globalAxios$1, BASE_PATH$1, configuration);
        },
        /**
         * List NFTs by contract address
         * @summary List NFTs by contract address
         * @param {string} contractAddress Contract address
         * @param {string} chainName The name of chain
         * @param {string} [pageCursor] Encoded page cursor to retrieve previous or next page. Use the value returned in the response.
         * @param {number} [pageSize] Maximum number of items to return
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listNFTs(contractAddress, chainName, pageCursor, pageSize, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listNFTs(contractAddress, chainName, pageCursor, pageSize, options);
            return createRequestFunction$1(localVarAxiosArgs, globalAxios$1, BASE_PATH$1, configuration);
        },
        /**
         * List NFTs by account address
         * @summary List NFTs by account address
         * @param {string} accountAddress Account address
         * @param {string} chainName The name of chain
         * @param {string} [contractAddress] The address of contract
         * @param {string} [pageCursor] Encoded page cursor to retrieve previous or next page. Use the value returned in the response.
         * @param {number} [pageSize] Maximum number of items to return
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listNFTsByAccountAddress(accountAddress, chainName, contractAddress, pageCursor, pageSize, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listNFTsByAccountAddress(accountAddress, chainName, contractAddress, pageCursor, pageSize, options);
            return createRequestFunction$1(localVarAxiosArgs, globalAxios$1, BASE_PATH$1, configuration);
        },
    };
};
/**
 * NftsApi - object-oriented interface
 * @export
 * @class NftsApi
 * @extends {BaseAPI}
 */
class NftsApi extends BaseAPI$1 {
    /**
     * Get NFT by token ID
     * @summary Get NFT by token ID
     * @param {NftsApiGetNFTRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NftsApi
     */
    getNFT(requestParameters, options) {
        return NftsApiFp(this.configuration).getNFT(requestParameters.contractAddress, requestParameters.tokenId, requestParameters.chainName, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * List NFTs by contract address
     * @summary List NFTs by contract address
     * @param {NftsApiListNFTsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NftsApi
     */
    listNFTs(requestParameters, options) {
        return NftsApiFp(this.configuration).listNFTs(requestParameters.contractAddress, requestParameters.chainName, requestParameters.pageCursor, requestParameters.pageSize, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * List NFTs by account address
     * @summary List NFTs by account address
     * @param {NftsApiListNFTsByAccountAddressRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NftsApi
     */
    listNFTsByAccountAddress(requestParameters, options) {
        return NftsApiFp(this.configuration).listNFTsByAccountAddress(requestParameters.accountAddress, requestParameters.chainName, requestParameters.contractAddress, requestParameters.pageCursor, requestParameters.pageSize, options).then((request) => request(this.axios, this.basePath));
    }
}

/* tslint:disable */
/* eslint-disable */
/**
 * Immutable zkEVM API
 * Immutable Multi Rollup API
 *
 * The version of the OpenAPI document: 1.0.0
 * Contact: support@immutable.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
/**
 * OrdersApi - axios parameter creator
 * @export
 */
const OrdersApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * Create a listing
         * @summary Create a listing
         * @param {string} chainName
         * @param {CreateListingRequestBody} createListingRequestBody
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createListing: async (chainName, createListingRequestBody, options = {}) => {
            // verify required parameter 'chainName' is not null or undefined
            assertParamExists$1('createListing', 'chainName', chainName);
            // verify required parameter 'createListingRequestBody' is not null or undefined
            assertParamExists$1('createListing', 'createListingRequestBody', createListingRequestBody);
            const localVarPath = `/v1/chains/{chain_name}/orders/listings`
                .replace(`{${"chain_name"}}`, encodeURIComponent(String(chainName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL$1);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter['Content-Type'] = 'application/json';
            setSearchParams$1(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = serializeDataIfNeeded$1(createListingRequestBody, localVarRequestOptions, configuration);
            return {
                url: toPathString$1(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve signed fulfillment data based on the list of order IDs and corresponding fees.
         * @summary Retrieve fulfillment data for orders
         * @param {string} chainName
         * @param {Array<FulfillmentDataRequest>} fulfillmentDataRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fulfillmentData: async (chainName, fulfillmentDataRequest, options = {}) => {
            // verify required parameter 'chainName' is not null or undefined
            assertParamExists$1('fulfillmentData', 'chainName', chainName);
            // verify required parameter 'fulfillmentDataRequest' is not null or undefined
            assertParamExists$1('fulfillmentData', 'fulfillmentDataRequest', fulfillmentDataRequest);
            const localVarPath = `/v1/chains/{chain_name}/orders/fulfillment-data`
                .replace(`{${"chain_name"}}`, encodeURIComponent(String(chainName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL$1);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter['Content-Type'] = 'application/json';
            setSearchParams$1(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = serializeDataIfNeeded$1(fulfillmentDataRequest, localVarRequestOptions, configuration);
            return {
                url: toPathString$1(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a single listing by ID
         * @summary Get a single listing by ID
         * @param {string} chainName
         * @param {string} listingId Global Order identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getListing: async (chainName, listingId, options = {}) => {
            // verify required parameter 'chainName' is not null or undefined
            assertParamExists$1('getListing', 'chainName', chainName);
            // verify required parameter 'listingId' is not null or undefined
            assertParamExists$1('getListing', 'listingId', listingId);
            const localVarPath = `/v1/chains/{chain_name}/orders/listings/{listing_id}`
                .replace(`{${"chain_name"}}`, encodeURIComponent(String(chainName)))
                .replace(`{${"listing_id"}}`, encodeURIComponent(String(listingId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL$1);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            setSearchParams$1(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: toPathString$1(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a single trade by ID
         * @summary Get a single trade by ID
         * @param {string} chainName
         * @param {string} tradeId Global Trade identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTrade: async (chainName, tradeId, options = {}) => {
            // verify required parameter 'chainName' is not null or undefined
            assertParamExists$1('getTrade', 'chainName', chainName);
            // verify required parameter 'tradeId' is not null or undefined
            assertParamExists$1('getTrade', 'tradeId', tradeId);
            const localVarPath = `/v1/chains/{chain_name}/trades/{trade_id}`
                .replace(`{${"chain_name"}}`, encodeURIComponent(String(chainName)))
                .replace(`{${"trade_id"}}`, encodeURIComponent(String(tradeId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL$1);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            setSearchParams$1(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: toPathString$1(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List all listings
         * @summary List all listings
         * @param {string} chainName
         * @param {OrderStatus} [status] Order status to filter by
         * @param {string} [sellItemContractAddress] Sell item contract address to filter by
         * @param {string} [buyItemContractAddress] Buy item contract address to filter by
         * @param {string} [sellItemTokenId] Sell item token identifier to filter by
         * @param {number} [pageSize] Maximum number of orders to return per page
         * @param {'created_at' | 'updated_at' | 'buy_item_amount'} [sortBy] Order field to sort by
         * @param {'asc' | 'desc'} [sortDirection] Ascending or descending direction for sort
         * @param {string} [pageCursor] Page cursor to retrieve previous or next page. Use the value returned in the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listListings: async (chainName, status, sellItemContractAddress, buyItemContractAddress, sellItemTokenId, pageSize, sortBy, sortDirection, pageCursor, options = {}) => {
            // verify required parameter 'chainName' is not null or undefined
            assertParamExists$1('listListings', 'chainName', chainName);
            const localVarPath = `/v1/chains/{chain_name}/orders/listings`
                .replace(`{${"chain_name"}}`, encodeURIComponent(String(chainName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL$1);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (status !== undefined) {
                localVarQueryParameter['status'] = status;
            }
            if (sellItemContractAddress !== undefined) {
                localVarQueryParameter['sell_item_contract_address'] = sellItemContractAddress;
            }
            if (buyItemContractAddress !== undefined) {
                localVarQueryParameter['buy_item_contract_address'] = buyItemContractAddress;
            }
            if (sellItemTokenId !== undefined) {
                localVarQueryParameter['sell_item_token_id'] = sellItemTokenId;
            }
            if (pageSize !== undefined) {
                localVarQueryParameter['page_size'] = pageSize;
            }
            if (sortBy !== undefined) {
                localVarQueryParameter['sort_by'] = sortBy;
            }
            if (sortDirection !== undefined) {
                localVarQueryParameter['sort_direction'] = sortDirection;
            }
            if (pageCursor !== undefined) {
                localVarQueryParameter['page_cursor'] = pageCursor;
            }
            setSearchParams$1(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: toPathString$1(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List all trades
         * @summary List all trades
         * @param {string} chainName
         * @param {string} [accountAddress]
         * @param {number} [pageSize] Maximum number of trades to return per page
         * @param {'indexed_at'} [sortBy] Trade field to sort by
         * @param {'asc' | 'desc'} [sortDirection] Ascending or descending direction for sort
         * @param {string} [pageCursor] Page cursor to retrieve previous or next page. Use the value returned in the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listTrades: async (chainName, accountAddress, pageSize, sortBy, sortDirection, pageCursor, options = {}) => {
            // verify required parameter 'chainName' is not null or undefined
            assertParamExists$1('listTrades', 'chainName', chainName);
            const localVarPath = `/v1/chains/{chain_name}/trades`
                .replace(`{${"chain_name"}}`, encodeURIComponent(String(chainName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL$1);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (accountAddress !== undefined) {
                localVarQueryParameter['account_address'] = accountAddress;
            }
            if (pageSize !== undefined) {
                localVarQueryParameter['page_size'] = pageSize;
            }
            if (sortBy !== undefined) {
                localVarQueryParameter['sort_by'] = sortBy;
            }
            if (sortDirection !== undefined) {
                localVarQueryParameter['sort_direction'] = sortDirection;
            }
            if (pageCursor !== undefined) {
                localVarQueryParameter['page_cursor'] = pageCursor;
            }
            setSearchParams$1(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: toPathString$1(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
/**
 * OrdersApi - functional programming interface
 * @export
 */
const OrdersApiFp = function (configuration) {
    const localVarAxiosParamCreator = OrdersApiAxiosParamCreator(configuration);
    return {
        /**
         * Create a listing
         * @summary Create a listing
         * @param {string} chainName
         * @param {CreateListingRequestBody} createListingRequestBody
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createListing(chainName, createListingRequestBody, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createListing(chainName, createListingRequestBody, options);
            return createRequestFunction$1(localVarAxiosArgs, globalAxios$1, BASE_PATH$1, configuration);
        },
        /**
         * Retrieve signed fulfillment data based on the list of order IDs and corresponding fees.
         * @summary Retrieve fulfillment data for orders
         * @param {string} chainName
         * @param {Array<FulfillmentDataRequest>} fulfillmentDataRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async fulfillmentData(chainName, fulfillmentDataRequest, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.fulfillmentData(chainName, fulfillmentDataRequest, options);
            return createRequestFunction$1(localVarAxiosArgs, globalAxios$1, BASE_PATH$1, configuration);
        },
        /**
         * Get a single listing by ID
         * @summary Get a single listing by ID
         * @param {string} chainName
         * @param {string} listingId Global Order identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getListing(chainName, listingId, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getListing(chainName, listingId, options);
            return createRequestFunction$1(localVarAxiosArgs, globalAxios$1, BASE_PATH$1, configuration);
        },
        /**
         * Get a single trade by ID
         * @summary Get a single trade by ID
         * @param {string} chainName
         * @param {string} tradeId Global Trade identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTrade(chainName, tradeId, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTrade(chainName, tradeId, options);
            return createRequestFunction$1(localVarAxiosArgs, globalAxios$1, BASE_PATH$1, configuration);
        },
        /**
         * List all listings
         * @summary List all listings
         * @param {string} chainName
         * @param {OrderStatus} [status] Order status to filter by
         * @param {string} [sellItemContractAddress] Sell item contract address to filter by
         * @param {string} [buyItemContractAddress] Buy item contract address to filter by
         * @param {string} [sellItemTokenId] Sell item token identifier to filter by
         * @param {number} [pageSize] Maximum number of orders to return per page
         * @param {'created_at' | 'updated_at' | 'buy_item_amount'} [sortBy] Order field to sort by
         * @param {'asc' | 'desc'} [sortDirection] Ascending or descending direction for sort
         * @param {string} [pageCursor] Page cursor to retrieve previous or next page. Use the value returned in the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listListings(chainName, status, sellItemContractAddress, buyItemContractAddress, sellItemTokenId, pageSize, sortBy, sortDirection, pageCursor, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listListings(chainName, status, sellItemContractAddress, buyItemContractAddress, sellItemTokenId, pageSize, sortBy, sortDirection, pageCursor, options);
            return createRequestFunction$1(localVarAxiosArgs, globalAxios$1, BASE_PATH$1, configuration);
        },
        /**
         * List all trades
         * @summary List all trades
         * @param {string} chainName
         * @param {string} [accountAddress]
         * @param {number} [pageSize] Maximum number of trades to return per page
         * @param {'indexed_at'} [sortBy] Trade field to sort by
         * @param {'asc' | 'desc'} [sortDirection] Ascending or descending direction for sort
         * @param {string} [pageCursor] Page cursor to retrieve previous or next page. Use the value returned in the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listTrades(chainName, accountAddress, pageSize, sortBy, sortDirection, pageCursor, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listTrades(chainName, accountAddress, pageSize, sortBy, sortDirection, pageCursor, options);
            return createRequestFunction$1(localVarAxiosArgs, globalAxios$1, BASE_PATH$1, configuration);
        },
    };
};
/**
 * OrdersApi - object-oriented interface
 * @export
 * @class OrdersApi
 * @extends {BaseAPI}
 */
class OrdersApi extends BaseAPI$1 {
    /**
     * Create a listing
     * @summary Create a listing
     * @param {OrdersApiCreateListingRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrdersApi
     */
    createListing(requestParameters, options) {
        return OrdersApiFp(this.configuration).createListing(requestParameters.chainName, requestParameters.createListingRequestBody, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Retrieve signed fulfillment data based on the list of order IDs and corresponding fees.
     * @summary Retrieve fulfillment data for orders
     * @param {OrdersApiFulfillmentDataRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrdersApi
     */
    fulfillmentData(requestParameters, options) {
        return OrdersApiFp(this.configuration).fulfillmentData(requestParameters.chainName, requestParameters.fulfillmentDataRequest, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Get a single listing by ID
     * @summary Get a single listing by ID
     * @param {OrdersApiGetListingRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrdersApi
     */
    getListing(requestParameters, options) {
        return OrdersApiFp(this.configuration).getListing(requestParameters.chainName, requestParameters.listingId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Get a single trade by ID
     * @summary Get a single trade by ID
     * @param {OrdersApiGetTradeRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrdersApi
     */
    getTrade(requestParameters, options) {
        return OrdersApiFp(this.configuration).getTrade(requestParameters.chainName, requestParameters.tradeId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * List all listings
     * @summary List all listings
     * @param {OrdersApiListListingsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrdersApi
     */
    listListings(requestParameters, options) {
        return OrdersApiFp(this.configuration).listListings(requestParameters.chainName, requestParameters.status, requestParameters.sellItemContractAddress, requestParameters.buyItemContractAddress, requestParameters.sellItemTokenId, requestParameters.pageSize, requestParameters.sortBy, requestParameters.sortDirection, requestParameters.pageCursor, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * List all trades
     * @summary List all trades
     * @param {OrdersApiListTradesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrdersApi
     */
    listTrades(requestParameters, options) {
        return OrdersApiFp(this.configuration).listTrades(requestParameters.chainName, requestParameters.accountAddress, requestParameters.pageSize, requestParameters.sortBy, requestParameters.sortDirection, requestParameters.pageCursor, options).then((request) => request(this.axios, this.basePath));
    }
}

/* tslint:disable */
/* eslint-disable */
/**
 * Immutable zkEVM API
 * Immutable Multi Rollup API
 *
 * The version of the OpenAPI document: 1.0.0
 * Contact: support@immutable.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
/**
 * PassportApi - axios parameter creator
 * @export
 */
const PassportApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * Create a counterfactual address for a user based on their Ethereum address
         * @summary Create a counterfactual address
         * @param {CreateCounterfactualAddressRequest} createCounterfactualAddressRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCounterfactualAddress: async (createCounterfactualAddressRequest, options = {}) => {
            // verify required parameter 'createCounterfactualAddressRequest' is not null or undefined
            assertParamExists$1('createCounterfactualAddress', 'createCounterfactualAddressRequest', createCounterfactualAddressRequest);
            const localVarPath = `/passport-mr/v1/counterfactual-address`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL$1);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject$1(localVarHeaderParameter, configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            setSearchParams$1(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = serializeDataIfNeeded$1(createCounterfactualAddressRequest, localVarRequestOptions, configuration);
            return {
                url: toPathString$1(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get all the Ethereum linked addresses for a user based on its userId
         * @summary Get Ethereum linked addresses for a user
         * @param {string} userId The user\&#39;s userId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLinkedAddresses: async (userId, options = {}) => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists$1('getLinkedAddresses', 'userId', userId);
            const localVarPath = `/passport-mr/v1/users/{userId}/linked-addresses`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL$1);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject$1(localVarHeaderParameter, configuration);
            setSearchParams$1(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: toPathString$1(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
/**
 * PassportApi - functional programming interface
 * @export
 */
const PassportApiFp = function (configuration) {
    const localVarAxiosParamCreator = PassportApiAxiosParamCreator(configuration);
    return {
        /**
         * Create a counterfactual address for a user based on their Ethereum address
         * @summary Create a counterfactual address
         * @param {CreateCounterfactualAddressRequest} createCounterfactualAddressRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createCounterfactualAddress(createCounterfactualAddressRequest, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createCounterfactualAddress(createCounterfactualAddressRequest, options);
            return createRequestFunction$1(localVarAxiosArgs, globalAxios$1, BASE_PATH$1, configuration);
        },
        /**
         * Get all the Ethereum linked addresses for a user based on its userId
         * @summary Get Ethereum linked addresses for a user
         * @param {string} userId The user\&#39;s userId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getLinkedAddresses(userId, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getLinkedAddresses(userId, options);
            return createRequestFunction$1(localVarAxiosArgs, globalAxios$1, BASE_PATH$1, configuration);
        },
    };
};
/**
 * PassportApi - object-oriented interface
 * @export
 * @class PassportApi
 * @extends {BaseAPI}
 */
class PassportApi extends BaseAPI$1 {
    /**
     * Create a counterfactual address for a user based on their Ethereum address
     * @summary Create a counterfactual address
     * @param {PassportApiCreateCounterfactualAddressRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PassportApi
     */
    createCounterfactualAddress(requestParameters, options) {
        return PassportApiFp(this.configuration).createCounterfactualAddress(requestParameters.createCounterfactualAddressRequest, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Get all the Ethereum linked addresses for a user based on its userId
     * @summary Get Ethereum linked addresses for a user
     * @param {PassportApiGetLinkedAddressesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PassportApi
     */
    getLinkedAddresses(requestParameters, options) {
        return PassportApiFp(this.configuration).getLinkedAddresses(requestParameters.userId, options).then((request) => request(this.axios, this.basePath));
    }
}

class MultiRollupApiClients {
    config;
    activitiesApi;
    chainsApi;
    collectionApi;
    nftOwnersApi;
    nftsApi;
    ordersApi;
    passportApi;
    constructor(config) {
        this.config = config;
        this.activitiesApi = new ActivitiesApi(config.indexer);
        this.chainsApi = new ChainsApi(config.indexer);
        this.collectionApi = new CollectionsApi(config.indexer);
        this.nftOwnersApi = new NftOwnersApi(config.indexer);
        this.nftsApi = new NftsApi(config.indexer);
        this.ordersApi = new OrdersApi(config.orderBook);
        this.passportApi = new PassportApi(config.passport);
    }
}

// eslint-disable-next-line @typescript-eslint/naming-convention
const defaultHeaders = { 'x-sdk-version': 'ts-immutable-sdk-0.22.0' };
const createConfig = ({ basePath, headers, }) => {
    if (!basePath.trim()) {
        throw Error('basePath can not be empty');
    }
    const composedHeaders = { ...defaultHeaders, ...(headers || {}) };
    const apiConfigOptions = {
        basePath,
        baseOptions: { headers: composedHeaders },
    };
    return new Configuration$1(apiConfigOptions);
};
/**
 * Creates a Configuration for the specified environment
 * @returns an MultiRollupAPIConfiguration
 */
const multiRollupConfig = {
    getProduction: () => ({
        indexer: createConfig({
            basePath: 'https://indexer-mr.imtbl.com',
        }),
        orderBook: createConfig({
            basePath: 'https://order-book-mr.imtbl.com',
        }),
        passport: createConfig({
            basePath: 'https://api.immutable.com',
        }),
    }),
    getSandbox: () => ({
        indexer: createConfig({
            basePath: 'https://api.sandbox.immutable.com',
        }),
        orderBook: createConfig({
            basePath: 'https://api.sandbox.immutable.com',
        }),
        passport: createConfig({
            basePath: 'https://api.sandbox.immutable.com',
        }),
    }),
};

var Environment;
(function (Environment) {
    Environment["PRODUCTION"] = "production";
    Environment["SANDBOX"] = "sandbox";
})(Environment || (Environment = {}));

/**
 * createImmutableXConfiguration to create a custom ImmutableXConfiguration
 * other than the production and sandbox defined below.
 */
const createImmutableXConfiguration = ({ basePath, chainID, coreContractAddress, registrationContractAddress, }) => Config.createConfig({
    basePath,
    chainID,
    coreContractAddress,
    registrationContractAddress,
    sdkVersion: 'ts-immutable-sdk-0.22.0',
});
/**
 * Sets `sdkVersion` at the time of build
 */
const production = () => createImmutableXConfiguration({
    basePath: 'https://api.x.immutable.com',
    chainID: 1,
    coreContractAddress: '0x5FDCCA53617f4d2b9134B29090C87D01058e27e9',
    registrationContractAddress: '0x72a06bf2a1CE5e39cBA06c0CAb824960B587d64c',
});
/**
 * Sets `sdkVersion` at the time of build
 */
const sandbox = () => createImmutableXConfiguration({
    basePath: 'https://api.sandbox.x.immutable.com',
    chainID: 5,
    coreContractAddress: '0x7917eDb51ecD6CdB3F9854c3cc593F33de10c623',
    registrationContractAddress: '0x1C97Ada273C9A52253f463042f29117090Cd7D83',
});
class ImxConfiguration {
    immutableXConfig;
    baseConfig;
    constructor({ baseConfig, overrides }) {
        this.baseConfig = baseConfig;
        if (overrides) {
            this.immutableXConfig = overrides.immutableXConfig;
        }
        else {
            switch (baseConfig.environment) {
                case Environment.SANDBOX: {
                    this.immutableXConfig = sandbox();
                    break;
                }
                case Environment.PRODUCTION: {
                    this.immutableXConfig = production();
                    break;
                }
                default: {
                    this.immutableXConfig = sandbox();
                }
            }
        }
    }
}

class ImmutableXClient {
    immutableX;
    depositsApi;
    mintsApi;
    ordersApi;
    tokensApi;
    tradesApi;
    transfersApi;
    exchangeApi;
    nftCheckoutPrimaryApi;
    usersApi;
    withdrawalsApi;
    balanceApi;
    assetApi;
    collectionApi;
    metadataApi;
    metadataRefreshesApi;
    projectsApi;
    constructor(config) {
        const imxConfig = new ImxConfiguration(config);
        this.immutableX = new ImmutableX(imxConfig.immutableXConfig);
        this.depositsApi = this.immutableX.depositsApi;
        this.mintsApi = this.immutableX.mintsApi;
        this.ordersApi = this.immutableX.ordersApi;
        this.tokensApi = this.immutableX.tokensApi;
        this.tradesApi = this.immutableX.tradesApi;
        this.transfersApi = this.immutableX.transfersApi;
        this.exchangeApi = this.immutableX.exchangeApi;
        this.usersApi = this.immutableX.usersApi;
        this.withdrawalsApi = this.immutableX.withdrawalsApi;
        this.balanceApi = this.immutableX.balanceApi;
        this.assetApi = this.immutableX.assetApi;
        this.collectionApi = this.immutableX.collectionApi;
        this.metadataApi = this.immutableX.metadataApi;
        this.metadataRefreshesApi = this.immutableX.metadataRefreshesApi;
        this.nftCheckoutPrimaryApi = this.immutableX.nftCheckoutPrimaryApi;
        this.projectsApi = this.immutableX.projectsApi;
    }
    /**
     * Get details of a Deposit with the given ID
     * @param request - the request object containing the parameters to be provided in the API request
     * @returns a promise that resolves with the requested Deposit
     * @throws {@link index.IMXError}
     */
    getDeposit(request) {
        return this.immutableX.getDeposit(request);
    }
    /**
     * Get a list of Deposits
     * @param request - optional object containing the parameters to be provided in the API request
     * @returns a promise that resolves with the requested list of Deposits
     * @throws {@link index.IMXError}
     */
    listDeposits(request) {
        return this.immutableX.listDeposits(request);
    }
    /**
     * Get Stark keys for a registered User
     * @param ethAddress - the eth address of the User
     * @returns a promise that resolves with the requested User
     * @throws {@link index.IMXError}
     */
    getUser(ethAddress) {
        return this.immutableX.getUser(ethAddress);
    }
    /**
     * Get details of an Asset
     * @param request - the request object containing the parameters to be provided in the API request
     * @returns a promise that resolves with the requested Asset
     * @throws {@link index.IMXError}
     */
    getAsset(request) {
        return this.immutableX.getAsset(request);
    }
    /**
     * Get a list of Assets
     * @param request - optional object containing the parameters to be provided in the API request
     * @returns a promise that resolves with the requested list of Assets
     * @throws {@link index.IMXError}
     */
    listAssets(request) {
        return this.immutableX.listAssets(request);
    }
    /**
     * Create a Collection
     * @param ethSigner - the L1 signer
     * @param request - the request object to be provided in the API request
     * @returns a promise that resolves with the created Collection
     * @throws {@link index.IMXError}
     */
    createCollection(ethSigner, request) {
        return this.immutableX.createCollection(ethSigner, request);
    }
    /**
     * Get details of a Collection at the given address
     * @param request - the request object containing the parameters to be provided in the API request
     * @returns a promise that resolves with the requested Collection
     * @throws {@link index.IMXError}
     */
    getCollection(request) {
        return this.immutableX.getCollection(request);
    }
    /**
     * Get a list of Collection filters
     * @param request - the request object containing the parameters to be provided in the API request
     * @returns a promise that resolves with the requested list of Collection Filters
     * @throws {@link index.IMXError}
     */
    listCollectionFilters(request) {
        return this.immutableX.listCollectionFilters(request);
    }
    /**
     * Get a list of Collections
     * @param request - optional object containing the parameters to be provided in the API request
     * @returns a promise that resolves with the requested list of Collections
     * @throws {@link index.IMXError}
     */
    listCollections(request) {
        return this.collectionApi.listCollections(request).then((res) => res.data);
    }
    /**
     * Update a Collection
     * @param ethSigner - the L1 signer
     * @param collectionAddress - the Collection contract address
     * @param request - the request object containing the parameters to be provided in the API request
     * @returns a promise that resolves with the updated Collection
     * @throws {@link index.IMXError}
     */
    updateCollection(ethSigner, collectionAddress, request) {
        return this.immutableX.updateCollection(ethSigner, collectionAddress, request);
    }
    /**
     * Add metadata schema to Collection
     * @param ethSigner - the L1 signer
     * @param collectionAddress - the Collection contract address
     * @param request - the request object containing the parameters to be provided in the API request
     * @returns a promise that resolves with the SuccessResponse if successful
     * @throws {@link index.IMXError}
     */
    addMetadataSchemaToCollection(ethSigner, collectionAddress, request) {
        return this.immutableX.addMetadataSchemaToCollection(ethSigner, collectionAddress, request);
    }
    /**
     * Get Metadata schema
     * @param request - the request object containing the parameters to be provided in the API request
     * @returns a promise that resolves with the requested Metadata schema
     * @throws {@link index.IMXError}
     */
    getMetadataSchema(request) {
        return this.immutableX.getMetadataSchema(request);
    }
    /**
     * Update metadata schema by name
     * @param ethSigner - the L1 signer
     * @param collectionAddress - the Collection contract address
     * @param name - the Metadata schema name
     * @param request - the request object containing the parameters to be provided in the API request
     * @returns a promise that resolves with the SuccessResponse if successful
     * @throws {@link index.IMXError}
     */
    updateMetadataSchemaByName(ethSigner, collectionAddress, name, request) {
        return this.immutableX.updateMetadataSchemaByName(ethSigner, collectionAddress, name, request);
    }
    /**
     * Get a list of metadata refreshes
     * @param ethSigner - the L1 signer
     * @param collectionAddress - the Collection contract address
     * @param pageSize - the page size of the result
     * @param cursor - the cursor
     * @returns a promise that resolves with the requested metadata refreshes
     * @throws {@link index.IMXError}
     */
    listMetadataRefreshes(ethSigner, collectionAddress, pageSize, cursor) {
        return this.immutableX.listMetadataRefreshes(ethSigner, collectionAddress, pageSize, cursor);
    }
    /**
     * Get a list of metadata refresh errors
     * @param ethSigner - the L1 signer
     * @param refreshId - the metadata refresh ID
     * @param pageSize - the page size of the result
     * @param cursor - the cursor
     * @returns a promise that resolves with the requested metadata refresh errors
     * @throws {@link index.IMXError}
     */
    getMetadataRefreshErrors(ethSigner, refreshId, pageSize, cursor) {
        return this.immutableX.getMetadataRefreshErrors(ethSigner, refreshId, pageSize, cursor);
    }
    /**
     * Get a list of metadata refresh results
     * @param ethSigner - the L1 signer
     * @param refreshId - the metadata refresh ID
     * @returns a promise that resolves with the requested metadata refresh results
     * @throws {@link index.IMXError}
     */
    getMetadataRefreshResults(ethSigner, refreshId) {
        return this.immutableX.getMetadataRefreshResults(ethSigner, refreshId);
    }
    /**
     * Request a metadata refresh
     * @param ethSigner - the L1 signer
     * @param request the request object containing the parameters to be provided in the API request
     * @returns a promise that resolves with the requested metadata refresh
     * @throws {@link index.IMXError}
     */
    createMetadataRefresh(ethSigner, request) {
        return this.immutableX.createMetadataRefresh(ethSigner, request);
    }
    /**
     * Create a Project
     * @param ethSigner - the L1 signer
     * @param request - the request object containing the parameters to be provided in the API request
     * @returns a promise that resolves with the created Project
     * @throws {@link index.IMXError}
     */
    async createProject(ethSigner, request) {
        return this.immutableX.createProject(ethSigner, request);
    }
    /**
     * Get a Project
     * @param ethSigner - the L1 signer
     * @param id - the Project ID
     * @returns a promise that resolves with the requested Project
     * @throws {@link index.IMXError}
     */
    async getProject(ethSigner, id) {
        return this.immutableX.getProject(ethSigner, id);
    }
    /**
     * Get Projects owned by the given User
     * @param ethSigner - the L1 signer
     * @param pageSize - the page size of the result
     * @param cursor - the cursor
     * @param orderBy - the property to sort by
     * @param direction - direction to sort (asc/desc)
     * @returns a promise that resolves with the requested Projects
     * @throws {@link index.IMXError}
     */
    async getProjects(ethSigner, pageSize, cursor, orderBy, direction) {
        return this.immutableX.getProjects(ethSigner, pageSize, cursor, orderBy, direction);
    }
    /**
     * Get the token Balances of the User
     * @param request - the request object containing the parameters to be provided in the API request
     * @returns a promise that resolves with the requested Balance
     * @throws {@link index.IMXError}
     */
    getBalance(request) {
        return this.immutableX.getBalance(request);
    }
    /**
     * Get a list of Balances for given User
     * @param request the request object containing the parameters to be provided in the API request
     * @returns a promise that resolves with the requested list of Balances
     * @throws {@link index.IMXError}
     */
    listBalances(request) {
        return this.immutableX.listBalances(request);
    }
    /**
     * Get details of a Mint with the given ID
     * @param request the request object containing the parameters to be provided in the API request
     * @returns a promise that resolves with the requested Mint
     * @throws {@link index.IMXError}
     */
    getMint(request) {
        return this.immutableX.getMint(request);
    }
    /**
     * Get a list of Mints
     * @param request optional object containing the parameters to be provided in the API request
     * @returns a promise that resolves with the requested list of Mints
     * @throws {@link index.IMXError}
     */
    listMints(request) {
        return this.immutableX.listMints(request);
    }
    /**
     * Mint tokens in a batch with fees
     * @param ethSigner - the L1 signer
     * @param request - the request object to be provided in the API request
     * @returns a promise that resolves with the minted tokens
     * @throws {@link index.IMXError}
     */
    mint(ethSigner, request) {
        return this.immutableX.mint(ethSigner, request);
    }
    /**
     * Get a list of Withdrawals
     * @param request - optional object containing the parameters to be provided in the API request
     * @returns a promise that resolves with the requested list of Withdrawals
     * @throws {@link index.IMXError}
     */
    listWithdrawals(request) {
        return this.immutableX.listWithdrawals(request);
    }
    /**
     * Get details of Withdrawal with the given ID
     * @param request - the request object containing the parameters to be provided in the API request
     * @returns a promise that resolves with the requested Withdrawal
     * @throws {@link index.IMXError}
     */
    getWithdrawal(request) {
        return this.immutableX.getWithdrawal(request);
    }
    /**
     * Get details of an Order with the given ID
     * @param request - the request object containing the parameters to be provided in the API request
     * @returns a promise that resolves with the requested Order
     * @throws {@link index.IMXError}
     */
    getOrder(request) {
        return this.immutableX.getOrder(request);
    }
    /**
     * Get a list of Orders
     * @param request - optional object containing the parameters to be provided in the API request
     * @returns a promise that resolves with the requested list of Orders
     * @throws {@link index.IMXError}
     */
    listOrders(request) {
        return this.immutableX.listOrders(request);
    }
    /**
     * Get details of a Trade with the given ID
     * @param request - the request object containing the parameters to be provided in the API request
     * @returns a promise that resolves with the requested Trade
     * @throws {@link index.IMXError}
     */
    getTrade(request) {
        return this.immutableX.getTrade(request);
    }
    /**
     * Get a list of Trades
     * @param request - optional object containing the parameters to be provided in the API request
     * @returns a promise that resolves with the requested list of Trades
     * @throws {@link index.IMXError}
     */
    listTrades(request) {
        return this.immutableX.listTrades(request);
    }
    /**
     * Get details of a Token
     * @param request - the request object containing the parameters to be provided in the API request
     * @returns a promise that resolves with the requested Token
     * @throws {@link index.IMXError}
     */
    getToken(request) {
        return this.immutableX.getToken(request);
    }
    /**
     * Get a list of Tokens
     * @param request - optional object containing the parameters to be provided in the API request
     * @returns a promise that resolves with the requested list of Tokens
     * @throws {@link index.IMXError}
     */
    listTokens(request) {
        return this.immutableX.listTokens(request);
    }
    /**
     * Get details of a Transfer with the given ID
     * @param request - the request object containing the parameters to be provided in the API request
     * @returns a promise that resolves with the requested Transfer
     * @throws {@link index.IMXError}
     */
    getTransfer(request) {
        return this.immutableX.getTransfer(request);
    }
    /**
     * Get a list of Transfers
     * @param request - optional object containing the parameters to be provided in the API request
     * @returns a promise that resolves with the requested list of Transfers
     * @throws {@link index.IMXError}
     */
    listTransfers(request) {
        return this.immutableX.listTransfers(request);
    }
    /**
     * Create a new Exchange transaction
     * @param request - the request object to be provided in the API request
     * @returns a promise that resolves with the created Exchange Transaction
     * @throws {@link index.IMXError}
     */
    createExchange(request) {
        return this.immutableX.createExchange(request).then((res) => res.data);
    }
    /**
     * Get an Exchange transaction
     * @param request - the request object to be provided in the API request
     * @returns a promise that resolves with the Exchange Transaction
     * @throws {@link index.IMXError}
     */
    getExchange(request) {
        return this.immutableX.getExchange(request).then((res) => res.data);
    }
    /**
     * Get Exchange transactions
     * @param request - the request object to be provided in the API request
     * @returns a promise that resolves with Exchange Transactions
     * @throws {@link index.IMXError}
     */
    getExchanges(request) {
        return this.immutableX.getExchanges(request).then((res) => res.data);
    }
    /**
     * Create a new Transfer request
     * @param walletConnection - the pair of Eth/Stark signers
     * @param request - the request object to be provided in the API request
     * @returns a promise that resolves with the created Exchange Transfer
     * @throws {@link index.IMXError}
     */
    exchangeTransfer(walletConnection, request) {
        return this.immutableX.exchangeTransfer(walletConnection, request);
    }
    /**
     * Create a new nft primary transaction
     * @param request - the request object to be provided in the API request
     * @returns a promise that resolves with the created nft primary Transaction
     * @throws {@link index.IMXError}
     */
    createNftPrimary(request) {
        return this.immutableX.createNftPrimary(request).then((res) => res.data);
    }
    /**
     * Get nft primary supported currencies and their limits
     * @param request - the request object to be provided in the API request
     * @returns a promise that resolves with nft primary Currencies
     * @throws {@link index.IMXError}
     */
    getCurrenciesNFTCheckoutPrimary(request) {
        return this.immutableX
            .getCurrenciesNFTCheckoutPrimary(request)
            .then((res) => res.data);
    }
    /**
     * Get nft primary transaction by transaction id
     * @param request - the request object to be provided in the API request
     * @returns a promise that resolves with nft primary transaction
     * @throws {@link index.IMXError}
     */
    getNftPrimaryTransaction(request) {
        return this.immutableX
            .getNftPrimaryTransaction(request)
            .then((res) => res.data);
    }
    /**
     * Get list of nft primary transactions
     * @param request - the request object to be provided in the API request
     * @returns a promise that resolves with nft primary transaction
     * @throws {@link index.IMXError}
     */
    getNftPrimaryTransactions(request) {
        return this.immutableX
            .getNftPrimaryTransactions(request)
            .then((res) => res.data);
    }
}

function bind(fn, thisArg) {
  return function wrap() {
    return fn.apply(thisArg, arguments);
  };
}

// utils is a library of generic helper functions non-specific to axios

const {toString} = Object.prototype;
const {getPrototypeOf} = Object;

const kindOf = (cache => thing => {
    const str = toString.call(thing);
    return cache[str] || (cache[str] = str.slice(8, -1).toLowerCase());
})(Object.create(null));

const kindOfTest = (type) => {
  type = type.toLowerCase();
  return (thing) => kindOf(thing) === type
};

const typeOfTest = type => thing => typeof thing === type;

/**
 * Determine if a value is an Array
 *
 * @param {Object} val The value to test
 *
 * @returns {boolean} True if value is an Array, otherwise false
 */
const {isArray} = Array;

/**
 * Determine if a value is undefined
 *
 * @param {*} val The value to test
 *
 * @returns {boolean} True if the value is undefined, otherwise false
 */
const isUndefined = typeOfTest('undefined');

/**
 * Determine if a value is a Buffer
 *
 * @param {*} val The value to test
 *
 * @returns {boolean} True if value is a Buffer, otherwise false
 */
function isBuffer(val) {
  return val !== null && !isUndefined(val) && val.constructor !== null && !isUndefined(val.constructor)
    && isFunction(val.constructor.isBuffer) && val.constructor.isBuffer(val);
}

/**
 * Determine if a value is an ArrayBuffer
 *
 * @param {*} val The value to test
 *
 * @returns {boolean} True if value is an ArrayBuffer, otherwise false
 */
const isArrayBuffer = kindOfTest('ArrayBuffer');


/**
 * Determine if a value is a view on an ArrayBuffer
 *
 * @param {*} val The value to test
 *
 * @returns {boolean} True if value is a view on an ArrayBuffer, otherwise false
 */
function isArrayBufferView(val) {
  let result;
  if ((typeof ArrayBuffer !== 'undefined') && (ArrayBuffer.isView)) {
    result = ArrayBuffer.isView(val);
  } else {
    result = (val) && (val.buffer) && (isArrayBuffer(val.buffer));
  }
  return result;
}

/**
 * Determine if a value is a String
 *
 * @param {*} val The value to test
 *
 * @returns {boolean} True if value is a String, otherwise false
 */
const isString = typeOfTest('string');

/**
 * Determine if a value is a Function
 *
 * @param {*} val The value to test
 * @returns {boolean} True if value is a Function, otherwise false
 */
const isFunction = typeOfTest('function');

/**
 * Determine if a value is a Number
 *
 * @param {*} val The value to test
 *
 * @returns {boolean} True if value is a Number, otherwise false
 */
const isNumber = typeOfTest('number');

/**
 * Determine if a value is an Object
 *
 * @param {*} thing The value to test
 *
 * @returns {boolean} True if value is an Object, otherwise false
 */
const isObject = (thing) => thing !== null && typeof thing === 'object';

/**
 * Determine if a value is a Boolean
 *
 * @param {*} thing The value to test
 * @returns {boolean} True if value is a Boolean, otherwise false
 */
const isBoolean = thing => thing === true || thing === false;

/**
 * Determine if a value is a plain Object
 *
 * @param {*} val The value to test
 *
 * @returns {boolean} True if value is a plain Object, otherwise false
 */
const isPlainObject = (val) => {
  if (kindOf(val) !== 'object') {
    return false;
  }

  const prototype = getPrototypeOf(val);
  return (prototype === null || prototype === Object.prototype || Object.getPrototypeOf(prototype) === null) && !(Symbol.toStringTag in val) && !(Symbol.iterator in val);
};

/**
 * Determine if a value is a Date
 *
 * @param {*} val The value to test
 *
 * @returns {boolean} True if value is a Date, otherwise false
 */
const isDate = kindOfTest('Date');

/**
 * Determine if a value is a File
 *
 * @param {*} val The value to test
 *
 * @returns {boolean} True if value is a File, otherwise false
 */
const isFile = kindOfTest('File');

/**
 * Determine if a value is a Blob
 *
 * @param {*} val The value to test
 *
 * @returns {boolean} True if value is a Blob, otherwise false
 */
const isBlob = kindOfTest('Blob');

/**
 * Determine if a value is a FileList
 *
 * @param {*} val The value to test
 *
 * @returns {boolean} True if value is a File, otherwise false
 */
const isFileList = kindOfTest('FileList');

/**
 * Determine if a value is a Stream
 *
 * @param {*} val The value to test
 *
 * @returns {boolean} True if value is a Stream, otherwise false
 */
const isStream = (val) => isObject(val) && isFunction(val.pipe);

/**
 * Determine if a value is a FormData
 *
 * @param {*} thing The value to test
 *
 * @returns {boolean} True if value is an FormData, otherwise false
 */
const isFormData = (thing) => {
  let kind;
  return thing && (
    (typeof FormData === 'function' && thing instanceof FormData) || (
      isFunction(thing.append) && (
        (kind = kindOf(thing)) === 'formdata' ||
        // detect form-data instance
        (kind === 'object' && isFunction(thing.toString) && thing.toString() === '[object FormData]')
      )
    )
  )
};

/**
 * Determine if a value is a URLSearchParams object
 *
 * @param {*} val The value to test
 *
 * @returns {boolean} True if value is a URLSearchParams object, otherwise false
 */
const isURLSearchParams = kindOfTest('URLSearchParams');

/**
 * Trim excess whitespace off the beginning and end of a string
 *
 * @param {String} str The String to trim
 *
 * @returns {String} The String freed of excess whitespace
 */
const trim = (str) => str.trim ?
  str.trim() : str.replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, '');

/**
 * Iterate over an Array or an Object invoking a function for each item.
 *
 * If `obj` is an Array callback will be called passing
 * the value, index, and complete array for each item.
 *
 * If 'obj' is an Object callback will be called passing
 * the value, key, and complete object for each property.
 *
 * @param {Object|Array} obj The object to iterate
 * @param {Function} fn The callback to invoke for each item
 *
 * @param {Boolean} [allOwnKeys = false]
 * @returns {any}
 */
function forEach(obj, fn, {allOwnKeys = false} = {}) {
  // Don't bother if no value provided
  if (obj === null || typeof obj === 'undefined') {
    return;
  }

  let i;
  let l;

  // Force an array if not already something iterable
  if (typeof obj !== 'object') {
    /*eslint no-param-reassign:0*/
    obj = [obj];
  }

  if (isArray(obj)) {
    // Iterate over array values
    for (i = 0, l = obj.length; i < l; i++) {
      fn.call(null, obj[i], i, obj);
    }
  } else {
    // Iterate over object keys
    const keys = allOwnKeys ? Object.getOwnPropertyNames(obj) : Object.keys(obj);
    const len = keys.length;
    let key;

    for (i = 0; i < len; i++) {
      key = keys[i];
      fn.call(null, obj[key], key, obj);
    }
  }
}

function findKey(obj, key) {
  key = key.toLowerCase();
  const keys = Object.keys(obj);
  let i = keys.length;
  let _key;
  while (i-- > 0) {
    _key = keys[i];
    if (key === _key.toLowerCase()) {
      return _key;
    }
  }
  return null;
}

const _global = (() => {
  /*eslint no-undef:0*/
  if (typeof globalThis !== "undefined") return globalThis;
  return typeof self !== "undefined" ? self : (typeof window !== 'undefined' ? window : global)
})();

const isContextDefined = (context) => !isUndefined(context) && context !== _global;

/**
 * Accepts varargs expecting each argument to be an object, then
 * immutably merges the properties of each object and returns result.
 *
 * When multiple objects contain the same key the later object in
 * the arguments list will take precedence.
 *
 * Example:
 *
 * ```js
 * var result = merge({foo: 123}, {foo: 456});
 * console.log(result.foo); // outputs 456
 * ```
 *
 * @param {Object} obj1 Object to merge
 *
 * @returns {Object} Result of all merge properties
 */
function merge(/* obj1, obj2, obj3, ... */) {
  const {caseless} = isContextDefined(this) && this || {};
  const result = {};
  const assignValue = (val, key) => {
    const targetKey = caseless && findKey(result, key) || key;
    if (isPlainObject(result[targetKey]) && isPlainObject(val)) {
      result[targetKey] = merge(result[targetKey], val);
    } else if (isPlainObject(val)) {
      result[targetKey] = merge({}, val);
    } else if (isArray(val)) {
      result[targetKey] = val.slice();
    } else {
      result[targetKey] = val;
    }
  };

  for (let i = 0, l = arguments.length; i < l; i++) {
    arguments[i] && forEach(arguments[i], assignValue);
  }
  return result;
}

/**
 * Extends object a by mutably adding to it the properties of object b.
 *
 * @param {Object} a The object to be extended
 * @param {Object} b The object to copy properties from
 * @param {Object} thisArg The object to bind function to
 *
 * @param {Boolean} [allOwnKeys]
 * @returns {Object} The resulting value of object a
 */
const extend = (a, b, thisArg, {allOwnKeys}= {}) => {
  forEach(b, (val, key) => {
    if (thisArg && isFunction(val)) {
      a[key] = bind(val, thisArg);
    } else {
      a[key] = val;
    }
  }, {allOwnKeys});
  return a;
};

/**
 * Remove byte order marker. This catches EF BB BF (the UTF-8 BOM)
 *
 * @param {string} content with BOM
 *
 * @returns {string} content value without BOM
 */
const stripBOM = (content) => {
  if (content.charCodeAt(0) === 0xFEFF) {
    content = content.slice(1);
  }
  return content;
};

/**
 * Inherit the prototype methods from one constructor into another
 * @param {function} constructor
 * @param {function} superConstructor
 * @param {object} [props]
 * @param {object} [descriptors]
 *
 * @returns {void}
 */
const inherits = (constructor, superConstructor, props, descriptors) => {
  constructor.prototype = Object.create(superConstructor.prototype, descriptors);
  constructor.prototype.constructor = constructor;
  Object.defineProperty(constructor, 'super', {
    value: superConstructor.prototype
  });
  props && Object.assign(constructor.prototype, props);
};

/**
 * Resolve object with deep prototype chain to a flat object
 * @param {Object} sourceObj source object
 * @param {Object} [destObj]
 * @param {Function|Boolean} [filter]
 * @param {Function} [propFilter]
 *
 * @returns {Object}
 */
const toFlatObject = (sourceObj, destObj, filter, propFilter) => {
  let props;
  let i;
  let prop;
  const merged = {};

  destObj = destObj || {};
  // eslint-disable-next-line no-eq-null,eqeqeq
  if (sourceObj == null) return destObj;

  do {
    props = Object.getOwnPropertyNames(sourceObj);
    i = props.length;
    while (i-- > 0) {
      prop = props[i];
      if ((!propFilter || propFilter(prop, sourceObj, destObj)) && !merged[prop]) {
        destObj[prop] = sourceObj[prop];
        merged[prop] = true;
      }
    }
    sourceObj = filter !== false && getPrototypeOf(sourceObj);
  } while (sourceObj && (!filter || filter(sourceObj, destObj)) && sourceObj !== Object.prototype);

  return destObj;
};

/**
 * Determines whether a string ends with the characters of a specified string
 *
 * @param {String} str
 * @param {String} searchString
 * @param {Number} [position= 0]
 *
 * @returns {boolean}
 */
const endsWith = (str, searchString, position) => {
  str = String(str);
  if (position === undefined || position > str.length) {
    position = str.length;
  }
  position -= searchString.length;
  const lastIndex = str.indexOf(searchString, position);
  return lastIndex !== -1 && lastIndex === position;
};


/**
 * Returns new array from array like object or null if failed
 *
 * @param {*} [thing]
 *
 * @returns {?Array}
 */
const toArray = (thing) => {
  if (!thing) return null;
  if (isArray(thing)) return thing;
  let i = thing.length;
  if (!isNumber(i)) return null;
  const arr = new Array(i);
  while (i-- > 0) {
    arr[i] = thing[i];
  }
  return arr;
};

/**
 * Checking if the Uint8Array exists and if it does, it returns a function that checks if the
 * thing passed in is an instance of Uint8Array
 *
 * @param {TypedArray}
 *
 * @returns {Array}
 */
// eslint-disable-next-line func-names
const isTypedArray = (TypedArray => {
  // eslint-disable-next-line func-names
  return thing => {
    return TypedArray && thing instanceof TypedArray;
  };
})(typeof Uint8Array !== 'undefined' && getPrototypeOf(Uint8Array));

/**
 * For each entry in the object, call the function with the key and value.
 *
 * @param {Object<any, any>} obj - The object to iterate over.
 * @param {Function} fn - The function to call for each entry.
 *
 * @returns {void}
 */
const forEachEntry = (obj, fn) => {
  const generator = obj && obj[Symbol.iterator];

  const iterator = generator.call(obj);

  let result;

  while ((result = iterator.next()) && !result.done) {
    const pair = result.value;
    fn.call(obj, pair[0], pair[1]);
  }
};

/**
 * It takes a regular expression and a string, and returns an array of all the matches
 *
 * @param {string} regExp - The regular expression to match against.
 * @param {string} str - The string to search.
 *
 * @returns {Array<boolean>}
 */
const matchAll = (regExp, str) => {
  let matches;
  const arr = [];

  while ((matches = regExp.exec(str)) !== null) {
    arr.push(matches);
  }

  return arr;
};

/* Checking if the kindOfTest function returns true when passed an HTMLFormElement. */
const isHTMLForm = kindOfTest('HTMLFormElement');

const toCamelCase = str => {
  return str.toLowerCase().replace(/[-_\s]([a-z\d])(\w*)/g,
    function replacer(m, p1, p2) {
      return p1.toUpperCase() + p2;
    }
  );
};

/* Creating a function that will check if an object has a property. */
const hasOwnProperty = (({hasOwnProperty}) => (obj, prop) => hasOwnProperty.call(obj, prop))(Object.prototype);

/**
 * Determine if a value is a RegExp object
 *
 * @param {*} val The value to test
 *
 * @returns {boolean} True if value is a RegExp object, otherwise false
 */
const isRegExp = kindOfTest('RegExp');

const reduceDescriptors = (obj, reducer) => {
  const descriptors = Object.getOwnPropertyDescriptors(obj);
  const reducedDescriptors = {};

  forEach(descriptors, (descriptor, name) => {
    if (reducer(descriptor, name, obj) !== false) {
      reducedDescriptors[name] = descriptor;
    }
  });

  Object.defineProperties(obj, reducedDescriptors);
};

/**
 * Makes all methods read-only
 * @param {Object} obj
 */

const freezeMethods = (obj) => {
  reduceDescriptors(obj, (descriptor, name) => {
    // skip restricted props in strict mode
    if (isFunction(obj) && ['arguments', 'caller', 'callee'].indexOf(name) !== -1) {
      return false;
    }

    const value = obj[name];

    if (!isFunction(value)) return;

    descriptor.enumerable = false;

    if ('writable' in descriptor) {
      descriptor.writable = false;
      return;
    }

    if (!descriptor.set) {
      descriptor.set = () => {
        throw Error('Can not rewrite read-only method \'' + name + '\'');
      };
    }
  });
};

const toObjectSet = (arrayOrString, delimiter) => {
  const obj = {};

  const define = (arr) => {
    arr.forEach(value => {
      obj[value] = true;
    });
  };

  isArray(arrayOrString) ? define(arrayOrString) : define(String(arrayOrString).split(delimiter));

  return obj;
};

const noop = () => {};

const toFiniteNumber = (value, defaultValue) => {
  value = +value;
  return Number.isFinite(value) ? value : defaultValue;
};

const ALPHA = 'abcdefghijklmnopqrstuvwxyz';

const DIGIT = '0123456789';

const ALPHABET = {
  DIGIT,
  ALPHA,
  ALPHA_DIGIT: ALPHA + ALPHA.toUpperCase() + DIGIT
};

const generateString = (size = 16, alphabet = ALPHABET.ALPHA_DIGIT) => {
  let str = '';
  const {length} = alphabet;
  while (size--) {
    str += alphabet[Math.random() * length|0];
  }

  return str;
};

/**
 * If the thing is a FormData object, return true, otherwise return false.
 *
 * @param {unknown} thing - The thing to check.
 *
 * @returns {boolean}
 */
function isSpecCompliantForm(thing) {
  return !!(thing && isFunction(thing.append) && thing[Symbol.toStringTag] === 'FormData' && thing[Symbol.iterator]);
}

const toJSONObject = (obj) => {
  const stack = new Array(10);

  const visit = (source, i) => {

    if (isObject(source)) {
      if (stack.indexOf(source) >= 0) {
        return;
      }

      if(!('toJSON' in source)) {
        stack[i] = source;
        const target = isArray(source) ? [] : {};

        forEach(source, (value, key) => {
          const reducedValue = visit(value, i + 1);
          !isUndefined(reducedValue) && (target[key] = reducedValue);
        });

        stack[i] = undefined;

        return target;
      }
    }

    return source;
  };

  return visit(obj, 0);
};

const isAsyncFn = kindOfTest('AsyncFunction');

const isThenable = (thing) =>
  thing && (isObject(thing) || isFunction(thing)) && isFunction(thing.then) && isFunction(thing.catch);

var utils = {
  isArray,
  isArrayBuffer,
  isBuffer,
  isFormData,
  isArrayBufferView,
  isString,
  isNumber,
  isBoolean,
  isObject,
  isPlainObject,
  isUndefined,
  isDate,
  isFile,
  isBlob,
  isRegExp,
  isFunction,
  isStream,
  isURLSearchParams,
  isTypedArray,
  isFileList,
  forEach,
  merge,
  extend,
  trim,
  stripBOM,
  inherits,
  toFlatObject,
  kindOf,
  kindOfTest,
  endsWith,
  toArray,
  forEachEntry,
  matchAll,
  isHTMLForm,
  hasOwnProperty,
  hasOwnProp: hasOwnProperty, // an alias to avoid ESLint no-prototype-builtins detection
  reduceDescriptors,
  freezeMethods,
  toObjectSet,
  toCamelCase,
  noop,
  toFiniteNumber,
  findKey,
  global: _global,
  isContextDefined,
  ALPHABET,
  generateString,
  isSpecCompliantForm,
  toJSONObject,
  isAsyncFn,
  isThenable
};

/**
 * Create an Error with the specified message, config, error code, request and response.
 *
 * @param {string} message The error message.
 * @param {string} [code] The error code (for example, 'ECONNABORTED').
 * @param {Object} [config] The config.
 * @param {Object} [request] The request.
 * @param {Object} [response] The response.
 *
 * @returns {Error} The created error.
 */
function AxiosError(message, code, config, request, response) {
  Error.call(this);

  if (Error.captureStackTrace) {
    Error.captureStackTrace(this, this.constructor);
  } else {
    this.stack = (new Error()).stack;
  }

  this.message = message;
  this.name = 'AxiosError';
  code && (this.code = code);
  config && (this.config = config);
  request && (this.request = request);
  response && (this.response = response);
}

utils.inherits(AxiosError, Error, {
  toJSON: function toJSON() {
    return {
      // Standard
      message: this.message,
      name: this.name,
      // Microsoft
      description: this.description,
      number: this.number,
      // Mozilla
      fileName: this.fileName,
      lineNumber: this.lineNumber,
      columnNumber: this.columnNumber,
      stack: this.stack,
      // Axios
      config: utils.toJSONObject(this.config),
      code: this.code,
      status: this.response && this.response.status ? this.response.status : null
    };
  }
});

const prototype$1 = AxiosError.prototype;
const descriptors = {};

[
  'ERR_BAD_OPTION_VALUE',
  'ERR_BAD_OPTION',
  'ECONNABORTED',
  'ETIMEDOUT',
  'ERR_NETWORK',
  'ERR_FR_TOO_MANY_REDIRECTS',
  'ERR_DEPRECATED',
  'ERR_BAD_RESPONSE',
  'ERR_BAD_REQUEST',
  'ERR_CANCELED',
  'ERR_NOT_SUPPORT',
  'ERR_INVALID_URL'
// eslint-disable-next-line func-names
].forEach(code => {
  descriptors[code] = {value: code};
});

Object.defineProperties(AxiosError, descriptors);
Object.defineProperty(prototype$1, 'isAxiosError', {value: true});

// eslint-disable-next-line func-names
AxiosError.from = (error, code, config, request, response, customProps) => {
  const axiosError = Object.create(prototype$1);

  utils.toFlatObject(error, axiosError, function filter(obj) {
    return obj !== Error.prototype;
  }, prop => {
    return prop !== 'isAxiosError';
  });

  AxiosError.call(axiosError, error.message, code, config, request, response);

  axiosError.cause = error;

  axiosError.name = error.name;

  customProps && Object.assign(axiosError, customProps);

  return axiosError;
};

// eslint-disable-next-line strict
var httpAdapter = null;

/**
 * Determines if the given thing is a array or js object.
 *
 * @param {string} thing - The object or array to be visited.
 *
 * @returns {boolean}
 */
function isVisitable(thing) {
  return utils.isPlainObject(thing) || utils.isArray(thing);
}

/**
 * It removes the brackets from the end of a string
 *
 * @param {string} key - The key of the parameter.
 *
 * @returns {string} the key without the brackets.
 */
function removeBrackets(key) {
  return utils.endsWith(key, '[]') ? key.slice(0, -2) : key;
}

/**
 * It takes a path, a key, and a boolean, and returns a string
 *
 * @param {string} path - The path to the current key.
 * @param {string} key - The key of the current object being iterated over.
 * @param {string} dots - If true, the key will be rendered with dots instead of brackets.
 *
 * @returns {string} The path to the current key.
 */
function renderKey(path, key, dots) {
  if (!path) return key;
  return path.concat(key).map(function each(token, i) {
    // eslint-disable-next-line no-param-reassign
    token = removeBrackets(token);
    return !dots && i ? '[' + token + ']' : token;
  }).join(dots ? '.' : '');
}

/**
 * If the array is an array and none of its elements are visitable, then it's a flat array.
 *
 * @param {Array<any>} arr - The array to check
 *
 * @returns {boolean}
 */
function isFlatArray(arr) {
  return utils.isArray(arr) && !arr.some(isVisitable);
}

const predicates = utils.toFlatObject(utils, {}, null, function filter(prop) {
  return /^is[A-Z]/.test(prop);
});

/**
 * Convert a data object to FormData
 *
 * @param {Object} obj
 * @param {?Object} [formData]
 * @param {?Object} [options]
 * @param {Function} [options.visitor]
 * @param {Boolean} [options.metaTokens = true]
 * @param {Boolean} [options.dots = false]
 * @param {?Boolean} [options.indexes = false]
 *
 * @returns {Object}
 **/

/**
 * It converts an object into a FormData object
 *
 * @param {Object<any, any>} obj - The object to convert to form data.
 * @param {string} formData - The FormData object to append to.
 * @param {Object<string, any>} options
 *
 * @returns
 */
function toFormData(obj, formData, options) {
  if (!utils.isObject(obj)) {
    throw new TypeError('target must be an object');
  }

  // eslint-disable-next-line no-param-reassign
  formData = formData || new (FormData)();

  // eslint-disable-next-line no-param-reassign
  options = utils.toFlatObject(options, {
    metaTokens: true,
    dots: false,
    indexes: false
  }, false, function defined(option, source) {
    // eslint-disable-next-line no-eq-null,eqeqeq
    return !utils.isUndefined(source[option]);
  });

  const metaTokens = options.metaTokens;
  // eslint-disable-next-line no-use-before-define
  const visitor = options.visitor || defaultVisitor;
  const dots = options.dots;
  const indexes = options.indexes;
  const _Blob = options.Blob || typeof Blob !== 'undefined' && Blob;
  const useBlob = _Blob && utils.isSpecCompliantForm(formData);

  if (!utils.isFunction(visitor)) {
    throw new TypeError('visitor must be a function');
  }

  function convertValue(value) {
    if (value === null) return '';

    if (utils.isDate(value)) {
      return value.toISOString();
    }

    if (!useBlob && utils.isBlob(value)) {
      throw new AxiosError('Blob is not supported. Use a Buffer instead.');
    }

    if (utils.isArrayBuffer(value) || utils.isTypedArray(value)) {
      return useBlob && typeof Blob === 'function' ? new Blob([value]) : Buffer.from(value);
    }

    return value;
  }

  /**
   * Default visitor.
   *
   * @param {*} value
   * @param {String|Number} key
   * @param {Array<String|Number>} path
   * @this {FormData}
   *
   * @returns {boolean} return true to visit the each prop of the value recursively
   */
  function defaultVisitor(value, key, path) {
    let arr = value;

    if (value && !path && typeof value === 'object') {
      if (utils.endsWith(key, '{}')) {
        // eslint-disable-next-line no-param-reassign
        key = metaTokens ? key : key.slice(0, -2);
        // eslint-disable-next-line no-param-reassign
        value = JSON.stringify(value);
      } else if (
        (utils.isArray(value) && isFlatArray(value)) ||
        ((utils.isFileList(value) || utils.endsWith(key, '[]')) && (arr = utils.toArray(value))
        )) {
        // eslint-disable-next-line no-param-reassign
        key = removeBrackets(key);

        arr.forEach(function each(el, index) {
          !(utils.isUndefined(el) || el === null) && formData.append(
            // eslint-disable-next-line no-nested-ternary
            indexes === true ? renderKey([key], index, dots) : (indexes === null ? key : key + '[]'),
            convertValue(el)
          );
        });
        return false;
      }
    }

    if (isVisitable(value)) {
      return true;
    }

    formData.append(renderKey(path, key, dots), convertValue(value));

    return false;
  }

  const stack = [];

  const exposedHelpers = Object.assign(predicates, {
    defaultVisitor,
    convertValue,
    isVisitable
  });

  function build(value, path) {
    if (utils.isUndefined(value)) return;

    if (stack.indexOf(value) !== -1) {
      throw Error('Circular reference detected in ' + path.join('.'));
    }

    stack.push(value);

    utils.forEach(value, function each(el, key) {
      const result = !(utils.isUndefined(el) || el === null) && visitor.call(
        formData, el, utils.isString(key) ? key.trim() : key, path, exposedHelpers
      );

      if (result === true) {
        build(el, path ? path.concat(key) : [key]);
      }
    });

    stack.pop();
  }

  if (!utils.isObject(obj)) {
    throw new TypeError('data must be an object');
  }

  build(obj);

  return formData;
}

/**
 * It encodes a string by replacing all characters that are not in the unreserved set with
 * their percent-encoded equivalents
 *
 * @param {string} str - The string to encode.
 *
 * @returns {string} The encoded string.
 */
function encode$1(str) {
  const charMap = {
    '!': '%21',
    "'": '%27',
    '(': '%28',
    ')': '%29',
    '~': '%7E',
    '%20': '+',
    '%00': '\x00'
  };
  return encodeURIComponent(str).replace(/[!'()~]|%20|%00/g, function replacer(match) {
    return charMap[match];
  });
}

/**
 * It takes a params object and converts it to a FormData object
 *
 * @param {Object<string, any>} params - The parameters to be converted to a FormData object.
 * @param {Object<string, any>} options - The options object passed to the Axios constructor.
 *
 * @returns {void}
 */
function AxiosURLSearchParams(params, options) {
  this._pairs = [];

  params && toFormData(params, this, options);
}

const prototype = AxiosURLSearchParams.prototype;

prototype.append = function append(name, value) {
  this._pairs.push([name, value]);
};

prototype.toString = function toString(encoder) {
  const _encode = encoder ? function(value) {
    return encoder.call(this, value, encode$1);
  } : encode$1;

  return this._pairs.map(function each(pair) {
    return _encode(pair[0]) + '=' + _encode(pair[1]);
  }, '').join('&');
};

/**
 * It replaces all instances of the characters `:`, `$`, `,`, `+`, `[`, and `]` with their
 * URI encoded counterparts
 *
 * @param {string} val The value to be encoded.
 *
 * @returns {string} The encoded value.
 */
function encode(val) {
  return encodeURIComponent(val).
    replace(/%3A/gi, ':').
    replace(/%24/g, '$').
    replace(/%2C/gi, ',').
    replace(/%20/g, '+').
    replace(/%5B/gi, '[').
    replace(/%5D/gi, ']');
}

/**
 * Build a URL by appending params to the end
 *
 * @param {string} url The base of the url (e.g., http://www.google.com)
 * @param {object} [params] The params to be appended
 * @param {?object} options
 *
 * @returns {string} The formatted url
 */
function buildURL(url, params, options) {
  /*eslint no-param-reassign:0*/
  if (!params) {
    return url;
  }
  
  const _encode = options && options.encode || encode;

  const serializeFn = options && options.serialize;

  let serializedParams;

  if (serializeFn) {
    serializedParams = serializeFn(params, options);
  } else {
    serializedParams = utils.isURLSearchParams(params) ?
      params.toString() :
      new AxiosURLSearchParams(params, options).toString(_encode);
  }

  if (serializedParams) {
    const hashmarkIndex = url.indexOf("#");

    if (hashmarkIndex !== -1) {
      url = url.slice(0, hashmarkIndex);
    }
    url += (url.indexOf('?') === -1 ? '?' : '&') + serializedParams;
  }

  return url;
}

class InterceptorManager {
  constructor() {
    this.handlers = [];
  }

  /**
   * Add a new interceptor to the stack
   *
   * @param {Function} fulfilled The function to handle `then` for a `Promise`
   * @param {Function} rejected The function to handle `reject` for a `Promise`
   *
   * @return {Number} An ID used to remove interceptor later
   */
  use(fulfilled, rejected, options) {
    this.handlers.push({
      fulfilled,
      rejected,
      synchronous: options ? options.synchronous : false,
      runWhen: options ? options.runWhen : null
    });
    return this.handlers.length - 1;
  }

  /**
   * Remove an interceptor from the stack
   *
   * @param {Number} id The ID that was returned by `use`
   *
   * @returns {Boolean} `true` if the interceptor was removed, `false` otherwise
   */
  eject(id) {
    if (this.handlers[id]) {
      this.handlers[id] = null;
    }
  }

  /**
   * Clear all interceptors from the stack
   *
   * @returns {void}
   */
  clear() {
    if (this.handlers) {
      this.handlers = [];
    }
  }

  /**
   * Iterate over all the registered interceptors
   *
   * This method is particularly useful for skipping over any
   * interceptors that may have become `null` calling `eject`.
   *
   * @param {Function} fn The function to call for each interceptor
   *
   * @returns {void}
   */
  forEach(fn) {
    utils.forEach(this.handlers, function forEachHandler(h) {
      if (h !== null) {
        fn(h);
      }
    });
  }
}

var InterceptorManager$1 = InterceptorManager;

var transitionalDefaults = {
  silentJSONParsing: true,
  forcedJSONParsing: true,
  clarifyTimeoutError: false
};

var URLSearchParams$1 = typeof URLSearchParams !== 'undefined' ? URLSearchParams : AxiosURLSearchParams;

var FormData$1 = typeof FormData !== 'undefined' ? FormData : null;

var Blob$1 = typeof Blob !== 'undefined' ? Blob : null;

/**
 * Determine if we're running in a standard browser environment
 *
 * This allows axios to run in a web worker, and react-native.
 * Both environments support XMLHttpRequest, but not fully standard globals.
 *
 * web workers:
 *  typeof window -> undefined
 *  typeof document -> undefined
 *
 * react-native:
 *  navigator.product -> 'ReactNative'
 * nativescript
 *  navigator.product -> 'NativeScript' or 'NS'
 *
 * @returns {boolean}
 */
const isStandardBrowserEnv = (() => {
  let product;
  if (typeof navigator !== 'undefined' && (
    (product = navigator.product) === 'ReactNative' ||
    product === 'NativeScript' ||
    product === 'NS')
  ) {
    return false;
  }

  return typeof window !== 'undefined' && typeof document !== 'undefined';
})();

/**
 * Determine if we're running in a standard browser webWorker environment
 *
 * Although the `isStandardBrowserEnv` method indicates that
 * `allows axios to run in a web worker`, the WebWorker will still be
 * filtered out due to its judgment standard
 * `typeof window !== 'undefined' && typeof document !== 'undefined'`.
 * This leads to a problem when axios post `FormData` in webWorker
 */
 const isStandardBrowserWebWorkerEnv = (() => {
  return (
    typeof WorkerGlobalScope !== 'undefined' &&
    // eslint-disable-next-line no-undef
    self instanceof WorkerGlobalScope &&
    typeof self.importScripts === 'function'
  );
})();


var platform = {
  isBrowser: true,
  classes: {
    URLSearchParams: URLSearchParams$1,
    FormData: FormData$1,
    Blob: Blob$1
  },
  isStandardBrowserEnv,
  isStandardBrowserWebWorkerEnv,
  protocols: ['http', 'https', 'file', 'blob', 'url', 'data']
};

function toURLEncodedForm(data, options) {
  return toFormData(data, new platform.classes.URLSearchParams(), Object.assign({
    visitor: function(value, key, path, helpers) {
      if (platform.isNode && utils.isBuffer(value)) {
        this.append(key, value.toString('base64'));
        return false;
      }

      return helpers.defaultVisitor.apply(this, arguments);
    }
  }, options));
}

/**
 * It takes a string like `foo[x][y][z]` and returns an array like `['foo', 'x', 'y', 'z']
 *
 * @param {string} name - The name of the property to get.
 *
 * @returns An array of strings.
 */
function parsePropPath(name) {
  // foo[x][y][z]
  // foo.x.y.z
  // foo-x-y-z
  // foo x y z
  return utils.matchAll(/\w+|\[(\w*)]/g, name).map(match => {
    return match[0] === '[]' ? '' : match[1] || match[0];
  });
}

/**
 * Convert an array to an object.
 *
 * @param {Array<any>} arr - The array to convert to an object.
 *
 * @returns An object with the same keys and values as the array.
 */
function arrayToObject(arr) {
  const obj = {};
  const keys = Object.keys(arr);
  let i;
  const len = keys.length;
  let key;
  for (i = 0; i < len; i++) {
    key = keys[i];
    obj[key] = arr[key];
  }
  return obj;
}

/**
 * It takes a FormData object and returns a JavaScript object
 *
 * @param {string} formData The FormData object to convert to JSON.
 *
 * @returns {Object<string, any> | null} The converted object.
 */
function formDataToJSON(formData) {
  function buildPath(path, value, target, index) {
    let name = path[index++];
    const isNumericKey = Number.isFinite(+name);
    const isLast = index >= path.length;
    name = !name && utils.isArray(target) ? target.length : name;

    if (isLast) {
      if (utils.hasOwnProp(target, name)) {
        target[name] = [target[name], value];
      } else {
        target[name] = value;
      }

      return !isNumericKey;
    }

    if (!target[name] || !utils.isObject(target[name])) {
      target[name] = [];
    }

    const result = buildPath(path, value, target[name], index);

    if (result && utils.isArray(target[name])) {
      target[name] = arrayToObject(target[name]);
    }

    return !isNumericKey;
  }

  if (utils.isFormData(formData) && utils.isFunction(formData.entries)) {
    const obj = {};

    utils.forEachEntry(formData, (name, value) => {
      buildPath(parsePropPath(name), value, obj, 0);
    });

    return obj;
  }

  return null;
}

const DEFAULT_CONTENT_TYPE = {
  'Content-Type': undefined
};

/**
 * It takes a string, tries to parse it, and if it fails, it returns the stringified version
 * of the input
 *
 * @param {any} rawValue - The value to be stringified.
 * @param {Function} parser - A function that parses a string into a JavaScript object.
 * @param {Function} encoder - A function that takes a value and returns a string.
 *
 * @returns {string} A stringified version of the rawValue.
 */
function stringifySafely(rawValue, parser, encoder) {
  if (utils.isString(rawValue)) {
    try {
      (parser || JSON.parse)(rawValue);
      return utils.trim(rawValue);
    } catch (e) {
      if (e.name !== 'SyntaxError') {
        throw e;
      }
    }
  }

  return (encoder || JSON.stringify)(rawValue);
}

const defaults = {

  transitional: transitionalDefaults,

  adapter: ['xhr', 'http'],

  transformRequest: [function transformRequest(data, headers) {
    const contentType = headers.getContentType() || '';
    const hasJSONContentType = contentType.indexOf('application/json') > -1;
    const isObjectPayload = utils.isObject(data);

    if (isObjectPayload && utils.isHTMLForm(data)) {
      data = new FormData(data);
    }

    const isFormData = utils.isFormData(data);

    if (isFormData) {
      if (!hasJSONContentType) {
        return data;
      }
      return hasJSONContentType ? JSON.stringify(formDataToJSON(data)) : data;
    }

    if (utils.isArrayBuffer(data) ||
      utils.isBuffer(data) ||
      utils.isStream(data) ||
      utils.isFile(data) ||
      utils.isBlob(data)
    ) {
      return data;
    }
    if (utils.isArrayBufferView(data)) {
      return data.buffer;
    }
    if (utils.isURLSearchParams(data)) {
      headers.setContentType('application/x-www-form-urlencoded;charset=utf-8', false);
      return data.toString();
    }

    let isFileList;

    if (isObjectPayload) {
      if (contentType.indexOf('application/x-www-form-urlencoded') > -1) {
        return toURLEncodedForm(data, this.formSerializer).toString();
      }

      if ((isFileList = utils.isFileList(data)) || contentType.indexOf('multipart/form-data') > -1) {
        const _FormData = this.env && this.env.FormData;

        return toFormData(
          isFileList ? {'files[]': data} : data,
          _FormData && new _FormData(),
          this.formSerializer
        );
      }
    }

    if (isObjectPayload || hasJSONContentType ) {
      headers.setContentType('application/json', false);
      return stringifySafely(data);
    }

    return data;
  }],

  transformResponse: [function transformResponse(data) {
    const transitional = this.transitional || defaults.transitional;
    const forcedJSONParsing = transitional && transitional.forcedJSONParsing;
    const JSONRequested = this.responseType === 'json';

    if (data && utils.isString(data) && ((forcedJSONParsing && !this.responseType) || JSONRequested)) {
      const silentJSONParsing = transitional && transitional.silentJSONParsing;
      const strictJSONParsing = !silentJSONParsing && JSONRequested;

      try {
        return JSON.parse(data);
      } catch (e) {
        if (strictJSONParsing) {
          if (e.name === 'SyntaxError') {
            throw AxiosError.from(e, AxiosError.ERR_BAD_RESPONSE, this, null, this.response);
          }
          throw e;
        }
      }
    }

    return data;
  }],

  /**
   * A timeout in milliseconds to abort a request. If set to 0 (default) a
   * timeout is not created.
   */
  timeout: 0,

  xsrfCookieName: 'XSRF-TOKEN',
  xsrfHeaderName: 'X-XSRF-TOKEN',

  maxContentLength: -1,
  maxBodyLength: -1,

  env: {
    FormData: platform.classes.FormData,
    Blob: platform.classes.Blob
  },

  validateStatus: function validateStatus(status) {
    return status >= 200 && status < 300;
  },

  headers: {
    common: {
      'Accept': 'application/json, text/plain, */*'
    }
  }
};

utils.forEach(['delete', 'get', 'head'], function forEachMethodNoData(method) {
  defaults.headers[method] = {};
});

utils.forEach(['post', 'put', 'patch'], function forEachMethodWithData(method) {
  defaults.headers[method] = utils.merge(DEFAULT_CONTENT_TYPE);
});

var defaults$1 = defaults;

// RawAxiosHeaders whose duplicates are ignored by node
// c.f. https://nodejs.org/api/http.html#http_message_headers
const ignoreDuplicateOf = utils.toObjectSet([
  'age', 'authorization', 'content-length', 'content-type', 'etag',
  'expires', 'from', 'host', 'if-modified-since', 'if-unmodified-since',
  'last-modified', 'location', 'max-forwards', 'proxy-authorization',
  'referer', 'retry-after', 'user-agent'
]);

/**
 * Parse headers into an object
 *
 * ```
 * Date: Wed, 27 Aug 2014 08:58:49 GMT
 * Content-Type: application/json
 * Connection: keep-alive
 * Transfer-Encoding: chunked
 * ```
 *
 * @param {String} rawHeaders Headers needing to be parsed
 *
 * @returns {Object} Headers parsed into an object
 */
var parseHeaders = rawHeaders => {
  const parsed = {};
  let key;
  let val;
  let i;

  rawHeaders && rawHeaders.split('\n').forEach(function parser(line) {
    i = line.indexOf(':');
    key = line.substring(0, i).trim().toLowerCase();
    val = line.substring(i + 1).trim();

    if (!key || (parsed[key] && ignoreDuplicateOf[key])) {
      return;
    }

    if (key === 'set-cookie') {
      if (parsed[key]) {
        parsed[key].push(val);
      } else {
        parsed[key] = [val];
      }
    } else {
      parsed[key] = parsed[key] ? parsed[key] + ', ' + val : val;
    }
  });

  return parsed;
};

const $internals = Symbol('internals');

function normalizeHeader(header) {
  return header && String(header).trim().toLowerCase();
}

function normalizeValue(value) {
  if (value === false || value == null) {
    return value;
  }

  return utils.isArray(value) ? value.map(normalizeValue) : String(value);
}

function parseTokens(str) {
  const tokens = Object.create(null);
  const tokensRE = /([^\s,;=]+)\s*(?:=\s*([^,;]+))?/g;
  let match;

  while ((match = tokensRE.exec(str))) {
    tokens[match[1]] = match[2];
  }

  return tokens;
}

const isValidHeaderName = (str) => /^[-_a-zA-Z0-9^`|~,!#$%&'*+.]+$/.test(str.trim());

function matchHeaderValue(context, value, header, filter, isHeaderNameFilter) {
  if (utils.isFunction(filter)) {
    return filter.call(this, value, header);
  }

  if (isHeaderNameFilter) {
    value = header;
  }

  if (!utils.isString(value)) return;

  if (utils.isString(filter)) {
    return value.indexOf(filter) !== -1;
  }

  if (utils.isRegExp(filter)) {
    return filter.test(value);
  }
}

function formatHeader(header) {
  return header.trim()
    .toLowerCase().replace(/([a-z\d])(\w*)/g, (w, char, str) => {
      return char.toUpperCase() + str;
    });
}

function buildAccessors(obj, header) {
  const accessorName = utils.toCamelCase(' ' + header);

  ['get', 'set', 'has'].forEach(methodName => {
    Object.defineProperty(obj, methodName + accessorName, {
      value: function(arg1, arg2, arg3) {
        return this[methodName].call(this, header, arg1, arg2, arg3);
      },
      configurable: true
    });
  });
}

class AxiosHeaders {
  constructor(headers) {
    headers && this.set(headers);
  }

  set(header, valueOrRewrite, rewrite) {
    const self = this;

    function setHeader(_value, _header, _rewrite) {
      const lHeader = normalizeHeader(_header);

      if (!lHeader) {
        throw new Error('header name must be a non-empty string');
      }

      const key = utils.findKey(self, lHeader);

      if(!key || self[key] === undefined || _rewrite === true || (_rewrite === undefined && self[key] !== false)) {
        self[key || _header] = normalizeValue(_value);
      }
    }

    const setHeaders = (headers, _rewrite) =>
      utils.forEach(headers, (_value, _header) => setHeader(_value, _header, _rewrite));

    if (utils.isPlainObject(header) || header instanceof this.constructor) {
      setHeaders(header, valueOrRewrite);
    } else if(utils.isString(header) && (header = header.trim()) && !isValidHeaderName(header)) {
      setHeaders(parseHeaders(header), valueOrRewrite);
    } else {
      header != null && setHeader(valueOrRewrite, header, rewrite);
    }

    return this;
  }

  get(header, parser) {
    header = normalizeHeader(header);

    if (header) {
      const key = utils.findKey(this, header);

      if (key) {
        const value = this[key];

        if (!parser) {
          return value;
        }

        if (parser === true) {
          return parseTokens(value);
        }

        if (utils.isFunction(parser)) {
          return parser.call(this, value, key);
        }

        if (utils.isRegExp(parser)) {
          return parser.exec(value);
        }

        throw new TypeError('parser must be boolean|regexp|function');
      }
    }
  }

  has(header, matcher) {
    header = normalizeHeader(header);

    if (header) {
      const key = utils.findKey(this, header);

      return !!(key && this[key] !== undefined && (!matcher || matchHeaderValue(this, this[key], key, matcher)));
    }

    return false;
  }

  delete(header, matcher) {
    const self = this;
    let deleted = false;

    function deleteHeader(_header) {
      _header = normalizeHeader(_header);

      if (_header) {
        const key = utils.findKey(self, _header);

        if (key && (!matcher || matchHeaderValue(self, self[key], key, matcher))) {
          delete self[key];

          deleted = true;
        }
      }
    }

    if (utils.isArray(header)) {
      header.forEach(deleteHeader);
    } else {
      deleteHeader(header);
    }

    return deleted;
  }

  clear(matcher) {
    const keys = Object.keys(this);
    let i = keys.length;
    let deleted = false;

    while (i--) {
      const key = keys[i];
      if(!matcher || matchHeaderValue(this, this[key], key, matcher, true)) {
        delete this[key];
        deleted = true;
      }
    }

    return deleted;
  }

  normalize(format) {
    const self = this;
    const headers = {};

    utils.forEach(this, (value, header) => {
      const key = utils.findKey(headers, header);

      if (key) {
        self[key] = normalizeValue(value);
        delete self[header];
        return;
      }

      const normalized = format ? formatHeader(header) : String(header).trim();

      if (normalized !== header) {
        delete self[header];
      }

      self[normalized] = normalizeValue(value);

      headers[normalized] = true;
    });

    return this;
  }

  concat(...targets) {
    return this.constructor.concat(this, ...targets);
  }

  toJSON(asStrings) {
    const obj = Object.create(null);

    utils.forEach(this, (value, header) => {
      value != null && value !== false && (obj[header] = asStrings && utils.isArray(value) ? value.join(', ') : value);
    });

    return obj;
  }

  [Symbol.iterator]() {
    return Object.entries(this.toJSON())[Symbol.iterator]();
  }

  toString() {
    return Object.entries(this.toJSON()).map(([header, value]) => header + ': ' + value).join('\n');
  }

  get [Symbol.toStringTag]() {
    return 'AxiosHeaders';
  }

  static from(thing) {
    return thing instanceof this ? thing : new this(thing);
  }

  static concat(first, ...targets) {
    const computed = new this(first);

    targets.forEach((target) => computed.set(target));

    return computed;
  }

  static accessor(header) {
    const internals = this[$internals] = (this[$internals] = {
      accessors: {}
    });

    const accessors = internals.accessors;
    const prototype = this.prototype;

    function defineAccessor(_header) {
      const lHeader = normalizeHeader(_header);

      if (!accessors[lHeader]) {
        buildAccessors(prototype, _header);
        accessors[lHeader] = true;
      }
    }

    utils.isArray(header) ? header.forEach(defineAccessor) : defineAccessor(header);

    return this;
  }
}

AxiosHeaders.accessor(['Content-Type', 'Content-Length', 'Accept', 'Accept-Encoding', 'User-Agent', 'Authorization']);

utils.freezeMethods(AxiosHeaders.prototype);
utils.freezeMethods(AxiosHeaders);

var AxiosHeaders$1 = AxiosHeaders;

/**
 * Transform the data for a request or a response
 *
 * @param {Array|Function} fns A single function or Array of functions
 * @param {?Object} response The response object
 *
 * @returns {*} The resulting transformed data
 */
function transformData(fns, response) {
  const config = this || defaults$1;
  const context = response || config;
  const headers = AxiosHeaders$1.from(context.headers);
  let data = context.data;

  utils.forEach(fns, function transform(fn) {
    data = fn.call(config, data, headers.normalize(), response ? response.status : undefined);
  });

  headers.normalize();

  return data;
}

function isCancel(value) {
  return !!(value && value.__CANCEL__);
}

/**
 * A `CanceledError` is an object that is thrown when an operation is canceled.
 *
 * @param {string=} message The message.
 * @param {Object=} config The config.
 * @param {Object=} request The request.
 *
 * @returns {CanceledError} The created error.
 */
function CanceledError(message, config, request) {
  // eslint-disable-next-line no-eq-null,eqeqeq
  AxiosError.call(this, message == null ? 'canceled' : message, AxiosError.ERR_CANCELED, config, request);
  this.name = 'CanceledError';
}

utils.inherits(CanceledError, AxiosError, {
  __CANCEL__: true
});

/**
 * Resolve or reject a Promise based on response status.
 *
 * @param {Function} resolve A function that resolves the promise.
 * @param {Function} reject A function that rejects the promise.
 * @param {object} response The response.
 *
 * @returns {object} The response.
 */
function settle(resolve, reject, response) {
  const validateStatus = response.config.validateStatus;
  if (!response.status || !validateStatus || validateStatus(response.status)) {
    resolve(response);
  } else {
    reject(new AxiosError(
      'Request failed with status code ' + response.status,
      [AxiosError.ERR_BAD_REQUEST, AxiosError.ERR_BAD_RESPONSE][Math.floor(response.status / 100) - 4],
      response.config,
      response.request,
      response
    ));
  }
}

var cookies = platform.isStandardBrowserEnv ?

// Standard browser envs support document.cookie
  (function standardBrowserEnv() {
    return {
      write: function write(name, value, expires, path, domain, secure) {
        const cookie = [];
        cookie.push(name + '=' + encodeURIComponent(value));

        if (utils.isNumber(expires)) {
          cookie.push('expires=' + new Date(expires).toGMTString());
        }

        if (utils.isString(path)) {
          cookie.push('path=' + path);
        }

        if (utils.isString(domain)) {
          cookie.push('domain=' + domain);
        }

        if (secure === true) {
          cookie.push('secure');
        }

        document.cookie = cookie.join('; ');
      },

      read: function read(name) {
        const match = document.cookie.match(new RegExp('(^|;\\s*)(' + name + ')=([^;]*)'));
        return (match ? decodeURIComponent(match[3]) : null);
      },

      remove: function remove(name) {
        this.write(name, '', Date.now() - 86400000);
      }
    };
  })() :

// Non standard browser env (web workers, react-native) lack needed support.
  (function nonStandardBrowserEnv() {
    return {
      write: function write() {},
      read: function read() { return null; },
      remove: function remove() {}
    };
  })();

/**
 * Determines whether the specified URL is absolute
 *
 * @param {string} url The URL to test
 *
 * @returns {boolean} True if the specified URL is absolute, otherwise false
 */
function isAbsoluteURL(url) {
  // A URL is considered absolute if it begins with "<scheme>://" or "//" (protocol-relative URL).
  // RFC 3986 defines scheme name as a sequence of characters beginning with a letter and followed
  // by any combination of letters, digits, plus, period, or hyphen.
  return /^([a-z][a-z\d+\-.]*:)?\/\//i.test(url);
}

/**
 * Creates a new URL by combining the specified URLs
 *
 * @param {string} baseURL The base URL
 * @param {string} relativeURL The relative URL
 *
 * @returns {string} The combined URL
 */
function combineURLs(baseURL, relativeURL) {
  return relativeURL
    ? baseURL.replace(/\/+$/, '') + '/' + relativeURL.replace(/^\/+/, '')
    : baseURL;
}

/**
 * Creates a new URL by combining the baseURL with the requestedURL,
 * only when the requestedURL is not already an absolute URL.
 * If the requestURL is absolute, this function returns the requestedURL untouched.
 *
 * @param {string} baseURL The base URL
 * @param {string} requestedURL Absolute or relative URL to combine
 *
 * @returns {string} The combined full path
 */
function buildFullPath(baseURL, requestedURL) {
  if (baseURL && !isAbsoluteURL(requestedURL)) {
    return combineURLs(baseURL, requestedURL);
  }
  return requestedURL;
}

var isURLSameOrigin = platform.isStandardBrowserEnv ?

// Standard browser envs have full support of the APIs needed to test
// whether the request URL is of the same origin as current location.
  (function standardBrowserEnv() {
    const msie = /(msie|trident)/i.test(navigator.userAgent);
    const urlParsingNode = document.createElement('a');
    let originURL;

    /**
    * Parse a URL to discover it's components
    *
    * @param {String} url The URL to be parsed
    * @returns {Object}
    */
    function resolveURL(url) {
      let href = url;

      if (msie) {
        // IE needs attribute set twice to normalize properties
        urlParsingNode.setAttribute('href', href);
        href = urlParsingNode.href;
      }

      urlParsingNode.setAttribute('href', href);

      // urlParsingNode provides the UrlUtils interface - http://url.spec.whatwg.org/#urlutils
      return {
        href: urlParsingNode.href,
        protocol: urlParsingNode.protocol ? urlParsingNode.protocol.replace(/:$/, '') : '',
        host: urlParsingNode.host,
        search: urlParsingNode.search ? urlParsingNode.search.replace(/^\?/, '') : '',
        hash: urlParsingNode.hash ? urlParsingNode.hash.replace(/^#/, '') : '',
        hostname: urlParsingNode.hostname,
        port: urlParsingNode.port,
        pathname: (urlParsingNode.pathname.charAt(0) === '/') ?
          urlParsingNode.pathname :
          '/' + urlParsingNode.pathname
      };
    }

    originURL = resolveURL(window.location.href);

    /**
    * Determine if a URL shares the same origin as the current location
    *
    * @param {String} requestURL The URL to test
    * @returns {boolean} True if URL shares the same origin, otherwise false
    */
    return function isURLSameOrigin(requestURL) {
      const parsed = (utils.isString(requestURL)) ? resolveURL(requestURL) : requestURL;
      return (parsed.protocol === originURL.protocol &&
          parsed.host === originURL.host);
    };
  })() :

  // Non standard browser envs (web workers, react-native) lack needed support.
  (function nonStandardBrowserEnv() {
    return function isURLSameOrigin() {
      return true;
    };
  })();

function parseProtocol(url) {
  const match = /^([-+\w]{1,25})(:?\/\/|:)/.exec(url);
  return match && match[1] || '';
}

/**
 * Calculate data maxRate
 * @param {Number} [samplesCount= 10]
 * @param {Number} [min= 1000]
 * @returns {Function}
 */
function speedometer(samplesCount, min) {
  samplesCount = samplesCount || 10;
  const bytes = new Array(samplesCount);
  const timestamps = new Array(samplesCount);
  let head = 0;
  let tail = 0;
  let firstSampleTS;

  min = min !== undefined ? min : 1000;

  return function push(chunkLength) {
    const now = Date.now();

    const startedAt = timestamps[tail];

    if (!firstSampleTS) {
      firstSampleTS = now;
    }

    bytes[head] = chunkLength;
    timestamps[head] = now;

    let i = tail;
    let bytesCount = 0;

    while (i !== head) {
      bytesCount += bytes[i++];
      i = i % samplesCount;
    }

    head = (head + 1) % samplesCount;

    if (head === tail) {
      tail = (tail + 1) % samplesCount;
    }

    if (now - firstSampleTS < min) {
      return;
    }

    const passed = startedAt && now - startedAt;

    return passed ? Math.round(bytesCount * 1000 / passed) : undefined;
  };
}

function progressEventReducer(listener, isDownloadStream) {
  let bytesNotified = 0;
  const _speedometer = speedometer(50, 250);

  return e => {
    const loaded = e.loaded;
    const total = e.lengthComputable ? e.total : undefined;
    const progressBytes = loaded - bytesNotified;
    const rate = _speedometer(progressBytes);
    const inRange = loaded <= total;

    bytesNotified = loaded;

    const data = {
      loaded,
      total,
      progress: total ? (loaded / total) : undefined,
      bytes: progressBytes,
      rate: rate ? rate : undefined,
      estimated: rate && total && inRange ? (total - loaded) / rate : undefined,
      event: e
    };

    data[isDownloadStream ? 'download' : 'upload'] = true;

    listener(data);
  };
}

const isXHRAdapterSupported = typeof XMLHttpRequest !== 'undefined';

var xhrAdapter = isXHRAdapterSupported && function (config) {
  return new Promise(function dispatchXhrRequest(resolve, reject) {
    let requestData = config.data;
    const requestHeaders = AxiosHeaders$1.from(config.headers).normalize();
    const responseType = config.responseType;
    let onCanceled;
    function done() {
      if (config.cancelToken) {
        config.cancelToken.unsubscribe(onCanceled);
      }

      if (config.signal) {
        config.signal.removeEventListener('abort', onCanceled);
      }
    }

    if (utils.isFormData(requestData)) {
      if (platform.isStandardBrowserEnv || platform.isStandardBrowserWebWorkerEnv) {
        requestHeaders.setContentType(false); // Let the browser set it
      } else {
        requestHeaders.setContentType('multipart/form-data;', false); // mobile/desktop app frameworks
      }
    }

    let request = new XMLHttpRequest();

    // HTTP basic authentication
    if (config.auth) {
      const username = config.auth.username || '';
      const password = config.auth.password ? unescape(encodeURIComponent(config.auth.password)) : '';
      requestHeaders.set('Authorization', 'Basic ' + btoa(username + ':' + password));
    }

    const fullPath = buildFullPath(config.baseURL, config.url);

    request.open(config.method.toUpperCase(), buildURL(fullPath, config.params, config.paramsSerializer), true);

    // Set the request timeout in MS
    request.timeout = config.timeout;

    function onloadend() {
      if (!request) {
        return;
      }
      // Prepare the response
      const responseHeaders = AxiosHeaders$1.from(
        'getAllResponseHeaders' in request && request.getAllResponseHeaders()
      );
      const responseData = !responseType || responseType === 'text' || responseType === 'json' ?
        request.responseText : request.response;
      const response = {
        data: responseData,
        status: request.status,
        statusText: request.statusText,
        headers: responseHeaders,
        config,
        request
      };

      settle(function _resolve(value) {
        resolve(value);
        done();
      }, function _reject(err) {
        reject(err);
        done();
      }, response);

      // Clean up request
      request = null;
    }

    if ('onloadend' in request) {
      // Use onloadend if available
      request.onloadend = onloadend;
    } else {
      // Listen for ready state to emulate onloadend
      request.onreadystatechange = function handleLoad() {
        if (!request || request.readyState !== 4) {
          return;
        }

        // The request errored out and we didn't get a response, this will be
        // handled by onerror instead
        // With one exception: request that using file: protocol, most browsers
        // will return status as 0 even though it's a successful request
        if (request.status === 0 && !(request.responseURL && request.responseURL.indexOf('file:') === 0)) {
          return;
        }
        // readystate handler is calling before onerror or ontimeout handlers,
        // so we should call onloadend on the next 'tick'
        setTimeout(onloadend);
      };
    }

    // Handle browser request cancellation (as opposed to a manual cancellation)
    request.onabort = function handleAbort() {
      if (!request) {
        return;
      }

      reject(new AxiosError('Request aborted', AxiosError.ECONNABORTED, config, request));

      // Clean up request
      request = null;
    };

    // Handle low level network errors
    request.onerror = function handleError() {
      // Real errors are hidden from us by the browser
      // onerror should only fire if it's a network error
      reject(new AxiosError('Network Error', AxiosError.ERR_NETWORK, config, request));

      // Clean up request
      request = null;
    };

    // Handle timeout
    request.ontimeout = function handleTimeout() {
      let timeoutErrorMessage = config.timeout ? 'timeout of ' + config.timeout + 'ms exceeded' : 'timeout exceeded';
      const transitional = config.transitional || transitionalDefaults;
      if (config.timeoutErrorMessage) {
        timeoutErrorMessage = config.timeoutErrorMessage;
      }
      reject(new AxiosError(
        timeoutErrorMessage,
        transitional.clarifyTimeoutError ? AxiosError.ETIMEDOUT : AxiosError.ECONNABORTED,
        config,
        request));

      // Clean up request
      request = null;
    };

    // Add xsrf header
    // This is only done if running in a standard browser environment.
    // Specifically not if we're in a web worker, or react-native.
    if (platform.isStandardBrowserEnv) {
      // Add xsrf header
      const xsrfValue = (config.withCredentials || isURLSameOrigin(fullPath))
        && config.xsrfCookieName && cookies.read(config.xsrfCookieName);

      if (xsrfValue) {
        requestHeaders.set(config.xsrfHeaderName, xsrfValue);
      }
    }

    // Remove Content-Type if data is undefined
    requestData === undefined && requestHeaders.setContentType(null);

    // Add headers to the request
    if ('setRequestHeader' in request) {
      utils.forEach(requestHeaders.toJSON(), function setRequestHeader(val, key) {
        request.setRequestHeader(key, val);
      });
    }

    // Add withCredentials to request if needed
    if (!utils.isUndefined(config.withCredentials)) {
      request.withCredentials = !!config.withCredentials;
    }

    // Add responseType to request if needed
    if (responseType && responseType !== 'json') {
      request.responseType = config.responseType;
    }

    // Handle progress if needed
    if (typeof config.onDownloadProgress === 'function') {
      request.addEventListener('progress', progressEventReducer(config.onDownloadProgress, true));
    }

    // Not all browsers support upload events
    if (typeof config.onUploadProgress === 'function' && request.upload) {
      request.upload.addEventListener('progress', progressEventReducer(config.onUploadProgress));
    }

    if (config.cancelToken || config.signal) {
      // Handle cancellation
      // eslint-disable-next-line func-names
      onCanceled = cancel => {
        if (!request) {
          return;
        }
        reject(!cancel || cancel.type ? new CanceledError(null, config, request) : cancel);
        request.abort();
        request = null;
      };

      config.cancelToken && config.cancelToken.subscribe(onCanceled);
      if (config.signal) {
        config.signal.aborted ? onCanceled() : config.signal.addEventListener('abort', onCanceled);
      }
    }

    const protocol = parseProtocol(fullPath);

    if (protocol && platform.protocols.indexOf(protocol) === -1) {
      reject(new AxiosError('Unsupported protocol ' + protocol + ':', AxiosError.ERR_BAD_REQUEST, config));
      return;
    }


    // Send the request
    request.send(requestData || null);
  });
};

const knownAdapters = {
  http: httpAdapter,
  xhr: xhrAdapter
};

utils.forEach(knownAdapters, (fn, value) => {
  if(fn) {
    try {
      Object.defineProperty(fn, 'name', {value});
    } catch (e) {
      // eslint-disable-next-line no-empty
    }
    Object.defineProperty(fn, 'adapterName', {value});
  }
});

var adapters = {
  getAdapter: (adapters) => {
    adapters = utils.isArray(adapters) ? adapters : [adapters];

    const {length} = adapters;
    let nameOrAdapter;
    let adapter;

    for (let i = 0; i < length; i++) {
      nameOrAdapter = adapters[i];
      if((adapter = utils.isString(nameOrAdapter) ? knownAdapters[nameOrAdapter.toLowerCase()] : nameOrAdapter)) {
        break;
      }
    }

    if (!adapter) {
      if (adapter === false) {
        throw new AxiosError(
          `Adapter ${nameOrAdapter} is not supported by the environment`,
          'ERR_NOT_SUPPORT'
        );
      }

      throw new Error(
        utils.hasOwnProp(knownAdapters, nameOrAdapter) ?
          `Adapter '${nameOrAdapter}' is not available in the build` :
          `Unknown adapter '${nameOrAdapter}'`
      );
    }

    if (!utils.isFunction(adapter)) {
      throw new TypeError('adapter is not a function');
    }

    return adapter;
  },
  adapters: knownAdapters
};

/**
 * Throws a `CanceledError` if cancellation has been requested.
 *
 * @param {Object} config The config that is to be used for the request
 *
 * @returns {void}
 */
function throwIfCancellationRequested(config) {
  if (config.cancelToken) {
    config.cancelToken.throwIfRequested();
  }

  if (config.signal && config.signal.aborted) {
    throw new CanceledError(null, config);
  }
}

/**
 * Dispatch a request to the server using the configured adapter.
 *
 * @param {object} config The config that is to be used for the request
 *
 * @returns {Promise} The Promise to be fulfilled
 */
function dispatchRequest(config) {
  throwIfCancellationRequested(config);

  config.headers = AxiosHeaders$1.from(config.headers);

  // Transform request data
  config.data = transformData.call(
    config,
    config.transformRequest
  );

  if (['post', 'put', 'patch'].indexOf(config.method) !== -1) {
    config.headers.setContentType('application/x-www-form-urlencoded', false);
  }

  const adapter = adapters.getAdapter(config.adapter || defaults$1.adapter);

  return adapter(config).then(function onAdapterResolution(response) {
    throwIfCancellationRequested(config);

    // Transform response data
    response.data = transformData.call(
      config,
      config.transformResponse,
      response
    );

    response.headers = AxiosHeaders$1.from(response.headers);

    return response;
  }, function onAdapterRejection(reason) {
    if (!isCancel(reason)) {
      throwIfCancellationRequested(config);

      // Transform response data
      if (reason && reason.response) {
        reason.response.data = transformData.call(
          config,
          config.transformResponse,
          reason.response
        );
        reason.response.headers = AxiosHeaders$1.from(reason.response.headers);
      }
    }

    return Promise.reject(reason);
  });
}

const headersToObject = (thing) => thing instanceof AxiosHeaders$1 ? thing.toJSON() : thing;

/**
 * Config-specific merge-function which creates a new config-object
 * by merging two configuration objects together.
 *
 * @param {Object} config1
 * @param {Object} config2
 *
 * @returns {Object} New object resulting from merging config2 to config1
 */
function mergeConfig(config1, config2) {
  // eslint-disable-next-line no-param-reassign
  config2 = config2 || {};
  const config = {};

  function getMergedValue(target, source, caseless) {
    if (utils.isPlainObject(target) && utils.isPlainObject(source)) {
      return utils.merge.call({caseless}, target, source);
    } else if (utils.isPlainObject(source)) {
      return utils.merge({}, source);
    } else if (utils.isArray(source)) {
      return source.slice();
    }
    return source;
  }

  // eslint-disable-next-line consistent-return
  function mergeDeepProperties(a, b, caseless) {
    if (!utils.isUndefined(b)) {
      return getMergedValue(a, b, caseless);
    } else if (!utils.isUndefined(a)) {
      return getMergedValue(undefined, a, caseless);
    }
  }

  // eslint-disable-next-line consistent-return
  function valueFromConfig2(a, b) {
    if (!utils.isUndefined(b)) {
      return getMergedValue(undefined, b);
    }
  }

  // eslint-disable-next-line consistent-return
  function defaultToConfig2(a, b) {
    if (!utils.isUndefined(b)) {
      return getMergedValue(undefined, b);
    } else if (!utils.isUndefined(a)) {
      return getMergedValue(undefined, a);
    }
  }

  // eslint-disable-next-line consistent-return
  function mergeDirectKeys(a, b, prop) {
    if (prop in config2) {
      return getMergedValue(a, b);
    } else if (prop in config1) {
      return getMergedValue(undefined, a);
    }
  }

  const mergeMap = {
    url: valueFromConfig2,
    method: valueFromConfig2,
    data: valueFromConfig2,
    baseURL: defaultToConfig2,
    transformRequest: defaultToConfig2,
    transformResponse: defaultToConfig2,
    paramsSerializer: defaultToConfig2,
    timeout: defaultToConfig2,
    timeoutMessage: defaultToConfig2,
    withCredentials: defaultToConfig2,
    adapter: defaultToConfig2,
    responseType: defaultToConfig2,
    xsrfCookieName: defaultToConfig2,
    xsrfHeaderName: defaultToConfig2,
    onUploadProgress: defaultToConfig2,
    onDownloadProgress: defaultToConfig2,
    decompress: defaultToConfig2,
    maxContentLength: defaultToConfig2,
    maxBodyLength: defaultToConfig2,
    beforeRedirect: defaultToConfig2,
    transport: defaultToConfig2,
    httpAgent: defaultToConfig2,
    httpsAgent: defaultToConfig2,
    cancelToken: defaultToConfig2,
    socketPath: defaultToConfig2,
    responseEncoding: defaultToConfig2,
    validateStatus: mergeDirectKeys,
    headers: (a, b) => mergeDeepProperties(headersToObject(a), headersToObject(b), true)
  };

  utils.forEach(Object.keys(Object.assign({}, config1, config2)), function computeConfigValue(prop) {
    const merge = mergeMap[prop] || mergeDeepProperties;
    const configValue = merge(config1[prop], config2[prop], prop);
    (utils.isUndefined(configValue) && merge !== mergeDirectKeys) || (config[prop] = configValue);
  });

  return config;
}

const VERSION = "1.4.0";

const validators$1 = {};

// eslint-disable-next-line func-names
['object', 'boolean', 'number', 'function', 'string', 'symbol'].forEach((type, i) => {
  validators$1[type] = function validator(thing) {
    return typeof thing === type || 'a' + (i < 1 ? 'n ' : ' ') + type;
  };
});

const deprecatedWarnings = {};

/**
 * Transitional option validator
 *
 * @param {function|boolean?} validator - set to false if the transitional option has been removed
 * @param {string?} version - deprecated version / removed since version
 * @param {string?} message - some message with additional info
 *
 * @returns {function}
 */
validators$1.transitional = function transitional(validator, version, message) {
  function formatMessage(opt, desc) {
    return '[Axios v' + VERSION + '] Transitional option \'' + opt + '\'' + desc + (message ? '. ' + message : '');
  }

  // eslint-disable-next-line func-names
  return (value, opt, opts) => {
    if (validator === false) {
      throw new AxiosError(
        formatMessage(opt, ' has been removed' + (version ? ' in ' + version : '')),
        AxiosError.ERR_DEPRECATED
      );
    }

    if (version && !deprecatedWarnings[opt]) {
      deprecatedWarnings[opt] = true;
      // eslint-disable-next-line no-console
      console.warn(
        formatMessage(
          opt,
          ' has been deprecated since v' + version + ' and will be removed in the near future'
        )
      );
    }

    return validator ? validator(value, opt, opts) : true;
  };
};

/**
 * Assert object's properties type
 *
 * @param {object} options
 * @param {object} schema
 * @param {boolean?} allowUnknown
 *
 * @returns {object}
 */

function assertOptions(options, schema, allowUnknown) {
  if (typeof options !== 'object') {
    throw new AxiosError('options must be an object', AxiosError.ERR_BAD_OPTION_VALUE);
  }
  const keys = Object.keys(options);
  let i = keys.length;
  while (i-- > 0) {
    const opt = keys[i];
    const validator = schema[opt];
    if (validator) {
      const value = options[opt];
      const result = value === undefined || validator(value, opt, options);
      if (result !== true) {
        throw new AxiosError('option ' + opt + ' must be ' + result, AxiosError.ERR_BAD_OPTION_VALUE);
      }
      continue;
    }
    if (allowUnknown !== true) {
      throw new AxiosError('Unknown option ' + opt, AxiosError.ERR_BAD_OPTION);
    }
  }
}

var validator = {
  assertOptions,
  validators: validators$1
};

const validators = validator.validators;

/**
 * Create a new instance of Axios
 *
 * @param {Object} instanceConfig The default config for the instance
 *
 * @return {Axios} A new instance of Axios
 */
class Axios {
  constructor(instanceConfig) {
    this.defaults = instanceConfig;
    this.interceptors = {
      request: new InterceptorManager$1(),
      response: new InterceptorManager$1()
    };
  }

  /**
   * Dispatch a request
   *
   * @param {String|Object} configOrUrl The config specific for this request (merged with this.defaults)
   * @param {?Object} config
   *
   * @returns {Promise} The Promise to be fulfilled
   */
  request(configOrUrl, config) {
    /*eslint no-param-reassign:0*/
    // Allow for axios('example/url'[, config]) a la fetch API
    if (typeof configOrUrl === 'string') {
      config = config || {};
      config.url = configOrUrl;
    } else {
      config = configOrUrl || {};
    }

    config = mergeConfig(this.defaults, config);

    const {transitional, paramsSerializer, headers} = config;

    if (transitional !== undefined) {
      validator.assertOptions(transitional, {
        silentJSONParsing: validators.transitional(validators.boolean),
        forcedJSONParsing: validators.transitional(validators.boolean),
        clarifyTimeoutError: validators.transitional(validators.boolean)
      }, false);
    }

    if (paramsSerializer != null) {
      if (utils.isFunction(paramsSerializer)) {
        config.paramsSerializer = {
          serialize: paramsSerializer
        };
      } else {
        validator.assertOptions(paramsSerializer, {
          encode: validators.function,
          serialize: validators.function
        }, true);
      }
    }

    // Set config.method
    config.method = (config.method || this.defaults.method || 'get').toLowerCase();

    let contextHeaders;

    // Flatten headers
    contextHeaders = headers && utils.merge(
      headers.common,
      headers[config.method]
    );

    contextHeaders && utils.forEach(
      ['delete', 'get', 'head', 'post', 'put', 'patch', 'common'],
      (method) => {
        delete headers[method];
      }
    );

    config.headers = AxiosHeaders$1.concat(contextHeaders, headers);

    // filter out skipped interceptors
    const requestInterceptorChain = [];
    let synchronousRequestInterceptors = true;
    this.interceptors.request.forEach(function unshiftRequestInterceptors(interceptor) {
      if (typeof interceptor.runWhen === 'function' && interceptor.runWhen(config) === false) {
        return;
      }

      synchronousRequestInterceptors = synchronousRequestInterceptors && interceptor.synchronous;

      requestInterceptorChain.unshift(interceptor.fulfilled, interceptor.rejected);
    });

    const responseInterceptorChain = [];
    this.interceptors.response.forEach(function pushResponseInterceptors(interceptor) {
      responseInterceptorChain.push(interceptor.fulfilled, interceptor.rejected);
    });

    let promise;
    let i = 0;
    let len;

    if (!synchronousRequestInterceptors) {
      const chain = [dispatchRequest.bind(this), undefined];
      chain.unshift.apply(chain, requestInterceptorChain);
      chain.push.apply(chain, responseInterceptorChain);
      len = chain.length;

      promise = Promise.resolve(config);

      while (i < len) {
        promise = promise.then(chain[i++], chain[i++]);
      }

      return promise;
    }

    len = requestInterceptorChain.length;

    let newConfig = config;

    i = 0;

    while (i < len) {
      const onFulfilled = requestInterceptorChain[i++];
      const onRejected = requestInterceptorChain[i++];
      try {
        newConfig = onFulfilled(newConfig);
      } catch (error) {
        onRejected.call(this, error);
        break;
      }
    }

    try {
      promise = dispatchRequest.call(this, newConfig);
    } catch (error) {
      return Promise.reject(error);
    }

    i = 0;
    len = responseInterceptorChain.length;

    while (i < len) {
      promise = promise.then(responseInterceptorChain[i++], responseInterceptorChain[i++]);
    }

    return promise;
  }

  getUri(config) {
    config = mergeConfig(this.defaults, config);
    const fullPath = buildFullPath(config.baseURL, config.url);
    return buildURL(fullPath, config.params, config.paramsSerializer);
  }
}

// Provide aliases for supported request methods
utils.forEach(['delete', 'get', 'head', 'options'], function forEachMethodNoData(method) {
  /*eslint func-names:0*/
  Axios.prototype[method] = function(url, config) {
    return this.request(mergeConfig(config || {}, {
      method,
      url,
      data: (config || {}).data
    }));
  };
});

utils.forEach(['post', 'put', 'patch'], function forEachMethodWithData(method) {
  /*eslint func-names:0*/

  function generateHTTPMethod(isForm) {
    return function httpMethod(url, data, config) {
      return this.request(mergeConfig(config || {}, {
        method,
        headers: isForm ? {
          'Content-Type': 'multipart/form-data'
        } : {},
        url,
        data
      }));
    };
  }

  Axios.prototype[method] = generateHTTPMethod();

  Axios.prototype[method + 'Form'] = generateHTTPMethod(true);
});

var Axios$1 = Axios;

/**
 * A `CancelToken` is an object that can be used to request cancellation of an operation.
 *
 * @param {Function} executor The executor function.
 *
 * @returns {CancelToken}
 */
class CancelToken {
  constructor(executor) {
    if (typeof executor !== 'function') {
      throw new TypeError('executor must be a function.');
    }

    let resolvePromise;

    this.promise = new Promise(function promiseExecutor(resolve) {
      resolvePromise = resolve;
    });

    const token = this;

    // eslint-disable-next-line func-names
    this.promise.then(cancel => {
      if (!token._listeners) return;

      let i = token._listeners.length;

      while (i-- > 0) {
        token._listeners[i](cancel);
      }
      token._listeners = null;
    });

    // eslint-disable-next-line func-names
    this.promise.then = onfulfilled => {
      let _resolve;
      // eslint-disable-next-line func-names
      const promise = new Promise(resolve => {
        token.subscribe(resolve);
        _resolve = resolve;
      }).then(onfulfilled);

      promise.cancel = function reject() {
        token.unsubscribe(_resolve);
      };

      return promise;
    };

    executor(function cancel(message, config, request) {
      if (token.reason) {
        // Cancellation has already been requested
        return;
      }

      token.reason = new CanceledError(message, config, request);
      resolvePromise(token.reason);
    });
  }

  /**
   * Throws a `CanceledError` if cancellation has been requested.
   */
  throwIfRequested() {
    if (this.reason) {
      throw this.reason;
    }
  }

  /**
   * Subscribe to the cancel signal
   */

  subscribe(listener) {
    if (this.reason) {
      listener(this.reason);
      return;
    }

    if (this._listeners) {
      this._listeners.push(listener);
    } else {
      this._listeners = [listener];
    }
  }

  /**
   * Unsubscribe from the cancel signal
   */

  unsubscribe(listener) {
    if (!this._listeners) {
      return;
    }
    const index = this._listeners.indexOf(listener);
    if (index !== -1) {
      this._listeners.splice(index, 1);
    }
  }

  /**
   * Returns an object that contains a new `CancelToken` and a function that, when called,
   * cancels the `CancelToken`.
   */
  static source() {
    let cancel;
    const token = new CancelToken(function executor(c) {
      cancel = c;
    });
    return {
      token,
      cancel
    };
  }
}

var CancelToken$1 = CancelToken;

/**
 * Syntactic sugar for invoking a function and expanding an array for arguments.
 *
 * Common use case would be to use `Function.prototype.apply`.
 *
 *  ```js
 *  function f(x, y, z) {}
 *  var args = [1, 2, 3];
 *  f.apply(null, args);
 *  ```
 *
 * With `spread` this example can be re-written.
 *
 *  ```js
 *  spread(function(x, y, z) {})([1, 2, 3]);
 *  ```
 *
 * @param {Function} callback
 *
 * @returns {Function}
 */
function spread(callback) {
  return function wrap(arr) {
    return callback.apply(null, arr);
  };
}

/**
 * Determines whether the payload is an error thrown by Axios
 *
 * @param {*} payload The value to test
 *
 * @returns {boolean} True if the payload is an error thrown by Axios, otherwise false
 */
function isAxiosError(payload) {
  return utils.isObject(payload) && (payload.isAxiosError === true);
}

const HttpStatusCode = {
  Continue: 100,
  SwitchingProtocols: 101,
  Processing: 102,
  EarlyHints: 103,
  Ok: 200,
  Created: 201,
  Accepted: 202,
  NonAuthoritativeInformation: 203,
  NoContent: 204,
  ResetContent: 205,
  PartialContent: 206,
  MultiStatus: 207,
  AlreadyReported: 208,
  ImUsed: 226,
  MultipleChoices: 300,
  MovedPermanently: 301,
  Found: 302,
  SeeOther: 303,
  NotModified: 304,
  UseProxy: 305,
  Unused: 306,
  TemporaryRedirect: 307,
  PermanentRedirect: 308,
  BadRequest: 400,
  Unauthorized: 401,
  PaymentRequired: 402,
  Forbidden: 403,
  NotFound: 404,
  MethodNotAllowed: 405,
  NotAcceptable: 406,
  ProxyAuthenticationRequired: 407,
  RequestTimeout: 408,
  Conflict: 409,
  Gone: 410,
  LengthRequired: 411,
  PreconditionFailed: 412,
  PayloadTooLarge: 413,
  UriTooLong: 414,
  UnsupportedMediaType: 415,
  RangeNotSatisfiable: 416,
  ExpectationFailed: 417,
  ImATeapot: 418,
  MisdirectedRequest: 421,
  UnprocessableEntity: 422,
  Locked: 423,
  FailedDependency: 424,
  TooEarly: 425,
  UpgradeRequired: 426,
  PreconditionRequired: 428,
  TooManyRequests: 429,
  RequestHeaderFieldsTooLarge: 431,
  UnavailableForLegalReasons: 451,
  InternalServerError: 500,
  NotImplemented: 501,
  BadGateway: 502,
  ServiceUnavailable: 503,
  GatewayTimeout: 504,
  HttpVersionNotSupported: 505,
  VariantAlsoNegotiates: 506,
  InsufficientStorage: 507,
  LoopDetected: 508,
  NotExtended: 510,
  NetworkAuthenticationRequired: 511,
};

Object.entries(HttpStatusCode).forEach(([key, value]) => {
  HttpStatusCode[value] = key;
});

var HttpStatusCode$1 = HttpStatusCode;

/**
 * Create an instance of Axios
 *
 * @param {Object} defaultConfig The default config for the instance
 *
 * @returns {Axios} A new instance of Axios
 */
function createInstance(defaultConfig) {
  const context = new Axios$1(defaultConfig);
  const instance = bind(Axios$1.prototype.request, context);

  // Copy axios.prototype to instance
  utils.extend(instance, Axios$1.prototype, context, {allOwnKeys: true});

  // Copy context to instance
  utils.extend(instance, context, null, {allOwnKeys: true});

  // Factory for creating new instances
  instance.create = function create(instanceConfig) {
    return createInstance(mergeConfig(defaultConfig, instanceConfig));
  };

  return instance;
}

// Create the default instance to be exported
const axios = createInstance(defaults$1);

// Expose Axios class to allow class inheritance
axios.Axios = Axios$1;

// Expose Cancel & CancelToken
axios.CanceledError = CanceledError;
axios.CancelToken = CancelToken$1;
axios.isCancel = isCancel;
axios.VERSION = VERSION;
axios.toFormData = toFormData;

// Expose AxiosError class
axios.AxiosError = AxiosError;

// alias for CanceledError for backward compatibility
axios.Cancel = axios.CanceledError;

// Expose all/spread
axios.all = function all(promises) {
  return Promise.all(promises);
};

axios.spread = spread;

// Expose isAxiosError
axios.isAxiosError = isAxiosError;

// Expose mergeConfig
axios.mergeConfig = mergeConfig;

axios.AxiosHeaders = AxiosHeaders$1;

axios.formToJSON = thing => formDataToJSON(utils.isHTMLForm(thing) ? new FormData(thing) : thing);

axios.HttpStatusCode = HttpStatusCode$1;

axios.default = axios;

// this module should only have a default export
var globalAxios = axios;

/* tslint:disable */
/* eslint-disable */
/**
 * Guardian
 * Guardian API
 *
 * The version of the OpenAPI document: 1.0.0
 * Contact: support@immutable.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
// Some imports not used depending on template conditions
// @ts-ignore
const BASE_PATH = "https://guardian.sandbox.imtbl.com".replace(/\/+$/, "");
/**
 *
 * @export
 * @class BaseAPI
 */
class BaseAPI {
    basePath;
    axios;
    configuration;
    constructor(configuration, basePath = BASE_PATH, axios = globalAxios) {
        this.basePath = basePath;
        this.axios = axios;
        if (configuration) {
            this.configuration = configuration;
            this.basePath = configuration.basePath || this.basePath;
        }
    }
}
/**
 *
 * @export
 * @class RequiredError
 * @extends {Error}
 */
class RequiredError extends Error {
    field;
    name = "RequiredError";
    constructor(field, msg) {
        super(msg);
        this.field = field;
    }
}

/* tslint:disable */
/* eslint-disable */
/**
 * Guardian
 * Guardian API
 *
 * The version of the OpenAPI document: 1.0.0
 * Contact: support@immutable.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
/**
 *
 * @export
 */
const DUMMY_BASE_URL = 'https://example.com';
/**
 *
 * @throws {RequiredError}
 * @export
 */
const assertParamExists = function (functionName, paramName, paramValue) {
    if (paramValue === null || paramValue === undefined) {
        throw new RequiredError(paramName, `Required parameter ${paramName} was null or undefined when calling ${functionName}.`);
    }
};
/**
 *
 * @export
 */
const setBearerAuthToObject = async function (object, configuration) {
    if (configuration && configuration.accessToken) {
        const accessToken = typeof configuration.accessToken === 'function'
            ? await configuration.accessToken()
            : await configuration.accessToken;
        object["Authorization"] = "Bearer " + accessToken;
    }
};
function setFlattenedQueryParams(urlSearchParams, parameter, key = "") {
    if (typeof parameter === "object") {
        if (Array.isArray(parameter)) {
            parameter.forEach(item => setFlattenedQueryParams(urlSearchParams, item, key));
        }
        else {
            Object.keys(parameter).forEach(currentKey => setFlattenedQueryParams(urlSearchParams, parameter[currentKey], `${key}${key !== '' ? '.' : ''}${currentKey}`));
        }
    }
    else {
        if (urlSearchParams.has(key)) {
            urlSearchParams.append(key, parameter);
        }
        else {
            urlSearchParams.set(key, parameter);
        }
    }
}
/**
 *
 * @export
 */
const setSearchParams = function (url, ...objects) {
    const searchParams = new URLSearchParams(url.search);
    setFlattenedQueryParams(searchParams, objects);
    url.search = searchParams.toString();
};
/**
 *
 * @export
 */
const serializeDataIfNeeded = function (value, requestOptions, configuration) {
    const nonString = typeof value !== 'string';
    const needsSerialization = nonString && configuration && configuration.isJsonMime
        ? configuration.isJsonMime(requestOptions.headers['Content-Type'])
        : nonString;
    return needsSerialization
        ? JSON.stringify(value !== undefined ? value : {})
        : (value || "");
};
/**
 *
 * @export
 */
const toPathString = function (url) {
    return url.pathname + url.search + url.hash;
};
/**
 *
 * @export
 */
const createRequestFunction = function (axiosArgs, globalAxios, BASE_PATH, configuration) {
    return (axios = globalAxios, basePath = BASE_PATH) => {
        const axiosRequestArgs = { ...axiosArgs.options, url: (configuration?.basePath || basePath) + axiosArgs.url };
        return axios.request(axiosRequestArgs);
    };
};

/* tslint:disable */
/* eslint-disable */
/**
 * Guardian
 * Guardian API
 *
 * The version of the OpenAPI document: 1.0.0
 * Contact: support@immutable.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
/**
 * MessagesApi - axios parameter creator
 * @export
 */
const MessagesApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * Approve a pending evm message
         * @summary Approve a pending evm message
         * @param {string} messageID id for the message
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        approvePendingMessage: async (messageID, options = {}) => {
            // verify required parameter 'messageID' is not null or undefined
            assertParamExists('approvePendingMessage', 'messageID', messageID);
            const localVarPath = `/guardian/v1/messages/{messageID}/approve`
                .replace(`{${"messageID"}}`, encodeURIComponent(String(messageID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration);
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Check if a given message is valid  for EVM
         * @summary Evaluate an evm message to sign
         * @param {MessageEvaluationRequest} messageEvaluationRequest Specifies the kind of transaction
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        evaluateMessage: async (messageEvaluationRequest, options = {}) => {
            // verify required parameter 'messageEvaluationRequest' is not null or undefined
            assertParamExists('evaluateMessage', 'messageEvaluationRequest', messageEvaluationRequest);
            const localVarPath = `/guardian/v1/messages/evaluate`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = serializeDataIfNeeded(messageEvaluationRequest, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get an evm message by id
         * @summary Info for a specific evm message
         * @param {string} messageID The id of the evm message
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMessageByID: async (messageID, options = {}) => {
            // verify required parameter 'messageID' is not null or undefined
            assertParamExists('getMessageByID', 'messageID', messageID);
            const localVarPath = `/guardian/v1/messages/{messageID}`
                .replace(`{${"messageID"}}`, encodeURIComponent(String(messageID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration);
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
/**
 * MessagesApi - functional programming interface
 * @export
 */
const MessagesApiFp = function (configuration) {
    const localVarAxiosParamCreator = MessagesApiAxiosParamCreator(configuration);
    return {
        /**
         * Approve a pending evm message
         * @summary Approve a pending evm message
         * @param {string} messageID id for the message
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async approvePendingMessage(messageID, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.approvePendingMessage(messageID, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Check if a given message is valid  for EVM
         * @summary Evaluate an evm message to sign
         * @param {MessageEvaluationRequest} messageEvaluationRequest Specifies the kind of transaction
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async evaluateMessage(messageEvaluationRequest, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.evaluateMessage(messageEvaluationRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get an evm message by id
         * @summary Info for a specific evm message
         * @param {string} messageID The id of the evm message
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMessageByID(messageID, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getMessageByID(messageID, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    };
};
/**
 * MessagesApi - object-oriented interface
 * @export
 * @class MessagesApi
 * @extends {BaseAPI}
 */
class MessagesApi extends BaseAPI {
    /**
     * Approve a pending evm message
     * @summary Approve a pending evm message
     * @param {MessagesApiApprovePendingMessageRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MessagesApi
     */
    approvePendingMessage(requestParameters, options) {
        return MessagesApiFp(this.configuration).approvePendingMessage(requestParameters.messageID, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Check if a given message is valid  for EVM
     * @summary Evaluate an evm message to sign
     * @param {MessagesApiEvaluateMessageRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MessagesApi
     */
    evaluateMessage(requestParameters, options) {
        return MessagesApiFp(this.configuration).evaluateMessage(requestParameters.messageEvaluationRequest, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Get an evm message by id
     * @summary Info for a specific evm message
     * @param {MessagesApiGetMessageByIDRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MessagesApi
     */
    getMessageByID(requestParameters, options) {
        return MessagesApiFp(this.configuration).getMessageByID(requestParameters.messageID, options).then((request) => request(this.axios, this.basePath));
    }
}

/* tslint:disable */
/* eslint-disable */
/**
 * Guardian
 * Guardian API
 *
 * The version of the OpenAPI document: 1.0.0
 * Contact: support@immutable.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
/**
 * TransactionsApi - axios parameter creator
 * @export
 */
const TransactionsApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * Approve a pending transaction
         * @summary Approve a pending transaction given chain
         * @param {string} payloadHash Hash for the payload
         * @param {TransactionApprovalRequest} transactionApprovalRequest request body for approving a pending transaction
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        approvePendingTransaction: async (payloadHash, transactionApprovalRequest, options = {}) => {
            // verify required parameter 'payloadHash' is not null or undefined
            assertParamExists('approvePendingTransaction', 'payloadHash', payloadHash);
            // verify required parameter 'transactionApprovalRequest' is not null or undefined
            assertParamExists('approvePendingTransaction', 'transactionApprovalRequest', transactionApprovalRequest);
            const localVarPath = `/guardian/v1/transactions/{payloadHash}/approve`
                .replace(`{${"payloadHash"}}`, encodeURIComponent(String(payloadHash)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = serializeDataIfNeeded(transactionApprovalRequest, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Check if the transaction is valid by transaction ID for both StarkEx and EVM
         * @summary Evaluate a transaction
         * @param {string} id Transaction identifier: payloadHash on StarkEx or EVM ID
         * @param {TransactionEvaluationRequest} transactionEvaluationRequest Specifies the kind of transaction
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        evaluateTransaction: async (id, transactionEvaluationRequest, options = {}) => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('evaluateTransaction', 'id', id);
            // verify required parameter 'transactionEvaluationRequest' is not null or undefined
            assertParamExists('evaluateTransaction', 'transactionEvaluationRequest', transactionEvaluationRequest);
            const localVarPath = `/guardian/v1/transactions/{id}/evaluate`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = serializeDataIfNeeded(transactionEvaluationRequest, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a transaction by payload hash
         * @summary Info for a specific transaction
         * @param {string} transactionID The id of the starkex transaction to retrieve
         * @param {'starkex' | 'evm'} chainType roll up type
         * @param {string} [chainID] ID of evm chain
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTransactionByID: async (transactionID, chainType, chainID, options = {}) => {
            // verify required parameter 'transactionID' is not null or undefined
            assertParamExists('getTransactionByID', 'transactionID', transactionID);
            // verify required parameter 'chainType' is not null or undefined
            assertParamExists('getTransactionByID', 'chainType', chainType);
            const localVarPath = `/guardian/v1/transactions/{transactionID}`
                .replace(`{${"transactionID"}}`, encodeURIComponent(String(transactionID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration);
            if (chainType !== undefined) {
                localVarQueryParameter['chainType'] = chainType;
            }
            if (chainID !== undefined) {
                localVarQueryParameter['chainID'] = chainID;
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
/**
 * TransactionsApi - functional programming interface
 * @export
 */
const TransactionsApiFp = function (configuration) {
    const localVarAxiosParamCreator = TransactionsApiAxiosParamCreator(configuration);
    return {
        /**
         * Approve a pending transaction
         * @summary Approve a pending transaction given chain
         * @param {string} payloadHash Hash for the payload
         * @param {TransactionApprovalRequest} transactionApprovalRequest request body for approving a pending transaction
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async approvePendingTransaction(payloadHash, transactionApprovalRequest, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.approvePendingTransaction(payloadHash, transactionApprovalRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Check if the transaction is valid by transaction ID for both StarkEx and EVM
         * @summary Evaluate a transaction
         * @param {string} id Transaction identifier: payloadHash on StarkEx or EVM ID
         * @param {TransactionEvaluationRequest} transactionEvaluationRequest Specifies the kind of transaction
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async evaluateTransaction(id, transactionEvaluationRequest, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.evaluateTransaction(id, transactionEvaluationRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get a transaction by payload hash
         * @summary Info for a specific transaction
         * @param {string} transactionID The id of the starkex transaction to retrieve
         * @param {'starkex' | 'evm'} chainType roll up type
         * @param {string} [chainID] ID of evm chain
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTransactionByID(transactionID, chainType, chainID, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTransactionByID(transactionID, chainType, chainID, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    };
};
/**
 * TransactionsApi - object-oriented interface
 * @export
 * @class TransactionsApi
 * @extends {BaseAPI}
 */
class TransactionsApi extends BaseAPI {
    /**
     * Approve a pending transaction
     * @summary Approve a pending transaction given chain
     * @param {TransactionsApiApprovePendingTransactionRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TransactionsApi
     */
    approvePendingTransaction(requestParameters, options) {
        return TransactionsApiFp(this.configuration).approvePendingTransaction(requestParameters.payloadHash, requestParameters.transactionApprovalRequest, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Check if the transaction is valid by transaction ID for both StarkEx and EVM
     * @summary Evaluate a transaction
     * @param {TransactionsApiEvaluateTransactionRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TransactionsApi
     */
    evaluateTransaction(requestParameters, options) {
        return TransactionsApiFp(this.configuration).evaluateTransaction(requestParameters.id, requestParameters.transactionEvaluationRequest, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Get a transaction by payload hash
     * @summary Info for a specific transaction
     * @param {TransactionsApiGetTransactionByIDRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TransactionsApi
     */
    getTransactionByID(requestParameters, options) {
        return TransactionsApiFp(this.configuration).getTransactionByID(requestParameters.transactionID, requestParameters.chainType, requestParameters.chainID, options).then((request) => request(this.axios, this.basePath));
    }
}

/* tslint:disable */
/* eslint-disable */
/**
 * Guardian
 * Guardian API
 *
 * The version of the OpenAPI document: 1.0.0
 * Contact: support@immutable.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
class Configuration {
    /**
     * parameter for apiKey security
     * @param name security name
     * @memberof Configuration
     */
    apiKey;
    /**
     * parameter for basic security
     *
     * @type {string}
     * @memberof Configuration
     */
    username;
    /**
     * parameter for basic security
     *
     * @type {string}
     * @memberof Configuration
     */
    password;
    /**
     * parameter for oauth2 security
     * @param name security name
     * @param scopes oauth2 scope
     * @memberof Configuration
     */
    accessToken;
    /**
     * override base path
     *
     * @type {string}
     * @memberof Configuration
     */
    basePath;
    /**
     * base options for axios calls
     *
     * @type {any}
     * @memberof Configuration
     */
    baseOptions;
    /**
     * The FormData constructor that will be used to create multipart form data
     * requests. You can inject this here so that execution environments that
     * do not support the FormData class can still run the generated client.
     *
     * @type {new () => FormData}
     */
    formDataCtor;
    constructor(param = {}) {
        this.apiKey = param.apiKey;
        this.username = param.username;
        this.password = param.password;
        this.accessToken = param.accessToken;
        this.basePath = param.basePath;
        this.baseOptions = param.baseOptions;
        this.formDataCtor = param.formDataCtor;
    }
    /**
     * Check if the given MIME is a JSON MIME.
     * JSON MIME examples:
     *   application/json
     *   application/json; charset=UTF8
     *   APPLICATION/JSON
     *   application/vnd.company+json
     * @param mime - MIME (Multipurpose Internet Mail Extensions)
     * @return True if the given MIME is JSON, false otherwise.
     */
    isJsonMime(mime) {
        const jsonMime = new RegExp('^(application\/json|[^;/ \t]+\/[^;/ \t]+[+]json)[ \t]*(;.*)?$', 'i');
        return mime !== null && (jsonMime.test(mime) || mime.toLowerCase() === 'application/json-patch+json');
    }
}

/* tslint:disable */
/* eslint-disable */
/**
 * Guardian
 * Guardian API
 *
 * The version of the OpenAPI document: 1.0.0
 * Contact: support@immutable.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
const TransactionApprovalRequestChainTypeEnum = {
    Starkex: 'starkex',
    Evm: 'evm'
};

// used to sign message with L1 keys. Used for registration
function serializeEthSignature(sig) {
    // This is because golang appends a recovery param
    // https://github.com/ethers-io/ethers.js/issues/823
    return encUtils.addHexPrefix(encUtils.padLeft(sig.r.toString(16), 64)
        + encUtils.padLeft(sig.s.toString(16), 64)
        + encUtils.padLeft(sig.recoveryParam?.toString(16) || '', 2));
}
function importRecoveryParam(v) {
    const isValidBigNumber = new BN(v, 16).cmp(new BN(27)) !== -1
        ? new BN(v, 16).sub(new BN(27)).toNumber()
        : new BN(v, 16).toNumber();
    return v.trim()
        ? isValidBigNumber
        : undefined;
}
// used chained with serializeEthSignature. serializeEthSignature(deserializeSignature(...))
function deserializeSignature(sig, size = 64) {
    const removedHexPrefixSig = encUtils.removeHexPrefix(sig);
    return {
        r: new BN(removedHexPrefixSig.substring(0, size), 'hex'),
        s: new BN(removedHexPrefixSig.substring(size, size * 2), 'hex'),
        recoveryParam: importRecoveryParam(removedHexPrefixSig.substring(size * 2, size * 2 + 2)),
    };
}
async function signRaw(payload, signer) {
    const signature = deserializeSignature(await signer.signMessage(payload));
    return serializeEthSignature(signature);
}

/**
 * Helper method to convert token type to a SignableToken type
 * @param token - the token type to convert to a SignableToken type
 * @returns the converted SignableToken
 */
function convertToSignableToken(token) {
    switch (token.type) {
        case 'ERC721':
            return {
                type: 'ERC721',
                data: {
                    token_id: token.tokenId,
                    token_address: token.tokenAddress,
                },
            };
        case 'ERC20':
            return {
                type: 'ERC20',
                data: {
                    token_address: token.tokenAddress,
                },
            };
        case 'ETH':
        default:
            return {
                type: 'ETH',
                data: {
                    decimals: 18,
                },
            };
    }
}

var PassportErrorType;
(function (PassportErrorType) {
    PassportErrorType["AUTHENTICATION_ERROR"] = "AUTHENTICATION_ERROR";
    PassportErrorType["INVALID_CONFIGURATION"] = "INVALID_CONFIGURATION";
    PassportErrorType["WALLET_CONNECTION_ERROR"] = "WALLET_CONNECTION_ERROR";
    PassportErrorType["NOT_LOGGED_IN_ERROR"] = "NOT_LOGGED_IN_ERROR";
    PassportErrorType["SILENT_LOGIN_ERROR"] = "SILENT_LOGIN_ERROR";
    PassportErrorType["REFRESH_TOKEN_ERROR"] = "REFRESH_TOKEN_ERROR";
    PassportErrorType["USER_REGISTRATION_ERROR"] = "USER_REGISTRATION_ERROR";
    PassportErrorType["LOGOUT_ERROR"] = "LOGOUT_ERROR";
    PassportErrorType["TRANSFER_ERROR"] = "TRANSFER_ERROR";
    PassportErrorType["CREATE_ORDER_ERROR"] = "CREATE_ORDER_ERROR";
    PassportErrorType["CANCEL_ORDER_ERROR"] = "CANCEL_ORDER_ERROR";
    PassportErrorType["EXCHANGE_TRANSFER_ERROR"] = "EXCHANGE_TRANSFER_ERROR";
    PassportErrorType["CREATE_TRADE_ERROR"] = "CREATE_TRADE_ERROR";
    PassportErrorType["OPERATION_NOT_SUPPORTED_ERROR"] = "OPERATION_NOT_SUPPORTED_ERROR";
})(PassportErrorType || (PassportErrorType = {}));
function isAPIError(error) {
    return 'code' in error && 'message' in error;
}
class PassportError extends Error {
    type;
    constructor(message, type) {
        super(message);
        this.type = type;
    }
}
const withPassportError = async (fn, customErrorType) => {
    try {
        return await fn();
    }
    catch (error) {
        let errorMessage;
        if (isAxiosError$1(error) && error.response?.data && isAPIError(error.response.data)) {
            errorMessage = error.response.data.message;
        }
        else {
            errorMessage = error.message;
        }
        throw new PassportError(errorMessage, customErrorType);
    }
};

const keyCrendentials = 'passport_credentials';
const KEY_PKCE_STATE = 'pkce_state';
const KEY_PKCE_VERIFIER = 'pkce_verifier';
const validCredentialsMinTtlSec = 3600; // 1 hour
class DeviceCredentialsManager {
    saveCredentials(tokenResponse) {
        if (this.areValid(tokenResponse)) {
            localStorage.setItem(keyCrendentials, JSON.stringify(tokenResponse));
        }
        else {
            throw Error('Invalid credentials.');
        }
    }
    getCredentials() {
        const credentialsJson = localStorage.getItem(keyCrendentials);
        if (credentialsJson) {
            return JSON.parse(credentialsJson);
        }
        return null;
    }
    areValid(tokenResponse) {
        if (tokenResponse) {
            const accessTokenValid = this.isTokenValid(tokenResponse.access_token);
            const idTokenValid = this.isTokenValid(tokenResponse.id_token);
            return accessTokenValid && idTokenValid;
        }
        return false;
    }
    isTokenValid(jwt) {
        try {
            const tokenPayload = jwt_decode(jwt);
            const expiresAt = tokenPayload.exp ?? 0;
            const now = (Date.now() / 1000) + validCredentialsMinTtlSec;
            return expiresAt > now;
        }
        catch (error) {
            return false;
        }
    }
    clearCredentials() {
        localStorage.removeItem(keyCrendentials);
    }
    savePKCEData(data) {
        localStorage.setItem(KEY_PKCE_STATE, data.state);
        localStorage.setItem(KEY_PKCE_VERIFIER, data.verifier);
    }
    getPKCEData() {
        const state = localStorage.getItem(KEY_PKCE_STATE);
        const verifier = localStorage.getItem(KEY_PKCE_VERIFIER);
        if (state && verifier) {
            return { state, verifier };
        }
        return null;
    }
}

const formUrlEncodedHeader = {
    headers: {
        'Content-Type': 'application/x-www-form-urlencoded',
    },
};
const getAuthConfiguration = ({ oidcConfiguration, authenticationDomain, }) => {
    const store = typeof window !== 'undefined' ? window.localStorage : new InMemoryWebStorage();
    const userStore = new WebStorageStateStore({ store });
    const baseConfiguration = {
        authority: authenticationDomain,
        redirect_uri: oidcConfiguration.redirectUri,
        popup_redirect_uri: oidcConfiguration.redirectUri,
        client_id: oidcConfiguration.clientId,
        metadata: {
            authorization_endpoint: `${authenticationDomain}/authorize`,
            token_endpoint: `${authenticationDomain}/oauth/token`,
            userinfo_endpoint: `${authenticationDomain}/userinfo`,
            end_session_endpoint: `${authenticationDomain}/v2/logout`
                + `?returnTo=${encodeURIComponent(oidcConfiguration.logoutRedirectUri)}`
                + `&client_id=${oidcConfiguration.clientId}`,
        },
        mergeClaims: true,
        loadUserInfo: true,
        scope: oidcConfiguration.scope,
        userStore,
    };
    if (oidcConfiguration.audience) {
        baseConfiguration.extraQueryParams = {
            audience: oidcConfiguration.audience,
        };
    }
    return baseConfiguration;
};
function wait$1(ms) {
    return new Promise((resolve) => {
        setTimeout(resolve, ms);
    });
}
class AuthManager {
    userManager;
    config;
    deviceCredentialsManager;
    logoutMode;
    constructor(config) {
        this.config = config;
        this.userManager = new UserManager(getAuthConfiguration(config));
        this.deviceCredentialsManager = new DeviceCredentialsManager();
        this.logoutMode = config.oidcConfiguration.logoutMode || 'redirect';
    }
    static mapOidcUserToDomainModel = (oidcUser) => {
        const passport = oidcUser.profile?.passport;
        const user = {
            expired: oidcUser.expired,
            idToken: oidcUser.id_token,
            accessToken: oidcUser.access_token,
            refreshToken: oidcUser.refresh_token,
            profile: {
                sub: oidcUser.profile.sub,
                email: oidcUser.profile.email,
                nickname: oidcUser.profile.nickname,
            },
        };
        if (passport?.imx_eth_address) {
            user.imx = {
                ethAddress: passport?.imx_eth_address,
                starkAddress: passport?.imx_stark_address,
                userAdminAddress: passport?.imx_user_admin_address,
            };
        }
        if (passport?.zkevm_eth_address) {
            user.zkEvm = {
                ethAddress: passport?.zkevm_eth_address,
                userAdminAddress: passport?.zkevm_user_admin_address,
            };
        }
        return user;
    };
    static mapDeviceTokenResponseToDomainUserModel = (tokenResponse) => {
        const idTokenPayload = jwt_decode(tokenResponse.id_token);
        const user = {
            idToken: tokenResponse.id_token,
            accessToken: tokenResponse.access_token,
            refreshToken: tokenResponse.refresh_token,
            profile: {
                sub: idTokenPayload.sub,
                email: idTokenPayload.email,
                nickname: idTokenPayload.nickname,
            },
        };
        if (idTokenPayload?.passport?.imx_eth_address) {
            user.imx = {
                ethAddress: idTokenPayload?.passport?.imx_eth_address,
                starkAddress: idTokenPayload?.passport?.imx_stark_address,
                userAdminAddress: idTokenPayload?.passport?.imx_user_admin_address,
            };
        }
        if (idTokenPayload?.passport?.zkevm_eth_address) {
            user.zkEvm = {
                ethAddress: idTokenPayload?.passport?.zkevm_eth_address,
                userAdminAddress: idTokenPayload?.passport?.zkevm_user_admin_address,
            };
        }
        return user;
    };
    async login() {
        return withPassportError(async () => {
            const popupWindowFeatures = { width: 410, height: 450 };
            const oidcUser = await this.userManager.signinPopup({
                popupWindowFeatures,
            });
            return AuthManager.mapOidcUserToDomainModel(oidcUser);
        }, PassportErrorType.AUTHENTICATION_ERROR);
    }
    async loginCallback() {
        return withPassportError(async () => this.userManager.signinPopupCallback(), PassportErrorType.AUTHENTICATION_ERROR);
    }
    async loginWithDeviceFlow() {
        return withPassportError(async () => {
            const response = await globalAxios$1.post(`${this.config.authenticationDomain}/oauth/device/code`, {
                client_id: this.config.oidcConfiguration.clientId,
                scope: this.config.oidcConfiguration.scope,
                audience: this.config.oidcConfiguration.audience,
            }, formUrlEncodedHeader);
            return {
                code: response.data.user_code,
                deviceCode: response.data.device_code,
                url: response.data.verification_uri_complete,
                interval: response.data.interval,
            };
        }, PassportErrorType.AUTHENTICATION_ERROR);
    }
    /* eslint-disable no-await-in-loop */
    async connectImxDeviceFlow(deviceCode, interval, timeoutMs) {
        return withPassportError(async () => {
            const startTime = Date.now();
            const loopCondition = true;
            while (loopCondition) {
                if (timeoutMs != null && Date.now() - startTime > timeoutMs) {
                    throw new Error('Timed out');
                }
                await wait$1(interval * 1000);
                try {
                    const tokenResponse = await this.getDeviceFlowToken(deviceCode);
                    const user = AuthManager.mapDeviceTokenResponseToDomainUserModel(tokenResponse);
                    // Only persist credentials that contain the necessary data
                    if (user.imx?.ethAddress && user.imx?.starkAddress && user.imx?.userAdminAddress) {
                        this.deviceCredentialsManager.saveCredentials(tokenResponse);
                    }
                    return user;
                }
                catch (error) {
                    if (globalAxios$1.isAxiosError(error)) {
                        const responseError = error.response?.data;
                        switch (responseError.error) {
                            case 'authorization_pending':
                                break;
                            case 'slow_down':
                                break;
                            case 'expired_token':
                                throw new Error('Token expired, please log in again');
                            case 'access_denied':
                                throw new Error('User denied access');
                            default:
                                throw new Error('Error getting token');
                        }
                    }
                    else {
                        throw error;
                    }
                }
            }
            throw new Error('Failed to get credentials');
        }, PassportErrorType.AUTHENTICATION_ERROR);
    }
    /* eslint-enable no-await-in-loop */
    async getDeviceFlowToken(deviceCode) {
        const response = await globalAxios$1.post(`${this.config.authenticationDomain}/oauth/token`, {
            client_id: this.config.oidcConfiguration.clientId,
            grant_type: 'urn:ietf:params:oauth:grant-type:device_code',
            device_code: deviceCode,
        }, formUrlEncodedHeader);
        return response.data;
    }
    static base64URLEncode(str) {
        return str.toString('base64')
            .replace(/\+/g, '-')
            .replace(/\//g, '_')
            .replace(/=/g, '');
    }
    static sha256(buffer) {
        return crypto.createHash('sha256').update(buffer).digest();
    }
    getPKCEAuthorizationUrl() {
        const verifier = AuthManager.base64URLEncode(crypto.randomBytes(32));
        const challenge = AuthManager.base64URLEncode(AuthManager.sha256(verifier));
        // https://auth0.com/docs/secure/attack-protection/state-parameters
        const state = AuthManager.base64URLEncode(crypto.randomBytes(32));
        this.deviceCredentialsManager.savePKCEData({ state, verifier });
        return `${this.config.authenticationDomain}/authorize?`
            + 'response_type=code'
            + `&code_challenge=${challenge}`
            + '&code_challenge_method=S256'
            + `&client_id=${this.config.oidcConfiguration.clientId}`
            + `&redirect_uri=${this.config.oidcConfiguration.redirectUri}`
            + `&scope=${this.config.oidcConfiguration.scope}`
            + `&state=${state}`
            + `&audience=${this.config.oidcConfiguration.audience}`;
    }
    async connectImxPKCEFlow(authorizationCode, state) {
        return withPassportError(async () => {
            const pkceData = this.deviceCredentialsManager.getPKCEData();
            if (!pkceData) {
                throw new Error('No code verifier or state for PKCE');
            }
            if (state !== pkceData.state) {
                throw new Error('Provided state does not match stored state');
            }
            const tokenResponse = await this.getPKCEToken(authorizationCode, pkceData.verifier);
            const user = AuthManager.mapDeviceTokenResponseToDomainUserModel(tokenResponse);
            // Only persist credentials that contain the necessary data
            if (user.imx?.ethAddress && user.imx?.starkAddress && user.imx?.userAdminAddress) {
                this.deviceCredentialsManager.saveCredentials(tokenResponse);
            }
            return user;
        }, PassportErrorType.AUTHENTICATION_ERROR);
    }
    async getPKCEToken(authorizationCode, codeVerifier) {
        const response = await globalAxios$1.post(`${this.config.authenticationDomain}/oauth/token`, {
            client_id: this.config.oidcConfiguration.clientId,
            grant_type: 'authorization_code',
            code_verifier: codeVerifier,
            code: authorizationCode,
            redirect_uri: this.config.oidcConfiguration.redirectUri,
        }, formUrlEncodedHeader);
        return response.data;
    }
    async connectImxWithCredentials(tokenResponse) {
        return withPassportError(async () => {
            if (this.deviceCredentialsManager.areValid(tokenResponse)) {
                // Credentials exist and are still valid
                return AuthManager.mapDeviceTokenResponseToDomainUserModel(tokenResponse);
            }
            const refreshToken = tokenResponse?.refresh_token ?? null;
            if (refreshToken) {
                // Token is no longer valid, but refresh token can be used to a new one
                const user = await this.refreshToken(refreshToken);
                return user;
            }
            return null;
        }, PassportErrorType.AUTHENTICATION_ERROR);
    }
    async refreshToken(refreshToken) {
        const response = await globalAxios$1.post(`${this.config.authenticationDomain}/oauth/token`, {
            client_id: this.config.oidcConfiguration.clientId,
            grant_type: 'refresh_token',
            refresh_token: refreshToken,
        }, formUrlEncodedHeader);
        const newTokenResponse = response.data;
        return AuthManager.mapDeviceTokenResponseToDomainUserModel(newTokenResponse);
    }
    async logout() {
        return withPassportError(async () => {
            if (this.logoutMode === 'silent') {
                return this.userManager.signoutSilent();
            }
            return this.userManager.signoutRedirect();
        }, PassportErrorType.LOGOUT_ERROR);
    }
    async logoutSilentCallback(url) {
        return this.userManager.signoutSilentCallback(url);
    }
    async logoutDeviceFlow() {
        return withPassportError(async () => {
            this.deviceCredentialsManager.clearCredentials();
        }, PassportErrorType.LOGOUT_ERROR);
    }
    async loginSilent() {
        return withPassportError(async () => {
            const existedUser = await this.getUser();
            if (!existedUser) {
                return null;
            }
            const oidcUser = await this.userManager.signinSilent();
            if (!oidcUser) {
                return null;
            }
            return AuthManager.mapOidcUserToDomainModel(oidcUser);
        }, PassportErrorType.SILENT_LOGIN_ERROR);
    }
    async getUser() {
        return withPassportError(async () => {
            const oidcUser = await this.userManager.getUser();
            if (oidcUser) {
                return AuthManager.mapOidcUserToDomainModel(oidcUser);
            }
            const deviceToken = this.deviceCredentialsManager.getCredentials();
            if (deviceToken) {
                return AuthManager.mapDeviceTokenResponseToDomainUserModel(deviceToken);
            }
            return null;
        }, PassportErrorType.NOT_LOGGED_IN_ERROR);
    }
    async getUserDeviceFlow() {
        return withPassportError(async () => {
            const deviceToken = this.deviceCredentialsManager.getCredentials();
            if (deviceToken) {
                return AuthManager.mapDeviceTokenResponseToDomainUserModel(deviceToken);
            }
            return null;
        }, PassportErrorType.NOT_LOGGED_IN_ERROR);
    }
    checkStoredDeviceFlowCredentials() {
        return this.deviceCredentialsManager.getCredentials();
    }
}

class MagicAdapter {
    config;
    magicClient;
    constructor(config) {
        this.config = config;
    }
    async login(idToken, network) {
        return withPassportError(async () => {
            this.magicClient = new Magic(this.config.magicPublishableApiKey, {
                extensions: [new OpenIdExtension()],
                network,
            });
            await this.magicClient.openid.loginWithOIDC({
                jwt: idToken,
                providerId: this.config.magicProviderId,
            });
            return this.magicClient.rpcProvider;
        }, PassportErrorType.WALLET_CONNECTION_ERROR);
    }
    async logout() {
        if (this.magicClient?.user) {
            await this.magicClient.user.logout();
        }
    }
}

const getStarkSigner = async (signer) => withPassportError(async () => {
    const privateKey = await generateLegacyStarkPrivateKey(signer);
    return createStarkSigner(privateKey);
}, PassportErrorType.WALLET_CONNECTION_ERROR);

const POLL_INTERVAL = 1 * 1000; // every 1 second
const MAX_RETRIES = 3;
const wait = (ms) => new Promise((resolve) => {
    setTimeout(() => resolve(), ms);
});
const retryWithDelay = async (fn, options) => {
    const { retries = MAX_RETRIES, interval = POLL_INTERVAL, finalErr = Error('Retry failed'), finallyFn = () => { }, } = options || {};
    try {
        return await fn();
    }
    catch (err) {
        if (retries <= 0) {
            return Promise.reject(finalErr);
        }
        await wait(interval);
        return retryWithDelay(fn, { retries: retries - 1, finalErr, finallyFn });
    }
    finally {
        if (retries <= 0) {
            finallyFn();
        }
    }
};

/**
 * ProviderErrors should take priority over RpcErrorCodes
 * https://eips.ethereum.org/EIPS/eip-1193#provider-errors
 * https://eips.ethereum.org/EIPS/eip-1474#error-codes
 */
var ProviderErrorCode;
(function (ProviderErrorCode) {
    ProviderErrorCode[ProviderErrorCode["USER_REJECTED_REQUEST"] = 4001] = "USER_REJECTED_REQUEST";
    ProviderErrorCode[ProviderErrorCode["UNAUTHORIZED"] = 4100] = "UNAUTHORIZED";
    ProviderErrorCode[ProviderErrorCode["UNSUPPORTED_METHOD"] = 4200] = "UNSUPPORTED_METHOD";
    ProviderErrorCode[ProviderErrorCode["DISCONNECTED"] = 4900] = "DISCONNECTED";
})(ProviderErrorCode || (ProviderErrorCode = {}));
var RpcErrorCode;
(function (RpcErrorCode) {
    RpcErrorCode[RpcErrorCode["RPC_SERVER_ERROR"] = -32000] = "RPC_SERVER_ERROR";
    RpcErrorCode[RpcErrorCode["INVALID_REQUEST"] = -32600] = "INVALID_REQUEST";
    RpcErrorCode[RpcErrorCode["METHOD_NOT_FOUND"] = -32601] = "METHOD_NOT_FOUND";
    RpcErrorCode[RpcErrorCode["INVALID_PARAMS"] = -32602] = "INVALID_PARAMS";
    RpcErrorCode[RpcErrorCode["INTERNAL_ERROR"] = -32603] = "INTERNAL_ERROR";
    RpcErrorCode[RpcErrorCode["PARSE_ERROR"] = -32700] = "PARSE_ERROR";
    RpcErrorCode[RpcErrorCode["TRANSACTION_REJECTED"] = -32003] = "TRANSACTION_REJECTED";
})(RpcErrorCode || (RpcErrorCode = {}));
class JsonRpcError extends Error {
    message;
    code;
    constructor(code, message) {
        super(message);
        this.message = message;
        this.code = code;
    }
}

const transactionRejectedCrossSdkBridgeError = 'Transaction requires confirmation but this functionality is not'
    + ' supported in this environment. Please contact Immutable support if you need to enable this feature.';
const convertBigNumberishToString = (value) => BigNumber.from(value).toString();
const transformGuardianTransactions = (txs) => {
    try {
        return txs.map((t) => ({
            delegateCall: t.delegateCall === true,
            revertOnError: t.revertOnError === true,
            gasLimit: t.gasLimit ? convertBigNumberishToString(t.gasLimit) : '0',
            target: t.to ?? ethers.constants.AddressZero,
            value: t.value ? convertBigNumberishToString(t.value) : '0',
            data: t.data ? t.data.toString() : '0x',
        }));
    }
    catch (error) {
        const errorMessage = error instanceof Error ? error.message : String(error);
        throw new JsonRpcError(RpcErrorCode.INVALID_PARAMS, `Transaction failed to parsing: ${errorMessage}`);
    }
};
class GuardianClient {
    transactionAPI;
    messageAPI;
    confirmationScreen;
    // TODO: ID-977, make this rollup agnostic
    imxEtherAddress;
    crossSdkBridgeEnabled;
    constructor({ accessToken, confirmationScreen, imxEtherAddress, config, }) {
        const guardianConfiguration = new Configuration({ accessToken, basePath: config.imxPublicApiDomain });
        this.confirmationScreen = confirmationScreen;
        this.transactionAPI = new TransactionsApi(new Configuration(guardianConfiguration));
        this.imxEtherAddress = imxEtherAddress;
        this.crossSdkBridgeEnabled = config.crossSdkBridgeEnabled;
        this.messageAPI = new MessagesApi(guardianConfiguration);
    }
    /**
     * Open confirmation screen and close it automatically if the
     * underlying task fails.
     */
    withConfirmationScreen(popupWindowSize) {
        return (task) => this.withConfirmationScreenTask(popupWindowSize)(task)();
    }
    withConfirmationScreenTask(popupWindowSize) {
        return (task) => async () => {
            this.confirmationScreen.loading(popupWindowSize);
            try {
                return await task();
            }
            catch (err) {
                this.confirmationScreen.closeWindow();
                throw err;
            }
        };
    }
    withDefaultConfirmationScreenTask(task) {
        return this.withConfirmationScreenTask()(task);
    }
    async validate({ payloadHash }) {
        const finallyFn = () => {
            this.confirmationScreen.closeWindow();
        };
        const transactionRes = await retryWithDelay(async () => this.transactionAPI.getTransactionByID({
            transactionID: payloadHash,
            chainType: 'starkex',
        }), { finallyFn });
        if (!transactionRes.data.id) {
            throw new Error("Transaction doesn't exists");
        }
        const evaluateStarkexRes = await this.transactionAPI.evaluateTransaction({
            id: payloadHash,
            transactionEvaluationRequest: {
                chainType: 'starkex',
            },
        });
        const { confirmationRequired } = evaluateStarkexRes.data;
        if (confirmationRequired) {
            if (this.crossSdkBridgeEnabled) {
                throw new Error(transactionRejectedCrossSdkBridgeError);
            }
            const confirmationResult = await this.confirmationScreen.requestConfirmation(payloadHash, this.imxEtherAddress, TransactionApprovalRequestChainTypeEnum.Starkex);
            if (!confirmationResult.confirmed) {
                throw new Error('Transaction rejected by user');
            }
        }
        else {
            this.confirmationScreen.closeWindow();
        }
    }
    async evaluateEVMTransaction({ chainId, nonce, user, metaTransactions, }) {
        const headers = { Authorization: `Bearer ${user.accessToken}` };
        const guardianTransactions = transformGuardianTransactions(metaTransactions);
        try {
            const transactionEvaluationResponseAxiosResponse = await this.transactionAPI.evaluateTransaction({
                id: 'evm',
                transactionEvaluationRequest: {
                    chainType: 'evm',
                    chainId,
                    transactionData: {
                        nonce,
                        userAddress: user.zkEvm.ethAddress,
                        metaTransactions: guardianTransactions,
                    },
                },
            }, { headers });
            return transactionEvaluationResponseAxiosResponse.data;
        }
        catch (error) {
            const errorMessage = error instanceof Error ? error.message : String(error);
            throw new JsonRpcError(RpcErrorCode.INTERNAL_ERROR, `Transaction failed to validate with error: ${errorMessage}`);
        }
    }
    async validateEVMTransaction({ chainId, nonce, user, metaTransactions, }) {
        const transactionEvaluationResponse = await this.evaluateEVMTransaction({
            chainId,
            nonce,
            user,
            metaTransactions,
        });
        const { confirmationRequired, transactionId } = transactionEvaluationResponse;
        if (confirmationRequired && this.crossSdkBridgeEnabled) {
            throw new JsonRpcError(RpcErrorCode.TRANSACTION_REJECTED, transactionRejectedCrossSdkBridgeError);
        }
        if (confirmationRequired && !!transactionId) {
            const confirmationResult = await this.confirmationScreen.requestConfirmation(transactionId, this.imxEtherAddress, TransactionApprovalRequestChainTypeEnum.Evm, chainId);
            if (!confirmationResult.confirmed) {
                throw new JsonRpcError(RpcErrorCode.TRANSACTION_REJECTED, 'Transaction rejected by user');
            }
        }
        else {
            this.confirmationScreen.closeWindow();
        }
    }
    async evaluateMessage({ chainID, payload, user }) {
        try {
            const messageEvalResponse = await this.messageAPI.evaluateMessage({ messageEvaluationRequest: { chainID, payload } }, { headers: { Authorization: `Bearer ${user.accessToken}` } });
            return messageEvalResponse.data;
        }
        catch (error) {
            const errorMessage = error instanceof Error ? error.message : String(error);
            throw new JsonRpcError(RpcErrorCode.INTERNAL_ERROR, `Message failed to validate with error: ${errorMessage}`);
        }
    }
    async validateMessage({ chainID, payload, user }) {
        const { messageId, confirmationRequired } = await this.evaluateMessage({ chainID, payload, user });
        if (confirmationRequired && this.crossSdkBridgeEnabled) {
            throw new JsonRpcError(RpcErrorCode.TRANSACTION_REJECTED, transactionRejectedCrossSdkBridgeError);
        }
        if (confirmationRequired && !!messageId) {
            const confirmationResult = await this.confirmationScreen.requestMessageConfirmation(messageId);
            if (!confirmationResult.confirmed) {
                throw new JsonRpcError(RpcErrorCode.TRANSACTION_REJECTED, 'Signature rejected by user');
            }
        }
        else {
            this.confirmationScreen.closeWindow();
        }
    }
}

var PassportEvents;
(function (PassportEvents) {
    PassportEvents["LOGGED_OUT"] = "loggedOut";
})(PassportEvents || (PassportEvents = {}));
var Networks;
(function (Networks) {
    Networks["PRODUCTION"] = "mainnet";
    Networks["SANDBOX"] = "goerli";
})(Networks || (Networks = {}));

async function exchangeTransfer({ user, starkSigner, request, exchangesApi, }) {
    return withPassportError(async () => {
        const { ethAddress } = user.imx;
        const transferAmount = request.amount;
        const signableResult = await exchangesApi.getExchangeSignableTransfer({
            id: request.transactionID,
            getSignableTransferRequest: {
                sender: ethAddress,
                token: convertToSignableToken(request),
                amount: transferAmount,
                receiver: request.receiver,
            },
        });
        const starkAddress = await starkSigner.getAddress();
        const { payload_hash: payloadHash } = signableResult.data;
        const starkSignature = await starkSigner.signMessage(payloadHash);
        const transferSigningParams = {
            sender_stark_key: signableResult.data.sender_stark_key || starkAddress,
            sender_vault_id: signableResult.data.sender_vault_id,
            receiver_stark_key: signableResult.data.receiver_stark_key,
            receiver_vault_id: signableResult.data.receiver_vault_id,
            asset_id: signableResult.data.asset_id,
            amount: signableResult.data.amount,
            nonce: signableResult.data.nonce,
            expiration_timestamp: signableResult.data.expiration_timestamp,
            stark_signature: starkSignature,
        };
        const headers = {
            // eslint-disable-next-line @typescript-eslint/naming-convention
            Authorization: `Bearer ${user.accessToken}`,
        };
        const response = await exchangesApi.createExchangeTransfer({
            id: request.transactionID,
            createTransferRequest: transferSigningParams,
        }, { headers });
        return {
            sent_signature: response?.data.sent_signature,
            status: response?.data.status?.toString(),
            time: response?.data.time,
            transfer_id: response?.data.transfer_id,
        };
    }, PassportErrorType.EXCHANGE_TRANSFER_ERROR);
}

const ERC721$1 = 'ERC721';
async function createOrder({ starkSigner, user, request, ordersApi, guardianClient, }) {
    return withPassportError(guardianClient.withDefaultConfirmationScreenTask(async () => {
        const { ethAddress } = user.imx;
        const amountSell = request.sell.type === ERC721$1 ? '1' : request.sell.amount;
        const amountBuy = request.buy.type === ERC721$1 ? '1' : request.buy.amount;
        const headers = {
            // eslint-disable-next-line @typescript-eslint/naming-convention
            Authorization: `Bearer ${user.accessToken}`,
        };
        const getSignableOrderRequestV3 = {
            user: ethAddress,
            amount_buy: amountBuy,
            token_buy: convertToSignableToken(request.buy),
            amount_sell: amountSell,
            token_sell: convertToSignableToken(request.sell),
            fees: request.fees,
            split_fees: true,
            expiration_timestamp: request.expiration_timestamp,
        };
        const getSignableOrderResponse = await ordersApi.getSignableOrder({
            getSignableOrderRequestV3,
        }, { headers });
        await guardianClient.validate({
            payloadHash: getSignableOrderResponse.data.payload_hash,
        });
        const { payload_hash: payloadHash } = getSignableOrderResponse.data;
        const starkSignature = await starkSigner.signMessage(payloadHash);
        const signableResultData = getSignableOrderResponse.data;
        const orderParams = {
            createOrderRequest: {
                include_fees: true,
                fees: request.fees,
                stark_signature: starkSignature,
                amount_buy: signableResultData.amount_buy,
                amount_sell: signableResultData.amount_sell,
                asset_id_buy: signableResultData.asset_id_buy,
                asset_id_sell: signableResultData.asset_id_sell,
                expiration_timestamp: signableResultData.expiration_timestamp,
                nonce: signableResultData.nonce,
                stark_key: signableResultData.stark_key,
                vault_id_buy: signableResultData.vault_id_buy,
                vault_id_sell: signableResultData.vault_id_sell,
            },
        };
        const createOrderResponse = await ordersApi.createOrderV3(orderParams, {
            headers,
        });
        return {
            ...createOrderResponse.data,
        };
    }), PassportErrorType.CREATE_ORDER_ERROR);
}
async function cancelOrder({ user, starkSigner, request, ordersApi, guardianClient, }) {
    return withPassportError(guardianClient.withDefaultConfirmationScreenTask(async () => {
        const getSignableCancelOrderRequest = {
            order_id: request.order_id,
        };
        const headers = {
            // eslint-disable-next-line @typescript-eslint/naming-convention
            Authorization: `Bearer ${user.accessToken}`,
        };
        const getSignableCancelOrderResponse = await ordersApi.getSignableCancelOrderV3({
            getSignableCancelOrderRequest,
        }, { headers });
        await guardianClient.validate({
            payloadHash: getSignableCancelOrderResponse.data.payload_hash,
        });
        const { payload_hash: payloadHash } = getSignableCancelOrderResponse.data;
        const starkSignature = await starkSigner.signMessage(payloadHash);
        const cancelOrderResponse = await ordersApi.cancelOrderV3({
            id: request.order_id.toString(),
            cancelOrderRequest: {
                order_id: request.order_id,
                stark_signature: starkSignature,
            },
        }, { headers });
        return {
            order_id: cancelOrderResponse.data.order_id,
            status: cancelOrderResponse.data.status,
        };
    }), PassportErrorType.CANCEL_ORDER_ERROR);
}

async function registerPassport({ ethSigner, starkSigner, usersApi }, authorization) {
    return withPassportError(async () => {
        const userAddress = await ethSigner.getAddress();
        const starkPublicKey = await starkSigner.getAddress();
        const signableResult = await usersApi.getSignableRegistrationOffchain({
            getSignableRegistrationRequest: {
                ether_key: userAddress,
                stark_key: starkPublicKey,
            },
        });
        const { signable_message: signableMessage, payload_hash: payloadHash } = signableResult.data;
        const ethSignature = await signRaw(signableMessage, ethSigner);
        const starkSignature = await starkSigner.signMessage(payloadHash);
        const response = await usersApi.registerPassportUser({
            authorization: `Bearer ${authorization}`,
            registerPassportUserRequest: {
                eth_signature: ethSignature,
                ether_key: userAddress,
                stark_signature: starkSignature,
                stark_key: starkPublicKey,
            },
        });
        return response.statusText;
    }, PassportErrorType.USER_REGISTRATION_ERROR);
}

async function createTrade({ request, tradesApi, user, starkSigner, guardianClient, }) {
    return withPassportError(guardianClient.withDefaultConfirmationScreenTask(async () => {
        const { ethAddress } = user.imx;
        const getSignableTradeRequest = {
            expiration_timestamp: request.expiration_timestamp,
            fees: request.fees,
            order_id: request.order_id,
            user: ethAddress,
        };
        // eslint-disable-next-line @typescript-eslint/naming-convention
        const headers = { Authorization: `Bearer ${user.accessToken}` };
        const getSignableTradeResponse = await tradesApi.getSignableTrade({
            getSignableTradeRequest,
        }, { headers });
        await guardianClient.validate({
            payloadHash: getSignableTradeResponse.data.payload_hash,
        });
        const { payload_hash: payloadHash } = getSignableTradeResponse.data;
        const starkSignature = await starkSigner.signMessage(payloadHash);
        const { data: signableResultData } = getSignableTradeResponse;
        const tradeParams = {
            createTradeRequest: {
                include_fees: true,
                fees: request?.fees,
                stark_signature: starkSignature,
                order_id: request?.order_id,
                fee_info: signableResultData.fee_info,
                amount_buy: signableResultData.amount_buy,
                amount_sell: signableResultData.amount_sell,
                asset_id_buy: signableResultData.asset_id_buy,
                asset_id_sell: signableResultData.asset_id_sell,
                expiration_timestamp: signableResultData.expiration_timestamp,
                nonce: signableResultData.nonce,
                stark_key: signableResultData.stark_key,
                vault_id_buy: signableResultData.vault_id_buy,
                vault_id_sell: signableResultData.vault_id_sell,
            },
        };
        const { data: createTradeResponse } = await tradesApi.createTradeV3(tradeParams, {
            headers,
        });
        return createTradeResponse;
    }), PassportErrorType.CREATE_TRADE_ERROR);
}

const ERC721 = 'ERC721';
async function transfer({ request, transfersApi, starkSigner, user, guardianClient, }) {
    return withPassportError(guardianClient.withDefaultConfirmationScreenTask(async () => {
        const transferAmount = request.type === ERC721 ? '1' : request.amount;
        const getSignableTransferRequest = {
            sender: user.imx.ethAddress,
            token: convertToSignableToken(request),
            amount: transferAmount,
            receiver: request.receiver,
        };
        const headers = {
            Authorization: `Bearer ${user.accessToken}`,
        };
        const signableResult = await transfersApi.getSignableTransferV1({
            getSignableTransferRequest,
        }, { headers });
        await guardianClient.validate({
            payloadHash: signableResult.data.payload_hash,
        });
        const signableResultData = signableResult.data;
        const { payload_hash: payloadHash } = signableResultData;
        const starkSignature = await starkSigner.signMessage(payloadHash);
        const senderStarkKey = await starkSigner.getAddress();
        const transferSigningParams = {
            sender_stark_key: signableResultData.sender_stark_key || senderStarkKey,
            sender_vault_id: signableResultData.sender_vault_id,
            receiver_stark_key: signableResultData.receiver_stark_key,
            receiver_vault_id: signableResultData.receiver_vault_id,
            asset_id: signableResultData.asset_id,
            amount: signableResultData.amount,
            nonce: signableResultData.nonce,
            expiration_timestamp: signableResultData.expiration_timestamp,
            stark_signature: starkSignature,
        };
        const createTransferRequest = {
            createTransferRequest: transferSigningParams,
        };
        const { data: responseData } = await transfersApi.createTransferV1(createTransferRequest, { headers });
        return {
            sent_signature: responseData.sent_signature,
            status: responseData.status?.toString(),
            time: responseData.time,
            transfer_id: responseData.transfer_id,
        };
    }), PassportErrorType.TRANSFER_ERROR);
}
async function batchNftTransfer({ user, starkSigner, request, transfersApi, guardianClient, }) {
    // eslint-disable-next-line function-paren-newline
    return withPassportError(guardianClient.withConfirmationScreenTask({ width: 480, height: 784 })(async () => {
        const { ethAddress } = user.imx;
        const signableRequests = request.map((nftTransfer) => ({
            amount: '1',
            token: convertToSignableToken({
                type: ERC721,
                tokenId: nftTransfer.tokenId,
                tokenAddress: nftTransfer.tokenAddress,
            }),
            receiver: nftTransfer.receiver,
        }));
        const getSignableTransferRequestV2 = {
            sender_ether_key: ethAddress,
            signable_requests: signableRequests,
        };
        const headers = {
            // eslint-disable-next-line @typescript-eslint/naming-convention
            Authorization: `Bearer ${user.accessToken}`,
        };
        const signableResult = await transfersApi.getSignableTransfer({
            getSignableTransferRequestV2,
        }, { headers });
        await guardianClient.validate({
            payloadHash: signableResult.data.signable_responses[0]?.payload_hash,
        });
        const requests = await Promise.all(signableResult.data.signable_responses.map(async (resp) => {
            const starkSignature = await starkSigner.signMessage(resp.payload_hash);
            return {
                sender_vault_id: resp.sender_vault_id,
                receiver_stark_key: resp.receiver_stark_key,
                receiver_vault_id: resp.receiver_vault_id,
                asset_id: resp.asset_id,
                amount: resp.amount,
                nonce: resp.nonce,
                expiration_timestamp: resp.expiration_timestamp,
                stark_signature: starkSignature,
            };
        }));
        const transferSigningParams = {
            sender_stark_key: signableResult.data.sender_stark_key,
            requests,
        };
        const response = await transfersApi.createTransfer({
            createTransferRequestV2: transferSigningParams,
        }, { headers });
        return {
            transfer_ids: response?.data.transfer_ids,
        };
    }), PassportErrorType.TRANSFER_ERROR);
}

class PassportImxProvider {
    user;
    starkSigner;
    immutableXClient;
    confirmationScreen;
    guardianClient;
    constructor({ user, starkSigner, immutableXClient, confirmationScreen, config, passportEventEmitter, }) {
        this.user = user;
        this.starkSigner = starkSigner;
        this.immutableXClient = immutableXClient;
        this.confirmationScreen = confirmationScreen;
        this.guardianClient = new GuardianClient({
            accessToken: user.accessToken,
            confirmationScreen,
            imxEtherAddress: user.imx.ethAddress,
            config,
        });
        passportEventEmitter.on(PassportEvents.LOGGED_OUT, this.handleLogout);
    }
    handleLogout = () => {
        this.user = undefined;
        this.starkSigner = undefined;
    };
    checkIsLoggedIn() {
        if (this.user === undefined || this.starkSigner === undefined) {
            throw new PassportError('User has been logged out', PassportErrorType.NOT_LOGGED_IN_ERROR);
        }
    }
    async transfer(request) {
        this.checkIsLoggedIn();
        return transfer({
            request,
            user: this.user,
            starkSigner: this.starkSigner,
            transfersApi: this.immutableXClient.transfersApi,
            guardianClient: this.guardianClient,
        });
    }
    // TODO: Remove once implemented
    // eslint-disable-next-line class-methods-use-this
    registerOffchain() {
        throw new PassportError('Operation not supported', PassportErrorType.OPERATION_NOT_SUPPORTED_ERROR);
    }
    // TODO: Remove once implemented
    // eslint-disable-next-line class-methods-use-this
    isRegisteredOnchain() {
        throw new PassportError('Operation not supported', PassportErrorType.OPERATION_NOT_SUPPORTED_ERROR);
    }
    createOrder(request) {
        this.checkIsLoggedIn();
        return createOrder({
            request,
            user: this.user,
            starkSigner: this.starkSigner,
            ordersApi: this.immutableXClient.ordersApi,
            guardianClient: this.guardianClient,
        });
    }
    cancelOrder(request) {
        this.checkIsLoggedIn();
        return cancelOrder({
            request,
            user: this.user,
            starkSigner: this.starkSigner,
            ordersApi: this.immutableXClient.ordersApi,
            guardianClient: this.guardianClient,
        });
    }
    createTrade(request) {
        this.checkIsLoggedIn();
        return createTrade({
            request,
            user: this.user,
            starkSigner: this.starkSigner,
            tradesApi: this.immutableXClient.tradesApi,
            guardianClient: this.guardianClient,
        });
    }
    batchNftTransfer(request) {
        this.checkIsLoggedIn();
        return batchNftTransfer({
            request,
            user: this.user,
            starkSigner: this.starkSigner,
            transfersApi: this.immutableXClient.transfersApi,
            guardianClient: this.guardianClient,
        });
    }
    exchangeTransfer(request) {
        this.checkIsLoggedIn();
        return exchangeTransfer({
            request,
            user: this.user,
            starkSigner: this.starkSigner,
            exchangesApi: this.immutableXClient.exchangeApi,
        });
    }
    // TODO: Remove once implemented
    // eslint-disable-next-line class-methods-use-this, @typescript-eslint/no-unused-vars
    deposit(deposit) {
        throw new PassportError('Operation not supported', PassportErrorType.OPERATION_NOT_SUPPORTED_ERROR);
    }
    // TODO: Remove once implemented
    // eslint-disable-next-line class-methods-use-this, @typescript-eslint/no-unused-vars
    prepareWithdrawal(request) {
        throw new PassportError('Operation not supported', PassportErrorType.OPERATION_NOT_SUPPORTED_ERROR);
    }
    // TODO: Remove once implemented
    // eslint-disable-next-line class-methods-use-this
    completeWithdrawal(
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    starkPublicKey, 
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    token) {
        throw new PassportError('Operation not supported', PassportErrorType.OPERATION_NOT_SUPPORTED_ERROR);
    }
    getAddress() {
        this.checkIsLoggedIn();
        return Promise.resolve(this.user.imx.ethAddress);
    }
}

class PassportImxProviderFactory {
    authManager;
    config;
    confirmationScreen;
    immutableXClient;
    magicAdapter;
    passportEventEmitter;
    constructor({ authManager, config, confirmationScreen, immutableXClient, magicAdapter, passportEventEmitter, }) {
        this.authManager = authManager;
        this.config = config;
        this.confirmationScreen = confirmationScreen;
        this.immutableXClient = immutableXClient;
        this.magicAdapter = magicAdapter;
        this.passportEventEmitter = passportEventEmitter;
    }
    async getProvider() {
        const user = await this.authManager.login();
        return this.createProviderInstance(user);
    }
    async getProviderSilent() {
        const user = await this.authManager.loginSilent();
        if (!user) {
            return null;
        }
        return this.createProviderInstance(user);
    }
    async getProviderWithDeviceFlow(deviceCode, interval, timeoutMs) {
        const user = await this.authManager.connectImxDeviceFlow(deviceCode, interval, timeoutMs);
        return this.createProviderInstance(user);
    }
    async getProviderWithPKCEFlow(authorizationCode, state) {
        const user = await this.authManager.connectImxPKCEFlow(authorizationCode, state);
        return this.createProviderInstance(user);
    }
    async getProviderWithCredentials(tokenResponse) {
        const user = await this.authManager.connectImxWithCredentials(tokenResponse);
        if (!user) {
            return null;
        }
        return this.createProviderInstance(user);
    }
    async createProviderInstance(user) {
        if (!user.idToken) {
            throw new PassportError('Failed to initialise', PassportErrorType.WALLET_CONNECTION_ERROR);
        }
        const magicRpcProvider = await this.magicAdapter.login(user.idToken, this.config.network);
        const web3Provider = new Web3Provider(magicRpcProvider);
        const ethSigner = web3Provider.getSigner();
        const starkSigner = await getStarkSigner(ethSigner);
        if (!user.imx?.ethAddress) {
            const userImx = await this.registerStarkEx(ethSigner, starkSigner, user.accessToken);
            return new PassportImxProvider({
                user: userImx,
                starkSigner,
                immutableXClient: this.immutableXClient,
                confirmationScreen: this.confirmationScreen,
                config: this.config,
                passportEventEmitter: this.passportEventEmitter,
            });
        }
        return new PassportImxProvider({
            user: user,
            starkSigner,
            immutableXClient: this.immutableXClient,
            confirmationScreen: this.confirmationScreen,
            config: this.config,
            passportEventEmitter: this.passportEventEmitter,
        });
    }
    async registerStarkEx(userAdminKeySigner, starkSigner, jwt) {
        return withPassportError(async () => {
            await registerPassport({
                ethSigner: userAdminKeySigner,
                starkSigner,
                usersApi: this.immutableXClient.usersApi,
            }, jwt);
            // User metadata is updated asynchronously. Poll userinfo endpoint until it is updated.
            const updatedUser = await retryWithDelay(async () => {
                const user = await this.authManager.loginSilent();
                const metadataExists = !!user?.imx;
                if (metadataExists) {
                    return user;
                }
                return Promise.reject(new Error('user wallet addresses not exist'));
            });
            return updatedUser;
        }, PassportErrorType.REFRESH_TOKEN_ERROR);
    }
}

const validateConfiguration = (configuration, requiredKeys, prefix) => {
    const missingKeys = requiredKeys
        .map((key) => !configuration[key] && key)
        .filter((n) => n)
        .join(', ');
    if (missingKeys !== '') {
        const errorMessage = prefix
            ? `${prefix} - ${missingKeys} cannot be null`
            : `${missingKeys} cannot be null`;
        throw new PassportError(errorMessage, PassportErrorType.INVALID_CONFIGURATION);
    }
};
class PassportConfiguration {
    network;
    authenticationDomain;
    passportDomain;
    imxPublicApiDomain;
    magicPublishableApiKey;
    magicProviderId;
    oidcConfiguration;
    baseConfig;
    zkEvmRpcUrl;
    relayerUrl;
    multiRollupConfig;
    crossSdkBridgeEnabled;
    constructor({ baseConfig, overrides, crossSdkBridgeEnabled, ...oidcConfiguration }) {
        validateConfiguration(oidcConfiguration, [
            'clientId',
            'logoutRedirectUri',
            'redirectUri',
        ]);
        this.oidcConfiguration = oidcConfiguration;
        this.baseConfig = baseConfig;
        this.crossSdkBridgeEnabled = crossSdkBridgeEnabled || false;
        if (overrides) {
            validateConfiguration(overrides, [
                'network',
                'authenticationDomain',
                'passportDomain',
                'magicPublishableApiKey',
                'magicProviderId',
                'zkEvmRpcUrl',
                'relayerUrl',
                'imxPublicApiDomain',
                'indexerMrBasePath',
                'orderBookMrBasePath',
                'passportMrBasePath',
            ], 'overrides');
            this.network = overrides.network;
            this.authenticationDomain = overrides.authenticationDomain;
            this.passportDomain = overrides.passportDomain;
            this.imxPublicApiDomain = overrides.imxPublicApiDomain;
            this.magicPublishableApiKey = overrides.magicPublishableApiKey;
            this.magicProviderId = overrides.magicProviderId;
            this.zkEvmRpcUrl = overrides.zkEvmRpcUrl;
            this.relayerUrl = overrides.relayerUrl;
            this.multiRollupConfig = {
                indexer: createConfig({
                    basePath: overrides.indexerMrBasePath,
                }),
                orderBook: createConfig({
                    basePath: overrides.orderBookMrBasePath,
                }),
                passport: createConfig({
                    basePath: overrides.passportMrBasePath,
                }),
            };
        }
        else {
            switch (baseConfig.environment) {
                case Environment.PRODUCTION: {
                    this.network = Networks.PRODUCTION;
                    this.authenticationDomain = 'https://auth.immutable.com';
                    this.magicPublishableApiKey = 'pk_live_10F423798A540ED7';
                    this.magicProviderId = 'fSMzaRQ4O7p4fttl7pCyGVtJS_G70P8SNsLXtPPGHo0=';
                    this.passportDomain = 'https://passport.immutable.com';
                    this.imxPublicApiDomain = 'https://api.immutable.com';
                    this.zkEvmRpcUrl = ''; // TODO: ID-785 Update once mainnet has been deployed
                    this.relayerUrl = 'https://api.immutable.com/relayer-mr';
                    this.multiRollupConfig = multiRollupConfig.getProduction();
                    break;
                }
                case Environment.SANDBOX:
                default: {
                    this.network = Networks.SANDBOX;
                    this.authenticationDomain = 'https://auth.immutable.com';
                    this.magicPublishableApiKey = 'pk_live_10F423798A540ED7';
                    this.magicProviderId = 'fSMzaRQ4O7p4fttl7pCyGVtJS_G70P8SNsLXtPPGHo0=';
                    this.passportDomain = 'https://passport.sandbox.immutable.com';
                    this.imxPublicApiDomain = 'https://api.sandbox.immutable.com';
                    this.zkEvmRpcUrl = 'https://rpc.testnet.immutable.com';
                    this.relayerUrl = 'https://api.sandbox.immutable.com/relayer-mr';
                    this.multiRollupConfig = multiRollupConfig.getSandbox();
                    break;
                }
            }
        }
    }
}

var ReceiveMessage;
(function (ReceiveMessage) {
    ReceiveMessage["CONFIRMATION_WINDOW_READY"] = "confirmation_window_ready";
    ReceiveMessage["TRANSACTION_CONFIRMED"] = "transaction_confirmed";
    ReceiveMessage["TRANSACTION_ERROR"] = "transaction_error";
    ReceiveMessage["MESSAGE_CONFIRMED"] = "message_confirmed";
    ReceiveMessage["MESSAGE_REJECTED"] = "message_rejected";
    ReceiveMessage["LOGOUT_SUCCESS"] = "logout_success";
})(ReceiveMessage || (ReceiveMessage = {}));
const PASSPORT_EVENT_TYPE = 'imx_passport_confirmation';

const openPopupCenter = ({ url, title, width, height, }) => {
    const left = Math.max(0, Math.round(window.screenX + (window.outerWidth - width) / 2));
    const top = Math.max(0, Math.round(window.screenY + (window.outerHeight - height) / 2));
    const newWindow = window.open(url, title, `
      scrollbars=yes,
      width=${width}, 
      height=${height}, 
      top=${top}, 
      left=${left}
     `);
    if (!newWindow) {
        throw new Error('Failed to open confirmation screen');
    }
    newWindow.focus();
    return newWindow;
};

const CONFIRMATION_WINDOW_TITLE = 'Confirm this transaction';
const CONFIRMATION_WINDOW_HEIGHT = 380;
const CONFIRMATION_WINDOW_WIDTH = 480;
const CONFIRMATION_WINDOW_CLOSED_POLLING_DURATION = 1000;
const CONFIRMATION_IFRAME_ID = 'passport-confirm';
const CONFIRMATION_IFRAME_STYLE = 'display: none; position: absolute;width:0px;height:0px;border:0;';
class ConfirmationScreen {
    config;
    confirmationWindow;
    constructor(config) {
        this.config = config;
    }
    requestConfirmation(transactionId, imxEtherAddress, chainType, chainId) {
        return new Promise((resolve, reject) => {
            const messageHandler = ({ data, origin }) => {
                if (origin !== this.config.passportDomain
                    || data.eventType !== PASSPORT_EVENT_TYPE) {
                    return;
                }
                switch (data.messageType) {
                    case ReceiveMessage.CONFIRMATION_WINDOW_READY: {
                        break;
                    }
                    case ReceiveMessage.TRANSACTION_CONFIRMED: {
                        resolve({ confirmed: true });
                        break;
                    }
                    case ReceiveMessage.TRANSACTION_ERROR: {
                        reject(new Error('Transaction error'));
                        break;
                    }
                    default:
                        reject(new Error('Unsupported message type'));
                }
            };
            if (!this.confirmationWindow) {
                resolve({ confirmed: false });
                return;
            }
            window.addEventListener('message', messageHandler);
            let href = '';
            if (chainType === TransactionApprovalRequestChainTypeEnum.Starkex) {
                // eslint-disable-next-line max-len
                href = `${this.config.passportDomain}/transaction-confirmation/transaction?transactionId=${transactionId}&imxEtherAddress=${imxEtherAddress}&chainType=starkex`;
            }
            else {
                // eslint-disable-next-line max-len
                href = `${this.config.passportDomain}/transaction-confirmation/zkevm?transactionId=${transactionId}&imxEtherAddress=${imxEtherAddress}&chainType=evm&chainId=${chainId}`;
            }
            this.showConfirmationScreen(href, messageHandler, resolve);
        });
    }
    requestMessageConfirmation(messageId) {
        return new Promise((resolve, reject) => {
            const messageHandler = ({ data, origin }) => {
                if (origin !== this.config.passportDomain
                    || data.eventType !== PASSPORT_EVENT_TYPE) {
                    return;
                }
                switch (data.messageType) {
                    case ReceiveMessage.CONFIRMATION_WINDOW_READY: {
                        break;
                    }
                    case ReceiveMessage.MESSAGE_CONFIRMED: {
                        resolve({ confirmed: true });
                        break;
                    }
                    case ReceiveMessage.MESSAGE_REJECTED: {
                        reject(new Error('Message rejected'));
                        break;
                    }
                    default:
                        reject(new Error('Unsupported message type'));
                }
            };
            if (!this.confirmationWindow) {
                resolve({ confirmed: false });
                return;
            }
            window.addEventListener('message', messageHandler);
            const href = `${this.config.passportDomain}/transaction-confirmation/zkevm/message?messageID=${messageId}`;
            this.showConfirmationScreen(href, messageHandler, resolve);
        });
    }
    loading(popupOptions) {
        if (this.config.crossSdkBridgeEnabled) {
            // There is no need to open a confirmation window if cross-sdk bridge is enabled
            return;
        }
        this.confirmationWindow = openPopupCenter({
            url: `${this.config.passportDomain}/transaction-confirmation/loading`,
            title: CONFIRMATION_WINDOW_TITLE,
            width: popupOptions?.width || CONFIRMATION_WINDOW_WIDTH,
            height: popupOptions?.height || CONFIRMATION_WINDOW_HEIGHT,
        });
    }
    closeWindow() {
        this.confirmationWindow?.close();
    }
    logout() {
        return new Promise((resolve, rejects) => {
            const iframe = document.createElement('iframe');
            iframe.setAttribute('id', CONFIRMATION_IFRAME_ID);
            iframe.setAttribute('src', `${this.config.passportDomain}/transaction-confirmation/logout`);
            iframe.setAttribute('style', CONFIRMATION_IFRAME_STYLE);
            const logoutHandler = ({ data, origin }) => {
                if (origin !== this.config.passportDomain
                    || data.eventType !== PASSPORT_EVENT_TYPE) {
                    return;
                }
                window.removeEventListener('message', logoutHandler);
                iframe.remove();
                if (data.messageType === ReceiveMessage.LOGOUT_SUCCESS) {
                    resolve({ logout: true });
                }
                rejects(new Error('Unsupported logout type'));
            };
            window.addEventListener('message', logoutHandler);
            document.body.appendChild(iframe);
        });
    }
    showConfirmationScreen(href, messageHandler, resolve) {
        this.confirmationWindow.location.href = href;
        // https://stackoverflow.com/questions/9388380/capture-the-close-event-of-popup-window-in-javascript/48240128#48240128
        const timer = setInterval(() => {
            if (this.confirmationWindow?.closed) {
                clearInterval(timer);
                window.removeEventListener('message', messageHandler);
                resolve({ confirmed: false });
            }
        }, CONFIRMATION_WINDOW_CLOSED_POLLING_DURATION);
    }
}

var RelayerTransactionStatus;
(function (RelayerTransactionStatus) {
    RelayerTransactionStatus["PENDING"] = "PENDING";
    RelayerTransactionStatus["SUBMITTED"] = "SUBMITTED";
    RelayerTransactionStatus["SUCCESSFUL"] = "SUCCESSFUL";
    RelayerTransactionStatus["REVERTED"] = "REVERTED";
    RelayerTransactionStatus["FAILED"] = "FAILED";
})(RelayerTransactionStatus || (RelayerTransactionStatus = {}));
var ProviderEvent;
(function (ProviderEvent) {
    ProviderEvent["ACCOUNTS_CHANGED"] = "accountsChanged";
})(ProviderEvent || (ProviderEvent = {}));

class TypedEventEmitter {
    emitter = new EventEmitter();
    emit(eventName, ...eventArg) {
        this.emitter.emit(eventName, ...eventArg);
    }
    on(eventName, handler) {
        this.emitter.on(eventName, handler);
    }
    removeListener(eventName, handler) {
        this.emitter.removeListener(eventName, handler);
    }
}

const SIGNATURE_WEIGHT = 1; // Weight of a single signature in the multi-sig
const TRANSACTION_SIGNATURE_THRESHOLD = 1; // Total required weight in the multi-sig for a transaction
const EIP712_SIGNATURE_THRESHOLD = 2; // Total required weight in the multi-sig for data signing
const ETH_SIGN_FLAG = '02';
const ETH_SIGN_PREFIX = '\x19\x01';
const META_TRANSACTIONS_TYPE = `tuple(
  bool delegateCall,
  bool revertOnError,
  uint256 gasLimit,
  address target,
  uint256 value,
  bytes data
)[]`;
function getNormalisedTransactions(txs) {
    return txs.map((t) => ({
        delegateCall: t.delegateCall === true,
        revertOnError: t.revertOnError === true,
        gasLimit: t.gasLimit ?? ethers.constants.Zero,
        target: t.to ?? ethers.constants.AddressZero,
        value: t.value ?? ethers.constants.Zero,
        data: t.data ?? [],
    }));
}
function digestOfTransactionsAndNonce(nonce, normalisedTransactions) {
    const packMetaTransactionsNonceData = ethers.utils.defaultAbiCoder.encode(['uint256', META_TRANSACTIONS_TYPE], [nonce, normalisedTransactions]);
    return ethers.utils.keccak256(packMetaTransactionsNonceData);
}
const getNonce = async (jsonRpcProvider, smartContractWalletAddress) => {
    const code = await jsonRpcProvider.send('eth_getCode', [smartContractWalletAddress, 'latest']);
    if (code && code !== '0x') {
        const contract = new ethers.Contract(smartContractWalletAddress, walletContracts.mainModule.abi, jsonRpcProvider);
        return contract.nonce();
    }
    return 0;
};
const encodeMessageSubDigest = (chainId, walletAddress, digest) => (ethers.utils.solidityPack(['string', 'uint256', 'address', 'bytes32'], [ETH_SIGN_PREFIX, chainId, walletAddress, digest]));
const getSignedMetaTransactions = async (metaTransactions, nonce, chainId, walletAddress, signer) => {
    const normalisedMetaTransactions = getNormalisedTransactions(metaTransactions);
    // Get the hash
    const digest = digestOfTransactionsAndNonce(nonce, normalisedMetaTransactions);
    const completePayload = encodeMessageSubDigest(chainId, walletAddress, digest);
    const hash = ethers.utils.keccak256(completePayload);
    // Sign the digest
    const hashArray = ethers.utils.arrayify(hash);
    const ethsigNoType = await signer.signMessage(hashArray);
    const signedDigest = `${ethsigNoType}${ETH_SIGN_FLAG}`;
    // Add metadata
    const encodedSignature = encodeSignature({
        threshold: TRANSACTION_SIGNATURE_THRESHOLD,
        signers: [
            {
                weight: SIGNATURE_WEIGHT,
                signature: signedDigest,
            },
        ],
    });
    // Encode the transaction;
    const walletInterface = new ethers.utils.Interface(walletContracts.mainModule.abi);
    return walletInterface.encodeFunctionData(walletInterface.getFunction('execute'), [
        normalisedMetaTransactions,
        nonce,
        encodedSignature,
    ]);
};
const decodeRelayerTypedDataSignature = (relayerSignature) => {
    const signatureWithThreshold = `0000${relayerSignature}`;
    return decodeSignature(signatureWithThreshold);
};
const getSignedTypedData = async (typedData, relayerSignature, chainId, walletAddress, signer) => {
    // Ethers auto-generates the EIP712Domain type in the TypedDataEncoder, and so it needs to be removed
    const types = { ...typedData.types };
    // @ts-ignore
    delete types.EIP712Domain;
    // eslint-disable-next-line no-underscore-dangle
    const digest = ethers.utils._TypedDataEncoder.hash(typedData.domain, types, typedData.message);
    const completePayload = encodeMessageSubDigest(chainId, walletAddress, digest);
    const hash = ethers.utils.keccak256(completePayload);
    // Sign the digest
    const hashArray = ethers.utils.arrayify(hash);
    const ethsigNoType = await signer.signMessage(hashArray);
    const signedDigest = `${ethsigNoType}${ETH_SIGN_FLAG}`;
    const { signers } = decodeRelayerTypedDataSignature(relayerSignature);
    return encodeSignature({
        threshold: EIP712_SIGNATURE_THRESHOLD,
        signers: [
            ...signers,
            {
                weight: SIGNATURE_WEIGHT,
                signature: signedDigest,
            },
        ],
    });
};
const getEip155ChainId = (chainId) => `eip155:${chainId}`;

class RelayerClient {
    config;
    jsonRpcProvider;
    user;
    constructor({ config, jsonRpcProvider, user }) {
        this.config = config;
        this.jsonRpcProvider = jsonRpcProvider;
        this.user = user;
    }
    async postToRelayer(request) {
        const body = {
            id: 1,
            jsonrpc: '2.0',
            ...request,
        };
        const response = await fetch(`${this.config.relayerUrl}/v1/transactions`, {
            method: 'POST',
            headers: {
                Authorization: `Bearer ${this.user.accessToken}`,
                'Content-Type': 'application/json',
            },
            body: JSON.stringify(body),
        });
        const jsonResponse = await response.json();
        if (jsonResponse.error) {
            throw jsonResponse.error;
        }
        return jsonResponse;
    }
    async ethSendTransaction(to, data) {
        const { chainId } = await this.jsonRpcProvider.ready;
        const payload = {
            method: 'eth_sendTransaction',
            params: [{
                    to,
                    data,
                    chainId: getEip155ChainId(chainId),
                }],
        };
        const { result } = await this.postToRelayer(payload);
        return result;
    }
    async imGetTransactionByHash(hash) {
        const payload = {
            method: 'im_getTransactionByHash',
            params: [hash],
        };
        const { result } = await this.postToRelayer(payload);
        return result;
    }
    async imGetFeeOptions(userAddress, data) {
        const { chainId } = await this.jsonRpcProvider.ready;
        const payload = {
            method: 'im_getFeeOptions',
            params: [{
                    userAddress,
                    data,
                    chainId: getEip155ChainId(chainId),
                }],
        };
        const { result } = await this.postToRelayer(payload);
        return result;
    }
    async imSignTypedData(address, eip712Payload) {
        const { chainId } = await this.jsonRpcProvider.ready;
        const payload = {
            method: 'im_signTypedData',
            params: [{
                    address,
                    eip712Payload,
                    chainId: getEip155ChainId(chainId),
                }],
        };
        const { result } = await this.postToRelayer(payload);
        return result;
    }
}

const MESSAGE_TO_SIGN = 'Only sign this message from Immutable Passport';
async function registerZkEvmUser({ authManager, config, magicProvider, multiRollupApiClients, accessToken, }) {
    const web3Provider = new Web3Provider(magicProvider);
    const ethSigner = web3Provider.getSigner();
    const ethereumAddress = await ethSigner.getAddress();
    const ethereumSignature = await signRaw(MESSAGE_TO_SIGN, ethSigner);
    const headers = { Authorization: `Bearer ${accessToken}` };
    try {
        await multiRollupApiClients.passportApi.createCounterfactualAddress({
            createCounterfactualAddressRequest: {
                ethereumAddress,
                ethereumSignature,
            },
        }, { headers });
    }
    catch (error) {
        throw new JsonRpcError(RpcErrorCode.INTERNAL_ERROR, `Failed to create counterfactual address: ${error}`);
    }
    let user;
    if (config.crossSdkBridgeEnabled) {
        const credentials = authManager.checkStoredDeviceFlowCredentials();
        if (!credentials || !credentials.refresh_token) {
            throw new JsonRpcError(RpcErrorCode.INTERNAL_ERROR, 'Cross SDK bridge: Failed to refresh user details');
        }
        user = await authManager.refreshToken(credentials.refresh_token);
    }
    else {
        user = await authManager.loginSilent();
    }
    if (!user?.zkEvm) {
        throw new JsonRpcError(RpcErrorCode.INTERNAL_ERROR, 'Failed to refresh user details');
    }
    return user;
}

const loginZkEvmUser = async ({ authManager, config, magicAdapter, multiRollupApiClients, }) => {
    const user = await authManager.getUser() || await authManager.getUserDeviceFlow() || await authManager.login();
    if (!user.idToken) {
        throw new Error('User is missing idToken');
    }
    const magicProvider = await magicAdapter.login(user.idToken, config.network);
    if (!user.zkEvm) {
        // Generate counterfactual address and retrieve updated Auth0 user
        const userZkevm = await registerZkEvmUser({
            authManager,
            config,
            magicProvider,
            multiRollupApiClients,
            accessToken: user.accessToken,
        });
        return {
            user: userZkevm,
            magicProvider,
        };
    }
    return {
        user: user,
        magicProvider,
    };
};

const MAX_TRANSACTION_HASH_RETRIEVAL_RETRIES = 30;
const TRANSACTION_HASH_RETRIEVAL_WAIT = 1000;
const sendTransaction = ({ params, magicProvider, jsonRpcProvider, relayerClient, guardianClient, user, }) => guardianClient
    .withConfirmationScreen({ width: 480, height: 520 })(async () => {
    const transactionRequest = params[0];
    if (!transactionRequest.to) {
        throw new JsonRpcError(RpcErrorCode.INVALID_PARAMS, 'eth_sendTransaction requires a "to" field');
    }
    const { chainId } = await jsonRpcProvider.ready;
    const chainIdBigNumber = BigNumber.from(chainId);
    const magicWeb3Provider = new Web3Provider(magicProvider);
    const signer = magicWeb3Provider.getSigner();
    const nonce = await getNonce(jsonRpcProvider, user.zkEvm.ethAddress);
    const metaTransaction = {
        to: transactionRequest.to,
        data: transactionRequest.data,
        nonce,
        value: transactionRequest.value,
        revertOnError: true,
    };
    // NOTE: We sign the transaction before getting the fee options because
    // accurate estimation of a transaction gas cost is only possible if the smart
    // wallet contract can actually execute it (in a simulated environment) - and
    // it can only execute signed transactions.
    const signedTransaction = await getSignedMetaTransactions([metaTransaction], nonce, chainIdBigNumber, user.zkEvm.ethAddress, signer);
    // TODO: ID-698 Add support for non-native gas payments (e.g ERC20, feeTransaction initialisation must change)
    // NOTE: "Fee Options" represent the multiple ways we could pay for the gas
    // used in this transaction. Each fee option has a "recipientAddress" we
    // should transfer the payment to, an amount and a currency. We choose one
    // option and build a transaction that sends the expected currency amount for
    // that option to the specified address.
    const feeOptions = await relayerClient.imGetFeeOptions(user.zkEvm.ethAddress, signedTransaction);
    const imxFeeOption = feeOptions.find((feeOption) => feeOption.tokenSymbol === 'IMX');
    if (!imxFeeOption) {
        throw new Error('Failed to retrieve fees for IMX token');
    }
    const feeMetaTransaction = {
        nonce,
        to: imxFeeOption.recipientAddress,
        value: imxFeeOption.tokenPrice,
        revertOnError: true,
    };
    await guardianClient.validateEVMTransaction({
        chainId: getEip155ChainId(chainId),
        nonce: convertBigNumberishToString(nonce),
        user,
        metaTransactions: [metaTransaction, feeMetaTransaction],
    });
    // NOTE: We sign again because we now are adding the fee transaction, so the
    // whole payload is different and needs a new signature.
    const signedTransactions = await getSignedMetaTransactions([metaTransaction, feeMetaTransaction], nonce, chainIdBigNumber, user.zkEvm.ethAddress, signer);
    const relayerId = await relayerClient.ethSendTransaction(user.zkEvm.ethAddress, signedTransactions);
    const retrieveRelayerTransaction = async () => {
        const tx = await relayerClient.imGetTransactionByHash(relayerId);
        // NOTE: The transaction hash is only available from the Relayer once the
        // transaction is actually submitted onchain. Hence we need to poll the
        // Relayer get transaction endpoint until the status transitions to one that
        // has the hash available.
        if (tx.status === RelayerTransactionStatus.PENDING) {
            throw new Error();
        }
        return tx;
    };
    const relayerTransaction = await retryWithDelay(retrieveRelayerTransaction, {
        retries: MAX_TRANSACTION_HASH_RETRIEVAL_RETRIES,
        interval: TRANSACTION_HASH_RETRIEVAL_WAIT,
        finalErr: new JsonRpcError(RpcErrorCode.RPC_SERVER_ERROR, 'transaction hash not generated in time'),
    });
    if (![
        RelayerTransactionStatus.SUBMITTED,
        RelayerTransactionStatus.SUCCESSFUL,
    ].includes(relayerTransaction.status)) {
        let errorMessage = `Transaction failed to submit with status ${relayerTransaction.status}.`;
        if (relayerTransaction.statusMessage) {
            errorMessage += ` Error message: ${relayerTransaction.statusMessage}`;
        }
        throw new JsonRpcError(RpcErrorCode.RPC_SERVER_ERROR, errorMessage);
    }
    return relayerTransaction.hash;
});

const REQUIRED_TYPED_DATA_PROPERTIES = ['types', 'domain', 'primaryType', 'message'];
const isValidTypedDataPayload = (typedData) => (REQUIRED_TYPED_DATA_PROPERTIES.every((key) => key in typedData));
const transformTypedData = (typedData, chainId) => {
    let transformedTypedData;
    if (typeof typedData === 'string') {
        try {
            transformedTypedData = JSON.parse(typedData);
        }
        catch (err) {
            throw new JsonRpcError(RpcErrorCode.INVALID_PARAMS, `Failed to parse typed data JSON: ${err}`);
        }
    }
    else if (typeof typedData === 'object') {
        transformedTypedData = typedData;
    }
    else {
        throw new JsonRpcError(RpcErrorCode.INVALID_PARAMS, `Invalid typed data argument: ${typedData}`);
    }
    if (!isValidTypedDataPayload(transformedTypedData)) {
        throw new JsonRpcError(RpcErrorCode.INVALID_PARAMS, `Invalid typed data argument. The following properties are required: ${REQUIRED_TYPED_DATA_PROPERTIES.join(', ')}`);
    }
    const providedChainId = transformedTypedData.domain?.chainId;
    if (providedChainId) {
        // domain.chainId (if defined) can be a number, string, or hex value, but the relayer & guardian only accept a number.
        if (typeof providedChainId === 'string') {
            if (providedChainId.startsWith('0x')) {
                transformedTypedData.domain.chainId = parseInt(providedChainId, 16);
            }
            else {
                transformedTypedData.domain.chainId = parseInt(providedChainId, 10);
            }
        }
        if (transformedTypedData.domain.chainId !== chainId) {
            throw new JsonRpcError(RpcErrorCode.INVALID_PARAMS, `Invalid chainId, expected ${chainId}`);
        }
    }
    return transformedTypedData;
};
const signTypedDataV4 = async ({ params, method, magicProvider, jsonRpcProvider, relayerClient, guardianClient, user, }) => guardianClient
    .withConfirmationScreen({ width: 480, height: 730 })(async () => {
    const fromAddress = params[0];
    const typedDataParam = params[1];
    if (!fromAddress || !typedDataParam) {
        throw new JsonRpcError(RpcErrorCode.INVALID_PARAMS, `${method} requires an address and a typed data JSON`);
    }
    const { chainId } = await jsonRpcProvider.ready;
    const typedData = transformTypedData(typedDataParam, chainId);
    await guardianClient.validateMessage({ chainID: String(chainId), payload: typedData, user });
    const relayerSignature = await relayerClient.imSignTypedData(fromAddress, typedData);
    const magicWeb3Provider = new Web3Provider(magicProvider);
    const signer = magicWeb3Provider.getSigner();
    return getSignedTypedData(typedData, relayerSignature, BigNumber.from(chainId), fromAddress, signer);
});

class ZkEvmProvider {
    authManager;
    config;
    confirmationScreen;
    magicAdapter;
    multiRollupApiClients;
    jsonRpcProvider; // Used for read
    eventEmitter;
    guardianClient;
    relayerClient;
    magicProvider; // Used for signing
    user;
    isPassport = true;
    constructor({ authManager, magicAdapter, config, confirmationScreen, multiRollupApiClients, passportEventEmitter, }) {
        this.authManager = authManager;
        this.magicAdapter = magicAdapter;
        this.config = config;
        this.confirmationScreen = confirmationScreen;
        this.jsonRpcProvider = new JsonRpcProvider(this.config.zkEvmRpcUrl);
        this.multiRollupApiClients = multiRollupApiClients;
        this.eventEmitter = new TypedEventEmitter();
        passportEventEmitter.on(PassportEvents.LOGGED_OUT, this.handleLogout);
    }
    handleLogout = () => {
        const shouldEmitAccountsChanged = this.isLoggedIn();
        this.magicProvider = undefined;
        this.user = undefined;
        this.relayerClient = undefined;
        this.guardianClient = undefined;
        if (shouldEmitAccountsChanged) {
            this.eventEmitter.emit(ProviderEvent.ACCOUNTS_CHANGED, []);
        }
    };
    isLoggedIn() {
        return this.magicProvider !== undefined
            && this.user !== undefined
            && this.relayerClient !== undefined
            && this.guardianClient !== undefined;
    }
    async performRequest(request) {
        switch (request.method) {
            case 'eth_requestAccounts': {
                if (this.isLoggedIn()) {
                    return [this.user.zkEvm.ethAddress];
                }
                const { magicProvider, user } = await loginZkEvmUser({
                    authManager: this.authManager,
                    config: this.config,
                    magicAdapter: this.magicAdapter,
                    multiRollupApiClients: this.multiRollupApiClients,
                });
                this.user = user;
                this.magicProvider = magicProvider;
                this.relayerClient = new RelayerClient({
                    config: this.config,
                    jsonRpcProvider: this.jsonRpcProvider,
                    user: this.user,
                });
                this.guardianClient = new GuardianClient({
                    accessToken: this.user.accessToken,
                    confirmationScreen: this.confirmationScreen,
                    imxEtherAddress: this.user.zkEvm.ethAddress,
                    config: this.config,
                });
                this.eventEmitter.emit(ProviderEvent.ACCOUNTS_CHANGED, [this.user.zkEvm.ethAddress]);
                return [this.user.zkEvm.ethAddress];
            }
            case 'eth_sendTransaction': {
                if (!this.isLoggedIn()) {
                    throw new JsonRpcError(ProviderErrorCode.UNAUTHORIZED, 'Unauthorised - call eth_requestAccounts first');
                }
                return sendTransaction({
                    params: request.params || [],
                    magicProvider: this.magicProvider,
                    guardianClient: this.guardianClient,
                    jsonRpcProvider: this.jsonRpcProvider,
                    relayerClient: this.relayerClient,
                    user: this.user,
                });
            }
            case 'eth_accounts': {
                return this.isLoggedIn() ? [this.user.zkEvm.ethAddress] : [];
            }
            case 'eth_signTypedData':
            case 'eth_signTypedData_v4': {
                if (!this.isLoggedIn()) {
                    throw new JsonRpcError(ProviderErrorCode.UNAUTHORIZED, 'Unauthorised - call eth_requestAccounts first');
                }
                return signTypedDataV4({
                    method: request.method,
                    params: request.params || [],
                    magicProvider: this.magicProvider,
                    jsonRpcProvider: this.jsonRpcProvider,
                    relayerClient: this.relayerClient,
                    user: this.user,
                    guardianClient: this.guardianClient,
                });
            }
            // Pass through methods
            case 'eth_gasPrice':
            case 'eth_getBalance':
            case 'eth_getCode':
            case 'eth_getStorageAt':
            case 'eth_estimateGas':
            case 'eth_call':
            case 'eth_blockNumber':
            case 'eth_chainId':
            case 'eth_getBlockByHash':
            case 'eth_getBlockByNumber':
            case 'eth_getTransactionByHash':
            case 'eth_getTransactionReceipt':
            case 'eth_getTransactionCount': {
                return this.jsonRpcProvider.send(request.method, request.params || []);
            }
            default: {
                throw new JsonRpcError(ProviderErrorCode.UNSUPPORTED_METHOD, 'Method not supported');
            }
        }
    }
    async performJsonRpcRequest(request) {
        const { id, jsonrpc } = request;
        try {
            const result = await this.performRequest(request);
            return {
                id,
                jsonrpc,
                result,
            };
        }
        catch (error) {
            let jsonRpcError;
            if (error instanceof JsonRpcError) {
                jsonRpcError = error;
            }
            else if (error instanceof Error) {
                jsonRpcError = new JsonRpcError(RpcErrorCode.INTERNAL_ERROR, error.message);
            }
            else {
                jsonRpcError = new JsonRpcError(RpcErrorCode.INTERNAL_ERROR, 'Internal error');
            }
            return {
                id,
                jsonrpc,
                error: jsonRpcError,
            };
        }
    }
    async request(request) {
        try {
            return this.performRequest(request);
        }
        catch (error) {
            if (error instanceof JsonRpcError) {
                throw error;
            }
            if (error instanceof Error) {
                throw new JsonRpcError(RpcErrorCode.INTERNAL_ERROR, error.message);
            }
            throw new JsonRpcError(RpcErrorCode.INTERNAL_ERROR, 'Internal error');
        }
    }
    sendAsync(request, callback) {
        if (!callback) {
            throw new Error('No callback provided');
        }
        if (Array.isArray(request)) {
            Promise.all(request.map(this.performJsonRpcRequest)).then((result) => {
                callback(null, result);
            }).catch((error) => {
                callback(error, []);
            });
        }
        else {
            this.performJsonRpcRequest(request).then((result) => {
                callback(null, result);
            }).catch((error) => {
                callback(error, null);
            });
        }
    }
    async send(request, callbackOrParams, callback) {
        // Web3 >= 1.0.0-beta.38 calls `send` with method and parameters.
        if (typeof request === 'string') {
            if (typeof callbackOrParams === 'function') {
                return this.sendAsync({
                    method: request,
                    params: [],
                }, callbackOrParams);
            }
            if (callback) {
                return this.sendAsync({
                    method: request,
                    params: Array.isArray(callbackOrParams) ? callbackOrParams : [],
                }, callback);
            }
            return this.request({
                method: request,
                params: Array.isArray(callbackOrParams) ? callbackOrParams : [],
            });
        }
        // Web3 <= 1.0.0-beta.37 uses `send` with a callback for async queries.
        if (typeof callbackOrParams === 'function') {
            return this.sendAsync(request, callbackOrParams);
        }
        if (!Array.isArray(request) && typeof request === 'object') {
            return this.performJsonRpcRequest(request);
        }
        throw new JsonRpcError(RpcErrorCode.INVALID_REQUEST, 'Invalid request');
    }
    on(event, listener) {
        this.eventEmitter.on(event, listener);
    }
    removeListener(event, listener) {
        this.eventEmitter.removeListener(event, listener);
    }
}

class Passport {
    authManager;
    config;
    confirmationScreen;
    immutableXClient;
    magicAdapter;
    multiRollupApiClients;
    passportImxProviderFactory;
    passportEventEmitter;
    constructor(passportModuleConfiguration) {
        this.config = new PassportConfiguration(passportModuleConfiguration);
        this.authManager = new AuthManager(this.config);
        this.magicAdapter = new MagicAdapter(this.config);
        this.confirmationScreen = new ConfirmationScreen(this.config);
        this.immutableXClient = passportModuleConfiguration.overrides?.immutableXClient
            || new ImmutableXClient({
                baseConfig: passportModuleConfiguration.baseConfig,
            });
        this.multiRollupApiClients = new MultiRollupApiClients(this.config.multiRollupConfig);
        this.passportEventEmitter = new TypedEventEmitter();
        this.passportImxProviderFactory = new PassportImxProviderFactory({
            authManager: this.authManager,
            config: this.config,
            confirmationScreen: this.confirmationScreen,
            immutableXClient: this.immutableXClient,
            magicAdapter: this.magicAdapter,
            passportEventEmitter: this.passportEventEmitter,
        });
    }
    async connectImxSilent() {
        return this.passportImxProviderFactory.getProviderSilent();
    }
    async connectImx() {
        return this.passportImxProviderFactory.getProvider();
    }
    async loginWithDeviceFlow() {
        return this.authManager.loginWithDeviceFlow();
    }
    async connectImxDeviceFlow(deviceCode, interval, timeoutMs) {
        return this.passportImxProviderFactory.getProviderWithDeviceFlow(deviceCode, interval, timeoutMs);
    }
    getPKCEAuthorizationUrl() {
        return this.authManager.getPKCEAuthorizationUrl();
    }
    async connectImxPKCEFlow(authorizationCode, state) {
        return this.passportImxProviderFactory.getProviderWithPKCEFlow(authorizationCode, state);
    }
    /**
     * @returns {boolean} the stored device flow credentials if they exist
     */
    checkStoredDeviceFlowCredentials() {
        return this.authManager.checkStoredDeviceFlowCredentials();
    }
    async connectImxWithCredentials(tokenResponse) {
        return this.passportImxProviderFactory.getProviderWithCredentials(tokenResponse);
    }
    connectEvm() {
        if (this.config.network === Networks.PRODUCTION) {
            throw new Error('EVM is not supported on production network');
        }
        return new ZkEvmProvider({
            passportEventEmitter: this.passportEventEmitter,
            authManager: this.authManager,
            magicAdapter: this.magicAdapter,
            config: this.config,
            confirmationScreen: this.confirmationScreen,
            multiRollupApiClients: this.multiRollupApiClients,
        });
    }
    async loginCallback() {
        return this.authManager.loginCallback();
    }
    async logout() {
        await this.authManager.logout();
        await this.confirmationScreen.logout();
        // Code after this point is only executed if the logout mode is silent
        await this.magicAdapter.logout();
        this.passportEventEmitter.emit(PassportEvents.LOGGED_OUT);
    }
    /**
     * This method should only be called from the logout redirect uri
     * when logout mode is 'silent'.
     */
    async logoutSilentCallback(url) {
        return this.authManager.logoutSilentCallback(url);
    }
    async logoutDeviceFlow() {
        return this.authManager.logoutDeviceFlow();
    }
    async getUserInfo() {
        const user = await this.authManager.getUser();
        return user?.profile;
    }
    async getUserInfoDeviceFlow() {
        const user = await this.authManager.getUserDeviceFlow();
        return user?.profile;
    }
    async getIdToken() {
        const user = await this.authManager.getUser();
        return user?.idToken;
    }
    async getAccessToken() {
        const user = await this.authManager.getUser();
        return user?.accessToken;
    }
    async getLinkedAddresses() {
        const user = await this.authManager.getUser();
        if (!user?.profile.sub) {
            return [];
        }
        const headers = { Authorization: `Bearer ${user.accessToken}` };
        const linkedAddressesResult = await this.multiRollupApiClients.passportApi.getLinkedAddresses({
            userId: user?.profile.sub,
        }, { headers });
        return linkedAddressesResult.data.linkedAddresses;
    }
}

export { JsonRpcError, Networks, Passport, PassportError, ProviderErrorCode, ProviderEvent, RpcErrorCode };
