import axios from 'axios';
import FormData from 'form-data';
import { providers, BigNumber, constants as constants$1 } from 'ethers';
import { Seaport as Seaport$1 } from '@opensea/seaport-js';

var Environment;
(function (Environment) {
    Environment["PRODUCTION"] = "production";
    Environment["SANDBOX"] = "sandbox";
})(Environment || (Environment = {}));

class BaseHttpRequest {
    config;
    constructor(config) {
        this.config = config;
    }
}

class ApiError extends Error {
    url;
    status;
    statusText;
    body;
    request;
    constructor(request, response, message) {
        super(message);
        this.name = 'ApiError';
        this.url = response.url;
        this.status = response.status;
        this.statusText = response.statusText;
        this.body = response.body;
        this.request = request;
    }
}

/* istanbul ignore file */
/* tslint:disable */
/* eslint-disable */
class CancelError extends Error {
    constructor(message) {
        super(message);
        this.name = 'CancelError';
    }
    get isCancelled() {
        return true;
    }
}
class CancelablePromise {
    [Symbol.toStringTag];
    _isResolved;
    _isRejected;
    _isCancelled;
    _cancelHandlers;
    _promise;
    _resolve;
    _reject;
    constructor(executor) {
        this._isResolved = false;
        this._isRejected = false;
        this._isCancelled = false;
        this._cancelHandlers = [];
        this._promise = new Promise((resolve, reject) => {
            this._resolve = resolve;
            this._reject = reject;
            const onResolve = (value) => {
                if (this._isResolved || this._isRejected || this._isCancelled) {
                    return;
                }
                this._isResolved = true;
                this._resolve?.(value);
            };
            const onReject = (reason) => {
                if (this._isResolved || this._isRejected || this._isCancelled) {
                    return;
                }
                this._isRejected = true;
                this._reject?.(reason);
            };
            const onCancel = (cancelHandler) => {
                if (this._isResolved || this._isRejected || this._isCancelled) {
                    return;
                }
                this._cancelHandlers.push(cancelHandler);
            };
            Object.defineProperty(onCancel, 'isResolved', {
                get: () => this._isResolved,
            });
            Object.defineProperty(onCancel, 'isRejected', {
                get: () => this._isRejected,
            });
            Object.defineProperty(onCancel, 'isCancelled', {
                get: () => this._isCancelled,
            });
            return executor(onResolve, onReject, onCancel);
        });
    }
    then(onFulfilled, onRejected) {
        return this._promise.then(onFulfilled, onRejected);
    }
    catch(onRejected) {
        return this._promise.catch(onRejected);
    }
    finally(onFinally) {
        return this._promise.finally(onFinally);
    }
    cancel() {
        if (this._isResolved || this._isRejected || this._isCancelled) {
            return;
        }
        this._isCancelled = true;
        if (this._cancelHandlers.length) {
            try {
                for (const cancelHandler of this._cancelHandlers) {
                    cancelHandler();
                }
            }
            catch (error) {
                console.warn('Cancellation threw an error', error);
                return;
            }
        }
        this._cancelHandlers.length = 0;
        this._reject?.(new CancelError('Request aborted'));
    }
    get isCancelled() {
        return this._isCancelled;
    }
}

/* istanbul ignore file */
/* tslint:disable */
/* eslint-disable */
const isDefined = (value) => {
    return value !== undefined && value !== null;
};
const isString = (value) => {
    return typeof value === 'string';
};
const isStringWithValue = (value) => {
    return isString(value) && value !== '';
};
const isBlob = (value) => {
    return (typeof value === 'object' &&
        typeof value.type === 'string' &&
        typeof value.stream === 'function' &&
        typeof value.arrayBuffer === 'function' &&
        typeof value.constructor === 'function' &&
        typeof value.constructor.name === 'string' &&
        /^(Blob|File)$/.test(value.constructor.name) &&
        /^(Blob|File)$/.test(value[Symbol.toStringTag]));
};
const isFormData = (value) => {
    return value instanceof FormData;
};
const isSuccess = (status) => {
    return status >= 200 && status < 300;
};
const base64 = (str) => {
    try {
        return btoa(str);
    }
    catch (err) {
        // @ts-ignore
        return Buffer.from(str).toString('base64');
    }
};
const getQueryString = (params) => {
    const qs = [];
    const append = (key, value) => {
        qs.push(`${encodeURIComponent(key)}=${encodeURIComponent(String(value))}`);
    };
    const process = (key, value) => {
        if (isDefined(value)) {
            if (Array.isArray(value)) {
                value.forEach(v => {
                    process(key, v);
                });
            }
            else if (typeof value === 'object') {
                Object.entries(value).forEach(([k, v]) => {
                    process(`${key}[${k}]`, v);
                });
            }
            else {
                append(key, value);
            }
        }
    };
    Object.entries(params).forEach(([key, value]) => {
        process(key, value);
    });
    if (qs.length > 0) {
        return `?${qs.join('&')}`;
    }
    return '';
};
const getUrl = (config, options) => {
    const encoder = config.ENCODE_PATH || encodeURI;
    const path = options.url
        .replace('{api-version}', config.VERSION)
        .replace(/{(.*?)}/g, (substring, group) => {
        if (options.path?.hasOwnProperty(group)) {
            return encoder(String(options.path[group]));
        }
        return substring;
    });
    const url = `${config.BASE}${path}`;
    if (options.query) {
        return `${url}${getQueryString(options.query)}`;
    }
    return url;
};
const getFormData = (options) => {
    if (options.formData) {
        const formData = new FormData();
        const process = (key, value) => {
            if (isString(value) || isBlob(value)) {
                formData.append(key, value);
            }
            else {
                formData.append(key, JSON.stringify(value));
            }
        };
        Object.entries(options.formData)
            .filter(([_, value]) => isDefined(value))
            .forEach(([key, value]) => {
            if (Array.isArray(value)) {
                value.forEach(v => process(key, v));
            }
            else {
                process(key, value);
            }
        });
        return formData;
    }
    return undefined;
};
const resolve = async (options, resolver) => {
    if (typeof resolver === 'function') {
        return resolver(options);
    }
    return resolver;
};
const getHeaders = async (config, options, formData) => {
    const token = await resolve(options, config.TOKEN);
    const username = await resolve(options, config.USERNAME);
    const password = await resolve(options, config.PASSWORD);
    const additionalHeaders = await resolve(options, config.HEADERS);
    const formHeaders = typeof formData?.getHeaders === 'function' && formData?.getHeaders() || {};
    const headers = Object.entries({
        Accept: 'application/json',
        ...additionalHeaders,
        ...options.headers,
        ...formHeaders,
    })
        .filter(([_, value]) => isDefined(value))
        .reduce((headers, [key, value]) => ({
        ...headers,
        [key]: String(value),
    }), {});
    if (isStringWithValue(token)) {
        headers['Authorization'] = `Bearer ${token}`;
    }
    if (isStringWithValue(username) && isStringWithValue(password)) {
        const credentials = base64(`${username}:${password}`);
        headers['Authorization'] = `Basic ${credentials}`;
    }
    if (options.body) {
        if (options.mediaType) {
            headers['Content-Type'] = options.mediaType;
        }
        else if (isBlob(options.body)) {
            headers['Content-Type'] = options.body.type || 'application/octet-stream';
        }
        else if (isString(options.body)) {
            headers['Content-Type'] = 'text/plain';
        }
        else if (!isFormData(options.body)) {
            headers['Content-Type'] = 'application/json';
        }
    }
    return headers;
};
const getRequestBody = (options) => {
    if (options.body) {
        return options.body;
    }
    return undefined;
};
const sendRequest = async (config, options, url, body, formData, headers, onCancel) => {
    const source = axios.CancelToken.source();
    const requestConfig = {
        url,
        headers,
        data: body ?? formData,
        method: options.method,
        withCredentials: config.WITH_CREDENTIALS,
        cancelToken: source.token,
    };
    onCancel(() => source.cancel('The user aborted a request.'));
    try {
        return await axios.request(requestConfig);
    }
    catch (error) {
        const axiosError = error;
        if (axiosError.response) {
            return axiosError.response;
        }
        throw error;
    }
};
const getResponseHeader = (response, responseHeader) => {
    if (responseHeader) {
        const content = response.headers[responseHeader];
        if (isString(content)) {
            return content;
        }
    }
    return undefined;
};
const getResponseBody = (response) => {
    if (response.status !== 204) {
        return response.data;
    }
    return undefined;
};
const catchErrorCodes = (options, result) => {
    const errors = {
        400: 'Bad Request',
        401: 'Unauthorized',
        403: 'Forbidden',
        404: 'Not Found',
        500: 'Internal Server Error',
        502: 'Bad Gateway',
        503: 'Service Unavailable',
        ...options.errors,
    };
    const error = errors[result.status];
    if (error) {
        throw new ApiError(options, result, error);
    }
    if (!result.ok) {
        throw new ApiError(options, result, 'Generic Error');
    }
};
/**
 * Request method
 * @param config The OpenAPI configuration object
 * @param options The request options from the service
 * @returns CancelablePromise<T>
 * @throws ApiError
 */
const request = (config, options) => {
    return new CancelablePromise(async (resolve, reject, onCancel) => {
        try {
            const url = getUrl(config, options);
            const formData = getFormData(options);
            const body = getRequestBody(options);
            const headers = await getHeaders(config, options, formData);
            if (!onCancel.isCancelled) {
                const response = await sendRequest(config, options, url, body, formData, headers, onCancel);
                const responseBody = getResponseBody(response);
                const responseHeader = getResponseHeader(response, options.responseHeader);
                const result = {
                    url,
                    ok: isSuccess(response.status),
                    status: response.status,
                    statusText: response.statusText,
                    body: responseHeader ?? responseBody,
                };
                catchErrorCodes(options, result);
                resolve(result.body);
            }
        }
        catch (error) {
            reject(error);
        }
    });
};

class AxiosHttpRequest extends BaseHttpRequest {
    constructor(config) {
        super(config);
    }
    /**
     * Request method
     * @param options The request options from the service
     * @returns CancelablePromise<T>
     * @throws ApiError
     */
    request(options) {
        return request(this.config, options);
    }
}

class OrdersService {
    httpRequest;
    constructor(httpRequest) {
        this.httpRequest = httpRequest;
    }
    /**
     * List all listings
     * List all listings
     * @returns ListListingsResult OK response.
     * @throws ApiError
     */
    listListings({ chainName, status, sellItemContractAddress, buyItemContractAddress, sellItemTokenId, pageSize, sortBy, sortDirection, pageCursor, }) {
        return this.httpRequest.request({
            method: 'GET',
            url: '/v1/chains/{chain_name}/orders/listings',
            path: {
                'chain_name': chainName,
            },
            query: {
                'status': status,
                'sell_item_contract_address': sellItemContractAddress,
                'buy_item_contract_address': buyItemContractAddress,
                'sell_item_token_id': sellItemTokenId,
                'page_size': pageSize,
                'sort_by': sortBy,
                'sort_direction': sortDirection,
                'page_cursor': pageCursor,
            },
            errors: {
                400: `Bad Request (400)`,
                404: `The specified resource was not found (404)`,
                500: `Internal Server Error (500)`,
            },
        });
    }
    /**
     * Create a listing
     * Create a listing
     * @returns ListingResult Created response.
     * @throws ApiError
     */
    createListing({ chainName, requestBody, }) {
        return this.httpRequest.request({
            method: 'POST',
            url: '/v1/chains/{chain_name}/orders/listings',
            path: {
                'chain_name': chainName,
            },
            body: requestBody,
            mediaType: 'application/json',
            errors: {
                400: `Bad Request (400)`,
                404: `The specified resource was not found (404)`,
                500: `Internal Server Error (500)`,
            },
        });
    }
    /**
     * Get a single listing by ID
     * Get a single listing by ID
     * @returns ListingResult OK response.
     * @throws ApiError
     */
    getListing({ chainName, listingId, }) {
        return this.httpRequest.request({
            method: 'GET',
            url: '/v1/chains/{chain_name}/orders/listings/{listing_id}',
            path: {
                'chain_name': chainName,
                'listing_id': listingId,
            },
            errors: {
                400: `Bad Request (400)`,
                404: `The specified resource was not found (404)`,
                500: `Internal Server Error (500)`,
            },
        });
    }
    /**
     * Retrieve fulfillment data for orders
     * Retrieve signed fulfillment data based on the list of order IDs and corresponding fees.
     * @returns any Successful response
     * @throws ApiError
     */
    fulfillmentData({ chainName, requestBody, }) {
        return this.httpRequest.request({
            method: 'POST',
            url: '/v1/chains/{chain_name}/orders/fulfillment-data',
            path: {
                'chain_name': chainName,
            },
            body: requestBody,
            mediaType: 'application/json',
            errors: {
                400: `Bad Request (400)`,
                404: `The specified resource was not found (404)`,
                500: `Internal Server Error (500)`,
            },
        });
    }
    /**
     * List all trades
     * List all trades
     * @returns ListTradeResult OK response.
     * @throws ApiError
     */
    listTrades({ chainName, accountAddress, pageSize, sortBy, sortDirection, pageCursor, }) {
        return this.httpRequest.request({
            method: 'GET',
            url: '/v1/chains/{chain_name}/trades',
            path: {
                'chain_name': chainName,
            },
            query: {
                'account_address': accountAddress,
                'page_size': pageSize,
                'sort_by': sortBy,
                'sort_direction': sortDirection,
                'page_cursor': pageCursor,
            },
            errors: {
                400: `Bad Request (400)`,
                404: `The specified resource was not found (404)`,
                500: `Internal Server Error (500)`,
            },
        });
    }
    /**
     * Get a single trade by ID
     * Get a single trade by ID
     * @returns TradeResult OK response.
     * @throws ApiError
     */
    getTrade({ chainName, tradeId, }) {
        return this.httpRequest.request({
            method: 'GET',
            url: '/v1/chains/{chain_name}/trades/{trade_id}',
            path: {
                'chain_name': chainName,
                'trade_id': tradeId,
            },
            errors: {
                400: `Bad Request (400)`,
                404: `The specified resource was not found (404)`,
                500: `Internal Server Error (500)`,
            },
        });
    }
}

class OrderBookClient {
    orders;
    request;
    constructor(config, HttpRequest = AxiosHttpRequest) {
        this.request = new HttpRequest({
            BASE: config?.BASE ?? 'https://api.sandbox.immutable.com',
            VERSION: config?.VERSION ?? '1.0.0',
            WITH_CREDENTIALS: config?.WITH_CREDENTIALS ?? false,
            CREDENTIALS: config?.CREDENTIALS ?? 'include',
            TOKEN: config?.TOKEN,
            USERNAME: config?.USERNAME,
            PASSWORD: config?.PASSWORD,
            HEADERS: config?.HEADERS,
            ENCODE_PATH: config?.ENCODE_PATH,
        });
        this.orders = new OrdersService(this.request);
    }
}

/* istanbul ignore file */
/* tslint:disable */
/* eslint-disable */
var Fee;
(function (Fee) {
    (function (fee_type) {
        fee_type["ROYALTY"] = "ROYALTY";
        fee_type["MAKER_ECOSYSTEM"] = "MAKER_ECOSYSTEM";
        fee_type["TAKER_ECOSYSTEM"] = "TAKER_ECOSYSTEM";
        fee_type["PROTOCOL"] = "PROTOCOL";
    })(Fee.fee_type || (Fee.fee_type = {}));
})(Fee || (Fee = {}));

/* istanbul ignore file */
/* tslint:disable */
/* eslint-disable */
/**
 * The Order status
 */
var OrderStatus;
(function (OrderStatus) {
    OrderStatus["PENDING"] = "PENDING";
    OrderStatus["ACTIVE"] = "ACTIVE";
    OrderStatus["INACTIVE"] = "INACTIVE";
    OrderStatus["FILLED"] = "FILLED";
    OrderStatus["CANCELLED"] = "CANCELLED";
    OrderStatus["EXPIRED"] = "EXPIRED";
})(OrderStatus || (OrderStatus = {}));

/* istanbul ignore file */
/* tslint:disable */
/* eslint-disable */
var ProtocolData;
(function (ProtocolData) {
    (function (order_type) {
        order_type["FULL_RESTRICTED"] = "FULL_RESTRICTED";
    })(ProtocolData.order_type || (ProtocolData.order_type = {}));
})(ProtocolData || (ProtocolData = {}));

var FeeType;
(function (FeeType) {
    FeeType["MAKER_ECOSYSTEM"] = "MAKER_ECOSYSTEM";
    FeeType["TAKER_ECOSYSTEM"] = "TAKER_ECOSYSTEM";
    FeeType["PROTOCOL"] = "PROTOCOL";
    FeeType["ROYALTY"] = "ROYALTY";
})(FeeType || (FeeType = {}));
var TransactionPurpose;
(function (TransactionPurpose) {
    TransactionPurpose["APPROVAL"] = "APPROVAL";
    TransactionPurpose["FULFILL_ORDER"] = "FULFILL_ORDER";
})(TransactionPurpose || (TransactionPurpose = {}));
var SignablePurpose;
(function (SignablePurpose) {
    SignablePurpose["CREATE_LISTING"] = "CREATE_LISTING";
})(SignablePurpose || (SignablePurpose = {}));
var ActionType;
(function (ActionType) {
    ActionType["TRANSACTION"] = "TRANSACTION";
    ActionType["SIGNABLE"] = "SIGNABLE";
})(ActionType || (ActionType = {}));

function mapFromOpenApiOrder(order) {
    const buyItems = order.buy.map((item) => {
        if (item.item_type === 'ERC20') {
            return {
                type: 'ERC20',
                contractAddress: item.contract_address,
                amount: item.start_amount,
            };
        }
        if (item.item_type === 'NATIVE') {
            return {
                type: 'NATIVE',
                amount: item.start_amount,
            };
        }
        throw new Error('Buy items must be either ERC20 or NATIVE');
    });
    const sellItems = order.sell.map((item) => {
        if (item.item_type === 'ERC721') {
            return {
                type: 'ERC721',
                contractAddress: item.contract_address,
                tokenId: item.token_id,
            };
        }
        throw new Error('Sell items must ERC721');
    });
    return {
        id: order.id,
        accountAddress: order.account_address,
        buy: buyItems,
        sell: sellItems,
        fees: order.fees.map((fee) => ({
            amount: fee.amount,
            recipient: fee.recipient,
            type: fee.fee_type,
        })),
        chain: order.chain,
        createdAt: order.created_at,
        endAt: order.end_at,
        protocolData: {
            counter: order.protocol_data.counter,
            orderType: order.protocol_data.order_type,
            seaportAddress: order.protocol_data.seaport_address,
            seaportVersion: order.protocol_data.seaport_version,
            zoneAddress: order.protocol_data.zone_address,
        },
        salt: order.salt,
        signature: order.signature,
        startAt: order.start_at,
        status: order.status,
        updatedAt: order.updated_at,
    };
}
function mapFromOpenApiTrade(trade) {
    const buyItems = trade.buy.map((item) => {
        if (item.item_type === 'ERC20') {
            return {
                type: 'ERC20',
                contractAddress: item.contract_address,
                amount: item.start_amount,
            };
        }
        if (item.item_type === 'NATIVE') {
            return {
                type: 'NATIVE',
                amount: item.start_amount,
            };
        }
        throw new Error('Buy items must be either ERC20 or NATIVE');
    });
    const sellItems = trade.sell.map((item) => {
        if (item.item_type === 'ERC721') {
            return {
                type: 'ERC721',
                contractAddress: item.contract_address,
                tokenId: item.token_id,
            };
        }
        throw new Error('Sell items must ERC721');
    });
    return {
        id: trade.id,
        orderId: trade.order_id,
        buy: buyItems,
        sell: sellItems,
        buyerFees: trade.buyer_fees.map((fee) => ({
            amount: fee.amount,
            recipient: fee.recipient,
            type: fee.fee_type,
        })),
        chain: trade.chain,
        indexedAt: trade.indexed_at,
        blockchainMetadata: {
            blockNumber: trade.blockchain_metadata.block_number,
            logIndex: trade.blockchain_metadata.log_index,
            transactionHash: trade.blockchain_metadata.transaction_hash,
            transactionIndex: trade.blockchain_metadata.transaction_index,
        },
        buyerAddress: trade.buyer_address,
        makerAddress: trade.maker_address,
        sellerAddress: trade.seller_address,
        takerAddress: trade.taker_address,
    };
}
function mapFromOpenApiPage(page) {
    return {
        nextCursor: page.next_cursor,
        previousCursor: page.previous_cursor,
    };
}

/* eslint-disable */
// TODO: Resolve these from seaport-js.
// There is some bundling issue that is preventing this from working
const SEAPORT_CONTRACT_NAME = 'ImmutableSeaport';
// export const SEAPORT_CONTRACT_VERSION_V1_4 = '1.4';
const SEAPORT_CONTRACT_VERSION_V1_5 = '1.5';
const EIP_712_ORDER_TYPE = {
    OrderComponents: [
        { name: 'offerer', type: 'address' },
        { name: 'zone', type: 'address' },
        { name: 'offer', type: 'OfferItem[]' },
        { name: 'consideration', type: 'ConsiderationItem[]' },
        { name: 'orderType', type: 'uint8' },
        { name: 'startTime', type: 'uint256' },
        { name: 'endTime', type: 'uint256' },
        { name: 'zoneHash', type: 'bytes32' },
        { name: 'salt', type: 'uint256' },
        { name: 'conduitKey', type: 'bytes32' },
        { name: 'counter', type: 'uint256' },
    ],
    OfferItem: [
        { name: 'itemType', type: 'uint8' },
        { name: 'token', type: 'address' },
        { name: 'identifierOrCriteria', type: 'uint256' },
        { name: 'startAmount', type: 'uint256' },
        { name: 'endAmount', type: 'uint256' },
    ],
    ConsiderationItem: [
        { name: 'itemType', type: 'uint8' },
        { name: 'token', type: 'address' },
        { name: 'identifierOrCriteria', type: 'uint256' },
        { name: 'startAmount', type: 'uint256' },
        { name: 'endAmount', type: 'uint256' },
        { name: 'recipient', type: 'address' },
    ],
};
var OrderType;
(function (OrderType) {
    OrderType[OrderType["FULL_OPEN"] = 0] = "FULL_OPEN";
    OrderType[OrderType["PARTIAL_OPEN"] = 1] = "PARTIAL_OPEN";
    OrderType[OrderType["FULL_RESTRICTED"] = 2] = "FULL_RESTRICTED";
    OrderType[OrderType["PARTIAL_RESTRICTED"] = 3] = "PARTIAL_RESTRICTED";
})(OrderType || (OrderType = {}));
var ItemType;
(function (ItemType) {
    ItemType[ItemType["NATIVE"] = 0] = "NATIVE";
    ItemType[ItemType["ERC20"] = 1] = "ERC20";
    ItemType[ItemType["ERC721"] = 2] = "ERC721";
    ItemType[ItemType["ERC1155"] = 3] = "ERC1155";
    ItemType[ItemType["ERC721_WITH_CRITERIA"] = 4] = "ERC721_WITH_CRITERIA";
    ItemType[ItemType["ERC1155_WITH_CRITERIA"] = 5] = "ERC1155_WITH_CRITERIA";
})(ItemType || (ItemType = {}));
var Side;
(function (Side) {
    Side[Side["OFFER"] = 0] = "OFFER";
    Side[Side["CONSIDERATION"] = 1] = "CONSIDERATION";
})(Side || (Side = {}));
var BasicOrderRouteType;
(function (BasicOrderRouteType) {
    BasicOrderRouteType[BasicOrderRouteType["ETH_TO_ERC721"] = 0] = "ETH_TO_ERC721";
    BasicOrderRouteType[BasicOrderRouteType["ETH_TO_ERC1155"] = 1] = "ETH_TO_ERC1155";
    BasicOrderRouteType[BasicOrderRouteType["ERC20_TO_ERC721"] = 2] = "ERC20_TO_ERC721";
    BasicOrderRouteType[BasicOrderRouteType["ERC20_TO_ERC1155"] = 3] = "ERC20_TO_ERC1155";
    BasicOrderRouteType[BasicOrderRouteType["ERC721_TO_ERC20"] = 4] = "ERC721_TO_ERC20";
    BasicOrderRouteType[BasicOrderRouteType["ERC1155_TO_ERC20"] = 5] = "ERC1155_TO_ERC20";
})(BasicOrderRouteType || (BasicOrderRouteType = {}));

function getOrderComponentsFromMessage(orderMessage) {
    const data = JSON.parse(orderMessage);
    const orderComponents = data.message;
    orderComponents.salt = BigNumber.from(orderComponents.salt).toHexString();
    return orderComponents;
}

// Add 20% more gas than estimate to prevent out of gas errors
// This can always be overwritten by the user signing the transaction
function prepareTransaction(transactionMethods) {
    return async () => {
        const transaction = await transactionMethods.buildTransaction();
        transaction.gasLimit = await transactionMethods.estimateGas();
        transaction.gasLimit = transaction.gasLimit
            .add(transaction.gasLimit.div(5));
        return transaction;
    };
}

function mapImmutableOrderToSeaportOrderComponents(order, counter, zoneAddress) {
    const considerationItems = order.buy.map((buyItem) => {
        switch (buyItem.item_type) {
            case 'NATIVE':
                return {
                    startAmount: buyItem.start_amount,
                    endAmount: buyItem.start_amount,
                    itemType: ItemType.NATIVE,
                    recipient: order.account_address,
                    token: constants$1.AddressZero,
                    identifierOrCriteria: '0',
                };
            case 'ERC20':
                return {
                    startAmount: buyItem.start_amount,
                    endAmount: buyItem.start_amount,
                    itemType: ItemType.ERC20,
                    recipient: order.account_address,
                    token: buyItem.contract_address || constants$1.AddressZero,
                    identifierOrCriteria: '0',
                };
            default: // ERC721
                return {
                    startAmount: '1',
                    endAmount: '1',
                    itemType: ItemType.ERC721,
                    recipient: order.account_address,
                    token: buyItem.contract_address || constants$1.AddressZero,
                    identifierOrCriteria: '0',
                };
        }
    });
    const fees = order.fees.map((fee) => ({
        amount: fee.amount,
        itemType: order.buy[0].item_type === 'ERC20' ? ItemType.ERC20 : ItemType.NATIVE,
        recipient: fee.recipient,
        token: order.buy[0].item_type === 'ERC20'
            ? order.buy[0].contract_address
            : constants$1.AddressZero,
        identifierOrCriteria: '0',
    }));
    return {
        orderComponents: {
            conduitKey: constants$1.HashZero,
            consideration: [...considerationItems],
            offer: order.sell.map((sellItem) => {
                const erc721Item = sellItem;
                return {
                    startAmount: '1',
                    endAmount: '1',
                    itemType: ItemType.ERC721,
                    token: erc721Item.contract_address,
                    identifierOrCriteria: erc721Item.token_id,
                };
            }),
            counter,
            endTime: Math.round(new Date(order.end_at).getTime() / 1000).toString(),
            startTime: Math.round(new Date(order.start_at).getTime() / 1000).toString(),
            salt: order.salt,
            offerer: order.account_address,
            zone: zoneAddress,
            // this should be the fee exclusive number of items the user signed for
            totalOriginalConsiderationItems: considerationItems.length,
            orderType: OrderType.FULL_RESTRICTED,
            zoneHash: constants$1.HashZero,
        },
        tips: fees,
    };
}

class Seaport {
    seaportLibFactory;
    provider;
    seaportContractAddress;
    zoneContractAddress;
    constructor(seaportLibFactory, provider, seaportContractAddress, zoneContractAddress) {
        this.seaportLibFactory = seaportLibFactory;
        this.provider = provider;
        this.seaportContractAddress = seaportContractAddress;
        this.zoneContractAddress = zoneContractAddress;
    }
    async prepareSeaportOrder(offerer, listingItem, considerationItem, orderStart, orderExpiry) {
        const { actions: seaportActions } = await this.createSeaportOrder(offerer, listingItem, considerationItem, orderStart, orderExpiry);
        const listingActions = [];
        const approvalAction = seaportActions.find((action) => action.type === 'approval');
        if (approvalAction) {
            listingActions.push({
                type: ActionType.TRANSACTION,
                purpose: TransactionPurpose.APPROVAL,
                buildTransaction: prepareTransaction(approvalAction.transactionMethods),
            });
        }
        const createAction = seaportActions.find((action) => action.type === 'create');
        if (!createAction) {
            throw new Error('No create order action found');
        }
        const orderMessageToSign = await createAction.getMessageToSign();
        const orderComponents = getOrderComponentsFromMessage(orderMessageToSign);
        listingActions.push({
            type: ActionType.SIGNABLE,
            purpose: SignablePurpose.CREATE_LISTING,
            message: await this.getTypedDataFromOrderComponents(orderComponents),
        });
        return {
            actions: listingActions,
            orderComponents,
            orderHash: this.getSeaportLib().getOrderHash(orderComponents),
        };
    }
    async fulfillOrder(order, account, extraData) {
        const { orderComponents, tips } = this.mapImmutableOrderToSeaportOrderComponents(order);
        const seaportLib = this.getSeaportLib(order);
        const { actions: seaportActions } = await seaportLib.fulfillOrders({
            accountAddress: account,
            fulfillOrderDetails: [
                {
                    order: {
                        parameters: orderComponents,
                        signature: order.signature,
                    },
                    extraData,
                    tips,
                },
            ],
        });
        const fulfillmentActions = [];
        const approvalAction = seaportActions.find((action) => action.type === 'approval');
        if (approvalAction) {
            fulfillmentActions.push({
                type: ActionType.TRANSACTION,
                buildTransaction: prepareTransaction(approvalAction.transactionMethods),
                purpose: TransactionPurpose.APPROVAL,
            });
        }
        const fulfilOrderAction = seaportActions.find((action) => action.type === 'exchange');
        if (!fulfilOrderAction) {
            throw new Error('No exchange action found');
        }
        fulfillmentActions.push({
            type: ActionType.TRANSACTION,
            buildTransaction: prepareTransaction(fulfilOrderAction.transactionMethods),
            purpose: TransactionPurpose.FULFILL_ORDER,
        });
        // Expirtaion bytes in SIP7 extra data [21:29]
        // In hex string -> [21 * 2 + 2 (0x) : 29 * 2]
        // In JS slice (start, end_inclusive), (44,60)
        // 8 bytes uint64 epoch time in seconds
        const expirationHex = extraData.slice(44, 60);
        const expirationInSeconds = parseInt(expirationHex, 16);
        return {
            actions: fulfillmentActions,
            expiration: (new Date(expirationInSeconds * 1000)).toISOString(),
            order: mapFromOpenApiOrder(order),
        };
    }
    async cancelOrder(order, account) {
        const { orderComponents } = this.mapImmutableOrderToSeaportOrderComponents(order);
        const seaportLib = this.getSeaportLib(order);
        const cancellationTransaction = await seaportLib.cancelOrders([orderComponents], account);
        return prepareTransaction(cancellationTransaction)();
    }
    mapImmutableOrderToSeaportOrderComponents(order) {
        const orderCounter = order.protocol_data.counter;
        return mapImmutableOrderToSeaportOrderComponents(order, orderCounter, this.zoneContractAddress);
    }
    createSeaportOrder(offerer, listingItem, considerationItem, orderStart, orderExpiry) {
        const seaportLib = this.getSeaportLib();
        return seaportLib.createOrder({
            allowPartialFills: false,
            offer: [
                {
                    itemType: ItemType.ERC721,
                    token: listingItem.contractAddress,
                    identifier: listingItem.tokenId,
                },
            ],
            consideration: [
                {
                    token: considerationItem.type === 'ERC20'
                        ? considerationItem.contractAddress
                        : undefined,
                    amount: considerationItem.amount,
                    recipient: offerer,
                },
            ],
            startTime: (orderStart.getTime() / 1000).toFixed(0),
            endTime: (orderExpiry.getTime() / 1000).toFixed(0),
            zone: this.zoneContractAddress,
            restrictedByZone: true,
        }, offerer);
    }
    async getTypedDataFromOrderComponents(orderComponents) {
        const { chainId } = await this.provider.getNetwork();
        const domainData = {
            name: SEAPORT_CONTRACT_NAME,
            version: SEAPORT_CONTRACT_VERSION_V1_5,
            chainId,
            verifyingContract: this.seaportContractAddress,
        };
        return {
            domain: domainData,
            types: EIP_712_ORDER_TYPE,
            value: orderComponents,
        };
    }
    getSeaportLib(order) {
        const seaportAddress = order?.protocol_data?.seaport_address ?? this.seaportContractAddress;
        const seaportVersion = SEAPORT_CONTRACT_VERSION_V1_5;
        // if (order?.protocol_data?.seaport_version === SEAPORT_CONTRACT_VERSION_V1_5) {
        //   seaportVersion = SEAPORT_CONTRACT_VERSION_V1_5;
        // }
        return this.seaportLibFactory.create(seaportVersion, seaportAddress);
    }
}

class ImmutableApiClient {
    orderbookService;
    chainName;
    seaportAddress;
    constructor(orderbookService, chainName, seaportAddress) {
        this.orderbookService = orderbookService;
        this.chainName = chainName;
        this.seaportAddress = seaportAddress;
    }
    async fulfillmentData(requests) {
        return this.orderbookService.fulfillmentData({
            chainName: this.chainName,
            requestBody: requests,
        });
    }
    async getListing(listingId) {
        return this.orderbookService.getListing({
            chainName: this.chainName,
            listingId,
        });
    }
    async getTrade(tradeId) {
        return this.orderbookService.getTrade({
            chainName: this.chainName,
            tradeId,
        });
    }
    async listListings(listOrderParams) {
        return this.orderbookService.listListings({
            chainName: this.chainName,
            ...listOrderParams,
        });
    }
    async listTrades(listTradesParams) {
        return this.orderbookService.listTrades({
            chainName: this.chainName,
            ...listTradesParams,
        });
    }
    async createListing({ orderHash, orderComponents, orderSignature, makerFees, }) {
        if (orderComponents.offer.length !== 1) {
            throw new Error('Only one item can be listed at a time');
        }
        if (Number(orderComponents.offer[0].itemType) !== ItemType.ERC721) {
            throw new Error('Only ERC721 tokens can be listed');
        }
        const orderTypes = [
            ...orderComponents.consideration.map((c) => c.itemType),
        ];
        const isSameConsiderationType = new Set(orderTypes).size === 1;
        if (!isSameConsiderationType) {
            throw new Error('All consideration items must be of the same type');
        }
        return this.orderbookService.createListing({
            chainName: this.chainName,
            requestBody: {
                order_hash: orderHash,
                account_address: orderComponents.offerer,
                buy: [
                    {
                        item_type: Number(orderComponents.consideration[0].itemType)
                            === ItemType.NATIVE
                            ? 'NATIVE'
                            : 'ERC20',
                        start_amount: orderComponents.consideration[0].startAmount,
                        contract_address: orderComponents.consideration[0].token,
                    },
                ],
                fees: makerFees.map((x) => ({
                    amount: x.amount,
                    fee_type: FeeType.MAKER_ECOSYSTEM,
                    recipient: x.recipient,
                })),
                end_at: new Date(parseInt(`${orderComponents.endTime.toString()}000`, 10)).toISOString(),
                protocol_data: {
                    order_type: ProtocolData.order_type.FULL_RESTRICTED,
                    zone_address: orderComponents.zone,
                    seaport_address: this.seaportAddress,
                    seaport_version: SEAPORT_CONTRACT_VERSION_V1_5,
                    counter: orderComponents.counter.toString(),
                },
                salt: orderComponents.salt,
                sell: [
                    {
                        contract_address: orderComponents.offer[0].token,
                        token_id: orderComponents.offer[0].identifierOrCriteria,
                        item_type: 'ERC721',
                    },
                ],
                signature: orderSignature,
                start_at: new Date(parseInt(`${orderComponents.startTime.toString()}000`, 10)).toISOString(),
            },
        });
    }
}

class ImmutableApiClientFactory {
    chainName;
    seaportAddress;
    orderbookClient;
    constructor(apiEndpoint, chainName, seaportAddress) {
        this.chainName = chainName;
        this.seaportAddress = seaportAddress;
        this.orderbookClient = new OrderBookClient({
            // eslint-disable-next-line @typescript-eslint/naming-convention
            BASE: apiEndpoint,
        });
    }
    create() {
        return new ImmutableApiClient(this.orderbookClient.orders, this.chainName, this.seaportAddress);
    }
}

const TESTNET_CHAIN_NAME = 'imtbl-zkevm-testnet';
const MAINNET_CHAIN_NAME = 'imtbl-zkevm-mainnet';
function getOrderbookConfig(environment) {
    switch (environment) {
        case Environment.SANDBOX:
            return {
                seaportContractAddress: '0x7Fb7Da6De152597830eD16361633e362A2F59410',
                zoneContractAddress: '0x63441cBfBd15Dd8f5E92598E535661Ac5aCB808E',
                apiEndpoint: 'https://api.sandbox.immutable.com',
                chainName: TESTNET_CHAIN_NAME,
                provider: new providers.JsonRpcProvider('https://rpc.testnet.immutable.com'),
            };
        // not yet deployed
        case Environment.PRODUCTION:
            return {
                seaportContractAddress: '',
                zoneContractAddress: '',
                apiEndpoint: 'https://api.immutable.com',
                chainName: MAINNET_CHAIN_NAME,
                provider: new providers.JsonRpcProvider('https://rpc.immutable.com'),
            };
        default:
            return null;
    }
}

class SeaportLibFactory {
    defaultSeaportContractAddress;
    provider;
    constructor(defaultSeaportContractAddress, provider) {
        this.defaultSeaportContractAddress = defaultSeaportContractAddress;
        this.provider = provider;
    }
    create(orderSeaportVersion, orderSeaportAddress) {
        const seaportVersion = orderSeaportVersion ?? SEAPORT_CONTRACT_VERSION_V1_5;
        const seaportContractAddress = orderSeaportAddress ?? this.defaultSeaportContractAddress;
        return new Seaport$1(this.provider, {
            seaportVersion,
            balanceAndApprovalChecksOnOrderCreation: true,
            overrides: {
                contractAddress: seaportContractAddress,
            },
        });
    }
}

/**
 * zkEVM orderbook SDK
 * @constructor
 * @param {OrderbookModuleConfiguration} config - Configuration for Immutable services.
 */
class Orderbook {
    apiClient;
    seaport;
    orderbookConfig;
    constructor(config) {
        const obConfig = getOrderbookConfig(config.baseConfig.environment);
        const finalConfig = {
            ...obConfig,
            ...config.overrides,
        };
        if (!finalConfig) {
            throw new Error('Orderbook configuration not passed, please specify the environment under config.baseConfig.environment');
        }
        this.orderbookConfig = finalConfig;
        const { apiEndpoint, chainName } = this.orderbookConfig;
        if (!apiEndpoint) {
            throw new Error('API endpoint must be provided');
        }
        this.apiClient = new ImmutableApiClientFactory(apiEndpoint, chainName, this.orderbookConfig.seaportContractAddress).create();
        const seaportLibFactory = new SeaportLibFactory(this.orderbookConfig.seaportContractAddress, this.orderbookConfig.provider);
        this.seaport = new Seaport(seaportLibFactory, this.orderbookConfig.provider, this.orderbookConfig.seaportContractAddress, this.orderbookConfig.zoneContractAddress);
    }
    /**
     * Return the configuration for the orderbook module.
     * @return {OrderbookModuleConfiguration} The configuration for the orderbook module.
     */
    config() {
        return this.orderbookConfig;
    }
    /**
     * Get an order by ID
     * @param {string} listingId - The listingId to find.
     * @return {ListingResult} The returned order result.
     */
    async getListing(listingId) {
        const apiListing = await this.apiClient.getListing(listingId);
        return {
            result: mapFromOpenApiOrder(apiListing.result),
        };
    }
    /**
     * Get a trade by ID
     * @param {string} tradeId - The tradeId to find.
     * @return {TradeResult} The returned order result.
     */
    async getTrade(tradeId) {
        const apiListing = await this.apiClient.getTrade(tradeId);
        return {
            result: mapFromOpenApiTrade(apiListing.result),
        };
    }
    /**
     * List orders. This method is used to get a list of orders filtered by conditions specified
     * in the params object.
     * @param {ListListingsParams} listOrderParams - Filtering, ordering and page parameters.
     * @return {ListListingsResult} The paged orders.
     */
    async listListings(listOrderParams) {
        const apiListings = await this.apiClient.listListings(listOrderParams);
        return {
            page: mapFromOpenApiPage(apiListings.page),
            result: apiListings.result.map(mapFromOpenApiOrder),
        };
    }
    /**
     * List trades. This method is used to get a list of trades filtered by conditions specified
     * in the params object
     * @param {ListTradesParams} listTradesParams - Filtering, ordering and page parameters.
     * @return {ListTradesResult} The paged trades.
     */
    async listTrades(listTradesParams) {
        const apiListings = await this.apiClient.listTrades(listTradesParams);
        return {
            page: mapFromOpenApiPage(apiListings.page),
            result: apiListings.result.map(mapFromOpenApiTrade),
        };
    }
    /**
     * Get required transactions and messages for signing prior to creating a listing
     * through the createListing method
     * @param {PrepareListingParams} prepareListingParams - Details about the listing to be created.
     * @return {PrepareListingResponse} PrepareListingResponse includes
     * the unsigned approval transaction, the typed order message for signing and
     * the order components that can be submitted to `createListing` with a signature.
     */
    async prepareListing({ makerAddress, sell, buy, orderExpiry, }) {
        return this.seaport.prepareSeaportOrder(makerAddress, sell, buy, 
        // Default order start to now
        new Date(), 
        // Default order expiry to 2 years from now
        orderExpiry || new Date(Date.now() + 1000 * 60 * 60 * 24 * 365 * 2));
    }
    /**
     * Create an order
     * @param {CreateListingParams} createListingParams - create an order with the given params.
     * @return {ListingResult} The result of the order created in the Immutable services.
     */
    async createListing(createListingParams) {
        const apiListingResponse = await this.apiClient.createListing({
            ...createListingParams,
        });
        return {
            result: mapFromOpenApiOrder(apiListingResponse.result),
        };
    }
    /**
     * Get unsigned transactions that can be submitted to fulfil an open order. If the approval
     * transaction exists it must be signed and submitted to the chain before the fulfilment
     * transaction can be submitted or it will be reverted.
     * @param {string} listingId - The listingId to fulfil.
     * @param {string} fulfillerAddress - The address of the account fulfilling the order.
     * @return {FulfillOrderResponse} Approval and fulfilment transactions.
     */
    async fulfillOrder(listingId, takerAddress, takerFees) {
        const fulfillmentDataRes = await this.apiClient.fulfillmentData([
            {
                order_id: listingId,
                fees: takerFees.map((fee) => ({
                    amount: fee.amount,
                    fee_type: FeeType.TAKER_ECOSYSTEM,
                    recipient: fee.recipient,
                })),
            },
        ]);
        if (fulfillmentDataRes.result.length !== 1) {
            throw new Error('unexpected fulfillment data result length');
        }
        const extraData = fulfillmentDataRes.result[0].extra_data;
        const orderResult = fulfillmentDataRes.result[0].order;
        if (orderResult.status !== OrderStatus.ACTIVE) {
            throw new Error(`Cannot fulfil order that is not active. Current status: ${orderResult.status}`);
        }
        return this.seaport.fulfillOrder(orderResult, takerAddress, extraData);
    }
    /**
     * Get an unsigned cancel order transaction. Orders can only be cancelled by
     * the account that created them.
     * @param {string} listingId - The listingId to cancel.
     * @param {string} accountAddress - The address of the account cancelling the order.
     * @return {CancelOrderResponse} The unsigned cancel order transaction
     */
    async cancelOrder(listingId, accountAddress) {
        const orderResult = await this.apiClient.getListing(listingId);
        if (orderResult.result.status !== OrderStatus.ACTIVE
            && orderResult.result.status !== OrderStatus.INACTIVE
            && orderResult.result.status !== OrderStatus.PENDING) {
            throw new Error(`Cannot cancel order with status ${orderResult.result.status}`);
        }
        if (orderResult.result.account_address !== accountAddress.toLowerCase()) {
            throw new Error(`Only account ${orderResult.result.account_address} can cancel order ${listingId}`);
        }
        const cancelOrderTransaction = await this.seaport.cancelOrder(orderResult.result, accountAddress);
        return { unsignedCancelOrderTransaction: cancelOrderTransaction };
    }
}

// Consumers might want an estimated gas limit for fulfilling an order
// without calling the transaction builder. This is an estimate that
// should work for all fulfillment scenarios.
const ESTIMATED_FULFILLMENT_GAS_GWEI = 400000;
const constants = {
    estimatedFulfillmentGasGwei: ESTIMATED_FULFILLMENT_GAS_GWEI,
};

export { ActionType, FeeType, OrderStatus, Orderbook, SignablePurpose, TransactionPurpose, constants };
