import globalAxios$1, { isAxiosError as isAxiosError$1, HttpStatusCode as HttpStatusCode$2 } from 'axios';
import { ImmutableX, Config, IMXError, createStarkSigner, generateLegacyStarkPrivateKey, TransfersApi, OrdersApi as OrdersApi$1, UsersApi, Contracts, TradesApi, ExchangesApi, WithdrawalsApi, MintsApi, DepositsApi, EncodingApi, TokensApi as TokensApi$1 } from '@imtbl/core-sdk';
import { UserManager, InMemoryWebStorage, WebStorageStateStore } from 'oidc-client-ts';
import jwt_decode from 'jwt-decode';
import * as crypto from 'crypto';
import { Magic } from 'magic-sdk';
import { OpenIdExtension } from '@magic-ext/oidc';
import { BigNumber as BigNumber$1, ethers, providers, constants as constants$1, ContractFactory, utils as utils$1, Contract as Contract$1 } from 'ethers';
import BN$2 from 'bn.js';
import * as encUtils from 'enc-utils';
import { Web3Provider, JsonRpcProvider } from '@ethersproject/providers';
import { EventEmitter } from 'events';
import { walletContracts } from '@0xsequence/abi';
import { encodeSignature, decodeSignature } from '@0xsequence/config';
import FormData$2 from 'form-data';
import { Seaport as Seaport$1 } from '@opensea/seaport-js';
import { parseUnits } from '@ethersproject/units';
import { BigNumber as BigNumber$2 } from '@ethersproject/bignumber';
import detectEthereumProvider from '@metamask/detect-provider';
import { TradeType, Token, CurrencyAmount, Percent } from '@uniswap/sdk-core';
import assert from 'assert';
import { FeeAmount, Route, SwapQuoter, Pool, Trade, toHex as toHex$1, encodeRouteToPath } from '@uniswap/v3-sdk';
import { keccak256 as keccak256$1 } from '@ethersproject/solidity';
import { SwapRouter } from '@uniswap/router-sdk';
import { parseUnits as parseUnits$1 } from 'ethers/lib/utils';
import { jsx } from 'react/jsx-runtime';
import { useEffect } from 'react';

var Environment$1;
(function (Environment) {
    Environment["PRODUCTION"] = "production";
    Environment["SANDBOX"] = "sandbox";
})(Environment$1 || (Environment$1 = {}));
class ImmutableConfiguration {
    environment;
    apiKey;
    constructor(options) {
        this.environment = options.environment;
        this.apiKey = options.apiKey;
    }
}

var config = /*#__PURE__*/Object.freeze({
    __proto__: null,
    get Environment () { return Environment$1; },
    ImmutableConfiguration: ImmutableConfiguration
});

/* tslint:disable */
/* eslint-disable */
/**
 * Immutable X API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 3.0
 * Contact: support@immutable.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
let Configuration$1 = class Configuration {
    /**
     * parameter for apiKey security
     * @param name security name
     * @memberof Configuration
     */
    apiKey;
    /**
     * parameter for basic security
     *
     * @type {string}
     * @memberof Configuration
     */
    username;
    /**
     * parameter for basic security
     *
     * @type {string}
     * @memberof Configuration
     */
    password;
    /**
     * parameter for oauth2 security
     * @param name security name
     * @param scopes oauth2 scope
     * @memberof Configuration
     */
    accessToken;
    /**
     * override base path
     *
     * @type {string}
     * @memberof Configuration
     */
    basePath;
    /**
     * base options for axios calls
     *
     * @type {any}
     * @memberof Configuration
     */
    baseOptions;
    /**
     * The FormData constructor that will be used to create multipart form data
     * requests. You can inject this here so that execution environments that
     * do not support the FormData class can still run the generated client.
     *
     * @type {new () => FormData}
     */
    formDataCtor;
    constructor(param = {}) {
        this.apiKey = param.apiKey;
        this.username = param.username;
        this.password = param.password;
        this.accessToken = param.accessToken;
        this.basePath = param.basePath;
        this.baseOptions = param.baseOptions;
        this.formDataCtor = param.formDataCtor;
    }
    /**
     * Check if the given MIME is a JSON MIME.
     * JSON MIME examples:
     *   application/json
     *   application/json; charset=UTF8
     *   APPLICATION/JSON
     *   application/vnd.company+json
     * @param mime - MIME (Multipurpose Internet Mail Extensions)
     * @return True if the given MIME is JSON, false otherwise.
     */
    isJsonMime(mime) {
        const jsonMime = new RegExp('^(application\/json|[^;/ \t]+\/[^;/ \t]+[+]json)[ \t]*(;.*)?$', 'i');
        return mime !== null && (jsonMime.test(mime) || mime.toLowerCase() === 'application/json-patch+json');
    }
};

/* tslint:disable */
/* eslint-disable */
/**
 * Immutable zkEVM API
 * Immutable Multi Rollup API
 *
 * The version of the OpenAPI document: 1.0.0
 * Contact: support@immutable.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
// Some imports not used depending on template conditions
// @ts-ignore
const BASE_PATH$1 = "https://api.sandbox.immutable.com".replace(/\/+$/, "");
/**
 *
 * @export
 * @class BaseAPI
 */
let BaseAPI$1 = class BaseAPI {
    basePath;
    axios;
    configuration;
    constructor(configuration, basePath = BASE_PATH$1, axios = globalAxios$1) {
        this.basePath = basePath;
        this.axios = axios;
        if (configuration) {
            this.configuration = configuration;
            this.basePath = configuration.basePath || this.basePath;
        }
    }
};
/**
 *
 * @export
 * @class RequiredError
 * @extends {Error}
 */
let RequiredError$1 = class RequiredError extends Error {
    field;
    name = "RequiredError";
    constructor(field, msg) {
        super(msg);
        this.field = field;
    }
};

/* tslint:disable */
/* eslint-disable */
/**
 * Immutable zkEVM API
 * Immutable Multi Rollup API
 *
 * The version of the OpenAPI document: 1.0.0
 * Contact: support@immutable.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
/**
 *
 * @export
 */
const DUMMY_BASE_URL$1 = 'https://example.com';
/**
 *
 * @throws {RequiredError}
 * @export
 */
const assertParamExists$1 = function (functionName, paramName, paramValue) {
    if (paramValue === null || paramValue === undefined) {
        throw new RequiredError$1(paramName, `Required parameter ${paramName} was null or undefined when calling ${functionName}.`);
    }
};
/**
 *
 * @export
 */
const setApiKeyToObject = async function (object, keyParamName, configuration) {
    if (configuration && configuration.apiKey) {
        const localVarApiKeyValue = typeof configuration.apiKey === 'function'
            ? await configuration.apiKey(keyParamName)
            : await configuration.apiKey;
        object[keyParamName] = localVarApiKeyValue;
    }
};
/**
 *
 * @export
 */
const setBearerAuthToObject$1 = async function (object, configuration) {
    if (configuration && configuration.accessToken) {
        const accessToken = typeof configuration.accessToken === 'function'
            ? await configuration.accessToken()
            : await configuration.accessToken;
        object["Authorization"] = "Bearer " + accessToken;
    }
};
function setFlattenedQueryParams$1(urlSearchParams, parameter, key = "") {
    if (typeof parameter === "object") {
        if (Array.isArray(parameter)) {
            parameter.forEach(item => setFlattenedQueryParams$1(urlSearchParams, item, key));
        }
        else {
            Object.keys(parameter).forEach(currentKey => setFlattenedQueryParams$1(urlSearchParams, parameter[currentKey], `${key}${key !== '' ? '.' : ''}${currentKey}`));
        }
    }
    else {
        if (urlSearchParams.has(key)) {
            urlSearchParams.append(key, parameter);
        }
        else {
            urlSearchParams.set(key, parameter);
        }
    }
}
/**
 *
 * @export
 */
const setSearchParams$1 = function (url, ...objects) {
    const searchParams = new URLSearchParams(url.search);
    setFlattenedQueryParams$1(searchParams, objects);
    url.search = searchParams.toString();
};
/**
 *
 * @export
 */
const serializeDataIfNeeded$1 = function (value, requestOptions, configuration) {
    const nonString = typeof value !== 'string';
    const needsSerialization = nonString && configuration && configuration.isJsonMime
        ? configuration.isJsonMime(requestOptions.headers['Content-Type'])
        : nonString;
    return needsSerialization
        ? JSON.stringify(value !== undefined ? value : {})
        : (value || "");
};
/**
 *
 * @export
 */
const toPathString$1 = function (url) {
    return url.pathname + url.search + url.hash;
};
/**
 *
 * @export
 */
const createRequestFunction$1 = function (axiosArgs, globalAxios, BASE_PATH, configuration) {
    return (axios = globalAxios, basePath = BASE_PATH) => {
        const axiosRequestArgs = { ...axiosArgs.options, url: (configuration?.basePath || basePath) + axiosArgs.url };
        return axios.request(axiosRequestArgs);
    };
};

/* tslint:disable */
/* eslint-disable */
/**
 * Immutable zkEVM API
 * Immutable Multi Rollup API
 *
 * The version of the OpenAPI document: 1.0.0
 * Contact: support@immutable.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
/**
 * ActivitiesApi - axios parameter creator
 * @export
 */
const ActivitiesApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * Get a single activity by ID
         * @summary Get a single activity by ID
         * @param {string} chainName The name of chain
         * @param {string} activityId The id of activity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getActivity: async (chainName, activityId, options = {}) => {
            // verify required parameter 'chainName' is not null or undefined
            assertParamExists$1('getActivity', 'chainName', chainName);
            // verify required parameter 'activityId' is not null or undefined
            assertParamExists$1('getActivity', 'activityId', activityId);
            const localVarPath = `/v1/chains/{chain_name}/activities/{activity_id}`
                .replace(`{${"chain_name"}}`, encodeURIComponent(String(chainName)))
                .replace(`{${"activity_id"}}`, encodeURIComponent(String(activityId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL$1);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            setSearchParams$1(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: toPathString$1(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List all activities
         * @summary List all activities
         * @param {string} chainName The name of chain
         * @param {string} [contractAddress] The contract address of NFT or ERC20 Token
         * @param {string} [tokenId] An &#x60;uint256&#x60; token id as string
         * @param {string} [accountAddress] The account address activity contains
         * @param {ActivityType} [activityType] The activity type
         * @param {string} [fromIndexedAt] From indexed at including given date
         * @param {string} [toIndexedAt] To indexed at including given date
         * @param {string} [transactionHash] The transaction hash of activity
         * @param {string} [pageCursor] Encoded page cursor to retrieve previous or next page. Use the value returned in the response.
         * @param {number} [pageSize] Maximum number of items to return
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listActivities: async (chainName, contractAddress, tokenId, accountAddress, activityType, fromIndexedAt, toIndexedAt, transactionHash, pageCursor, pageSize, options = {}) => {
            // verify required parameter 'chainName' is not null or undefined
            assertParamExists$1('listActivities', 'chainName', chainName);
            const localVarPath = `/v1/chains/{chain_name}/activities`
                .replace(`{${"chain_name"}}`, encodeURIComponent(String(chainName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL$1);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (contractAddress !== undefined) {
                localVarQueryParameter['contract_address'] = contractAddress;
            }
            if (tokenId !== undefined) {
                localVarQueryParameter['token_id'] = tokenId;
            }
            if (accountAddress !== undefined) {
                localVarQueryParameter['account_address'] = accountAddress;
            }
            if (activityType !== undefined) {
                localVarQueryParameter['activity_type'] = activityType;
            }
            if (fromIndexedAt !== undefined) {
                localVarQueryParameter['from_indexed_at'] = (fromIndexedAt instanceof Date) ?
                    fromIndexedAt.toISOString() :
                    fromIndexedAt;
            }
            if (toIndexedAt !== undefined) {
                localVarQueryParameter['to_indexed_at'] = (toIndexedAt instanceof Date) ?
                    toIndexedAt.toISOString() :
                    toIndexedAt;
            }
            if (transactionHash !== undefined) {
                localVarQueryParameter['transaction_hash'] = transactionHash;
            }
            if (pageCursor !== undefined) {
                localVarQueryParameter['page_cursor'] = pageCursor;
            }
            if (pageSize !== undefined) {
                localVarQueryParameter['page_size'] = pageSize;
            }
            setSearchParams$1(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: toPathString$1(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
/**
 * ActivitiesApi - functional programming interface
 * @export
 */
const ActivitiesApiFp = function (configuration) {
    const localVarAxiosParamCreator = ActivitiesApiAxiosParamCreator(configuration);
    return {
        /**
         * Get a single activity by ID
         * @summary Get a single activity by ID
         * @param {string} chainName The name of chain
         * @param {string} activityId The id of activity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getActivity(chainName, activityId, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getActivity(chainName, activityId, options);
            return createRequestFunction$1(localVarAxiosArgs, globalAxios$1, BASE_PATH$1, configuration);
        },
        /**
         * List all activities
         * @summary List all activities
         * @param {string} chainName The name of chain
         * @param {string} [contractAddress] The contract address of NFT or ERC20 Token
         * @param {string} [tokenId] An &#x60;uint256&#x60; token id as string
         * @param {string} [accountAddress] The account address activity contains
         * @param {ActivityType} [activityType] The activity type
         * @param {string} [fromIndexedAt] From indexed at including given date
         * @param {string} [toIndexedAt] To indexed at including given date
         * @param {string} [transactionHash] The transaction hash of activity
         * @param {string} [pageCursor] Encoded page cursor to retrieve previous or next page. Use the value returned in the response.
         * @param {number} [pageSize] Maximum number of items to return
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listActivities(chainName, contractAddress, tokenId, accountAddress, activityType, fromIndexedAt, toIndexedAt, transactionHash, pageCursor, pageSize, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listActivities(chainName, contractAddress, tokenId, accountAddress, activityType, fromIndexedAt, toIndexedAt, transactionHash, pageCursor, pageSize, options);
            return createRequestFunction$1(localVarAxiosArgs, globalAxios$1, BASE_PATH$1, configuration);
        },
    };
};
/**
 * ActivitiesApi - factory interface
 * @export
 */
const ActivitiesApiFactory = function (configuration, basePath, axios) {
    const localVarFp = ActivitiesApiFp(configuration);
    return {
        /**
         * Get a single activity by ID
         * @summary Get a single activity by ID
         * @param {string} chainName The name of chain
         * @param {string} activityId The id of activity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getActivity(chainName, activityId, options) {
            return localVarFp.getActivity(chainName, activityId, options).then((request) => request(axios, basePath));
        },
        /**
         * List all activities
         * @summary List all activities
         * @param {string} chainName The name of chain
         * @param {string} [contractAddress] The contract address of NFT or ERC20 Token
         * @param {string} [tokenId] An &#x60;uint256&#x60; token id as string
         * @param {string} [accountAddress] The account address activity contains
         * @param {ActivityType} [activityType] The activity type
         * @param {string} [fromIndexedAt] From indexed at including given date
         * @param {string} [toIndexedAt] To indexed at including given date
         * @param {string} [transactionHash] The transaction hash of activity
         * @param {string} [pageCursor] Encoded page cursor to retrieve previous or next page. Use the value returned in the response.
         * @param {number} [pageSize] Maximum number of items to return
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listActivities(chainName, contractAddress, tokenId, accountAddress, activityType, fromIndexedAt, toIndexedAt, transactionHash, pageCursor, pageSize, options) {
            return localVarFp.listActivities(chainName, contractAddress, tokenId, accountAddress, activityType, fromIndexedAt, toIndexedAt, transactionHash, pageCursor, pageSize, options).then((request) => request(axios, basePath));
        },
    };
};
/**
 * ActivitiesApi - object-oriented interface
 * @export
 * @class ActivitiesApi
 * @extends {BaseAPI}
 */
class ActivitiesApi extends BaseAPI$1 {
    /**
     * Get a single activity by ID
     * @summary Get a single activity by ID
     * @param {ActivitiesApiGetActivityRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActivitiesApi
     */
    getActivity(requestParameters, options) {
        return ActivitiesApiFp(this.configuration).getActivity(requestParameters.chainName, requestParameters.activityId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * List all activities
     * @summary List all activities
     * @param {ActivitiesApiListActivitiesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActivitiesApi
     */
    listActivities(requestParameters, options) {
        return ActivitiesApiFp(this.configuration).listActivities(requestParameters.chainName, requestParameters.contractAddress, requestParameters.tokenId, requestParameters.accountAddress, requestParameters.activityType, requestParameters.fromIndexedAt, requestParameters.toIndexedAt, requestParameters.transactionHash, requestParameters.pageCursor, requestParameters.pageSize, options).then((request) => request(this.axios, this.basePath));
    }
}

/* tslint:disable */
/* eslint-disable */
/**
 * Immutable zkEVM API
 * Immutable Multi Rollup API
 *
 * The version of the OpenAPI document: 1.0.0
 * Contact: support@immutable.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
/**
 * ChainsApi - axios parameter creator
 * @export
 */
const ChainsApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * List supported chains
         * @summary List supported chains
         * @param {string} [pageCursor] Encoded page cursor to retrieve previous or next page. Use the value returned in the response.
         * @param {number} [pageSize] Maximum number of items to return
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listChains: async (pageCursor, pageSize, options = {}) => {
            const localVarPath = `/v1/chains`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL$1);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (pageCursor !== undefined) {
                localVarQueryParameter['page_cursor'] = pageCursor;
            }
            if (pageSize !== undefined) {
                localVarQueryParameter['page_size'] = pageSize;
            }
            setSearchParams$1(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: toPathString$1(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
/**
 * ChainsApi - functional programming interface
 * @export
 */
const ChainsApiFp = function (configuration) {
    const localVarAxiosParamCreator = ChainsApiAxiosParamCreator(configuration);
    return {
        /**
         * List supported chains
         * @summary List supported chains
         * @param {string} [pageCursor] Encoded page cursor to retrieve previous or next page. Use the value returned in the response.
         * @param {number} [pageSize] Maximum number of items to return
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listChains(pageCursor, pageSize, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listChains(pageCursor, pageSize, options);
            return createRequestFunction$1(localVarAxiosArgs, globalAxios$1, BASE_PATH$1, configuration);
        },
    };
};
/**
 * ChainsApi - factory interface
 * @export
 */
const ChainsApiFactory = function (configuration, basePath, axios) {
    const localVarFp = ChainsApiFp(configuration);
    return {
        /**
         * List supported chains
         * @summary List supported chains
         * @param {string} [pageCursor] Encoded page cursor to retrieve previous or next page. Use the value returned in the response.
         * @param {number} [pageSize] Maximum number of items to return
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listChains(pageCursor, pageSize, options) {
            return localVarFp.listChains(pageCursor, pageSize, options).then((request) => request(axios, basePath));
        },
    };
};
/**
 * ChainsApi - object-oriented interface
 * @export
 * @class ChainsApi
 * @extends {BaseAPI}
 */
class ChainsApi extends BaseAPI$1 {
    /**
     * List supported chains
     * @summary List supported chains
     * @param {ChainsApiListChainsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChainsApi
     */
    listChains(requestParameters = {}, options) {
        return ChainsApiFp(this.configuration).listChains(requestParameters.pageCursor, requestParameters.pageSize, options).then((request) => request(this.axios, this.basePath));
    }
}

/* tslint:disable */
/* eslint-disable */
/**
 * Immutable zkEVM API
 * Immutable Multi Rollup API
 *
 * The version of the OpenAPI document: 1.0.0
 * Contact: support@immutable.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
/**
 * CollectionsApi - axios parameter creator
 * @export
 */
const CollectionsApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * Get collection by contract address
         * @summary Get collection by contract address
         * @param {string} contractAddress The address contract
         * @param {string} chainName The name of chain
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCollection: async (contractAddress, chainName, options = {}) => {
            // verify required parameter 'contractAddress' is not null or undefined
            assertParamExists$1('getCollection', 'contractAddress', contractAddress);
            // verify required parameter 'chainName' is not null or undefined
            assertParamExists$1('getCollection', 'chainName', chainName);
            const localVarPath = `/v1/chains/{chain_name}/collections/{contract_address}`
                .replace(`{${"contract_address"}}`, encodeURIComponent(String(contractAddress)))
                .replace(`{${"chain_name"}}`, encodeURIComponent(String(chainName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL$1);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            setSearchParams$1(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: toPathString$1(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List all collections
         * @summary List all collections
         * @param {string} chainName The name of chain
         * @param {string} [pageCursor] Encoded page cursor to retrieve previous or next page. Use the value returned in the response.
         * @param {number} [pageSize] Maximum number of items to return
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listCollections: async (chainName, pageCursor, pageSize, options = {}) => {
            // verify required parameter 'chainName' is not null or undefined
            assertParamExists$1('listCollections', 'chainName', chainName);
            const localVarPath = `/v1/chains/{chain_name}/collections`
                .replace(`{${"chain_name"}}`, encodeURIComponent(String(chainName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL$1);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (pageCursor !== undefined) {
                localVarQueryParameter['page_cursor'] = pageCursor;
            }
            if (pageSize !== undefined) {
                localVarQueryParameter['page_size'] = pageSize;
            }
            setSearchParams$1(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: toPathString$1(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List collections by NFT owner account address
         * @summary List collections by NFT owner
         * @param {string} accountAddress Account address
         * @param {string} chainName The name of chain
         * @param {string} [pageCursor] Encoded page cursor to retrieve previous or next page. Use the value returned in the response.
         * @param {number} [pageSize] Maximum number of items to return
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listCollectionsByNFTOwner: async (accountAddress, chainName, pageCursor, pageSize, options = {}) => {
            // verify required parameter 'accountAddress' is not null or undefined
            assertParamExists$1('listCollectionsByNFTOwner', 'accountAddress', accountAddress);
            // verify required parameter 'chainName' is not null or undefined
            assertParamExists$1('listCollectionsByNFTOwner', 'chainName', chainName);
            const localVarPath = `/v1/chains/{chain_name}/accounts/{account_address}/collections`
                .replace(`{${"account_address"}}`, encodeURIComponent(String(accountAddress)))
                .replace(`{${"chain_name"}}`, encodeURIComponent(String(chainName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL$1);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (pageCursor !== undefined) {
                localVarQueryParameter['page_cursor'] = pageCursor;
            }
            if (pageSize !== undefined) {
                localVarQueryParameter['page_size'] = pageSize;
            }
            setSearchParams$1(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: toPathString$1(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Refresh collection metadata
         * @summary Refresh collection metadata
         * @param {string} contractAddress The address contract
         * @param {string} chainName The name of chain
         * @param {RefreshCollectionMetadataRequest} refreshCollectionMetadataRequest The request body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        refreshCollectionMetadata: async (contractAddress, chainName, refreshCollectionMetadataRequest, options = {}) => {
            // verify required parameter 'contractAddress' is not null or undefined
            assertParamExists$1('refreshCollectionMetadata', 'contractAddress', contractAddress);
            // verify required parameter 'chainName' is not null or undefined
            assertParamExists$1('refreshCollectionMetadata', 'chainName', chainName);
            // verify required parameter 'refreshCollectionMetadataRequest' is not null or undefined
            assertParamExists$1('refreshCollectionMetadata', 'refreshCollectionMetadataRequest', refreshCollectionMetadataRequest);
            const localVarPath = `/v1/chains/{chain_name}/collections/{contract_address}/refresh-metadata`
                .replace(`{${"contract_address"}}`, encodeURIComponent(String(contractAddress)))
                .replace(`{${"chain_name"}}`, encodeURIComponent(String(chainName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL$1);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ImmutableApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "X-Immutable-API-Key", configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            setSearchParams$1(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = serializeDataIfNeeded$1(refreshCollectionMetadataRequest, localVarRequestOptions, configuration);
            return {
                url: toPathString$1(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
/**
 * CollectionsApi - functional programming interface
 * @export
 */
const CollectionsApiFp = function (configuration) {
    const localVarAxiosParamCreator = CollectionsApiAxiosParamCreator(configuration);
    return {
        /**
         * Get collection by contract address
         * @summary Get collection by contract address
         * @param {string} contractAddress The address contract
         * @param {string} chainName The name of chain
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCollection(contractAddress, chainName, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCollection(contractAddress, chainName, options);
            return createRequestFunction$1(localVarAxiosArgs, globalAxios$1, BASE_PATH$1, configuration);
        },
        /**
         * List all collections
         * @summary List all collections
         * @param {string} chainName The name of chain
         * @param {string} [pageCursor] Encoded page cursor to retrieve previous or next page. Use the value returned in the response.
         * @param {number} [pageSize] Maximum number of items to return
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listCollections(chainName, pageCursor, pageSize, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listCollections(chainName, pageCursor, pageSize, options);
            return createRequestFunction$1(localVarAxiosArgs, globalAxios$1, BASE_PATH$1, configuration);
        },
        /**
         * List collections by NFT owner account address
         * @summary List collections by NFT owner
         * @param {string} accountAddress Account address
         * @param {string} chainName The name of chain
         * @param {string} [pageCursor] Encoded page cursor to retrieve previous or next page. Use the value returned in the response.
         * @param {number} [pageSize] Maximum number of items to return
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listCollectionsByNFTOwner(accountAddress, chainName, pageCursor, pageSize, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listCollectionsByNFTOwner(accountAddress, chainName, pageCursor, pageSize, options);
            return createRequestFunction$1(localVarAxiosArgs, globalAxios$1, BASE_PATH$1, configuration);
        },
        /**
         * Refresh collection metadata
         * @summary Refresh collection metadata
         * @param {string} contractAddress The address contract
         * @param {string} chainName The name of chain
         * @param {RefreshCollectionMetadataRequest} refreshCollectionMetadataRequest The request body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async refreshCollectionMetadata(contractAddress, chainName, refreshCollectionMetadataRequest, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.refreshCollectionMetadata(contractAddress, chainName, refreshCollectionMetadataRequest, options);
            return createRequestFunction$1(localVarAxiosArgs, globalAxios$1, BASE_PATH$1, configuration);
        },
    };
};
/**
 * CollectionsApi - factory interface
 * @export
 */
const CollectionsApiFactory = function (configuration, basePath, axios) {
    const localVarFp = CollectionsApiFp(configuration);
    return {
        /**
         * Get collection by contract address
         * @summary Get collection by contract address
         * @param {string} contractAddress The address contract
         * @param {string} chainName The name of chain
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCollection(contractAddress, chainName, options) {
            return localVarFp.getCollection(contractAddress, chainName, options).then((request) => request(axios, basePath));
        },
        /**
         * List all collections
         * @summary List all collections
         * @param {string} chainName The name of chain
         * @param {string} [pageCursor] Encoded page cursor to retrieve previous or next page. Use the value returned in the response.
         * @param {number} [pageSize] Maximum number of items to return
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listCollections(chainName, pageCursor, pageSize, options) {
            return localVarFp.listCollections(chainName, pageCursor, pageSize, options).then((request) => request(axios, basePath));
        },
        /**
         * List collections by NFT owner account address
         * @summary List collections by NFT owner
         * @param {string} accountAddress Account address
         * @param {string} chainName The name of chain
         * @param {string} [pageCursor] Encoded page cursor to retrieve previous or next page. Use the value returned in the response.
         * @param {number} [pageSize] Maximum number of items to return
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listCollectionsByNFTOwner(accountAddress, chainName, pageCursor, pageSize, options) {
            return localVarFp.listCollectionsByNFTOwner(accountAddress, chainName, pageCursor, pageSize, options).then((request) => request(axios, basePath));
        },
        /**
         * Refresh collection metadata
         * @summary Refresh collection metadata
         * @param {string} contractAddress The address contract
         * @param {string} chainName The name of chain
         * @param {RefreshCollectionMetadataRequest} refreshCollectionMetadataRequest The request body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        refreshCollectionMetadata(contractAddress, chainName, refreshCollectionMetadataRequest, options) {
            return localVarFp.refreshCollectionMetadata(contractAddress, chainName, refreshCollectionMetadataRequest, options).then((request) => request(axios, basePath));
        },
    };
};
/**
 * CollectionsApi - object-oriented interface
 * @export
 * @class CollectionsApi
 * @extends {BaseAPI}
 */
class CollectionsApi extends BaseAPI$1 {
    /**
     * Get collection by contract address
     * @summary Get collection by contract address
     * @param {CollectionsApiGetCollectionRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CollectionsApi
     */
    getCollection(requestParameters, options) {
        return CollectionsApiFp(this.configuration).getCollection(requestParameters.contractAddress, requestParameters.chainName, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * List all collections
     * @summary List all collections
     * @param {CollectionsApiListCollectionsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CollectionsApi
     */
    listCollections(requestParameters, options) {
        return CollectionsApiFp(this.configuration).listCollections(requestParameters.chainName, requestParameters.pageCursor, requestParameters.pageSize, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * List collections by NFT owner account address
     * @summary List collections by NFT owner
     * @param {CollectionsApiListCollectionsByNFTOwnerRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CollectionsApi
     */
    listCollectionsByNFTOwner(requestParameters, options) {
        return CollectionsApiFp(this.configuration).listCollectionsByNFTOwner(requestParameters.accountAddress, requestParameters.chainName, requestParameters.pageCursor, requestParameters.pageSize, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Refresh collection metadata
     * @summary Refresh collection metadata
     * @param {CollectionsApiRefreshCollectionMetadataRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CollectionsApi
     */
    refreshCollectionMetadata(requestParameters, options) {
        return CollectionsApiFp(this.configuration).refreshCollectionMetadata(requestParameters.contractAddress, requestParameters.chainName, requestParameters.refreshCollectionMetadataRequest, options).then((request) => request(this.axios, this.basePath));
    }
}

/* tslint:disable */
/* eslint-disable */
/**
 * Immutable zkEVM API
 * Immutable Multi Rollup API
 *
 * The version of the OpenAPI document: 1.0.0
 * Contact: support@immutable.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
/**
 * MetadataApi - axios parameter creator
 * @export
 */
const MetadataApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * Get a single metadata by ID
         * @summary Get a single metadata by ID
         * @param {string} chainName The name of chain
         * @param {string} contractAddress The address of metadata contract
         * @param {string} metadataId The id of the metadata
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMetadata: async (chainName, contractAddress, metadataId, options = {}) => {
            // verify required parameter 'chainName' is not null or undefined
            assertParamExists$1('getMetadata', 'chainName', chainName);
            // verify required parameter 'contractAddress' is not null or undefined
            assertParamExists$1('getMetadata', 'contractAddress', contractAddress);
            // verify required parameter 'metadataId' is not null or undefined
            assertParamExists$1('getMetadata', 'metadataId', metadataId);
            const localVarPath = `/v1/chains/{chain_name}/collections/{contract_address}/metadata/{metadata_id}`
                .replace(`{${"chain_name"}}`, encodeURIComponent(String(chainName)))
                .replace(`{${"contract_address"}}`, encodeURIComponent(String(contractAddress)))
                .replace(`{${"metadata_id"}}`, encodeURIComponent(String(metadataId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL$1);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            setSearchParams$1(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: toPathString$1(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Refresh shared metadata for a collection
         * @param {string} chainName The name of chain
         * @param {string} contractAddress Contract address
         * @param {RefreshMetadataByIDRequest} refreshMetadataByIDRequest NFT Metadata Refresh Request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        refreshMetadataByID: async (chainName, contractAddress, refreshMetadataByIDRequest, options = {}) => {
            // verify required parameter 'chainName' is not null or undefined
            assertParamExists$1('refreshMetadataByID', 'chainName', chainName);
            // verify required parameter 'contractAddress' is not null or undefined
            assertParamExists$1('refreshMetadataByID', 'contractAddress', contractAddress);
            // verify required parameter 'refreshMetadataByIDRequest' is not null or undefined
            assertParamExists$1('refreshMetadataByID', 'refreshMetadataByIDRequest', refreshMetadataByIDRequest);
            const localVarPath = `/v1/chains/{chain_name}/collections/{contract_address}/metadata/refresh-metadata`
                .replace(`{${"chain_name"}}`, encodeURIComponent(String(chainName)))
                .replace(`{${"contract_address"}}`, encodeURIComponent(String(contractAddress)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL$1);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ImmutableApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "X-Immutable-API-Key", configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            setSearchParams$1(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = serializeDataIfNeeded$1(refreshMetadataByIDRequest, localVarRequestOptions, configuration);
            return {
                url: toPathString$1(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
/**
 * MetadataApi - functional programming interface
 * @export
 */
const MetadataApiFp = function (configuration) {
    const localVarAxiosParamCreator = MetadataApiAxiosParamCreator(configuration);
    return {
        /**
         * Get a single metadata by ID
         * @summary Get a single metadata by ID
         * @param {string} chainName The name of chain
         * @param {string} contractAddress The address of metadata contract
         * @param {string} metadataId The id of the metadata
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMetadata(chainName, contractAddress, metadataId, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getMetadata(chainName, contractAddress, metadataId, options);
            return createRequestFunction$1(localVarAxiosArgs, globalAxios$1, BASE_PATH$1, configuration);
        },
        /**
         * Refresh shared metadata for a collection
         * @param {string} chainName The name of chain
         * @param {string} contractAddress Contract address
         * @param {RefreshMetadataByIDRequest} refreshMetadataByIDRequest NFT Metadata Refresh Request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async refreshMetadataByID(chainName, contractAddress, refreshMetadataByIDRequest, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.refreshMetadataByID(chainName, contractAddress, refreshMetadataByIDRequest, options);
            return createRequestFunction$1(localVarAxiosArgs, globalAxios$1, BASE_PATH$1, configuration);
        },
    };
};
/**
 * MetadataApi - factory interface
 * @export
 */
const MetadataApiFactory = function (configuration, basePath, axios) {
    const localVarFp = MetadataApiFp(configuration);
    return {
        /**
         * Get a single metadata by ID
         * @summary Get a single metadata by ID
         * @param {string} chainName The name of chain
         * @param {string} contractAddress The address of metadata contract
         * @param {string} metadataId The id of the metadata
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMetadata(chainName, contractAddress, metadataId, options) {
            return localVarFp.getMetadata(chainName, contractAddress, metadataId, options).then((request) => request(axios, basePath));
        },
        /**
         * Refresh shared metadata for a collection
         * @param {string} chainName The name of chain
         * @param {string} contractAddress Contract address
         * @param {RefreshMetadataByIDRequest} refreshMetadataByIDRequest NFT Metadata Refresh Request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        refreshMetadataByID(chainName, contractAddress, refreshMetadataByIDRequest, options) {
            return localVarFp.refreshMetadataByID(chainName, contractAddress, refreshMetadataByIDRequest, options).then((request) => request(axios, basePath));
        },
    };
};
/**
 * MetadataApi - object-oriented interface
 * @export
 * @class MetadataApi
 * @extends {BaseAPI}
 */
class MetadataApi extends BaseAPI$1 {
    /**
     * Get a single metadata by ID
     * @summary Get a single metadata by ID
     * @param {MetadataApiGetMetadataRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MetadataApi
     */
    getMetadata(requestParameters, options) {
        return MetadataApiFp(this.configuration).getMetadata(requestParameters.chainName, requestParameters.contractAddress, requestParameters.metadataId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Refresh shared metadata for a collection
     * @param {MetadataApiRefreshMetadataByIDRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MetadataApi
     */
    refreshMetadataByID(requestParameters, options) {
        return MetadataApiFp(this.configuration).refreshMetadataByID(requestParameters.chainName, requestParameters.contractAddress, requestParameters.refreshMetadataByIDRequest, options).then((request) => request(this.axios, this.basePath));
    }
}

/* tslint:disable */
/* eslint-disable */
/**
 * Immutable zkEVM API
 * Immutable Multi Rollup API
 *
 * The version of the OpenAPI document: 1.0.0
 * Contact: support@immutable.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
/**
 * NftOwnersApi - axios parameter creator
 * @export
 */
const NftOwnersApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * List NFT owners by token ID
         * @summary List NFT owners by token ID
         * @param {string} contractAddress The address of contract
         * @param {string} tokenId An &#x60;uint256&#x60; token id as string
         * @param {string} chainName The name of chain
         * @param {string} [pageCursor] Encoded page cursor to retrieve previous or next page. Use the value returned in the response.
         * @param {number} [pageSize] Maximum number of items to return
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listNFTOwners: async (contractAddress, tokenId, chainName, pageCursor, pageSize, options = {}) => {
            // verify required parameter 'contractAddress' is not null or undefined
            assertParamExists$1('listNFTOwners', 'contractAddress', contractAddress);
            // verify required parameter 'tokenId' is not null or undefined
            assertParamExists$1('listNFTOwners', 'tokenId', tokenId);
            // verify required parameter 'chainName' is not null or undefined
            assertParamExists$1('listNFTOwners', 'chainName', chainName);
            const localVarPath = `/v1/chains/{chain_name}/collections/{contract_address}/nfts/{token_id}/owners`
                .replace(`{${"contract_address"}}`, encodeURIComponent(String(contractAddress)))
                .replace(`{${"token_id"}}`, encodeURIComponent(String(tokenId)))
                .replace(`{${"chain_name"}}`, encodeURIComponent(String(chainName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL$1);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (pageCursor !== undefined) {
                localVarQueryParameter['page_cursor'] = pageCursor;
            }
            if (pageSize !== undefined) {
                localVarQueryParameter['page_size'] = pageSize;
            }
            setSearchParams$1(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: toPathString$1(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
/**
 * NftOwnersApi - functional programming interface
 * @export
 */
const NftOwnersApiFp = function (configuration) {
    const localVarAxiosParamCreator = NftOwnersApiAxiosParamCreator(configuration);
    return {
        /**
         * List NFT owners by token ID
         * @summary List NFT owners by token ID
         * @param {string} contractAddress The address of contract
         * @param {string} tokenId An &#x60;uint256&#x60; token id as string
         * @param {string} chainName The name of chain
         * @param {string} [pageCursor] Encoded page cursor to retrieve previous or next page. Use the value returned in the response.
         * @param {number} [pageSize] Maximum number of items to return
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listNFTOwners(contractAddress, tokenId, chainName, pageCursor, pageSize, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listNFTOwners(contractAddress, tokenId, chainName, pageCursor, pageSize, options);
            return createRequestFunction$1(localVarAxiosArgs, globalAxios$1, BASE_PATH$1, configuration);
        },
    };
};
/**
 * NftOwnersApi - factory interface
 * @export
 */
const NftOwnersApiFactory = function (configuration, basePath, axios) {
    const localVarFp = NftOwnersApiFp(configuration);
    return {
        /**
         * List NFT owners by token ID
         * @summary List NFT owners by token ID
         * @param {string} contractAddress The address of contract
         * @param {string} tokenId An &#x60;uint256&#x60; token id as string
         * @param {string} chainName The name of chain
         * @param {string} [pageCursor] Encoded page cursor to retrieve previous or next page. Use the value returned in the response.
         * @param {number} [pageSize] Maximum number of items to return
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listNFTOwners(contractAddress, tokenId, chainName, pageCursor, pageSize, options) {
            return localVarFp.listNFTOwners(contractAddress, tokenId, chainName, pageCursor, pageSize, options).then((request) => request(axios, basePath));
        },
    };
};
/**
 * NftOwnersApi - object-oriented interface
 * @export
 * @class NftOwnersApi
 * @extends {BaseAPI}
 */
class NftOwnersApi extends BaseAPI$1 {
    /**
     * List NFT owners by token ID
     * @summary List NFT owners by token ID
     * @param {NftOwnersApiListNFTOwnersRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NftOwnersApi
     */
    listNFTOwners(requestParameters, options) {
        return NftOwnersApiFp(this.configuration).listNFTOwners(requestParameters.contractAddress, requestParameters.tokenId, requestParameters.chainName, requestParameters.pageCursor, requestParameters.pageSize, options).then((request) => request(this.axios, this.basePath));
    }
}

/* tslint:disable */
/* eslint-disable */
/**
 * Immutable zkEVM API
 * Immutable Multi Rollup API
 *
 * The version of the OpenAPI document: 1.0.0
 * Contact: support@immutable.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
/**
 * NftsApi - axios parameter creator
 * @export
 */
const NftsApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * Get NFT by token ID
         * @summary Get NFT by token ID
         * @param {string} contractAddress The address of NFT contract
         * @param {string} tokenId An &#x60;uint256&#x60; token id as string
         * @param {string} chainName The name of chain
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getNFT: async (contractAddress, tokenId, chainName, options = {}) => {
            // verify required parameter 'contractAddress' is not null or undefined
            assertParamExists$1('getNFT', 'contractAddress', contractAddress);
            // verify required parameter 'tokenId' is not null or undefined
            assertParamExists$1('getNFT', 'tokenId', tokenId);
            // verify required parameter 'chainName' is not null or undefined
            assertParamExists$1('getNFT', 'chainName', chainName);
            const localVarPath = `/v1/chains/{chain_name}/collections/{contract_address}/nfts/{token_id}`
                .replace(`{${"contract_address"}}`, encodeURIComponent(String(contractAddress)))
                .replace(`{${"token_id"}}`, encodeURIComponent(String(tokenId)))
                .replace(`{${"chain_name"}}`, encodeURIComponent(String(chainName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL$1);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            setSearchParams$1(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: toPathString$1(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List NFTs by contract address
         * @summary List NFTs by contract address
         * @param {string} contractAddress Contract address
         * @param {string} chainName The name of chain
         * @param {string} [pageCursor] Encoded page cursor to retrieve previous or next page. Use the value returned in the response.
         * @param {number} [pageSize] Maximum number of items to return
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listNFTs: async (contractAddress, chainName, pageCursor, pageSize, options = {}) => {
            // verify required parameter 'contractAddress' is not null or undefined
            assertParamExists$1('listNFTs', 'contractAddress', contractAddress);
            // verify required parameter 'chainName' is not null or undefined
            assertParamExists$1('listNFTs', 'chainName', chainName);
            const localVarPath = `/v1/chains/{chain_name}/collections/{contract_address}/nfts`
                .replace(`{${"contract_address"}}`, encodeURIComponent(String(contractAddress)))
                .replace(`{${"chain_name"}}`, encodeURIComponent(String(chainName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL$1);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (pageCursor !== undefined) {
                localVarQueryParameter['page_cursor'] = pageCursor;
            }
            if (pageSize !== undefined) {
                localVarQueryParameter['page_size'] = pageSize;
            }
            setSearchParams$1(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: toPathString$1(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List NFTs by account address
         * @summary List NFTs by account address
         * @param {string} accountAddress Account address
         * @param {string} chainName The name of chain
         * @param {string} [contractAddress] The address of contract
         * @param {string} [pageCursor] Encoded page cursor to retrieve previous or next page. Use the value returned in the response.
         * @param {number} [pageSize] Maximum number of items to return
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listNFTsByAccountAddress: async (accountAddress, chainName, contractAddress, pageCursor, pageSize, options = {}) => {
            // verify required parameter 'accountAddress' is not null or undefined
            assertParamExists$1('listNFTsByAccountAddress', 'accountAddress', accountAddress);
            // verify required parameter 'chainName' is not null or undefined
            assertParamExists$1('listNFTsByAccountAddress', 'chainName', chainName);
            const localVarPath = `/v1/chains/{chain_name}/accounts/{account_address}/nfts`
                .replace(`{${"account_address"}}`, encodeURIComponent(String(accountAddress)))
                .replace(`{${"chain_name"}}`, encodeURIComponent(String(chainName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL$1);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (contractAddress !== undefined) {
                localVarQueryParameter['contract_address'] = contractAddress;
            }
            if (pageCursor !== undefined) {
                localVarQueryParameter['page_cursor'] = pageCursor;
            }
            if (pageSize !== undefined) {
                localVarQueryParameter['page_size'] = pageSize;
            }
            setSearchParams$1(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: toPathString$1(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
/**
 * NftsApi - functional programming interface
 * @export
 */
const NftsApiFp = function (configuration) {
    const localVarAxiosParamCreator = NftsApiAxiosParamCreator(configuration);
    return {
        /**
         * Get NFT by token ID
         * @summary Get NFT by token ID
         * @param {string} contractAddress The address of NFT contract
         * @param {string} tokenId An &#x60;uint256&#x60; token id as string
         * @param {string} chainName The name of chain
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getNFT(contractAddress, tokenId, chainName, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getNFT(contractAddress, tokenId, chainName, options);
            return createRequestFunction$1(localVarAxiosArgs, globalAxios$1, BASE_PATH$1, configuration);
        },
        /**
         * List NFTs by contract address
         * @summary List NFTs by contract address
         * @param {string} contractAddress Contract address
         * @param {string} chainName The name of chain
         * @param {string} [pageCursor] Encoded page cursor to retrieve previous or next page. Use the value returned in the response.
         * @param {number} [pageSize] Maximum number of items to return
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listNFTs(contractAddress, chainName, pageCursor, pageSize, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listNFTs(contractAddress, chainName, pageCursor, pageSize, options);
            return createRequestFunction$1(localVarAxiosArgs, globalAxios$1, BASE_PATH$1, configuration);
        },
        /**
         * List NFTs by account address
         * @summary List NFTs by account address
         * @param {string} accountAddress Account address
         * @param {string} chainName The name of chain
         * @param {string} [contractAddress] The address of contract
         * @param {string} [pageCursor] Encoded page cursor to retrieve previous or next page. Use the value returned in the response.
         * @param {number} [pageSize] Maximum number of items to return
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listNFTsByAccountAddress(accountAddress, chainName, contractAddress, pageCursor, pageSize, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listNFTsByAccountAddress(accountAddress, chainName, contractAddress, pageCursor, pageSize, options);
            return createRequestFunction$1(localVarAxiosArgs, globalAxios$1, BASE_PATH$1, configuration);
        },
    };
};
/**
 * NftsApi - factory interface
 * @export
 */
const NftsApiFactory = function (configuration, basePath, axios) {
    const localVarFp = NftsApiFp(configuration);
    return {
        /**
         * Get NFT by token ID
         * @summary Get NFT by token ID
         * @param {string} contractAddress The address of NFT contract
         * @param {string} tokenId An &#x60;uint256&#x60; token id as string
         * @param {string} chainName The name of chain
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getNFT(contractAddress, tokenId, chainName, options) {
            return localVarFp.getNFT(contractAddress, tokenId, chainName, options).then((request) => request(axios, basePath));
        },
        /**
         * List NFTs by contract address
         * @summary List NFTs by contract address
         * @param {string} contractAddress Contract address
         * @param {string} chainName The name of chain
         * @param {string} [pageCursor] Encoded page cursor to retrieve previous or next page. Use the value returned in the response.
         * @param {number} [pageSize] Maximum number of items to return
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listNFTs(contractAddress, chainName, pageCursor, pageSize, options) {
            return localVarFp.listNFTs(contractAddress, chainName, pageCursor, pageSize, options).then((request) => request(axios, basePath));
        },
        /**
         * List NFTs by account address
         * @summary List NFTs by account address
         * @param {string} accountAddress Account address
         * @param {string} chainName The name of chain
         * @param {string} [contractAddress] The address of contract
         * @param {string} [pageCursor] Encoded page cursor to retrieve previous or next page. Use the value returned in the response.
         * @param {number} [pageSize] Maximum number of items to return
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listNFTsByAccountAddress(accountAddress, chainName, contractAddress, pageCursor, pageSize, options) {
            return localVarFp.listNFTsByAccountAddress(accountAddress, chainName, contractAddress, pageCursor, pageSize, options).then((request) => request(axios, basePath));
        },
    };
};
/**
 * NftsApi - object-oriented interface
 * @export
 * @class NftsApi
 * @extends {BaseAPI}
 */
class NftsApi extends BaseAPI$1 {
    /**
     * Get NFT by token ID
     * @summary Get NFT by token ID
     * @param {NftsApiGetNFTRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NftsApi
     */
    getNFT(requestParameters, options) {
        return NftsApiFp(this.configuration).getNFT(requestParameters.contractAddress, requestParameters.tokenId, requestParameters.chainName, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * List NFTs by contract address
     * @summary List NFTs by contract address
     * @param {NftsApiListNFTsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NftsApi
     */
    listNFTs(requestParameters, options) {
        return NftsApiFp(this.configuration).listNFTs(requestParameters.contractAddress, requestParameters.chainName, requestParameters.pageCursor, requestParameters.pageSize, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * List NFTs by account address
     * @summary List NFTs by account address
     * @param {NftsApiListNFTsByAccountAddressRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NftsApi
     */
    listNFTsByAccountAddress(requestParameters, options) {
        return NftsApiFp(this.configuration).listNFTsByAccountAddress(requestParameters.accountAddress, requestParameters.chainName, requestParameters.contractAddress, requestParameters.pageCursor, requestParameters.pageSize, options).then((request) => request(this.axios, this.basePath));
    }
}

/* tslint:disable */
/* eslint-disable */
/**
 * Immutable zkEVM API
 * Immutable Multi Rollup API
 *
 * The version of the OpenAPI document: 1.0.0
 * Contact: support@immutable.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
/**
 * OrdersApi - axios parameter creator
 * @export
 */
const OrdersApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * Create a listing
         * @summary Create a listing
         * @param {string} chainName
         * @param {CreateListingRequestBody} createListingRequestBody
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createListing: async (chainName, createListingRequestBody, options = {}) => {
            // verify required parameter 'chainName' is not null or undefined
            assertParamExists$1('createListing', 'chainName', chainName);
            // verify required parameter 'createListingRequestBody' is not null or undefined
            assertParamExists$1('createListing', 'createListingRequestBody', createListingRequestBody);
            const localVarPath = `/v1/chains/{chain_name}/orders/listings`
                .replace(`{${"chain_name"}}`, encodeURIComponent(String(chainName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL$1);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter['Content-Type'] = 'application/json';
            setSearchParams$1(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = serializeDataIfNeeded$1(createListingRequestBody, localVarRequestOptions, configuration);
            return {
                url: toPathString$1(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve signed fulfillment data based on the list of order IDs and corresponding fees.
         * @summary Retrieve fulfillment data for orders
         * @param {string} chainName
         * @param {Array<FulfillmentDataRequest>} fulfillmentDataRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fulfillmentData: async (chainName, fulfillmentDataRequest, options = {}) => {
            // verify required parameter 'chainName' is not null or undefined
            assertParamExists$1('fulfillmentData', 'chainName', chainName);
            // verify required parameter 'fulfillmentDataRequest' is not null or undefined
            assertParamExists$1('fulfillmentData', 'fulfillmentDataRequest', fulfillmentDataRequest);
            const localVarPath = `/v1/chains/{chain_name}/orders/fulfillment-data`
                .replace(`{${"chain_name"}}`, encodeURIComponent(String(chainName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL$1);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter['Content-Type'] = 'application/json';
            setSearchParams$1(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = serializeDataIfNeeded$1(fulfillmentDataRequest, localVarRequestOptions, configuration);
            return {
                url: toPathString$1(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a single listing by ID
         * @summary Get a single listing by ID
         * @param {string} chainName
         * @param {string} listingId Global Order identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getListing: async (chainName, listingId, options = {}) => {
            // verify required parameter 'chainName' is not null or undefined
            assertParamExists$1('getListing', 'chainName', chainName);
            // verify required parameter 'listingId' is not null or undefined
            assertParamExists$1('getListing', 'listingId', listingId);
            const localVarPath = `/v1/chains/{chain_name}/orders/listings/{listing_id}`
                .replace(`{${"chain_name"}}`, encodeURIComponent(String(chainName)))
                .replace(`{${"listing_id"}}`, encodeURIComponent(String(listingId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL$1);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            setSearchParams$1(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: toPathString$1(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a single trade by ID
         * @summary Get a single trade by ID
         * @param {string} chainName
         * @param {string} tradeId Global Trade identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTrade: async (chainName, tradeId, options = {}) => {
            // verify required parameter 'chainName' is not null or undefined
            assertParamExists$1('getTrade', 'chainName', chainName);
            // verify required parameter 'tradeId' is not null or undefined
            assertParamExists$1('getTrade', 'tradeId', tradeId);
            const localVarPath = `/v1/chains/{chain_name}/trades/{trade_id}`
                .replace(`{${"chain_name"}}`, encodeURIComponent(String(chainName)))
                .replace(`{${"trade_id"}}`, encodeURIComponent(String(tradeId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL$1);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            setSearchParams$1(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: toPathString$1(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List all listings
         * @summary List all listings
         * @param {string} chainName
         * @param {OrderStatus} [status] Order status to filter by
         * @param {string} [sellItemContractAddress] Sell item contract address to filter by
         * @param {string} [buyItemContractAddress] Buy item contract address to filter by
         * @param {string} [sellItemTokenId] Sell item token identifier to filter by
         * @param {number} [pageSize] Maximum number of orders to return per page
         * @param {'created_at' | 'updated_at' | 'buy_item_amount'} [sortBy] Order field to sort by
         * @param {'asc' | 'desc'} [sortDirection] Ascending or descending direction for sort
         * @param {string} [pageCursor] Page cursor to retrieve previous or next page. Use the value returned in the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listListings: async (chainName, status, sellItemContractAddress, buyItemContractAddress, sellItemTokenId, pageSize, sortBy, sortDirection, pageCursor, options = {}) => {
            // verify required parameter 'chainName' is not null or undefined
            assertParamExists$1('listListings', 'chainName', chainName);
            const localVarPath = `/v1/chains/{chain_name}/orders/listings`
                .replace(`{${"chain_name"}}`, encodeURIComponent(String(chainName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL$1);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (status !== undefined) {
                localVarQueryParameter['status'] = status;
            }
            if (sellItemContractAddress !== undefined) {
                localVarQueryParameter['sell_item_contract_address'] = sellItemContractAddress;
            }
            if (buyItemContractAddress !== undefined) {
                localVarQueryParameter['buy_item_contract_address'] = buyItemContractAddress;
            }
            if (sellItemTokenId !== undefined) {
                localVarQueryParameter['sell_item_token_id'] = sellItemTokenId;
            }
            if (pageSize !== undefined) {
                localVarQueryParameter['page_size'] = pageSize;
            }
            if (sortBy !== undefined) {
                localVarQueryParameter['sort_by'] = sortBy;
            }
            if (sortDirection !== undefined) {
                localVarQueryParameter['sort_direction'] = sortDirection;
            }
            if (pageCursor !== undefined) {
                localVarQueryParameter['page_cursor'] = pageCursor;
            }
            setSearchParams$1(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: toPathString$1(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List all trades
         * @summary List all trades
         * @param {string} chainName
         * @param {string} [accountAddress]
         * @param {number} [pageSize] Maximum number of trades to return per page
         * @param {'indexed_at'} [sortBy] Trade field to sort by
         * @param {'asc' | 'desc'} [sortDirection] Ascending or descending direction for sort
         * @param {string} [pageCursor] Page cursor to retrieve previous or next page. Use the value returned in the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listTrades: async (chainName, accountAddress, pageSize, sortBy, sortDirection, pageCursor, options = {}) => {
            // verify required parameter 'chainName' is not null or undefined
            assertParamExists$1('listTrades', 'chainName', chainName);
            const localVarPath = `/v1/chains/{chain_name}/trades`
                .replace(`{${"chain_name"}}`, encodeURIComponent(String(chainName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL$1);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (accountAddress !== undefined) {
                localVarQueryParameter['account_address'] = accountAddress;
            }
            if (pageSize !== undefined) {
                localVarQueryParameter['page_size'] = pageSize;
            }
            if (sortBy !== undefined) {
                localVarQueryParameter['sort_by'] = sortBy;
            }
            if (sortDirection !== undefined) {
                localVarQueryParameter['sort_direction'] = sortDirection;
            }
            if (pageCursor !== undefined) {
                localVarQueryParameter['page_cursor'] = pageCursor;
            }
            setSearchParams$1(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: toPathString$1(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
/**
 * OrdersApi - functional programming interface
 * @export
 */
const OrdersApiFp = function (configuration) {
    const localVarAxiosParamCreator = OrdersApiAxiosParamCreator(configuration);
    return {
        /**
         * Create a listing
         * @summary Create a listing
         * @param {string} chainName
         * @param {CreateListingRequestBody} createListingRequestBody
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createListing(chainName, createListingRequestBody, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createListing(chainName, createListingRequestBody, options);
            return createRequestFunction$1(localVarAxiosArgs, globalAxios$1, BASE_PATH$1, configuration);
        },
        /**
         * Retrieve signed fulfillment data based on the list of order IDs and corresponding fees.
         * @summary Retrieve fulfillment data for orders
         * @param {string} chainName
         * @param {Array<FulfillmentDataRequest>} fulfillmentDataRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async fulfillmentData(chainName, fulfillmentDataRequest, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.fulfillmentData(chainName, fulfillmentDataRequest, options);
            return createRequestFunction$1(localVarAxiosArgs, globalAxios$1, BASE_PATH$1, configuration);
        },
        /**
         * Get a single listing by ID
         * @summary Get a single listing by ID
         * @param {string} chainName
         * @param {string} listingId Global Order identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getListing(chainName, listingId, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getListing(chainName, listingId, options);
            return createRequestFunction$1(localVarAxiosArgs, globalAxios$1, BASE_PATH$1, configuration);
        },
        /**
         * Get a single trade by ID
         * @summary Get a single trade by ID
         * @param {string} chainName
         * @param {string} tradeId Global Trade identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTrade(chainName, tradeId, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTrade(chainName, tradeId, options);
            return createRequestFunction$1(localVarAxiosArgs, globalAxios$1, BASE_PATH$1, configuration);
        },
        /**
         * List all listings
         * @summary List all listings
         * @param {string} chainName
         * @param {OrderStatus} [status] Order status to filter by
         * @param {string} [sellItemContractAddress] Sell item contract address to filter by
         * @param {string} [buyItemContractAddress] Buy item contract address to filter by
         * @param {string} [sellItemTokenId] Sell item token identifier to filter by
         * @param {number} [pageSize] Maximum number of orders to return per page
         * @param {'created_at' | 'updated_at' | 'buy_item_amount'} [sortBy] Order field to sort by
         * @param {'asc' | 'desc'} [sortDirection] Ascending or descending direction for sort
         * @param {string} [pageCursor] Page cursor to retrieve previous or next page. Use the value returned in the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listListings(chainName, status, sellItemContractAddress, buyItemContractAddress, sellItemTokenId, pageSize, sortBy, sortDirection, pageCursor, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listListings(chainName, status, sellItemContractAddress, buyItemContractAddress, sellItemTokenId, pageSize, sortBy, sortDirection, pageCursor, options);
            return createRequestFunction$1(localVarAxiosArgs, globalAxios$1, BASE_PATH$1, configuration);
        },
        /**
         * List all trades
         * @summary List all trades
         * @param {string} chainName
         * @param {string} [accountAddress]
         * @param {number} [pageSize] Maximum number of trades to return per page
         * @param {'indexed_at'} [sortBy] Trade field to sort by
         * @param {'asc' | 'desc'} [sortDirection] Ascending or descending direction for sort
         * @param {string} [pageCursor] Page cursor to retrieve previous or next page. Use the value returned in the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listTrades(chainName, accountAddress, pageSize, sortBy, sortDirection, pageCursor, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listTrades(chainName, accountAddress, pageSize, sortBy, sortDirection, pageCursor, options);
            return createRequestFunction$1(localVarAxiosArgs, globalAxios$1, BASE_PATH$1, configuration);
        },
    };
};
/**
 * OrdersApi - factory interface
 * @export
 */
const OrdersApiFactory = function (configuration, basePath, axios) {
    const localVarFp = OrdersApiFp(configuration);
    return {
        /**
         * Create a listing
         * @summary Create a listing
         * @param {string} chainName
         * @param {CreateListingRequestBody} createListingRequestBody
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createListing(chainName, createListingRequestBody, options) {
            return localVarFp.createListing(chainName, createListingRequestBody, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve signed fulfillment data based on the list of order IDs and corresponding fees.
         * @summary Retrieve fulfillment data for orders
         * @param {string} chainName
         * @param {Array<FulfillmentDataRequest>} fulfillmentDataRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fulfillmentData(chainName, fulfillmentDataRequest, options) {
            return localVarFp.fulfillmentData(chainName, fulfillmentDataRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a single listing by ID
         * @summary Get a single listing by ID
         * @param {string} chainName
         * @param {string} listingId Global Order identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getListing(chainName, listingId, options) {
            return localVarFp.getListing(chainName, listingId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a single trade by ID
         * @summary Get a single trade by ID
         * @param {string} chainName
         * @param {string} tradeId Global Trade identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTrade(chainName, tradeId, options) {
            return localVarFp.getTrade(chainName, tradeId, options).then((request) => request(axios, basePath));
        },
        /**
         * List all listings
         * @summary List all listings
         * @param {string} chainName
         * @param {OrderStatus} [status] Order status to filter by
         * @param {string} [sellItemContractAddress] Sell item contract address to filter by
         * @param {string} [buyItemContractAddress] Buy item contract address to filter by
         * @param {string} [sellItemTokenId] Sell item token identifier to filter by
         * @param {number} [pageSize] Maximum number of orders to return per page
         * @param {'created_at' | 'updated_at' | 'buy_item_amount'} [sortBy] Order field to sort by
         * @param {'asc' | 'desc'} [sortDirection] Ascending or descending direction for sort
         * @param {string} [pageCursor] Page cursor to retrieve previous or next page. Use the value returned in the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listListings(chainName, status, sellItemContractAddress, buyItemContractAddress, sellItemTokenId, pageSize, sortBy, sortDirection, pageCursor, options) {
            return localVarFp.listListings(chainName, status, sellItemContractAddress, buyItemContractAddress, sellItemTokenId, pageSize, sortBy, sortDirection, pageCursor, options).then((request) => request(axios, basePath));
        },
        /**
         * List all trades
         * @summary List all trades
         * @param {string} chainName
         * @param {string} [accountAddress]
         * @param {number} [pageSize] Maximum number of trades to return per page
         * @param {'indexed_at'} [sortBy] Trade field to sort by
         * @param {'asc' | 'desc'} [sortDirection] Ascending or descending direction for sort
         * @param {string} [pageCursor] Page cursor to retrieve previous or next page. Use the value returned in the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listTrades(chainName, accountAddress, pageSize, sortBy, sortDirection, pageCursor, options) {
            return localVarFp.listTrades(chainName, accountAddress, pageSize, sortBy, sortDirection, pageCursor, options).then((request) => request(axios, basePath));
        },
    };
};
/**
 * OrdersApi - object-oriented interface
 * @export
 * @class OrdersApi
 * @extends {BaseAPI}
 */
class OrdersApi extends BaseAPI$1 {
    /**
     * Create a listing
     * @summary Create a listing
     * @param {OrdersApiCreateListingRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrdersApi
     */
    createListing(requestParameters, options) {
        return OrdersApiFp(this.configuration).createListing(requestParameters.chainName, requestParameters.createListingRequestBody, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Retrieve signed fulfillment data based on the list of order IDs and corresponding fees.
     * @summary Retrieve fulfillment data for orders
     * @param {OrdersApiFulfillmentDataRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrdersApi
     */
    fulfillmentData(requestParameters, options) {
        return OrdersApiFp(this.configuration).fulfillmentData(requestParameters.chainName, requestParameters.fulfillmentDataRequest, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Get a single listing by ID
     * @summary Get a single listing by ID
     * @param {OrdersApiGetListingRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrdersApi
     */
    getListing(requestParameters, options) {
        return OrdersApiFp(this.configuration).getListing(requestParameters.chainName, requestParameters.listingId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Get a single trade by ID
     * @summary Get a single trade by ID
     * @param {OrdersApiGetTradeRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrdersApi
     */
    getTrade(requestParameters, options) {
        return OrdersApiFp(this.configuration).getTrade(requestParameters.chainName, requestParameters.tradeId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * List all listings
     * @summary List all listings
     * @param {OrdersApiListListingsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrdersApi
     */
    listListings(requestParameters, options) {
        return OrdersApiFp(this.configuration).listListings(requestParameters.chainName, requestParameters.status, requestParameters.sellItemContractAddress, requestParameters.buyItemContractAddress, requestParameters.sellItemTokenId, requestParameters.pageSize, requestParameters.sortBy, requestParameters.sortDirection, requestParameters.pageCursor, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * List all trades
     * @summary List all trades
     * @param {OrdersApiListTradesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrdersApi
     */
    listTrades(requestParameters, options) {
        return OrdersApiFp(this.configuration).listTrades(requestParameters.chainName, requestParameters.accountAddress, requestParameters.pageSize, requestParameters.sortBy, requestParameters.sortDirection, requestParameters.pageCursor, options).then((request) => request(this.axios, this.basePath));
    }
}

/* tslint:disable */
/* eslint-disable */
/**
 * Immutable zkEVM API
 * Immutable Multi Rollup API
 *
 * The version of the OpenAPI document: 1.0.0
 * Contact: support@immutable.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
/**
 * PassportApi - axios parameter creator
 * @export
 */
const PassportApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * Create a counterfactual address for a user based on their Ethereum address
         * @summary Create a counterfactual address
         * @param {CreateCounterfactualAddressRequest} createCounterfactualAddressRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCounterfactualAddress: async (createCounterfactualAddressRequest, options = {}) => {
            // verify required parameter 'createCounterfactualAddressRequest' is not null or undefined
            assertParamExists$1('createCounterfactualAddress', 'createCounterfactualAddressRequest', createCounterfactualAddressRequest);
            const localVarPath = `/passport-mr/v1/counterfactual-address`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL$1);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject$1(localVarHeaderParameter, configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            setSearchParams$1(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = serializeDataIfNeeded$1(createCounterfactualAddressRequest, localVarRequestOptions, configuration);
            return {
                url: toPathString$1(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get all the Ethereum linked addresses for a user based on its userId
         * @summary Get Ethereum linked addresses for a user
         * @param {string} userId The user\&#39;s userId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLinkedAddresses: async (userId, options = {}) => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists$1('getLinkedAddresses', 'userId', userId);
            const localVarPath = `/passport-mr/v1/users/{userId}/linked-addresses`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL$1);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject$1(localVarHeaderParameter, configuration);
            setSearchParams$1(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: toPathString$1(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
/**
 * PassportApi - functional programming interface
 * @export
 */
const PassportApiFp = function (configuration) {
    const localVarAxiosParamCreator = PassportApiAxiosParamCreator(configuration);
    return {
        /**
         * Create a counterfactual address for a user based on their Ethereum address
         * @summary Create a counterfactual address
         * @param {CreateCounterfactualAddressRequest} createCounterfactualAddressRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createCounterfactualAddress(createCounterfactualAddressRequest, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createCounterfactualAddress(createCounterfactualAddressRequest, options);
            return createRequestFunction$1(localVarAxiosArgs, globalAxios$1, BASE_PATH$1, configuration);
        },
        /**
         * Get all the Ethereum linked addresses for a user based on its userId
         * @summary Get Ethereum linked addresses for a user
         * @param {string} userId The user\&#39;s userId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getLinkedAddresses(userId, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getLinkedAddresses(userId, options);
            return createRequestFunction$1(localVarAxiosArgs, globalAxios$1, BASE_PATH$1, configuration);
        },
    };
};
/**
 * PassportApi - factory interface
 * @export
 */
const PassportApiFactory = function (configuration, basePath, axios) {
    const localVarFp = PassportApiFp(configuration);
    return {
        /**
         * Create a counterfactual address for a user based on their Ethereum address
         * @summary Create a counterfactual address
         * @param {CreateCounterfactualAddressRequest} createCounterfactualAddressRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCounterfactualAddress(createCounterfactualAddressRequest, options) {
            return localVarFp.createCounterfactualAddress(createCounterfactualAddressRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Get all the Ethereum linked addresses for a user based on its userId
         * @summary Get Ethereum linked addresses for a user
         * @param {string} userId The user\&#39;s userId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLinkedAddresses(userId, options) {
            return localVarFp.getLinkedAddresses(userId, options).then((request) => request(axios, basePath));
        },
    };
};
/**
 * PassportApi - object-oriented interface
 * @export
 * @class PassportApi
 * @extends {BaseAPI}
 */
class PassportApi extends BaseAPI$1 {
    /**
     * Create a counterfactual address for a user based on their Ethereum address
     * @summary Create a counterfactual address
     * @param {PassportApiCreateCounterfactualAddressRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PassportApi
     */
    createCounterfactualAddress(requestParameters, options) {
        return PassportApiFp(this.configuration).createCounterfactualAddress(requestParameters.createCounterfactualAddressRequest, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Get all the Ethereum linked addresses for a user based on its userId
     * @summary Get Ethereum linked addresses for a user
     * @param {PassportApiGetLinkedAddressesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PassportApi
     */
    getLinkedAddresses(requestParameters, options) {
        return PassportApiFp(this.configuration).getLinkedAddresses(requestParameters.userId, options).then((request) => request(this.axios, this.basePath));
    }
}

/* tslint:disable */
/* eslint-disable */
/**
 * Immutable zkEVM API
 * Immutable Multi Rollup API
 *
 * The version of the OpenAPI document: 1.0.0
 * Contact: support@immutable.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
/**
 * TokensApi - axios parameter creator
 * @export
 */
const TokensApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * Get single ERC20 token
         * @summary Get single ERC20 token
         * @param {string} contractAddress The address of contract
         * @param {string} chainName The name of chain
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getERC20Token: async (contractAddress, chainName, options = {}) => {
            // verify required parameter 'contractAddress' is not null or undefined
            assertParamExists$1('getERC20Token', 'contractAddress', contractAddress);
            // verify required parameter 'chainName' is not null or undefined
            assertParamExists$1('getERC20Token', 'chainName', chainName);
            const localVarPath = `/v1/chains/{chain_name}/tokens/{contract_address}`
                .replace(`{${"contract_address"}}`, encodeURIComponent(String(contractAddress)))
                .replace(`{${"chain_name"}}`, encodeURIComponent(String(chainName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL$1);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            setSearchParams$1(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: toPathString$1(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List ERC20 tokens
         * @summary List ERC20 tokens
         * @param {string} chainName The name of chain
         * @param {string} [pageCursor] Encoded page cursor to retrieve previous or next page. Use the value returned in the response.
         * @param {number} [pageSize] Maximum number of items to return
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listERC20Tokens: async (chainName, pageCursor, pageSize, options = {}) => {
            // verify required parameter 'chainName' is not null or undefined
            assertParamExists$1('listERC20Tokens', 'chainName', chainName);
            const localVarPath = `/v1/chains/{chain_name}/tokens`
                .replace(`{${"chain_name"}}`, encodeURIComponent(String(chainName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL$1);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (pageCursor !== undefined) {
                localVarQueryParameter['page_cursor'] = pageCursor;
            }
            if (pageSize !== undefined) {
                localVarQueryParameter['page_size'] = pageSize;
            }
            setSearchParams$1(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: toPathString$1(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
/**
 * TokensApi - functional programming interface
 * @export
 */
const TokensApiFp = function (configuration) {
    const localVarAxiosParamCreator = TokensApiAxiosParamCreator(configuration);
    return {
        /**
         * Get single ERC20 token
         * @summary Get single ERC20 token
         * @param {string} contractAddress The address of contract
         * @param {string} chainName The name of chain
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getERC20Token(contractAddress, chainName, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getERC20Token(contractAddress, chainName, options);
            return createRequestFunction$1(localVarAxiosArgs, globalAxios$1, BASE_PATH$1, configuration);
        },
        /**
         * List ERC20 tokens
         * @summary List ERC20 tokens
         * @param {string} chainName The name of chain
         * @param {string} [pageCursor] Encoded page cursor to retrieve previous or next page. Use the value returned in the response.
         * @param {number} [pageSize] Maximum number of items to return
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listERC20Tokens(chainName, pageCursor, pageSize, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listERC20Tokens(chainName, pageCursor, pageSize, options);
            return createRequestFunction$1(localVarAxiosArgs, globalAxios$1, BASE_PATH$1, configuration);
        },
    };
};
/**
 * TokensApi - factory interface
 * @export
 */
const TokensApiFactory = function (configuration, basePath, axios) {
    const localVarFp = TokensApiFp(configuration);
    return {
        /**
         * Get single ERC20 token
         * @summary Get single ERC20 token
         * @param {string} contractAddress The address of contract
         * @param {string} chainName The name of chain
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getERC20Token(contractAddress, chainName, options) {
            return localVarFp.getERC20Token(contractAddress, chainName, options).then((request) => request(axios, basePath));
        },
        /**
         * List ERC20 tokens
         * @summary List ERC20 tokens
         * @param {string} chainName The name of chain
         * @param {string} [pageCursor] Encoded page cursor to retrieve previous or next page. Use the value returned in the response.
         * @param {number} [pageSize] Maximum number of items to return
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listERC20Tokens(chainName, pageCursor, pageSize, options) {
            return localVarFp.listERC20Tokens(chainName, pageCursor, pageSize, options).then((request) => request(axios, basePath));
        },
    };
};
/**
 * TokensApi - object-oriented interface
 * @export
 * @class TokensApi
 * @extends {BaseAPI}
 */
class TokensApi extends BaseAPI$1 {
    /**
     * Get single ERC20 token
     * @summary Get single ERC20 token
     * @param {TokensApiGetERC20TokenRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TokensApi
     */
    getERC20Token(requestParameters, options) {
        return TokensApiFp(this.configuration).getERC20Token(requestParameters.contractAddress, requestParameters.chainName, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * List ERC20 tokens
     * @summary List ERC20 tokens
     * @param {TokensApiListERC20TokensRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TokensApi
     */
    listERC20Tokens(requestParameters, options) {
        return TokensApiFp(this.configuration).listERC20Tokens(requestParameters.chainName, requestParameters.pageCursor, requestParameters.pageSize, options).then((request) => request(this.axios, this.basePath));
    }
}

/* tslint:disable */
/* eslint-disable */
/**
 * Immutable zkEVM API
 * Immutable Multi Rollup API
 *
 * The version of the OpenAPI document: 1.0.0
 * Contact: support@immutable.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
let Configuration$2 = class Configuration {
    /**
     * parameter for apiKey security
     * @param name security name
     * @memberof Configuration
     */
    apiKey;
    /**
     * parameter for basic security
     *
     * @type {string}
     * @memberof Configuration
     */
    username;
    /**
     * parameter for basic security
     *
     * @type {string}
     * @memberof Configuration
     */
    password;
    /**
     * parameter for oauth2 security
     * @param name security name
     * @param scopes oauth2 scope
     * @memberof Configuration
     */
    accessToken;
    /**
     * override base path
     *
     * @type {string}
     * @memberof Configuration
     */
    basePath;
    /**
     * base options for axios calls
     *
     * @type {any}
     * @memberof Configuration
     */
    baseOptions;
    /**
     * The FormData constructor that will be used to create multipart form data
     * requests. You can inject this here so that execution environments that
     * do not support the FormData class can still run the generated client.
     *
     * @type {new () => FormData}
     */
    formDataCtor;
    constructor(param = {}) {
        this.apiKey = param.apiKey;
        this.username = param.username;
        this.password = param.password;
        this.accessToken = param.accessToken;
        this.basePath = param.basePath;
        this.baseOptions = param.baseOptions;
        this.formDataCtor = param.formDataCtor;
    }
    /**
     * Check if the given MIME is a JSON MIME.
     * JSON MIME examples:
     *   application/json
     *   application/json; charset=UTF8
     *   APPLICATION/JSON
     *   application/vnd.company+json
     * @param mime - MIME (Multipurpose Internet Mail Extensions)
     * @return True if the given MIME is JSON, false otherwise.
     */
    isJsonMime(mime) {
        const jsonMime = new RegExp('^(application\/json|[^;/ \t]+\/[^;/ \t]+[+]json)[ \t]*(;.*)?$', 'i');
        return mime !== null && (jsonMime.test(mime) || mime.toLowerCase() === 'application/json-patch+json');
    }
};

/* tslint:disable */
/* eslint-disable */
/**
 * Immutable zkEVM API
 * Immutable Multi Rollup API
 *
 * The version of the OpenAPI document: 1.0.0
 * Contact: support@immutable.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
const APIError400AllOfCodeEnum = {
    ValidationError: 'VALIDATION_ERROR'
};

/* tslint:disable */
/* eslint-disable */
/**
 * Immutable zkEVM API
 * Immutable Multi Rollup API
 *
 * The version of the OpenAPI document: 1.0.0
 * Contact: support@immutable.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
const APIError401AllOfCodeEnum = {
    UnauthorisedRequest: 'UNAUTHORISED_REQUEST'
};

/* tslint:disable */
/* eslint-disable */
/**
 * Immutable zkEVM API
 * Immutable Multi Rollup API
 *
 * The version of the OpenAPI document: 1.0.0
 * Contact: support@immutable.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
const APIError403AllOfCodeEnum = {
    AuthenticationError: 'AUTHENTICATION_ERROR'
};

/* tslint:disable */
/* eslint-disable */
/**
 * Immutable zkEVM API
 * Immutable Multi Rollup API
 *
 * The version of the OpenAPI document: 1.0.0
 * Contact: support@immutable.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
const APIError404AllOfCodeEnum = {
    ResourceNotFound: 'RESOURCE_NOT_FOUND'
};

/* tslint:disable */
/* eslint-disable */
/**
 * Immutable zkEVM API
 * Immutable Multi Rollup API
 *
 * The version of the OpenAPI document: 1.0.0
 * Contact: support@immutable.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
const APIError429AllOfCodeEnum = {
    TooManyRequestsError: 'TOO_MANY_REQUESTS_ERROR'
};

/* tslint:disable */
/* eslint-disable */
/**
 * Immutable zkEVM API
 * Immutable Multi Rollup API
 *
 * The version of the OpenAPI document: 1.0.0
 * Contact: support@immutable.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
const APIError500AllOfCodeEnum = {
    InternalServerError: 'INTERNAL_SERVER_ERROR'
};

/* tslint:disable */
/* eslint-disable */
/**
 * Immutable zkEVM API
 * Immutable Multi Rollup API
 *
 * The version of the OpenAPI document: 1.0.0
 * Contact: support@immutable.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
/**
 * The activity type
 * @export
 * @enum {string}
 */
const ActivityType = {
    Mint: 'mint',
    Burn: 'burn',
    Transfer: 'transfer',
    Sale: 'sale',
    Deposit: 'deposit',
    Withdrawal: 'withdrawal'
};

/* tslint:disable */
/* eslint-disable */
/**
 * Immutable zkEVM API
 * Immutable Multi Rollup API
 *
 * The version of the OpenAPI document: 1.0.0
 * Contact: support@immutable.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
/**
 * The collection contract type
 * @export
 * @enum {string}
 */
const CollectionContractType = {
    Erc721: 'ERC721'
};

/* tslint:disable */
/* eslint-disable */
/**
 * Immutable zkEVM API
 * Immutable Multi Rollup API
 *
 * The version of the OpenAPI document: 1.0.0
 * Contact: support@immutable.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
const ERC20ItemItemTypeEnum = {
    Erc20: 'ERC20'
};

/* tslint:disable */
/* eslint-disable */
/**
 * Immutable zkEVM API
 * Immutable Multi Rollup API
 *
 * The version of the OpenAPI document: 1.0.0
 * Contact: support@immutable.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
const ERC721ItemItemTypeEnum = {
    Erc721: 'ERC721'
};

/* tslint:disable */
/* eslint-disable */
/**
 * Immutable zkEVM API
 * Immutable Multi Rollup API
 *
 * The version of the OpenAPI document: 1.0.0
 * Contact: support@immutable.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
const FeeFeeTypeEnum = {
    Royalty: 'ROYALTY',
    MakerMarketplace: 'MAKER_MARKETPLACE',
    TakerMarketplace: 'TAKER_MARKETPLACE',
    Protocol: 'PROTOCOL'
};

/* tslint:disable */
/* eslint-disable */
/**
 * Immutable zkEVM API
 * Immutable Multi Rollup API
 *
 * The version of the OpenAPI document: 1.0.0
 * Contact: support@immutable.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
/**
 * The contract type for an NFT
 * @export
 * @enum {string}
 */
const NFTContractType = {
    Erc721: 'ERC721'
};

/* tslint:disable */
/* eslint-disable */
/**
 * Immutable zkEVM API
 * Immutable Multi Rollup API
 *
 * The version of the OpenAPI document: 1.0.0
 * Contact: support@immutable.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
const NativeItemItemTypeEnum = {
    Native: 'NATIVE'
};

/* tslint:disable */
/* eslint-disable */
/**
 * Immutable zkEVM API
 * Immutable Multi Rollup API
 *
 * The version of the OpenAPI document: 1.0.0
 * Contact: support@immutable.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
/**
 * The Order status
 * @export
 * @enum {string}
 */
const OrderStatus$1 = {
    Pending: 'PENDING',
    Active: 'ACTIVE',
    Inactive: 'INACTIVE',
    Filled: 'FILLED',
    Cancelled: 'CANCELLED',
    Expired: 'EXPIRED'
};

/* tslint:disable */
/* eslint-disable */
/**
 * Immutable zkEVM API
 * Immutable Multi Rollup API
 *
 * The version of the OpenAPI document: 1.0.0
 * Contact: support@immutable.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
const ProtocolDataOrderTypeEnum = {
    FullRestricted: 'FULL_RESTRICTED'
};

/* tslint:disable */
/* eslint-disable */
/**
 * Immutable zkEVM API
 * Immutable Multi Rollup API
 *
 * The version of the OpenAPI document: 1.0.0
 * Contact: support@immutable.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
const SaleFeeTypeEnum = {
    Royalty: 'ROYALTY'
};

/* tslint:disable */
/* eslint-disable */
/**
 * Immutable zkEVM API
 * Immutable Multi Rollup API
 *
 * The version of the OpenAPI document: 1.0.0
 * Contact: support@immutable.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
/**
 * The contract type for a token
 * @export
 * @enum {string}
 */
const TokenContractType = {
    Erc20: 'ERC20'
};

/* tslint:disable */
/* eslint-disable */
/**
 * Immutable zkEVM API
 * Immutable Multi Rollup API
 *
 * The version of the OpenAPI document: 1.0.0
 * Contact: support@immutable.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

var index = /*#__PURE__*/Object.freeze({
    __proto__: null,
    APIError400AllOfCodeEnum: APIError400AllOfCodeEnum,
    APIError401AllOfCodeEnum: APIError401AllOfCodeEnum,
    APIError403AllOfCodeEnum: APIError403AllOfCodeEnum,
    APIError404AllOfCodeEnum: APIError404AllOfCodeEnum,
    APIError429AllOfCodeEnum: APIError429AllOfCodeEnum,
    APIError500AllOfCodeEnum: APIError500AllOfCodeEnum,
    ActivitiesApi: ActivitiesApi,
    ActivitiesApiAxiosParamCreator: ActivitiesApiAxiosParamCreator,
    ActivitiesApiFactory: ActivitiesApiFactory,
    ActivitiesApiFp: ActivitiesApiFp,
    ActivityType: ActivityType,
    ChainsApi: ChainsApi,
    ChainsApiAxiosParamCreator: ChainsApiAxiosParamCreator,
    ChainsApiFactory: ChainsApiFactory,
    ChainsApiFp: ChainsApiFp,
    CollectionContractType: CollectionContractType,
    CollectionsApi: CollectionsApi,
    CollectionsApiAxiosParamCreator: CollectionsApiAxiosParamCreator,
    CollectionsApiFactory: CollectionsApiFactory,
    CollectionsApiFp: CollectionsApiFp,
    Configuration: Configuration$2,
    ERC20ItemItemTypeEnum: ERC20ItemItemTypeEnum,
    ERC721ItemItemTypeEnum: ERC721ItemItemTypeEnum,
    FeeFeeTypeEnum: FeeFeeTypeEnum,
    MetadataApi: MetadataApi,
    MetadataApiAxiosParamCreator: MetadataApiAxiosParamCreator,
    MetadataApiFactory: MetadataApiFactory,
    MetadataApiFp: MetadataApiFp,
    NFTContractType: NFTContractType,
    NativeItemItemTypeEnum: NativeItemItemTypeEnum,
    NftOwnersApi: NftOwnersApi,
    NftOwnersApiAxiosParamCreator: NftOwnersApiAxiosParamCreator,
    NftOwnersApiFactory: NftOwnersApiFactory,
    NftOwnersApiFp: NftOwnersApiFp,
    NftsApi: NftsApi,
    NftsApiAxiosParamCreator: NftsApiAxiosParamCreator,
    NftsApiFactory: NftsApiFactory,
    NftsApiFp: NftsApiFp,
    OrderStatus: OrderStatus$1,
    OrdersApi: OrdersApi,
    OrdersApiAxiosParamCreator: OrdersApiAxiosParamCreator,
    OrdersApiFactory: OrdersApiFactory,
    OrdersApiFp: OrdersApiFp,
    PassportApi: PassportApi,
    PassportApiAxiosParamCreator: PassportApiAxiosParamCreator,
    PassportApiFactory: PassportApiFactory,
    PassportApiFp: PassportApiFp,
    ProtocolDataOrderTypeEnum: ProtocolDataOrderTypeEnum,
    SaleFeeTypeEnum: SaleFeeTypeEnum,
    TokenContractType: TokenContractType,
    TokensApi: TokensApi,
    TokensApiAxiosParamCreator: TokensApiAxiosParamCreator,
    TokensApiFactory: TokensApiFactory,
    TokensApiFp: TokensApiFp
});

class MultiRollupApiClients {
    config;
    activitiesApi;
    chainsApi;
    collectionApi;
    nftOwnersApi;
    nftsApi;
    ordersApi;
    passportApi;
    constructor(config) {
        this.config = config;
        this.activitiesApi = new ActivitiesApi(config.indexer);
        this.chainsApi = new ChainsApi(config.indexer);
        this.collectionApi = new CollectionsApi(config.indexer);
        this.nftOwnersApi = new NftOwnersApi(config.indexer);
        this.nftsApi = new NftsApi(config.indexer);
        this.ordersApi = new OrdersApi(config.orderBook);
        this.passportApi = new PassportApi(config.passport);
    }
}

// eslint-disable-next-line @typescript-eslint/naming-convention
const defaultHeaders$1 = { 'x-sdk-version': 'ts-immutable-sdk-0.22.0' };
const createConfig = ({ basePath, headers, }) => {
    if (!basePath.trim()) {
        throw Error('basePath can not be empty');
    }
    const composedHeaders = { ...defaultHeaders$1, ...(headers || {}) };
    const apiConfigOptions = {
        basePath,
        baseOptions: { headers: composedHeaders },
    };
    return new Configuration$1(apiConfigOptions);
};
/**
 * Creates a Configuration for the specified environment
 * @returns an MultiRollupAPIConfiguration
 */
const multiRollupConfig = {
    getProduction: () => ({
        indexer: createConfig({
            basePath: 'https://indexer-mr.imtbl.com',
        }),
        orderBook: createConfig({
            basePath: 'https://order-book-mr.imtbl.com',
        }),
        passport: createConfig({
            basePath: 'https://api.immutable.com',
        }),
    }),
    getSandbox: () => ({
        indexer: createConfig({
            basePath: 'https://api.sandbox.immutable.com',
        }),
        orderBook: createConfig({
            basePath: 'https://api.sandbox.immutable.com',
        }),
        passport: createConfig({
            basePath: 'https://api.sandbox.immutable.com',
        }),
    }),
};

/**
 * Custom Error class that is returned from the API when a request fails
 */
class APIError extends Error {
    code;
    details;
    link;
    traceId;
    constructor({ message, code, details, link, trace_id: traceId, }) {
        super(message);
        this.code = code;
        this.details = details;
        this.link = link;
        this.traceId = traceId;
    }
}

/* eslint-disable implicit-arrow-linebreak */
const defaultHeaders = {
    sdkVersion: 'ts-immutable-sdk-multi-rollup-api-client-0.22.0',
};
/**
 * createAPIConfiguration to create a custom Configuration
 * other than the production and sandbox defined below.
 */
const createAPIConfiguration = ({ basePath, headers: baseHeaders, }) => {
    if (!basePath.trim()) {
        throw Error('basePath can not be empty');
    }
    const headers = { ...(baseHeaders || {}), ...defaultHeaders };
    const configParams = {
        basePath,
        baseOptions: { headers },
    };
    return new index.Configuration(configParams);
};
const production$1 = () => createAPIConfiguration({
    basePath: 'https://indexer-mr.imtbl.com',
});
const sandbox$1 = () => createAPIConfiguration({
    basePath: 'https://api.sandbox.immutable.com',
});
class BlockchainDataConfiguration {
    apiConfig;
    baseConfig;
    constructor({ baseConfig, overrides }) {
        this.baseConfig = baseConfig;
        if (overrides) {
            this.apiConfig = createAPIConfiguration(overrides);
        }
        else {
            switch (baseConfig.environment) {
                case Environment$1.SANDBOX: {
                    this.apiConfig = sandbox$1();
                    break;
                }
                case Environment$1.PRODUCTION: {
                    this.apiConfig = production$1();
                    break;
                }
                default: {
                    this.apiConfig = sandbox$1();
                }
            }
        }
    }
}

/* eslint-disable @typescript-eslint/naming-convention */
/**
 * [Formats an error in the APIError shape](https://axios-http.com/docs/handling_errors)
 * @param error - The Error object thrown by the request
 * @returns APIError
 */
function formatError(error) {
    if (globalAxios$1.isAxiosError(error) && error.response) {
        const apiError = error.response.data;
        if (apiError.code && apiError.message) {
            return new APIError({
                code: apiError.code,
                message: apiError.message,
                details: apiError.details || null,
                link: apiError.link || '',
                trace_id: apiError.trace_id || '',
            });
        }
        return new APIError({
            code: error.code ?? error.response?.status.toString() ?? 'unknown_error_code',
            message: String(error),
            details: null,
            link: '',
            trace_id: '',
        });
    }
    return new APIError({
        code: 'unknown_error_code',
        message: String(error),
        details: null,
        link: '',
        trace_id: '',
    });
}

class BlockchainData {
    config;
    activities;
    chains;
    collections;
    nfts;
    nftOwners;
    tokens;
    constructor(moduleConfig) {
        this.config = new BlockchainDataConfiguration(moduleConfig);
        this.activities = new index.ActivitiesApi(this.config.apiConfig);
        this.chains = new index.ChainsApi(this.config.apiConfig);
        this.collections = new index.CollectionsApi(this.config.apiConfig);
        this.nfts = new index.NftsApi(this.config.apiConfig);
        this.nftOwners = new index.NftOwnersApi(this.config.apiConfig);
        this.tokens = new index.TokensApi(this.config.apiConfig);
    }
    /**
     * List all activities
     * @param request - the request object containing the parameters to be provided in the API request
     * @returns a promise that resolves with a list of activities
     * @throws {@link index.APIError}
     */
    async listActivities(request) {
        return await this.activities
            .listActivities(request)
            .then((res) => res.data)
            .catch((err) => {
            throw formatError(err);
        });
    }
    /**
     * Get a single activity by ID
     * @param request - the request object containing the parameters to be provided in the API request
     * @returns a promise that resolves with a single activity
     * @throws {@link index.APIError}
     */
    async getActivity(request) {
        return await this.activities
            .getActivity(request)
            .then((res) => res.data)
            .catch((err) => {
            throw formatError(err);
        });
    }
    /**
     * List supported chains
     * @param request - the request object containing the parameters to be provided in the API request
     * @returns a promise that resolves with a list of supported chains
     * @throws {@link index.APIError}
     */
    async listChains(request) {
        return await this.chains
            .listChains(request)
            .then((res) => res.data)
            .catch((err) => {
            throw formatError(err);
        });
    }
    /**
     * List all collections
     * @param request - the request object containing the parameters to be provided in the API request
     * @returns a promise that resolves with a list of collections
     * @throws {@link index.APIError}
     */
    async listCollections(request) {
        return await this.collections
            .listCollections(request)
            .then((res) => res.data)
            .catch((err) => {
            throw formatError(err);
        });
    }
    /**
     * List collections by NFT owner
     * @param request - the request object containing the parameters to be provided in the API request
     * @returns a promise that resolves with a list of collections
     * @throws {@link index.APIError}
     */
    async listCollectionsByNFTOwner(request) {
        return await this.collections
            .listCollectionsByNFTOwner(request)
            .then((res) => res.data)
            .catch((err) => {
            throw formatError(err);
        });
    }
    /**
     * Get collection by contract address
     * @param request - the request object containing the parameters to be provided in the API request
     * @returns a promise that resolves with a single collection
     * @throws {@link index.APIError}
     */
    async getCollection(request) {
        return await this.collections
            .getCollection(request)
            .then((res) => res.data)
            .catch((err) => {
            throw formatError(err);
        });
    }
    /**
     * Get NFT by token ID
     * @param request - the request object containing the parameters to be provided in the API request
     * @returns a promise that resolves with a single NFT
     * @throws {@link index.APIError}
     */
    async getNFT(request) {
        return await this.nfts
            .getNFT(request)
            .then((res) => res.data)
            .catch((err) => {
            throw formatError(err);
        });
    }
    /**
     * List NFTs by contract address
     * @param request - the request object containing the parameters to be provided in the API request
     * @returns a promise that resolves with a list of NFTs
     * @throws {@link index.APIError}
     */
    async listNFTs(request) {
        return await this.nfts
            .listNFTs(request)
            .then((res) => res.data)
            .catch((err) => {
            throw formatError(err);
        });
    }
    /**
     * List NFTs by account address
     * @param request - the request object containing the parameters to be provided in the API request
     * @returns a promise that resolves with a list of NFTs
     * @throws {@link index.APIError}
     */
    async listNFTsByAccountAddress(request) {
        return await this.nfts
            .listNFTsByAccountAddress(request)
            .then((res) => res.data)
            .catch((err) => {
            throw formatError(err);
        });
    }
    /**
     * List NFT owners by token ID
     * @param request - the request object containing the parameters to be provided in the API request
     * @returns a promise that resolves with a list of NFT owners
     * @throws {@link index.APIError}
     */
    async listNFTOwners(request) {
        return await this.nftOwners
            .listNFTOwners(request)
            .then((res) => res.data)
            .catch((err) => {
            throw formatError(err);
        });
    }
    /**
     * List ERC20 Token contracts
     * @param request - the request object containing the parameters to be provided in the API request
     * @returns a promise that resolves with a list of ERC20 Tokens
     * @throws {@link index.APIError}
     */
    async listTokens(request) {
        return await this.tokens
            .listERC20Tokens(request)
            .then((res) => res.data)
            .catch((err) => {
            throw formatError(err);
        });
    }
    /**
     * Get details for an ERC20 Token by contract address
     * @param request - the request object containing the parameters to be provided in the API request
     * @returns a promise that resolves with a list of ERC20 Tokens
     * @throws {@link index.APIError}
     */
    async getToken(request) {
        return await this.tokens
            .getERC20Token(request)
            .then((res) => res.data)
            .catch((err) => {
            throw formatError(err);
        });
    }
}

var blockchain_data = /*#__PURE__*/Object.freeze({
    __proto__: null,
    APIError: APIError,
    BlockchainData: BlockchainData
});

/**
 * createImmutableXConfiguration to create a custom ImmutableXConfiguration
 * other than the production and sandbox defined below.
 */
const createImmutableXConfiguration = ({ basePath, chainID, coreContractAddress, registrationContractAddress, }) => Config.createConfig({
    basePath,
    chainID,
    coreContractAddress,
    registrationContractAddress,
    sdkVersion: 'ts-immutable-sdk-0.22.0',
});
/**
 * Sets `sdkVersion` at the time of build
 */
const production = () => createImmutableXConfiguration({
    basePath: 'https://api.x.immutable.com',
    chainID: 1,
    coreContractAddress: '0x5FDCCA53617f4d2b9134B29090C87D01058e27e9',
    registrationContractAddress: '0x72a06bf2a1CE5e39cBA06c0CAb824960B587d64c',
});
/**
 * Sets `sdkVersion` at the time of build
 */
const sandbox = () => createImmutableXConfiguration({
    basePath: 'https://api.sandbox.x.immutable.com',
    chainID: 5,
    coreContractAddress: '0x7917eDb51ecD6CdB3F9854c3cc593F33de10c623',
    registrationContractAddress: '0x1C97Ada273C9A52253f463042f29117090Cd7D83',
});
class ImxConfiguration {
    immutableXConfig;
    baseConfig;
    constructor({ baseConfig, overrides }) {
        this.baseConfig = baseConfig;
        if (overrides) {
            this.immutableXConfig = overrides.immutableXConfig;
        }
        else {
            switch (baseConfig.environment) {
                case Environment$1.SANDBOX: {
                    this.immutableXConfig = sandbox();
                    break;
                }
                case Environment$1.PRODUCTION: {
                    this.immutableXConfig = production();
                    break;
                }
                default: {
                    this.immutableXConfig = sandbox();
                }
            }
        }
    }
}

class ImmutableXClient {
    immutableX;
    depositsApi;
    mintsApi;
    ordersApi;
    tokensApi;
    tradesApi;
    transfersApi;
    exchangeApi;
    nftCheckoutPrimaryApi;
    usersApi;
    withdrawalsApi;
    balanceApi;
    assetApi;
    collectionApi;
    metadataApi;
    metadataRefreshesApi;
    projectsApi;
    constructor(config) {
        const imxConfig = new ImxConfiguration(config);
        this.immutableX = new ImmutableX(imxConfig.immutableXConfig);
        this.depositsApi = this.immutableX.depositsApi;
        this.mintsApi = this.immutableX.mintsApi;
        this.ordersApi = this.immutableX.ordersApi;
        this.tokensApi = this.immutableX.tokensApi;
        this.tradesApi = this.immutableX.tradesApi;
        this.transfersApi = this.immutableX.transfersApi;
        this.exchangeApi = this.immutableX.exchangeApi;
        this.usersApi = this.immutableX.usersApi;
        this.withdrawalsApi = this.immutableX.withdrawalsApi;
        this.balanceApi = this.immutableX.balanceApi;
        this.assetApi = this.immutableX.assetApi;
        this.collectionApi = this.immutableX.collectionApi;
        this.metadataApi = this.immutableX.metadataApi;
        this.metadataRefreshesApi = this.immutableX.metadataRefreshesApi;
        this.nftCheckoutPrimaryApi = this.immutableX.nftCheckoutPrimaryApi;
        this.projectsApi = this.immutableX.projectsApi;
    }
    /**
     * Get details of a Deposit with the given ID
     * @param request - the request object containing the parameters to be provided in the API request
     * @returns a promise that resolves with the requested Deposit
     * @throws {@link index.IMXError}
     */
    getDeposit(request) {
        return this.immutableX.getDeposit(request);
    }
    /**
     * Get a list of Deposits
     * @param request - optional object containing the parameters to be provided in the API request
     * @returns a promise that resolves with the requested list of Deposits
     * @throws {@link index.IMXError}
     */
    listDeposits(request) {
        return this.immutableX.listDeposits(request);
    }
    /**
     * Get Stark keys for a registered User
     * @param ethAddress - the eth address of the User
     * @returns a promise that resolves with the requested User
     * @throws {@link index.IMXError}
     */
    getUser(ethAddress) {
        return this.immutableX.getUser(ethAddress);
    }
    /**
     * Get details of an Asset
     * @param request - the request object containing the parameters to be provided in the API request
     * @returns a promise that resolves with the requested Asset
     * @throws {@link index.IMXError}
     */
    getAsset(request) {
        return this.immutableX.getAsset(request);
    }
    /**
     * Get a list of Assets
     * @param request - optional object containing the parameters to be provided in the API request
     * @returns a promise that resolves with the requested list of Assets
     * @throws {@link index.IMXError}
     */
    listAssets(request) {
        return this.immutableX.listAssets(request);
    }
    /**
     * Create a Collection
     * @param ethSigner - the L1 signer
     * @param request - the request object to be provided in the API request
     * @returns a promise that resolves with the created Collection
     * @throws {@link index.IMXError}
     */
    createCollection(ethSigner, request) {
        return this.immutableX.createCollection(ethSigner, request);
    }
    /**
     * Get details of a Collection at the given address
     * @param request - the request object containing the parameters to be provided in the API request
     * @returns a promise that resolves with the requested Collection
     * @throws {@link index.IMXError}
     */
    getCollection(request) {
        return this.immutableX.getCollection(request);
    }
    /**
     * Get a list of Collection filters
     * @param request - the request object containing the parameters to be provided in the API request
     * @returns a promise that resolves with the requested list of Collection Filters
     * @throws {@link index.IMXError}
     */
    listCollectionFilters(request) {
        return this.immutableX.listCollectionFilters(request);
    }
    /**
     * Get a list of Collections
     * @param request - optional object containing the parameters to be provided in the API request
     * @returns a promise that resolves with the requested list of Collections
     * @throws {@link index.IMXError}
     */
    listCollections(request) {
        return this.collectionApi.listCollections(request).then((res) => res.data);
    }
    /**
     * Update a Collection
     * @param ethSigner - the L1 signer
     * @param collectionAddress - the Collection contract address
     * @param request - the request object containing the parameters to be provided in the API request
     * @returns a promise that resolves with the updated Collection
     * @throws {@link index.IMXError}
     */
    updateCollection(ethSigner, collectionAddress, request) {
        return this.immutableX.updateCollection(ethSigner, collectionAddress, request);
    }
    /**
     * Add metadata schema to Collection
     * @param ethSigner - the L1 signer
     * @param collectionAddress - the Collection contract address
     * @param request - the request object containing the parameters to be provided in the API request
     * @returns a promise that resolves with the SuccessResponse if successful
     * @throws {@link index.IMXError}
     */
    addMetadataSchemaToCollection(ethSigner, collectionAddress, request) {
        return this.immutableX.addMetadataSchemaToCollection(ethSigner, collectionAddress, request);
    }
    /**
     * Get Metadata schema
     * @param request - the request object containing the parameters to be provided in the API request
     * @returns a promise that resolves with the requested Metadata schema
     * @throws {@link index.IMXError}
     */
    getMetadataSchema(request) {
        return this.immutableX.getMetadataSchema(request);
    }
    /**
     * Update metadata schema by name
     * @param ethSigner - the L1 signer
     * @param collectionAddress - the Collection contract address
     * @param name - the Metadata schema name
     * @param request - the request object containing the parameters to be provided in the API request
     * @returns a promise that resolves with the SuccessResponse if successful
     * @throws {@link index.IMXError}
     */
    updateMetadataSchemaByName(ethSigner, collectionAddress, name, request) {
        return this.immutableX.updateMetadataSchemaByName(ethSigner, collectionAddress, name, request);
    }
    /**
     * Get a list of metadata refreshes
     * @param ethSigner - the L1 signer
     * @param collectionAddress - the Collection contract address
     * @param pageSize - the page size of the result
     * @param cursor - the cursor
     * @returns a promise that resolves with the requested metadata refreshes
     * @throws {@link index.IMXError}
     */
    listMetadataRefreshes(ethSigner, collectionAddress, pageSize, cursor) {
        return this.immutableX.listMetadataRefreshes(ethSigner, collectionAddress, pageSize, cursor);
    }
    /**
     * Get a list of metadata refresh errors
     * @param ethSigner - the L1 signer
     * @param refreshId - the metadata refresh ID
     * @param pageSize - the page size of the result
     * @param cursor - the cursor
     * @returns a promise that resolves with the requested metadata refresh errors
     * @throws {@link index.IMXError}
     */
    getMetadataRefreshErrors(ethSigner, refreshId, pageSize, cursor) {
        return this.immutableX.getMetadataRefreshErrors(ethSigner, refreshId, pageSize, cursor);
    }
    /**
     * Get a list of metadata refresh results
     * @param ethSigner - the L1 signer
     * @param refreshId - the metadata refresh ID
     * @returns a promise that resolves with the requested metadata refresh results
     * @throws {@link index.IMXError}
     */
    getMetadataRefreshResults(ethSigner, refreshId) {
        return this.immutableX.getMetadataRefreshResults(ethSigner, refreshId);
    }
    /**
     * Request a metadata refresh
     * @param ethSigner - the L1 signer
     * @param request the request object containing the parameters to be provided in the API request
     * @returns a promise that resolves with the requested metadata refresh
     * @throws {@link index.IMXError}
     */
    createMetadataRefresh(ethSigner, request) {
        return this.immutableX.createMetadataRefresh(ethSigner, request);
    }
    /**
     * Create a Project
     * @param ethSigner - the L1 signer
     * @param request - the request object containing the parameters to be provided in the API request
     * @returns a promise that resolves with the created Project
     * @throws {@link index.IMXError}
     */
    async createProject(ethSigner, request) {
        return this.immutableX.createProject(ethSigner, request);
    }
    /**
     * Get a Project
     * @param ethSigner - the L1 signer
     * @param id - the Project ID
     * @returns a promise that resolves with the requested Project
     * @throws {@link index.IMXError}
     */
    async getProject(ethSigner, id) {
        return this.immutableX.getProject(ethSigner, id);
    }
    /**
     * Get Projects owned by the given User
     * @param ethSigner - the L1 signer
     * @param pageSize - the page size of the result
     * @param cursor - the cursor
     * @param orderBy - the property to sort by
     * @param direction - direction to sort (asc/desc)
     * @returns a promise that resolves with the requested Projects
     * @throws {@link index.IMXError}
     */
    async getProjects(ethSigner, pageSize, cursor, orderBy, direction) {
        return this.immutableX.getProjects(ethSigner, pageSize, cursor, orderBy, direction);
    }
    /**
     * Get the token Balances of the User
     * @param request - the request object containing the parameters to be provided in the API request
     * @returns a promise that resolves with the requested Balance
     * @throws {@link index.IMXError}
     */
    getBalance(request) {
        return this.immutableX.getBalance(request);
    }
    /**
     * Get a list of Balances for given User
     * @param request the request object containing the parameters to be provided in the API request
     * @returns a promise that resolves with the requested list of Balances
     * @throws {@link index.IMXError}
     */
    listBalances(request) {
        return this.immutableX.listBalances(request);
    }
    /**
     * Get details of a Mint with the given ID
     * @param request the request object containing the parameters to be provided in the API request
     * @returns a promise that resolves with the requested Mint
     * @throws {@link index.IMXError}
     */
    getMint(request) {
        return this.immutableX.getMint(request);
    }
    /**
     * Get a list of Mints
     * @param request optional object containing the parameters to be provided in the API request
     * @returns a promise that resolves with the requested list of Mints
     * @throws {@link index.IMXError}
     */
    listMints(request) {
        return this.immutableX.listMints(request);
    }
    /**
     * Mint tokens in a batch with fees
     * @param ethSigner - the L1 signer
     * @param request - the request object to be provided in the API request
     * @returns a promise that resolves with the minted tokens
     * @throws {@link index.IMXError}
     */
    mint(ethSigner, request) {
        return this.immutableX.mint(ethSigner, request);
    }
    /**
     * Get a list of Withdrawals
     * @param request - optional object containing the parameters to be provided in the API request
     * @returns a promise that resolves with the requested list of Withdrawals
     * @throws {@link index.IMXError}
     */
    listWithdrawals(request) {
        return this.immutableX.listWithdrawals(request);
    }
    /**
     * Get details of Withdrawal with the given ID
     * @param request - the request object containing the parameters to be provided in the API request
     * @returns a promise that resolves with the requested Withdrawal
     * @throws {@link index.IMXError}
     */
    getWithdrawal(request) {
        return this.immutableX.getWithdrawal(request);
    }
    /**
     * Get details of an Order with the given ID
     * @param request - the request object containing the parameters to be provided in the API request
     * @returns a promise that resolves with the requested Order
     * @throws {@link index.IMXError}
     */
    getOrder(request) {
        return this.immutableX.getOrder(request);
    }
    /**
     * Get a list of Orders
     * @param request - optional object containing the parameters to be provided in the API request
     * @returns a promise that resolves with the requested list of Orders
     * @throws {@link index.IMXError}
     */
    listOrders(request) {
        return this.immutableX.listOrders(request);
    }
    /**
     * Get details of a Trade with the given ID
     * @param request - the request object containing the parameters to be provided in the API request
     * @returns a promise that resolves with the requested Trade
     * @throws {@link index.IMXError}
     */
    getTrade(request) {
        return this.immutableX.getTrade(request);
    }
    /**
     * Get a list of Trades
     * @param request - optional object containing the parameters to be provided in the API request
     * @returns a promise that resolves with the requested list of Trades
     * @throws {@link index.IMXError}
     */
    listTrades(request) {
        return this.immutableX.listTrades(request);
    }
    /**
     * Get details of a Token
     * @param request - the request object containing the parameters to be provided in the API request
     * @returns a promise that resolves with the requested Token
     * @throws {@link index.IMXError}
     */
    getToken(request) {
        return this.immutableX.getToken(request);
    }
    /**
     * Get a list of Tokens
     * @param request - optional object containing the parameters to be provided in the API request
     * @returns a promise that resolves with the requested list of Tokens
     * @throws {@link index.IMXError}
     */
    listTokens(request) {
        return this.immutableX.listTokens(request);
    }
    /**
     * Get details of a Transfer with the given ID
     * @param request - the request object containing the parameters to be provided in the API request
     * @returns a promise that resolves with the requested Transfer
     * @throws {@link index.IMXError}
     */
    getTransfer(request) {
        return this.immutableX.getTransfer(request);
    }
    /**
     * Get a list of Transfers
     * @param request - optional object containing the parameters to be provided in the API request
     * @returns a promise that resolves with the requested list of Transfers
     * @throws {@link index.IMXError}
     */
    listTransfers(request) {
        return this.immutableX.listTransfers(request);
    }
    /**
     * Create a new Exchange transaction
     * @param request - the request object to be provided in the API request
     * @returns a promise that resolves with the created Exchange Transaction
     * @throws {@link index.IMXError}
     */
    createExchange(request) {
        return this.immutableX.createExchange(request).then((res) => res.data);
    }
    /**
     * Get an Exchange transaction
     * @param request - the request object to be provided in the API request
     * @returns a promise that resolves with the Exchange Transaction
     * @throws {@link index.IMXError}
     */
    getExchange(request) {
        return this.immutableX.getExchange(request).then((res) => res.data);
    }
    /**
     * Get Exchange transactions
     * @param request - the request object to be provided in the API request
     * @returns a promise that resolves with Exchange Transactions
     * @throws {@link index.IMXError}
     */
    getExchanges(request) {
        return this.immutableX.getExchanges(request).then((res) => res.data);
    }
    /**
     * Create a new Transfer request
     * @param walletConnection - the pair of Eth/Stark signers
     * @param request - the request object to be provided in the API request
     * @returns a promise that resolves with the created Exchange Transfer
     * @throws {@link index.IMXError}
     */
    exchangeTransfer(walletConnection, request) {
        return this.immutableX.exchangeTransfer(walletConnection, request);
    }
    /**
     * Create a new nft primary transaction
     * @param request - the request object to be provided in the API request
     * @returns a promise that resolves with the created nft primary Transaction
     * @throws {@link index.IMXError}
     */
    createNftPrimary(request) {
        return this.immutableX.createNftPrimary(request).then((res) => res.data);
    }
    /**
     * Get nft primary supported currencies and their limits
     * @param request - the request object to be provided in the API request
     * @returns a promise that resolves with nft primary Currencies
     * @throws {@link index.IMXError}
     */
    getCurrenciesNFTCheckoutPrimary(request) {
        return this.immutableX
            .getCurrenciesNFTCheckoutPrimary(request)
            .then((res) => res.data);
    }
    /**
     * Get nft primary transaction by transaction id
     * @param request - the request object to be provided in the API request
     * @returns a promise that resolves with nft primary transaction
     * @throws {@link index.IMXError}
     */
    getNftPrimaryTransaction(request) {
        return this.immutableX
            .getNftPrimaryTransaction(request)
            .then((res) => res.data);
    }
    /**
     * Get list of nft primary transactions
     * @param request - the request object to be provided in the API request
     * @returns a promise that resolves with nft primary transaction
     * @throws {@link index.IMXError}
     */
    getNftPrimaryTransactions(request) {
        return this.immutableX
            .getNftPrimaryTransactions(request)
            .then((res) => res.data);
    }
}

var immutablex_client = /*#__PURE__*/Object.freeze({
    __proto__: null,
    IMXError: IMXError,
    ImmutableXClient: ImmutableXClient,
    imxClientCreateStarkSigner: createStarkSigner,
    imxClientGenerateLegacyStarkPrivateKey: generateLegacyStarkPrivateKey
});

function bind(fn, thisArg) {
  return function wrap() {
    return fn.apply(thisArg, arguments);
  };
}

// utils is a library of generic helper functions non-specific to axios

const {toString} = Object.prototype;
const {getPrototypeOf} = Object;

const kindOf = (cache => thing => {
    const str = toString.call(thing);
    return cache[str] || (cache[str] = str.slice(8, -1).toLowerCase());
})(Object.create(null));

const kindOfTest = (type) => {
  type = type.toLowerCase();
  return (thing) => kindOf(thing) === type
};

const typeOfTest = type => thing => typeof thing === type;

/**
 * Determine if a value is an Array
 *
 * @param {Object} val The value to test
 *
 * @returns {boolean} True if value is an Array, otherwise false
 */
const {isArray} = Array;

/**
 * Determine if a value is undefined
 *
 * @param {*} val The value to test
 *
 * @returns {boolean} True if the value is undefined, otherwise false
 */
const isUndefined = typeOfTest('undefined');

/**
 * Determine if a value is a Buffer
 *
 * @param {*} val The value to test
 *
 * @returns {boolean} True if value is a Buffer, otherwise false
 */
function isBuffer(val) {
  return val !== null && !isUndefined(val) && val.constructor !== null && !isUndefined(val.constructor)
    && isFunction(val.constructor.isBuffer) && val.constructor.isBuffer(val);
}

/**
 * Determine if a value is an ArrayBuffer
 *
 * @param {*} val The value to test
 *
 * @returns {boolean} True if value is an ArrayBuffer, otherwise false
 */
const isArrayBuffer = kindOfTest('ArrayBuffer');


/**
 * Determine if a value is a view on an ArrayBuffer
 *
 * @param {*} val The value to test
 *
 * @returns {boolean} True if value is a view on an ArrayBuffer, otherwise false
 */
function isArrayBufferView(val) {
  let result;
  if ((typeof ArrayBuffer !== 'undefined') && (ArrayBuffer.isView)) {
    result = ArrayBuffer.isView(val);
  } else {
    result = (val) && (val.buffer) && (isArrayBuffer(val.buffer));
  }
  return result;
}

/**
 * Determine if a value is a String
 *
 * @param {*} val The value to test
 *
 * @returns {boolean} True if value is a String, otherwise false
 */
const isString$1 = typeOfTest('string');

/**
 * Determine if a value is a Function
 *
 * @param {*} val The value to test
 * @returns {boolean} True if value is a Function, otherwise false
 */
const isFunction = typeOfTest('function');

/**
 * Determine if a value is a Number
 *
 * @param {*} val The value to test
 *
 * @returns {boolean} True if value is a Number, otherwise false
 */
const isNumber = typeOfTest('number');

/**
 * Determine if a value is an Object
 *
 * @param {*} thing The value to test
 *
 * @returns {boolean} True if value is an Object, otherwise false
 */
const isObject = (thing) => thing !== null && typeof thing === 'object';

/**
 * Determine if a value is a Boolean
 *
 * @param {*} thing The value to test
 * @returns {boolean} True if value is a Boolean, otherwise false
 */
const isBoolean = thing => thing === true || thing === false;

/**
 * Determine if a value is a plain Object
 *
 * @param {*} val The value to test
 *
 * @returns {boolean} True if value is a plain Object, otherwise false
 */
const isPlainObject = (val) => {
  if (kindOf(val) !== 'object') {
    return false;
  }

  const prototype = getPrototypeOf(val);
  return (prototype === null || prototype === Object.prototype || Object.getPrototypeOf(prototype) === null) && !(Symbol.toStringTag in val) && !(Symbol.iterator in val);
};

/**
 * Determine if a value is a Date
 *
 * @param {*} val The value to test
 *
 * @returns {boolean} True if value is a Date, otherwise false
 */
const isDate = kindOfTest('Date');

/**
 * Determine if a value is a File
 *
 * @param {*} val The value to test
 *
 * @returns {boolean} True if value is a File, otherwise false
 */
const isFile = kindOfTest('File');

/**
 * Determine if a value is a Blob
 *
 * @param {*} val The value to test
 *
 * @returns {boolean} True if value is a Blob, otherwise false
 */
const isBlob$1 = kindOfTest('Blob');

/**
 * Determine if a value is a FileList
 *
 * @param {*} val The value to test
 *
 * @returns {boolean} True if value is a File, otherwise false
 */
const isFileList = kindOfTest('FileList');

/**
 * Determine if a value is a Stream
 *
 * @param {*} val The value to test
 *
 * @returns {boolean} True if value is a Stream, otherwise false
 */
const isStream = (val) => isObject(val) && isFunction(val.pipe);

/**
 * Determine if a value is a FormData
 *
 * @param {*} thing The value to test
 *
 * @returns {boolean} True if value is an FormData, otherwise false
 */
const isFormData$1 = (thing) => {
  let kind;
  return thing && (
    (typeof FormData === 'function' && thing instanceof FormData) || (
      isFunction(thing.append) && (
        (kind = kindOf(thing)) === 'formdata' ||
        // detect form-data instance
        (kind === 'object' && isFunction(thing.toString) && thing.toString() === '[object FormData]')
      )
    )
  )
};

/**
 * Determine if a value is a URLSearchParams object
 *
 * @param {*} val The value to test
 *
 * @returns {boolean} True if value is a URLSearchParams object, otherwise false
 */
const isURLSearchParams = kindOfTest('URLSearchParams');

/**
 * Trim excess whitespace off the beginning and end of a string
 *
 * @param {String} str The String to trim
 *
 * @returns {String} The String freed of excess whitespace
 */
const trim = (str) => str.trim ?
  str.trim() : str.replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, '');

/**
 * Iterate over an Array or an Object invoking a function for each item.
 *
 * If `obj` is an Array callback will be called passing
 * the value, index, and complete array for each item.
 *
 * If 'obj' is an Object callback will be called passing
 * the value, key, and complete object for each property.
 *
 * @param {Object|Array} obj The object to iterate
 * @param {Function} fn The callback to invoke for each item
 *
 * @param {Boolean} [allOwnKeys = false]
 * @returns {any}
 */
function forEach(obj, fn, {allOwnKeys = false} = {}) {
  // Don't bother if no value provided
  if (obj === null || typeof obj === 'undefined') {
    return;
  }

  let i;
  let l;

  // Force an array if not already something iterable
  if (typeof obj !== 'object') {
    /*eslint no-param-reassign:0*/
    obj = [obj];
  }

  if (isArray(obj)) {
    // Iterate over array values
    for (i = 0, l = obj.length; i < l; i++) {
      fn.call(null, obj[i], i, obj);
    }
  } else {
    // Iterate over object keys
    const keys = allOwnKeys ? Object.getOwnPropertyNames(obj) : Object.keys(obj);
    const len = keys.length;
    let key;

    for (i = 0; i < len; i++) {
      key = keys[i];
      fn.call(null, obj[key], key, obj);
    }
  }
}

function findKey(obj, key) {
  key = key.toLowerCase();
  const keys = Object.keys(obj);
  let i = keys.length;
  let _key;
  while (i-- > 0) {
    _key = keys[i];
    if (key === _key.toLowerCase()) {
      return _key;
    }
  }
  return null;
}

const _global = (() => {
  /*eslint no-undef:0*/
  if (typeof globalThis !== "undefined") return globalThis;
  return typeof self !== "undefined" ? self : (typeof window !== 'undefined' ? window : global)
})();

const isContextDefined = (context) => !isUndefined(context) && context !== _global;

/**
 * Accepts varargs expecting each argument to be an object, then
 * immutably merges the properties of each object and returns result.
 *
 * When multiple objects contain the same key the later object in
 * the arguments list will take precedence.
 *
 * Example:
 *
 * ```js
 * var result = merge({foo: 123}, {foo: 456});
 * console.log(result.foo); // outputs 456
 * ```
 *
 * @param {Object} obj1 Object to merge
 *
 * @returns {Object} Result of all merge properties
 */
function merge(/* obj1, obj2, obj3, ... */) {
  const {caseless} = isContextDefined(this) && this || {};
  const result = {};
  const assignValue = (val, key) => {
    const targetKey = caseless && findKey(result, key) || key;
    if (isPlainObject(result[targetKey]) && isPlainObject(val)) {
      result[targetKey] = merge(result[targetKey], val);
    } else if (isPlainObject(val)) {
      result[targetKey] = merge({}, val);
    } else if (isArray(val)) {
      result[targetKey] = val.slice();
    } else {
      result[targetKey] = val;
    }
  };

  for (let i = 0, l = arguments.length; i < l; i++) {
    arguments[i] && forEach(arguments[i], assignValue);
  }
  return result;
}

/**
 * Extends object a by mutably adding to it the properties of object b.
 *
 * @param {Object} a The object to be extended
 * @param {Object} b The object to copy properties from
 * @param {Object} thisArg The object to bind function to
 *
 * @param {Boolean} [allOwnKeys]
 * @returns {Object} The resulting value of object a
 */
const extend = (a, b, thisArg, {allOwnKeys}= {}) => {
  forEach(b, (val, key) => {
    if (thisArg && isFunction(val)) {
      a[key] = bind(val, thisArg);
    } else {
      a[key] = val;
    }
  }, {allOwnKeys});
  return a;
};

/**
 * Remove byte order marker. This catches EF BB BF (the UTF-8 BOM)
 *
 * @param {string} content with BOM
 *
 * @returns {string} content value without BOM
 */
const stripBOM = (content) => {
  if (content.charCodeAt(0) === 0xFEFF) {
    content = content.slice(1);
  }
  return content;
};

/**
 * Inherit the prototype methods from one constructor into another
 * @param {function} constructor
 * @param {function} superConstructor
 * @param {object} [props]
 * @param {object} [descriptors]
 *
 * @returns {void}
 */
const inherits = (constructor, superConstructor, props, descriptors) => {
  constructor.prototype = Object.create(superConstructor.prototype, descriptors);
  constructor.prototype.constructor = constructor;
  Object.defineProperty(constructor, 'super', {
    value: superConstructor.prototype
  });
  props && Object.assign(constructor.prototype, props);
};

/**
 * Resolve object with deep prototype chain to a flat object
 * @param {Object} sourceObj source object
 * @param {Object} [destObj]
 * @param {Function|Boolean} [filter]
 * @param {Function} [propFilter]
 *
 * @returns {Object}
 */
const toFlatObject = (sourceObj, destObj, filter, propFilter) => {
  let props;
  let i;
  let prop;
  const merged = {};

  destObj = destObj || {};
  // eslint-disable-next-line no-eq-null,eqeqeq
  if (sourceObj == null) return destObj;

  do {
    props = Object.getOwnPropertyNames(sourceObj);
    i = props.length;
    while (i-- > 0) {
      prop = props[i];
      if ((!propFilter || propFilter(prop, sourceObj, destObj)) && !merged[prop]) {
        destObj[prop] = sourceObj[prop];
        merged[prop] = true;
      }
    }
    sourceObj = filter !== false && getPrototypeOf(sourceObj);
  } while (sourceObj && (!filter || filter(sourceObj, destObj)) && sourceObj !== Object.prototype);

  return destObj;
};

/**
 * Determines whether a string ends with the characters of a specified string
 *
 * @param {String} str
 * @param {String} searchString
 * @param {Number} [position= 0]
 *
 * @returns {boolean}
 */
const endsWith = (str, searchString, position) => {
  str = String(str);
  if (position === undefined || position > str.length) {
    position = str.length;
  }
  position -= searchString.length;
  const lastIndex = str.indexOf(searchString, position);
  return lastIndex !== -1 && lastIndex === position;
};


/**
 * Returns new array from array like object or null if failed
 *
 * @param {*} [thing]
 *
 * @returns {?Array}
 */
const toArray = (thing) => {
  if (!thing) return null;
  if (isArray(thing)) return thing;
  let i = thing.length;
  if (!isNumber(i)) return null;
  const arr = new Array(i);
  while (i-- > 0) {
    arr[i] = thing[i];
  }
  return arr;
};

/**
 * Checking if the Uint8Array exists and if it does, it returns a function that checks if the
 * thing passed in is an instance of Uint8Array
 *
 * @param {TypedArray}
 *
 * @returns {Array}
 */
// eslint-disable-next-line func-names
const isTypedArray = (TypedArray => {
  // eslint-disable-next-line func-names
  return thing => {
    return TypedArray && thing instanceof TypedArray;
  };
})(typeof Uint8Array !== 'undefined' && getPrototypeOf(Uint8Array));

/**
 * For each entry in the object, call the function with the key and value.
 *
 * @param {Object<any, any>} obj - The object to iterate over.
 * @param {Function} fn - The function to call for each entry.
 *
 * @returns {void}
 */
const forEachEntry = (obj, fn) => {
  const generator = obj && obj[Symbol.iterator];

  const iterator = generator.call(obj);

  let result;

  while ((result = iterator.next()) && !result.done) {
    const pair = result.value;
    fn.call(obj, pair[0], pair[1]);
  }
};

/**
 * It takes a regular expression and a string, and returns an array of all the matches
 *
 * @param {string} regExp - The regular expression to match against.
 * @param {string} str - The string to search.
 *
 * @returns {Array<boolean>}
 */
const matchAll = (regExp, str) => {
  let matches;
  const arr = [];

  while ((matches = regExp.exec(str)) !== null) {
    arr.push(matches);
  }

  return arr;
};

/* Checking if the kindOfTest function returns true when passed an HTMLFormElement. */
const isHTMLForm = kindOfTest('HTMLFormElement');

const toCamelCase = str => {
  return str.toLowerCase().replace(/[-_\s]([a-z\d])(\w*)/g,
    function replacer(m, p1, p2) {
      return p1.toUpperCase() + p2;
    }
  );
};

/* Creating a function that will check if an object has a property. */
const hasOwnProperty = (({hasOwnProperty}) => (obj, prop) => hasOwnProperty.call(obj, prop))(Object.prototype);

/**
 * Determine if a value is a RegExp object
 *
 * @param {*} val The value to test
 *
 * @returns {boolean} True if value is a RegExp object, otherwise false
 */
const isRegExp = kindOfTest('RegExp');

const reduceDescriptors = (obj, reducer) => {
  const descriptors = Object.getOwnPropertyDescriptors(obj);
  const reducedDescriptors = {};

  forEach(descriptors, (descriptor, name) => {
    if (reducer(descriptor, name, obj) !== false) {
      reducedDescriptors[name] = descriptor;
    }
  });

  Object.defineProperties(obj, reducedDescriptors);
};

/**
 * Makes all methods read-only
 * @param {Object} obj
 */

const freezeMethods = (obj) => {
  reduceDescriptors(obj, (descriptor, name) => {
    // skip restricted props in strict mode
    if (isFunction(obj) && ['arguments', 'caller', 'callee'].indexOf(name) !== -1) {
      return false;
    }

    const value = obj[name];

    if (!isFunction(value)) return;

    descriptor.enumerable = false;

    if ('writable' in descriptor) {
      descriptor.writable = false;
      return;
    }

    if (!descriptor.set) {
      descriptor.set = () => {
        throw Error('Can not rewrite read-only method \'' + name + '\'');
      };
    }
  });
};

const toObjectSet = (arrayOrString, delimiter) => {
  const obj = {};

  const define = (arr) => {
    arr.forEach(value => {
      obj[value] = true;
    });
  };

  isArray(arrayOrString) ? define(arrayOrString) : define(String(arrayOrString).split(delimiter));

  return obj;
};

const noop = () => {};

const toFiniteNumber = (value, defaultValue) => {
  value = +value;
  return Number.isFinite(value) ? value : defaultValue;
};

const ALPHA = 'abcdefghijklmnopqrstuvwxyz';

const DIGIT = '0123456789';

const ALPHABET = {
  DIGIT,
  ALPHA,
  ALPHA_DIGIT: ALPHA + ALPHA.toUpperCase() + DIGIT
};

const generateString = (size = 16, alphabet = ALPHABET.ALPHA_DIGIT) => {
  let str = '';
  const {length} = alphabet;
  while (size--) {
    str += alphabet[Math.random() * length|0];
  }

  return str;
};

/**
 * If the thing is a FormData object, return true, otherwise return false.
 *
 * @param {unknown} thing - The thing to check.
 *
 * @returns {boolean}
 */
function isSpecCompliantForm(thing) {
  return !!(thing && isFunction(thing.append) && thing[Symbol.toStringTag] === 'FormData' && thing[Symbol.iterator]);
}

const toJSONObject = (obj) => {
  const stack = new Array(10);

  const visit = (source, i) => {

    if (isObject(source)) {
      if (stack.indexOf(source) >= 0) {
        return;
      }

      if(!('toJSON' in source)) {
        stack[i] = source;
        const target = isArray(source) ? [] : {};

        forEach(source, (value, key) => {
          const reducedValue = visit(value, i + 1);
          !isUndefined(reducedValue) && (target[key] = reducedValue);
        });

        stack[i] = undefined;

        return target;
      }
    }

    return source;
  };

  return visit(obj, 0);
};

const isAsyncFn = kindOfTest('AsyncFunction');

const isThenable = (thing) =>
  thing && (isObject(thing) || isFunction(thing)) && isFunction(thing.then) && isFunction(thing.catch);

var utils = {
  isArray,
  isArrayBuffer,
  isBuffer,
  isFormData: isFormData$1,
  isArrayBufferView,
  isString: isString$1,
  isNumber,
  isBoolean,
  isObject,
  isPlainObject,
  isUndefined,
  isDate,
  isFile,
  isBlob: isBlob$1,
  isRegExp,
  isFunction,
  isStream,
  isURLSearchParams,
  isTypedArray,
  isFileList,
  forEach,
  merge,
  extend,
  trim,
  stripBOM,
  inherits,
  toFlatObject,
  kindOf,
  kindOfTest,
  endsWith,
  toArray,
  forEachEntry,
  matchAll,
  isHTMLForm,
  hasOwnProperty,
  hasOwnProp: hasOwnProperty, // an alias to avoid ESLint no-prototype-builtins detection
  reduceDescriptors,
  freezeMethods,
  toObjectSet,
  toCamelCase,
  noop,
  toFiniteNumber,
  findKey,
  global: _global,
  isContextDefined,
  ALPHABET,
  generateString,
  isSpecCompliantForm,
  toJSONObject,
  isAsyncFn,
  isThenable
};

/**
 * Create an Error with the specified message, config, error code, request and response.
 *
 * @param {string} message The error message.
 * @param {string} [code] The error code (for example, 'ECONNABORTED').
 * @param {Object} [config] The config.
 * @param {Object} [request] The request.
 * @param {Object} [response] The response.
 *
 * @returns {Error} The created error.
 */
function AxiosError(message, code, config, request, response) {
  Error.call(this);

  if (Error.captureStackTrace) {
    Error.captureStackTrace(this, this.constructor);
  } else {
    this.stack = (new Error()).stack;
  }

  this.message = message;
  this.name = 'AxiosError';
  code && (this.code = code);
  config && (this.config = config);
  request && (this.request = request);
  response && (this.response = response);
}

utils.inherits(AxiosError, Error, {
  toJSON: function toJSON() {
    return {
      // Standard
      message: this.message,
      name: this.name,
      // Microsoft
      description: this.description,
      number: this.number,
      // Mozilla
      fileName: this.fileName,
      lineNumber: this.lineNumber,
      columnNumber: this.columnNumber,
      stack: this.stack,
      // Axios
      config: utils.toJSONObject(this.config),
      code: this.code,
      status: this.response && this.response.status ? this.response.status : null
    };
  }
});

const prototype$1 = AxiosError.prototype;
const descriptors = {};

[
  'ERR_BAD_OPTION_VALUE',
  'ERR_BAD_OPTION',
  'ECONNABORTED',
  'ETIMEDOUT',
  'ERR_NETWORK',
  'ERR_FR_TOO_MANY_REDIRECTS',
  'ERR_DEPRECATED',
  'ERR_BAD_RESPONSE',
  'ERR_BAD_REQUEST',
  'ERR_CANCELED',
  'ERR_NOT_SUPPORT',
  'ERR_INVALID_URL'
// eslint-disable-next-line func-names
].forEach(code => {
  descriptors[code] = {value: code};
});

Object.defineProperties(AxiosError, descriptors);
Object.defineProperty(prototype$1, 'isAxiosError', {value: true});

// eslint-disable-next-line func-names
AxiosError.from = (error, code, config, request, response, customProps) => {
  const axiosError = Object.create(prototype$1);

  utils.toFlatObject(error, axiosError, function filter(obj) {
    return obj !== Error.prototype;
  }, prop => {
    return prop !== 'isAxiosError';
  });

  AxiosError.call(axiosError, error.message, code, config, request, response);

  axiosError.cause = error;

  axiosError.name = error.name;

  customProps && Object.assign(axiosError, customProps);

  return axiosError;
};

// eslint-disable-next-line strict
var httpAdapter = null;

/**
 * Determines if the given thing is a array or js object.
 *
 * @param {string} thing - The object or array to be visited.
 *
 * @returns {boolean}
 */
function isVisitable(thing) {
  return utils.isPlainObject(thing) || utils.isArray(thing);
}

/**
 * It removes the brackets from the end of a string
 *
 * @param {string} key - The key of the parameter.
 *
 * @returns {string} the key without the brackets.
 */
function removeBrackets(key) {
  return utils.endsWith(key, '[]') ? key.slice(0, -2) : key;
}

/**
 * It takes a path, a key, and a boolean, and returns a string
 *
 * @param {string} path - The path to the current key.
 * @param {string} key - The key of the current object being iterated over.
 * @param {string} dots - If true, the key will be rendered with dots instead of brackets.
 *
 * @returns {string} The path to the current key.
 */
function renderKey(path, key, dots) {
  if (!path) return key;
  return path.concat(key).map(function each(token, i) {
    // eslint-disable-next-line no-param-reassign
    token = removeBrackets(token);
    return !dots && i ? '[' + token + ']' : token;
  }).join(dots ? '.' : '');
}

/**
 * If the array is an array and none of its elements are visitable, then it's a flat array.
 *
 * @param {Array<any>} arr - The array to check
 *
 * @returns {boolean}
 */
function isFlatArray(arr) {
  return utils.isArray(arr) && !arr.some(isVisitable);
}

const predicates = utils.toFlatObject(utils, {}, null, function filter(prop) {
  return /^is[A-Z]/.test(prop);
});

/**
 * Convert a data object to FormData
 *
 * @param {Object} obj
 * @param {?Object} [formData]
 * @param {?Object} [options]
 * @param {Function} [options.visitor]
 * @param {Boolean} [options.metaTokens = true]
 * @param {Boolean} [options.dots = false]
 * @param {?Boolean} [options.indexes = false]
 *
 * @returns {Object}
 **/

/**
 * It converts an object into a FormData object
 *
 * @param {Object<any, any>} obj - The object to convert to form data.
 * @param {string} formData - The FormData object to append to.
 * @param {Object<string, any>} options
 *
 * @returns
 */
function toFormData(obj, formData, options) {
  if (!utils.isObject(obj)) {
    throw new TypeError('target must be an object');
  }

  // eslint-disable-next-line no-param-reassign
  formData = formData || new (FormData)();

  // eslint-disable-next-line no-param-reassign
  options = utils.toFlatObject(options, {
    metaTokens: true,
    dots: false,
    indexes: false
  }, false, function defined(option, source) {
    // eslint-disable-next-line no-eq-null,eqeqeq
    return !utils.isUndefined(source[option]);
  });

  const metaTokens = options.metaTokens;
  // eslint-disable-next-line no-use-before-define
  const visitor = options.visitor || defaultVisitor;
  const dots = options.dots;
  const indexes = options.indexes;
  const _Blob = options.Blob || typeof Blob !== 'undefined' && Blob;
  const useBlob = _Blob && utils.isSpecCompliantForm(formData);

  if (!utils.isFunction(visitor)) {
    throw new TypeError('visitor must be a function');
  }

  function convertValue(value) {
    if (value === null) return '';

    if (utils.isDate(value)) {
      return value.toISOString();
    }

    if (!useBlob && utils.isBlob(value)) {
      throw new AxiosError('Blob is not supported. Use a Buffer instead.');
    }

    if (utils.isArrayBuffer(value) || utils.isTypedArray(value)) {
      return useBlob && typeof Blob === 'function' ? new Blob([value]) : Buffer.from(value);
    }

    return value;
  }

  /**
   * Default visitor.
   *
   * @param {*} value
   * @param {String|Number} key
   * @param {Array<String|Number>} path
   * @this {FormData}
   *
   * @returns {boolean} return true to visit the each prop of the value recursively
   */
  function defaultVisitor(value, key, path) {
    let arr = value;

    if (value && !path && typeof value === 'object') {
      if (utils.endsWith(key, '{}')) {
        // eslint-disable-next-line no-param-reassign
        key = metaTokens ? key : key.slice(0, -2);
        // eslint-disable-next-line no-param-reassign
        value = JSON.stringify(value);
      } else if (
        (utils.isArray(value) && isFlatArray(value)) ||
        ((utils.isFileList(value) || utils.endsWith(key, '[]')) && (arr = utils.toArray(value))
        )) {
        // eslint-disable-next-line no-param-reassign
        key = removeBrackets(key);

        arr.forEach(function each(el, index) {
          !(utils.isUndefined(el) || el === null) && formData.append(
            // eslint-disable-next-line no-nested-ternary
            indexes === true ? renderKey([key], index, dots) : (indexes === null ? key : key + '[]'),
            convertValue(el)
          );
        });
        return false;
      }
    }

    if (isVisitable(value)) {
      return true;
    }

    formData.append(renderKey(path, key, dots), convertValue(value));

    return false;
  }

  const stack = [];

  const exposedHelpers = Object.assign(predicates, {
    defaultVisitor,
    convertValue,
    isVisitable
  });

  function build(value, path) {
    if (utils.isUndefined(value)) return;

    if (stack.indexOf(value) !== -1) {
      throw Error('Circular reference detected in ' + path.join('.'));
    }

    stack.push(value);

    utils.forEach(value, function each(el, key) {
      const result = !(utils.isUndefined(el) || el === null) && visitor.call(
        formData, el, utils.isString(key) ? key.trim() : key, path, exposedHelpers
      );

      if (result === true) {
        build(el, path ? path.concat(key) : [key]);
      }
    });

    stack.pop();
  }

  if (!utils.isObject(obj)) {
    throw new TypeError('data must be an object');
  }

  build(obj);

  return formData;
}

/**
 * It encodes a string by replacing all characters that are not in the unreserved set with
 * their percent-encoded equivalents
 *
 * @param {string} str - The string to encode.
 *
 * @returns {string} The encoded string.
 */
function encode$1(str) {
  const charMap = {
    '!': '%21',
    "'": '%27',
    '(': '%28',
    ')': '%29',
    '~': '%7E',
    '%20': '+',
    '%00': '\x00'
  };
  return encodeURIComponent(str).replace(/[!'()~]|%20|%00/g, function replacer(match) {
    return charMap[match];
  });
}

/**
 * It takes a params object and converts it to a FormData object
 *
 * @param {Object<string, any>} params - The parameters to be converted to a FormData object.
 * @param {Object<string, any>} options - The options object passed to the Axios constructor.
 *
 * @returns {void}
 */
function AxiosURLSearchParams(params, options) {
  this._pairs = [];

  params && toFormData(params, this, options);
}

const prototype = AxiosURLSearchParams.prototype;

prototype.append = function append(name, value) {
  this._pairs.push([name, value]);
};

prototype.toString = function toString(encoder) {
  const _encode = encoder ? function(value) {
    return encoder.call(this, value, encode$1);
  } : encode$1;

  return this._pairs.map(function each(pair) {
    return _encode(pair[0]) + '=' + _encode(pair[1]);
  }, '').join('&');
};

/**
 * It replaces all instances of the characters `:`, `$`, `,`, `+`, `[`, and `]` with their
 * URI encoded counterparts
 *
 * @param {string} val The value to be encoded.
 *
 * @returns {string} The encoded value.
 */
function encode$2(val) {
  return encodeURIComponent(val).
    replace(/%3A/gi, ':').
    replace(/%24/g, '$').
    replace(/%2C/gi, ',').
    replace(/%20/g, '+').
    replace(/%5B/gi, '[').
    replace(/%5D/gi, ']');
}

/**
 * Build a URL by appending params to the end
 *
 * @param {string} url The base of the url (e.g., http://www.google.com)
 * @param {object} [params] The params to be appended
 * @param {?object} options
 *
 * @returns {string} The formatted url
 */
function buildURL(url, params, options) {
  /*eslint no-param-reassign:0*/
  if (!params) {
    return url;
  }
  
  const _encode = options && options.encode || encode$2;

  const serializeFn = options && options.serialize;

  let serializedParams;

  if (serializeFn) {
    serializedParams = serializeFn(params, options);
  } else {
    serializedParams = utils.isURLSearchParams(params) ?
      params.toString() :
      new AxiosURLSearchParams(params, options).toString(_encode);
  }

  if (serializedParams) {
    const hashmarkIndex = url.indexOf("#");

    if (hashmarkIndex !== -1) {
      url = url.slice(0, hashmarkIndex);
    }
    url += (url.indexOf('?') === -1 ? '?' : '&') + serializedParams;
  }

  return url;
}

class InterceptorManager {
  constructor() {
    this.handlers = [];
  }

  /**
   * Add a new interceptor to the stack
   *
   * @param {Function} fulfilled The function to handle `then` for a `Promise`
   * @param {Function} rejected The function to handle `reject` for a `Promise`
   *
   * @return {Number} An ID used to remove interceptor later
   */
  use(fulfilled, rejected, options) {
    this.handlers.push({
      fulfilled,
      rejected,
      synchronous: options ? options.synchronous : false,
      runWhen: options ? options.runWhen : null
    });
    return this.handlers.length - 1;
  }

  /**
   * Remove an interceptor from the stack
   *
   * @param {Number} id The ID that was returned by `use`
   *
   * @returns {Boolean} `true` if the interceptor was removed, `false` otherwise
   */
  eject(id) {
    if (this.handlers[id]) {
      this.handlers[id] = null;
    }
  }

  /**
   * Clear all interceptors from the stack
   *
   * @returns {void}
   */
  clear() {
    if (this.handlers) {
      this.handlers = [];
    }
  }

  /**
   * Iterate over all the registered interceptors
   *
   * This method is particularly useful for skipping over any
   * interceptors that may have become `null` calling `eject`.
   *
   * @param {Function} fn The function to call for each interceptor
   *
   * @returns {void}
   */
  forEach(fn) {
    utils.forEach(this.handlers, function forEachHandler(h) {
      if (h !== null) {
        fn(h);
      }
    });
  }
}

var InterceptorManager$1 = InterceptorManager;

var transitionalDefaults = {
  silentJSONParsing: true,
  forcedJSONParsing: true,
  clarifyTimeoutError: false
};

var URLSearchParams$1 = typeof URLSearchParams !== 'undefined' ? URLSearchParams : AxiosURLSearchParams;

var FormData$1 = typeof FormData !== 'undefined' ? FormData : null;

var Blob$1 = typeof Blob !== 'undefined' ? Blob : null;

/**
 * Determine if we're running in a standard browser environment
 *
 * This allows axios to run in a web worker, and react-native.
 * Both environments support XMLHttpRequest, but not fully standard globals.
 *
 * web workers:
 *  typeof window -> undefined
 *  typeof document -> undefined
 *
 * react-native:
 *  navigator.product -> 'ReactNative'
 * nativescript
 *  navigator.product -> 'NativeScript' or 'NS'
 *
 * @returns {boolean}
 */
const isStandardBrowserEnv = (() => {
  let product;
  if (typeof navigator !== 'undefined' && (
    (product = navigator.product) === 'ReactNative' ||
    product === 'NativeScript' ||
    product === 'NS')
  ) {
    return false;
  }

  return typeof window !== 'undefined' && typeof document !== 'undefined';
})();

/**
 * Determine if we're running in a standard browser webWorker environment
 *
 * Although the `isStandardBrowserEnv` method indicates that
 * `allows axios to run in a web worker`, the WebWorker will still be
 * filtered out due to its judgment standard
 * `typeof window !== 'undefined' && typeof document !== 'undefined'`.
 * This leads to a problem when axios post `FormData` in webWorker
 */
 const isStandardBrowserWebWorkerEnv = (() => {
  return (
    typeof WorkerGlobalScope !== 'undefined' &&
    // eslint-disable-next-line no-undef
    self instanceof WorkerGlobalScope &&
    typeof self.importScripts === 'function'
  );
})();


var platform = {
  isBrowser: true,
  classes: {
    URLSearchParams: URLSearchParams$1,
    FormData: FormData$1,
    Blob: Blob$1
  },
  isStandardBrowserEnv,
  isStandardBrowserWebWorkerEnv,
  protocols: ['http', 'https', 'file', 'blob', 'url', 'data']
};

function toURLEncodedForm(data, options) {
  return toFormData(data, new platform.classes.URLSearchParams(), Object.assign({
    visitor: function(value, key, path, helpers) {
      if (platform.isNode && utils.isBuffer(value)) {
        this.append(key, value.toString('base64'));
        return false;
      }

      return helpers.defaultVisitor.apply(this, arguments);
    }
  }, options));
}

/**
 * It takes a string like `foo[x][y][z]` and returns an array like `['foo', 'x', 'y', 'z']
 *
 * @param {string} name - The name of the property to get.
 *
 * @returns An array of strings.
 */
function parsePropPath(name) {
  // foo[x][y][z]
  // foo.x.y.z
  // foo-x-y-z
  // foo x y z
  return utils.matchAll(/\w+|\[(\w*)]/g, name).map(match => {
    return match[0] === '[]' ? '' : match[1] || match[0];
  });
}

/**
 * Convert an array to an object.
 *
 * @param {Array<any>} arr - The array to convert to an object.
 *
 * @returns An object with the same keys and values as the array.
 */
function arrayToObject(arr) {
  const obj = {};
  const keys = Object.keys(arr);
  let i;
  const len = keys.length;
  let key;
  for (i = 0; i < len; i++) {
    key = keys[i];
    obj[key] = arr[key];
  }
  return obj;
}

/**
 * It takes a FormData object and returns a JavaScript object
 *
 * @param {string} formData The FormData object to convert to JSON.
 *
 * @returns {Object<string, any> | null} The converted object.
 */
function formDataToJSON(formData) {
  function buildPath(path, value, target, index) {
    let name = path[index++];
    const isNumericKey = Number.isFinite(+name);
    const isLast = index >= path.length;
    name = !name && utils.isArray(target) ? target.length : name;

    if (isLast) {
      if (utils.hasOwnProp(target, name)) {
        target[name] = [target[name], value];
      } else {
        target[name] = value;
      }

      return !isNumericKey;
    }

    if (!target[name] || !utils.isObject(target[name])) {
      target[name] = [];
    }

    const result = buildPath(path, value, target[name], index);

    if (result && utils.isArray(target[name])) {
      target[name] = arrayToObject(target[name]);
    }

    return !isNumericKey;
  }

  if (utils.isFormData(formData) && utils.isFunction(formData.entries)) {
    const obj = {};

    utils.forEachEntry(formData, (name, value) => {
      buildPath(parsePropPath(name), value, obj, 0);
    });

    return obj;
  }

  return null;
}

const DEFAULT_CONTENT_TYPE = {
  'Content-Type': undefined
};

/**
 * It takes a string, tries to parse it, and if it fails, it returns the stringified version
 * of the input
 *
 * @param {any} rawValue - The value to be stringified.
 * @param {Function} parser - A function that parses a string into a JavaScript object.
 * @param {Function} encoder - A function that takes a value and returns a string.
 *
 * @returns {string} A stringified version of the rawValue.
 */
function stringifySafely(rawValue, parser, encoder) {
  if (utils.isString(rawValue)) {
    try {
      (parser || JSON.parse)(rawValue);
      return utils.trim(rawValue);
    } catch (e) {
      if (e.name !== 'SyntaxError') {
        throw e;
      }
    }
  }

  return (encoder || JSON.stringify)(rawValue);
}

const defaults = {

  transitional: transitionalDefaults,

  adapter: ['xhr', 'http'],

  transformRequest: [function transformRequest(data, headers) {
    const contentType = headers.getContentType() || '';
    const hasJSONContentType = contentType.indexOf('application/json') > -1;
    const isObjectPayload = utils.isObject(data);

    if (isObjectPayload && utils.isHTMLForm(data)) {
      data = new FormData(data);
    }

    const isFormData = utils.isFormData(data);

    if (isFormData) {
      if (!hasJSONContentType) {
        return data;
      }
      return hasJSONContentType ? JSON.stringify(formDataToJSON(data)) : data;
    }

    if (utils.isArrayBuffer(data) ||
      utils.isBuffer(data) ||
      utils.isStream(data) ||
      utils.isFile(data) ||
      utils.isBlob(data)
    ) {
      return data;
    }
    if (utils.isArrayBufferView(data)) {
      return data.buffer;
    }
    if (utils.isURLSearchParams(data)) {
      headers.setContentType('application/x-www-form-urlencoded;charset=utf-8', false);
      return data.toString();
    }

    let isFileList;

    if (isObjectPayload) {
      if (contentType.indexOf('application/x-www-form-urlencoded') > -1) {
        return toURLEncodedForm(data, this.formSerializer).toString();
      }

      if ((isFileList = utils.isFileList(data)) || contentType.indexOf('multipart/form-data') > -1) {
        const _FormData = this.env && this.env.FormData;

        return toFormData(
          isFileList ? {'files[]': data} : data,
          _FormData && new _FormData(),
          this.formSerializer
        );
      }
    }

    if (isObjectPayload || hasJSONContentType ) {
      headers.setContentType('application/json', false);
      return stringifySafely(data);
    }

    return data;
  }],

  transformResponse: [function transformResponse(data) {
    const transitional = this.transitional || defaults.transitional;
    const forcedJSONParsing = transitional && transitional.forcedJSONParsing;
    const JSONRequested = this.responseType === 'json';

    if (data && utils.isString(data) && ((forcedJSONParsing && !this.responseType) || JSONRequested)) {
      const silentJSONParsing = transitional && transitional.silentJSONParsing;
      const strictJSONParsing = !silentJSONParsing && JSONRequested;

      try {
        return JSON.parse(data);
      } catch (e) {
        if (strictJSONParsing) {
          if (e.name === 'SyntaxError') {
            throw AxiosError.from(e, AxiosError.ERR_BAD_RESPONSE, this, null, this.response);
          }
          throw e;
        }
      }
    }

    return data;
  }],

  /**
   * A timeout in milliseconds to abort a request. If set to 0 (default) a
   * timeout is not created.
   */
  timeout: 0,

  xsrfCookieName: 'XSRF-TOKEN',
  xsrfHeaderName: 'X-XSRF-TOKEN',

  maxContentLength: -1,
  maxBodyLength: -1,

  env: {
    FormData: platform.classes.FormData,
    Blob: platform.classes.Blob
  },

  validateStatus: function validateStatus(status) {
    return status >= 200 && status < 300;
  },

  headers: {
    common: {
      'Accept': 'application/json, text/plain, */*'
    }
  }
};

utils.forEach(['delete', 'get', 'head'], function forEachMethodNoData(method) {
  defaults.headers[method] = {};
});

utils.forEach(['post', 'put', 'patch'], function forEachMethodWithData(method) {
  defaults.headers[method] = utils.merge(DEFAULT_CONTENT_TYPE);
});

var defaults$1 = defaults;

// RawAxiosHeaders whose duplicates are ignored by node
// c.f. https://nodejs.org/api/http.html#http_message_headers
const ignoreDuplicateOf = utils.toObjectSet([
  'age', 'authorization', 'content-length', 'content-type', 'etag',
  'expires', 'from', 'host', 'if-modified-since', 'if-unmodified-since',
  'last-modified', 'location', 'max-forwards', 'proxy-authorization',
  'referer', 'retry-after', 'user-agent'
]);

/**
 * Parse headers into an object
 *
 * ```
 * Date: Wed, 27 Aug 2014 08:58:49 GMT
 * Content-Type: application/json
 * Connection: keep-alive
 * Transfer-Encoding: chunked
 * ```
 *
 * @param {String} rawHeaders Headers needing to be parsed
 *
 * @returns {Object} Headers parsed into an object
 */
var parseHeaders = rawHeaders => {
  const parsed = {};
  let key;
  let val;
  let i;

  rawHeaders && rawHeaders.split('\n').forEach(function parser(line) {
    i = line.indexOf(':');
    key = line.substring(0, i).trim().toLowerCase();
    val = line.substring(i + 1).trim();

    if (!key || (parsed[key] && ignoreDuplicateOf[key])) {
      return;
    }

    if (key === 'set-cookie') {
      if (parsed[key]) {
        parsed[key].push(val);
      } else {
        parsed[key] = [val];
      }
    } else {
      parsed[key] = parsed[key] ? parsed[key] + ', ' + val : val;
    }
  });

  return parsed;
};

const $internals = Symbol('internals');

function normalizeHeader(header) {
  return header && String(header).trim().toLowerCase();
}

function normalizeValue(value) {
  if (value === false || value == null) {
    return value;
  }

  return utils.isArray(value) ? value.map(normalizeValue) : String(value);
}

function parseTokens(str) {
  const tokens = Object.create(null);
  const tokensRE = /([^\s,;=]+)\s*(?:=\s*([^,;]+))?/g;
  let match;

  while ((match = tokensRE.exec(str))) {
    tokens[match[1]] = match[2];
  }

  return tokens;
}

const isValidHeaderName = (str) => /^[-_a-zA-Z0-9^`|~,!#$%&'*+.]+$/.test(str.trim());

function matchHeaderValue(context, value, header, filter, isHeaderNameFilter) {
  if (utils.isFunction(filter)) {
    return filter.call(this, value, header);
  }

  if (isHeaderNameFilter) {
    value = header;
  }

  if (!utils.isString(value)) return;

  if (utils.isString(filter)) {
    return value.indexOf(filter) !== -1;
  }

  if (utils.isRegExp(filter)) {
    return filter.test(value);
  }
}

function formatHeader(header) {
  return header.trim()
    .toLowerCase().replace(/([a-z\d])(\w*)/g, (w, char, str) => {
      return char.toUpperCase() + str;
    });
}

function buildAccessors(obj, header) {
  const accessorName = utils.toCamelCase(' ' + header);

  ['get', 'set', 'has'].forEach(methodName => {
    Object.defineProperty(obj, methodName + accessorName, {
      value: function(arg1, arg2, arg3) {
        return this[methodName].call(this, header, arg1, arg2, arg3);
      },
      configurable: true
    });
  });
}

class AxiosHeaders {
  constructor(headers) {
    headers && this.set(headers);
  }

  set(header, valueOrRewrite, rewrite) {
    const self = this;

    function setHeader(_value, _header, _rewrite) {
      const lHeader = normalizeHeader(_header);

      if (!lHeader) {
        throw new Error('header name must be a non-empty string');
      }

      const key = utils.findKey(self, lHeader);

      if(!key || self[key] === undefined || _rewrite === true || (_rewrite === undefined && self[key] !== false)) {
        self[key || _header] = normalizeValue(_value);
      }
    }

    const setHeaders = (headers, _rewrite) =>
      utils.forEach(headers, (_value, _header) => setHeader(_value, _header, _rewrite));

    if (utils.isPlainObject(header) || header instanceof this.constructor) {
      setHeaders(header, valueOrRewrite);
    } else if(utils.isString(header) && (header = header.trim()) && !isValidHeaderName(header)) {
      setHeaders(parseHeaders(header), valueOrRewrite);
    } else {
      header != null && setHeader(valueOrRewrite, header, rewrite);
    }

    return this;
  }

  get(header, parser) {
    header = normalizeHeader(header);

    if (header) {
      const key = utils.findKey(this, header);

      if (key) {
        const value = this[key];

        if (!parser) {
          return value;
        }

        if (parser === true) {
          return parseTokens(value);
        }

        if (utils.isFunction(parser)) {
          return parser.call(this, value, key);
        }

        if (utils.isRegExp(parser)) {
          return parser.exec(value);
        }

        throw new TypeError('parser must be boolean|regexp|function');
      }
    }
  }

  has(header, matcher) {
    header = normalizeHeader(header);

    if (header) {
      const key = utils.findKey(this, header);

      return !!(key && this[key] !== undefined && (!matcher || matchHeaderValue(this, this[key], key, matcher)));
    }

    return false;
  }

  delete(header, matcher) {
    const self = this;
    let deleted = false;

    function deleteHeader(_header) {
      _header = normalizeHeader(_header);

      if (_header) {
        const key = utils.findKey(self, _header);

        if (key && (!matcher || matchHeaderValue(self, self[key], key, matcher))) {
          delete self[key];

          deleted = true;
        }
      }
    }

    if (utils.isArray(header)) {
      header.forEach(deleteHeader);
    } else {
      deleteHeader(header);
    }

    return deleted;
  }

  clear(matcher) {
    const keys = Object.keys(this);
    let i = keys.length;
    let deleted = false;

    while (i--) {
      const key = keys[i];
      if(!matcher || matchHeaderValue(this, this[key], key, matcher, true)) {
        delete this[key];
        deleted = true;
      }
    }

    return deleted;
  }

  normalize(format) {
    const self = this;
    const headers = {};

    utils.forEach(this, (value, header) => {
      const key = utils.findKey(headers, header);

      if (key) {
        self[key] = normalizeValue(value);
        delete self[header];
        return;
      }

      const normalized = format ? formatHeader(header) : String(header).trim();

      if (normalized !== header) {
        delete self[header];
      }

      self[normalized] = normalizeValue(value);

      headers[normalized] = true;
    });

    return this;
  }

  concat(...targets) {
    return this.constructor.concat(this, ...targets);
  }

  toJSON(asStrings) {
    const obj = Object.create(null);

    utils.forEach(this, (value, header) => {
      value != null && value !== false && (obj[header] = asStrings && utils.isArray(value) ? value.join(', ') : value);
    });

    return obj;
  }

  [Symbol.iterator]() {
    return Object.entries(this.toJSON())[Symbol.iterator]();
  }

  toString() {
    return Object.entries(this.toJSON()).map(([header, value]) => header + ': ' + value).join('\n');
  }

  get [Symbol.toStringTag]() {
    return 'AxiosHeaders';
  }

  static from(thing) {
    return thing instanceof this ? thing : new this(thing);
  }

  static concat(first, ...targets) {
    const computed = new this(first);

    targets.forEach((target) => computed.set(target));

    return computed;
  }

  static accessor(header) {
    const internals = this[$internals] = (this[$internals] = {
      accessors: {}
    });

    const accessors = internals.accessors;
    const prototype = this.prototype;

    function defineAccessor(_header) {
      const lHeader = normalizeHeader(_header);

      if (!accessors[lHeader]) {
        buildAccessors(prototype, _header);
        accessors[lHeader] = true;
      }
    }

    utils.isArray(header) ? header.forEach(defineAccessor) : defineAccessor(header);

    return this;
  }
}

AxiosHeaders.accessor(['Content-Type', 'Content-Length', 'Accept', 'Accept-Encoding', 'User-Agent', 'Authorization']);

utils.freezeMethods(AxiosHeaders.prototype);
utils.freezeMethods(AxiosHeaders);

var AxiosHeaders$1 = AxiosHeaders;

/**
 * Transform the data for a request or a response
 *
 * @param {Array|Function} fns A single function or Array of functions
 * @param {?Object} response The response object
 *
 * @returns {*} The resulting transformed data
 */
function transformData(fns, response) {
  const config = this || defaults$1;
  const context = response || config;
  const headers = AxiosHeaders$1.from(context.headers);
  let data = context.data;

  utils.forEach(fns, function transform(fn) {
    data = fn.call(config, data, headers.normalize(), response ? response.status : undefined);
  });

  headers.normalize();

  return data;
}

function isCancel(value) {
  return !!(value && value.__CANCEL__);
}

/**
 * A `CanceledError` is an object that is thrown when an operation is canceled.
 *
 * @param {string=} message The message.
 * @param {Object=} config The config.
 * @param {Object=} request The request.
 *
 * @returns {CanceledError} The created error.
 */
function CanceledError(message, config, request) {
  // eslint-disable-next-line no-eq-null,eqeqeq
  AxiosError.call(this, message == null ? 'canceled' : message, AxiosError.ERR_CANCELED, config, request);
  this.name = 'CanceledError';
}

utils.inherits(CanceledError, AxiosError, {
  __CANCEL__: true
});

/**
 * Resolve or reject a Promise based on response status.
 *
 * @param {Function} resolve A function that resolves the promise.
 * @param {Function} reject A function that rejects the promise.
 * @param {object} response The response.
 *
 * @returns {object} The response.
 */
function settle(resolve, reject, response) {
  const validateStatus = response.config.validateStatus;
  if (!response.status || !validateStatus || validateStatus(response.status)) {
    resolve(response);
  } else {
    reject(new AxiosError(
      'Request failed with status code ' + response.status,
      [AxiosError.ERR_BAD_REQUEST, AxiosError.ERR_BAD_RESPONSE][Math.floor(response.status / 100) - 4],
      response.config,
      response.request,
      response
    ));
  }
}

var cookies = platform.isStandardBrowserEnv ?

// Standard browser envs support document.cookie
  (function standardBrowserEnv() {
    return {
      write: function write(name, value, expires, path, domain, secure) {
        const cookie = [];
        cookie.push(name + '=' + encodeURIComponent(value));

        if (utils.isNumber(expires)) {
          cookie.push('expires=' + new Date(expires).toGMTString());
        }

        if (utils.isString(path)) {
          cookie.push('path=' + path);
        }

        if (utils.isString(domain)) {
          cookie.push('domain=' + domain);
        }

        if (secure === true) {
          cookie.push('secure');
        }

        document.cookie = cookie.join('; ');
      },

      read: function read(name) {
        const match = document.cookie.match(new RegExp('(^|;\\s*)(' + name + ')=([^;]*)'));
        return (match ? decodeURIComponent(match[3]) : null);
      },

      remove: function remove(name) {
        this.write(name, '', Date.now() - 86400000);
      }
    };
  })() :

// Non standard browser env (web workers, react-native) lack needed support.
  (function nonStandardBrowserEnv() {
    return {
      write: function write() {},
      read: function read() { return null; },
      remove: function remove() {}
    };
  })();

/**
 * Determines whether the specified URL is absolute
 *
 * @param {string} url The URL to test
 *
 * @returns {boolean} True if the specified URL is absolute, otherwise false
 */
function isAbsoluteURL(url) {
  // A URL is considered absolute if it begins with "<scheme>://" or "//" (protocol-relative URL).
  // RFC 3986 defines scheme name as a sequence of characters beginning with a letter and followed
  // by any combination of letters, digits, plus, period, or hyphen.
  return /^([a-z][a-z\d+\-.]*:)?\/\//i.test(url);
}

/**
 * Creates a new URL by combining the specified URLs
 *
 * @param {string} baseURL The base URL
 * @param {string} relativeURL The relative URL
 *
 * @returns {string} The combined URL
 */
function combineURLs(baseURL, relativeURL) {
  return relativeURL
    ? baseURL.replace(/\/+$/, '') + '/' + relativeURL.replace(/^\/+/, '')
    : baseURL;
}

/**
 * Creates a new URL by combining the baseURL with the requestedURL,
 * only when the requestedURL is not already an absolute URL.
 * If the requestURL is absolute, this function returns the requestedURL untouched.
 *
 * @param {string} baseURL The base URL
 * @param {string} requestedURL Absolute or relative URL to combine
 *
 * @returns {string} The combined full path
 */
function buildFullPath(baseURL, requestedURL) {
  if (baseURL && !isAbsoluteURL(requestedURL)) {
    return combineURLs(baseURL, requestedURL);
  }
  return requestedURL;
}

var isURLSameOrigin = platform.isStandardBrowserEnv ?

// Standard browser envs have full support of the APIs needed to test
// whether the request URL is of the same origin as current location.
  (function standardBrowserEnv() {
    const msie = /(msie|trident)/i.test(navigator.userAgent);
    const urlParsingNode = document.createElement('a');
    let originURL;

    /**
    * Parse a URL to discover it's components
    *
    * @param {String} url The URL to be parsed
    * @returns {Object}
    */
    function resolveURL(url) {
      let href = url;

      if (msie) {
        // IE needs attribute set twice to normalize properties
        urlParsingNode.setAttribute('href', href);
        href = urlParsingNode.href;
      }

      urlParsingNode.setAttribute('href', href);

      // urlParsingNode provides the UrlUtils interface - http://url.spec.whatwg.org/#urlutils
      return {
        href: urlParsingNode.href,
        protocol: urlParsingNode.protocol ? urlParsingNode.protocol.replace(/:$/, '') : '',
        host: urlParsingNode.host,
        search: urlParsingNode.search ? urlParsingNode.search.replace(/^\?/, '') : '',
        hash: urlParsingNode.hash ? urlParsingNode.hash.replace(/^#/, '') : '',
        hostname: urlParsingNode.hostname,
        port: urlParsingNode.port,
        pathname: (urlParsingNode.pathname.charAt(0) === '/') ?
          urlParsingNode.pathname :
          '/' + urlParsingNode.pathname
      };
    }

    originURL = resolveURL(window.location.href);

    /**
    * Determine if a URL shares the same origin as the current location
    *
    * @param {String} requestURL The URL to test
    * @returns {boolean} True if URL shares the same origin, otherwise false
    */
    return function isURLSameOrigin(requestURL) {
      const parsed = (utils.isString(requestURL)) ? resolveURL(requestURL) : requestURL;
      return (parsed.protocol === originURL.protocol &&
          parsed.host === originURL.host);
    };
  })() :

  // Non standard browser envs (web workers, react-native) lack needed support.
  (function nonStandardBrowserEnv() {
    return function isURLSameOrigin() {
      return true;
    };
  })();

function parseProtocol(url) {
  const match = /^([-+\w]{1,25})(:?\/\/|:)/.exec(url);
  return match && match[1] || '';
}

/**
 * Calculate data maxRate
 * @param {Number} [samplesCount= 10]
 * @param {Number} [min= 1000]
 * @returns {Function}
 */
function speedometer(samplesCount, min) {
  samplesCount = samplesCount || 10;
  const bytes = new Array(samplesCount);
  const timestamps = new Array(samplesCount);
  let head = 0;
  let tail = 0;
  let firstSampleTS;

  min = min !== undefined ? min : 1000;

  return function push(chunkLength) {
    const now = Date.now();

    const startedAt = timestamps[tail];

    if (!firstSampleTS) {
      firstSampleTS = now;
    }

    bytes[head] = chunkLength;
    timestamps[head] = now;

    let i = tail;
    let bytesCount = 0;

    while (i !== head) {
      bytesCount += bytes[i++];
      i = i % samplesCount;
    }

    head = (head + 1) % samplesCount;

    if (head === tail) {
      tail = (tail + 1) % samplesCount;
    }

    if (now - firstSampleTS < min) {
      return;
    }

    const passed = startedAt && now - startedAt;

    return passed ? Math.round(bytesCount * 1000 / passed) : undefined;
  };
}

function progressEventReducer(listener, isDownloadStream) {
  let bytesNotified = 0;
  const _speedometer = speedometer(50, 250);

  return e => {
    const loaded = e.loaded;
    const total = e.lengthComputable ? e.total : undefined;
    const progressBytes = loaded - bytesNotified;
    const rate = _speedometer(progressBytes);
    const inRange = loaded <= total;

    bytesNotified = loaded;

    const data = {
      loaded,
      total,
      progress: total ? (loaded / total) : undefined,
      bytes: progressBytes,
      rate: rate ? rate : undefined,
      estimated: rate && total && inRange ? (total - loaded) / rate : undefined,
      event: e
    };

    data[isDownloadStream ? 'download' : 'upload'] = true;

    listener(data);
  };
}

const isXHRAdapterSupported = typeof XMLHttpRequest !== 'undefined';

var xhrAdapter = isXHRAdapterSupported && function (config) {
  return new Promise(function dispatchXhrRequest(resolve, reject) {
    let requestData = config.data;
    const requestHeaders = AxiosHeaders$1.from(config.headers).normalize();
    const responseType = config.responseType;
    let onCanceled;
    function done() {
      if (config.cancelToken) {
        config.cancelToken.unsubscribe(onCanceled);
      }

      if (config.signal) {
        config.signal.removeEventListener('abort', onCanceled);
      }
    }

    if (utils.isFormData(requestData)) {
      if (platform.isStandardBrowserEnv || platform.isStandardBrowserWebWorkerEnv) {
        requestHeaders.setContentType(false); // Let the browser set it
      } else {
        requestHeaders.setContentType('multipart/form-data;', false); // mobile/desktop app frameworks
      }
    }

    let request = new XMLHttpRequest();

    // HTTP basic authentication
    if (config.auth) {
      const username = config.auth.username || '';
      const password = config.auth.password ? unescape(encodeURIComponent(config.auth.password)) : '';
      requestHeaders.set('Authorization', 'Basic ' + btoa(username + ':' + password));
    }

    const fullPath = buildFullPath(config.baseURL, config.url);

    request.open(config.method.toUpperCase(), buildURL(fullPath, config.params, config.paramsSerializer), true);

    // Set the request timeout in MS
    request.timeout = config.timeout;

    function onloadend() {
      if (!request) {
        return;
      }
      // Prepare the response
      const responseHeaders = AxiosHeaders$1.from(
        'getAllResponseHeaders' in request && request.getAllResponseHeaders()
      );
      const responseData = !responseType || responseType === 'text' || responseType === 'json' ?
        request.responseText : request.response;
      const response = {
        data: responseData,
        status: request.status,
        statusText: request.statusText,
        headers: responseHeaders,
        config,
        request
      };

      settle(function _resolve(value) {
        resolve(value);
        done();
      }, function _reject(err) {
        reject(err);
        done();
      }, response);

      // Clean up request
      request = null;
    }

    if ('onloadend' in request) {
      // Use onloadend if available
      request.onloadend = onloadend;
    } else {
      // Listen for ready state to emulate onloadend
      request.onreadystatechange = function handleLoad() {
        if (!request || request.readyState !== 4) {
          return;
        }

        // The request errored out and we didn't get a response, this will be
        // handled by onerror instead
        // With one exception: request that using file: protocol, most browsers
        // will return status as 0 even though it's a successful request
        if (request.status === 0 && !(request.responseURL && request.responseURL.indexOf('file:') === 0)) {
          return;
        }
        // readystate handler is calling before onerror or ontimeout handlers,
        // so we should call onloadend on the next 'tick'
        setTimeout(onloadend);
      };
    }

    // Handle browser request cancellation (as opposed to a manual cancellation)
    request.onabort = function handleAbort() {
      if (!request) {
        return;
      }

      reject(new AxiosError('Request aborted', AxiosError.ECONNABORTED, config, request));

      // Clean up request
      request = null;
    };

    // Handle low level network errors
    request.onerror = function handleError() {
      // Real errors are hidden from us by the browser
      // onerror should only fire if it's a network error
      reject(new AxiosError('Network Error', AxiosError.ERR_NETWORK, config, request));

      // Clean up request
      request = null;
    };

    // Handle timeout
    request.ontimeout = function handleTimeout() {
      let timeoutErrorMessage = config.timeout ? 'timeout of ' + config.timeout + 'ms exceeded' : 'timeout exceeded';
      const transitional = config.transitional || transitionalDefaults;
      if (config.timeoutErrorMessage) {
        timeoutErrorMessage = config.timeoutErrorMessage;
      }
      reject(new AxiosError(
        timeoutErrorMessage,
        transitional.clarifyTimeoutError ? AxiosError.ETIMEDOUT : AxiosError.ECONNABORTED,
        config,
        request));

      // Clean up request
      request = null;
    };

    // Add xsrf header
    // This is only done if running in a standard browser environment.
    // Specifically not if we're in a web worker, or react-native.
    if (platform.isStandardBrowserEnv) {
      // Add xsrf header
      const xsrfValue = (config.withCredentials || isURLSameOrigin(fullPath))
        && config.xsrfCookieName && cookies.read(config.xsrfCookieName);

      if (xsrfValue) {
        requestHeaders.set(config.xsrfHeaderName, xsrfValue);
      }
    }

    // Remove Content-Type if data is undefined
    requestData === undefined && requestHeaders.setContentType(null);

    // Add headers to the request
    if ('setRequestHeader' in request) {
      utils.forEach(requestHeaders.toJSON(), function setRequestHeader(val, key) {
        request.setRequestHeader(key, val);
      });
    }

    // Add withCredentials to request if needed
    if (!utils.isUndefined(config.withCredentials)) {
      request.withCredentials = !!config.withCredentials;
    }

    // Add responseType to request if needed
    if (responseType && responseType !== 'json') {
      request.responseType = config.responseType;
    }

    // Handle progress if needed
    if (typeof config.onDownloadProgress === 'function') {
      request.addEventListener('progress', progressEventReducer(config.onDownloadProgress, true));
    }

    // Not all browsers support upload events
    if (typeof config.onUploadProgress === 'function' && request.upload) {
      request.upload.addEventListener('progress', progressEventReducer(config.onUploadProgress));
    }

    if (config.cancelToken || config.signal) {
      // Handle cancellation
      // eslint-disable-next-line func-names
      onCanceled = cancel => {
        if (!request) {
          return;
        }
        reject(!cancel || cancel.type ? new CanceledError(null, config, request) : cancel);
        request.abort();
        request = null;
      };

      config.cancelToken && config.cancelToken.subscribe(onCanceled);
      if (config.signal) {
        config.signal.aborted ? onCanceled() : config.signal.addEventListener('abort', onCanceled);
      }
    }

    const protocol = parseProtocol(fullPath);

    if (protocol && platform.protocols.indexOf(protocol) === -1) {
      reject(new AxiosError('Unsupported protocol ' + protocol + ':', AxiosError.ERR_BAD_REQUEST, config));
      return;
    }


    // Send the request
    request.send(requestData || null);
  });
};

const knownAdapters = {
  http: httpAdapter,
  xhr: xhrAdapter
};

utils.forEach(knownAdapters, (fn, value) => {
  if(fn) {
    try {
      Object.defineProperty(fn, 'name', {value});
    } catch (e) {
      // eslint-disable-next-line no-empty
    }
    Object.defineProperty(fn, 'adapterName', {value});
  }
});

var adapters = {
  getAdapter: (adapters) => {
    adapters = utils.isArray(adapters) ? adapters : [adapters];

    const {length} = adapters;
    let nameOrAdapter;
    let adapter;

    for (let i = 0; i < length; i++) {
      nameOrAdapter = adapters[i];
      if((adapter = utils.isString(nameOrAdapter) ? knownAdapters[nameOrAdapter.toLowerCase()] : nameOrAdapter)) {
        break;
      }
    }

    if (!adapter) {
      if (adapter === false) {
        throw new AxiosError(
          `Adapter ${nameOrAdapter} is not supported by the environment`,
          'ERR_NOT_SUPPORT'
        );
      }

      throw new Error(
        utils.hasOwnProp(knownAdapters, nameOrAdapter) ?
          `Adapter '${nameOrAdapter}' is not available in the build` :
          `Unknown adapter '${nameOrAdapter}'`
      );
    }

    if (!utils.isFunction(adapter)) {
      throw new TypeError('adapter is not a function');
    }

    return adapter;
  },
  adapters: knownAdapters
};

/**
 * Throws a `CanceledError` if cancellation has been requested.
 *
 * @param {Object} config The config that is to be used for the request
 *
 * @returns {void}
 */
function throwIfCancellationRequested(config) {
  if (config.cancelToken) {
    config.cancelToken.throwIfRequested();
  }

  if (config.signal && config.signal.aborted) {
    throw new CanceledError(null, config);
  }
}

/**
 * Dispatch a request to the server using the configured adapter.
 *
 * @param {object} config The config that is to be used for the request
 *
 * @returns {Promise} The Promise to be fulfilled
 */
function dispatchRequest(config) {
  throwIfCancellationRequested(config);

  config.headers = AxiosHeaders$1.from(config.headers);

  // Transform request data
  config.data = transformData.call(
    config,
    config.transformRequest
  );

  if (['post', 'put', 'patch'].indexOf(config.method) !== -1) {
    config.headers.setContentType('application/x-www-form-urlencoded', false);
  }

  const adapter = adapters.getAdapter(config.adapter || defaults$1.adapter);

  return adapter(config).then(function onAdapterResolution(response) {
    throwIfCancellationRequested(config);

    // Transform response data
    response.data = transformData.call(
      config,
      config.transformResponse,
      response
    );

    response.headers = AxiosHeaders$1.from(response.headers);

    return response;
  }, function onAdapterRejection(reason) {
    if (!isCancel(reason)) {
      throwIfCancellationRequested(config);

      // Transform response data
      if (reason && reason.response) {
        reason.response.data = transformData.call(
          config,
          config.transformResponse,
          reason.response
        );
        reason.response.headers = AxiosHeaders$1.from(reason.response.headers);
      }
    }

    return Promise.reject(reason);
  });
}

const headersToObject = (thing) => thing instanceof AxiosHeaders$1 ? thing.toJSON() : thing;

/**
 * Config-specific merge-function which creates a new config-object
 * by merging two configuration objects together.
 *
 * @param {Object} config1
 * @param {Object} config2
 *
 * @returns {Object} New object resulting from merging config2 to config1
 */
function mergeConfig(config1, config2) {
  // eslint-disable-next-line no-param-reassign
  config2 = config2 || {};
  const config = {};

  function getMergedValue(target, source, caseless) {
    if (utils.isPlainObject(target) && utils.isPlainObject(source)) {
      return utils.merge.call({caseless}, target, source);
    } else if (utils.isPlainObject(source)) {
      return utils.merge({}, source);
    } else if (utils.isArray(source)) {
      return source.slice();
    }
    return source;
  }

  // eslint-disable-next-line consistent-return
  function mergeDeepProperties(a, b, caseless) {
    if (!utils.isUndefined(b)) {
      return getMergedValue(a, b, caseless);
    } else if (!utils.isUndefined(a)) {
      return getMergedValue(undefined, a, caseless);
    }
  }

  // eslint-disable-next-line consistent-return
  function valueFromConfig2(a, b) {
    if (!utils.isUndefined(b)) {
      return getMergedValue(undefined, b);
    }
  }

  // eslint-disable-next-line consistent-return
  function defaultToConfig2(a, b) {
    if (!utils.isUndefined(b)) {
      return getMergedValue(undefined, b);
    } else if (!utils.isUndefined(a)) {
      return getMergedValue(undefined, a);
    }
  }

  // eslint-disable-next-line consistent-return
  function mergeDirectKeys(a, b, prop) {
    if (prop in config2) {
      return getMergedValue(a, b);
    } else if (prop in config1) {
      return getMergedValue(undefined, a);
    }
  }

  const mergeMap = {
    url: valueFromConfig2,
    method: valueFromConfig2,
    data: valueFromConfig2,
    baseURL: defaultToConfig2,
    transformRequest: defaultToConfig2,
    transformResponse: defaultToConfig2,
    paramsSerializer: defaultToConfig2,
    timeout: defaultToConfig2,
    timeoutMessage: defaultToConfig2,
    withCredentials: defaultToConfig2,
    adapter: defaultToConfig2,
    responseType: defaultToConfig2,
    xsrfCookieName: defaultToConfig2,
    xsrfHeaderName: defaultToConfig2,
    onUploadProgress: defaultToConfig2,
    onDownloadProgress: defaultToConfig2,
    decompress: defaultToConfig2,
    maxContentLength: defaultToConfig2,
    maxBodyLength: defaultToConfig2,
    beforeRedirect: defaultToConfig2,
    transport: defaultToConfig2,
    httpAgent: defaultToConfig2,
    httpsAgent: defaultToConfig2,
    cancelToken: defaultToConfig2,
    socketPath: defaultToConfig2,
    responseEncoding: defaultToConfig2,
    validateStatus: mergeDirectKeys,
    headers: (a, b) => mergeDeepProperties(headersToObject(a), headersToObject(b), true)
  };

  utils.forEach(Object.keys(Object.assign({}, config1, config2)), function computeConfigValue(prop) {
    const merge = mergeMap[prop] || mergeDeepProperties;
    const configValue = merge(config1[prop], config2[prop], prop);
    (utils.isUndefined(configValue) && merge !== mergeDirectKeys) || (config[prop] = configValue);
  });

  return config;
}

const VERSION = "1.4.0";

const validators$1 = {};

// eslint-disable-next-line func-names
['object', 'boolean', 'number', 'function', 'string', 'symbol'].forEach((type, i) => {
  validators$1[type] = function validator(thing) {
    return typeof thing === type || 'a' + (i < 1 ? 'n ' : ' ') + type;
  };
});

const deprecatedWarnings = {};

/**
 * Transitional option validator
 *
 * @param {function|boolean?} validator - set to false if the transitional option has been removed
 * @param {string?} version - deprecated version / removed since version
 * @param {string?} message - some message with additional info
 *
 * @returns {function}
 */
validators$1.transitional = function transitional(validator, version, message) {
  function formatMessage(opt, desc) {
    return '[Axios v' + VERSION + '] Transitional option \'' + opt + '\'' + desc + (message ? '. ' + message : '');
  }

  // eslint-disable-next-line func-names
  return (value, opt, opts) => {
    if (validator === false) {
      throw new AxiosError(
        formatMessage(opt, ' has been removed' + (version ? ' in ' + version : '')),
        AxiosError.ERR_DEPRECATED
      );
    }

    if (version && !deprecatedWarnings[opt]) {
      deprecatedWarnings[opt] = true;
      // eslint-disable-next-line no-console
      console.warn(
        formatMessage(
          opt,
          ' has been deprecated since v' + version + ' and will be removed in the near future'
        )
      );
    }

    return validator ? validator(value, opt, opts) : true;
  };
};

/**
 * Assert object's properties type
 *
 * @param {object} options
 * @param {object} schema
 * @param {boolean?} allowUnknown
 *
 * @returns {object}
 */

function assertOptions(options, schema, allowUnknown) {
  if (typeof options !== 'object') {
    throw new AxiosError('options must be an object', AxiosError.ERR_BAD_OPTION_VALUE);
  }
  const keys = Object.keys(options);
  let i = keys.length;
  while (i-- > 0) {
    const opt = keys[i];
    const validator = schema[opt];
    if (validator) {
      const value = options[opt];
      const result = value === undefined || validator(value, opt, options);
      if (result !== true) {
        throw new AxiosError('option ' + opt + ' must be ' + result, AxiosError.ERR_BAD_OPTION_VALUE);
      }
      continue;
    }
    if (allowUnknown !== true) {
      throw new AxiosError('Unknown option ' + opt, AxiosError.ERR_BAD_OPTION);
    }
  }
}

var validator = {
  assertOptions,
  validators: validators$1
};

const validators = validator.validators;

/**
 * Create a new instance of Axios
 *
 * @param {Object} instanceConfig The default config for the instance
 *
 * @return {Axios} A new instance of Axios
 */
class Axios {
  constructor(instanceConfig) {
    this.defaults = instanceConfig;
    this.interceptors = {
      request: new InterceptorManager$1(),
      response: new InterceptorManager$1()
    };
  }

  /**
   * Dispatch a request
   *
   * @param {String|Object} configOrUrl The config specific for this request (merged with this.defaults)
   * @param {?Object} config
   *
   * @returns {Promise} The Promise to be fulfilled
   */
  request(configOrUrl, config) {
    /*eslint no-param-reassign:0*/
    // Allow for axios('example/url'[, config]) a la fetch API
    if (typeof configOrUrl === 'string') {
      config = config || {};
      config.url = configOrUrl;
    } else {
      config = configOrUrl || {};
    }

    config = mergeConfig(this.defaults, config);

    const {transitional, paramsSerializer, headers} = config;

    if (transitional !== undefined) {
      validator.assertOptions(transitional, {
        silentJSONParsing: validators.transitional(validators.boolean),
        forcedJSONParsing: validators.transitional(validators.boolean),
        clarifyTimeoutError: validators.transitional(validators.boolean)
      }, false);
    }

    if (paramsSerializer != null) {
      if (utils.isFunction(paramsSerializer)) {
        config.paramsSerializer = {
          serialize: paramsSerializer
        };
      } else {
        validator.assertOptions(paramsSerializer, {
          encode: validators.function,
          serialize: validators.function
        }, true);
      }
    }

    // Set config.method
    config.method = (config.method || this.defaults.method || 'get').toLowerCase();

    let contextHeaders;

    // Flatten headers
    contextHeaders = headers && utils.merge(
      headers.common,
      headers[config.method]
    );

    contextHeaders && utils.forEach(
      ['delete', 'get', 'head', 'post', 'put', 'patch', 'common'],
      (method) => {
        delete headers[method];
      }
    );

    config.headers = AxiosHeaders$1.concat(contextHeaders, headers);

    // filter out skipped interceptors
    const requestInterceptorChain = [];
    let synchronousRequestInterceptors = true;
    this.interceptors.request.forEach(function unshiftRequestInterceptors(interceptor) {
      if (typeof interceptor.runWhen === 'function' && interceptor.runWhen(config) === false) {
        return;
      }

      synchronousRequestInterceptors = synchronousRequestInterceptors && interceptor.synchronous;

      requestInterceptorChain.unshift(interceptor.fulfilled, interceptor.rejected);
    });

    const responseInterceptorChain = [];
    this.interceptors.response.forEach(function pushResponseInterceptors(interceptor) {
      responseInterceptorChain.push(interceptor.fulfilled, interceptor.rejected);
    });

    let promise;
    let i = 0;
    let len;

    if (!synchronousRequestInterceptors) {
      const chain = [dispatchRequest.bind(this), undefined];
      chain.unshift.apply(chain, requestInterceptorChain);
      chain.push.apply(chain, responseInterceptorChain);
      len = chain.length;

      promise = Promise.resolve(config);

      while (i < len) {
        promise = promise.then(chain[i++], chain[i++]);
      }

      return promise;
    }

    len = requestInterceptorChain.length;

    let newConfig = config;

    i = 0;

    while (i < len) {
      const onFulfilled = requestInterceptorChain[i++];
      const onRejected = requestInterceptorChain[i++];
      try {
        newConfig = onFulfilled(newConfig);
      } catch (error) {
        onRejected.call(this, error);
        break;
      }
    }

    try {
      promise = dispatchRequest.call(this, newConfig);
    } catch (error) {
      return Promise.reject(error);
    }

    i = 0;
    len = responseInterceptorChain.length;

    while (i < len) {
      promise = promise.then(responseInterceptorChain[i++], responseInterceptorChain[i++]);
    }

    return promise;
  }

  getUri(config) {
    config = mergeConfig(this.defaults, config);
    const fullPath = buildFullPath(config.baseURL, config.url);
    return buildURL(fullPath, config.params, config.paramsSerializer);
  }
}

// Provide aliases for supported request methods
utils.forEach(['delete', 'get', 'head', 'options'], function forEachMethodNoData(method) {
  /*eslint func-names:0*/
  Axios.prototype[method] = function(url, config) {
    return this.request(mergeConfig(config || {}, {
      method,
      url,
      data: (config || {}).data
    }));
  };
});

utils.forEach(['post', 'put', 'patch'], function forEachMethodWithData(method) {
  /*eslint func-names:0*/

  function generateHTTPMethod(isForm) {
    return function httpMethod(url, data, config) {
      return this.request(mergeConfig(config || {}, {
        method,
        headers: isForm ? {
          'Content-Type': 'multipart/form-data'
        } : {},
        url,
        data
      }));
    };
  }

  Axios.prototype[method] = generateHTTPMethod();

  Axios.prototype[method + 'Form'] = generateHTTPMethod(true);
});

var Axios$1 = Axios;

/**
 * A `CancelToken` is an object that can be used to request cancellation of an operation.
 *
 * @param {Function} executor The executor function.
 *
 * @returns {CancelToken}
 */
class CancelToken {
  constructor(executor) {
    if (typeof executor !== 'function') {
      throw new TypeError('executor must be a function.');
    }

    let resolvePromise;

    this.promise = new Promise(function promiseExecutor(resolve) {
      resolvePromise = resolve;
    });

    const token = this;

    // eslint-disable-next-line func-names
    this.promise.then(cancel => {
      if (!token._listeners) return;

      let i = token._listeners.length;

      while (i-- > 0) {
        token._listeners[i](cancel);
      }
      token._listeners = null;
    });

    // eslint-disable-next-line func-names
    this.promise.then = onfulfilled => {
      let _resolve;
      // eslint-disable-next-line func-names
      const promise = new Promise(resolve => {
        token.subscribe(resolve);
        _resolve = resolve;
      }).then(onfulfilled);

      promise.cancel = function reject() {
        token.unsubscribe(_resolve);
      };

      return promise;
    };

    executor(function cancel(message, config, request) {
      if (token.reason) {
        // Cancellation has already been requested
        return;
      }

      token.reason = new CanceledError(message, config, request);
      resolvePromise(token.reason);
    });
  }

  /**
   * Throws a `CanceledError` if cancellation has been requested.
   */
  throwIfRequested() {
    if (this.reason) {
      throw this.reason;
    }
  }

  /**
   * Subscribe to the cancel signal
   */

  subscribe(listener) {
    if (this.reason) {
      listener(this.reason);
      return;
    }

    if (this._listeners) {
      this._listeners.push(listener);
    } else {
      this._listeners = [listener];
    }
  }

  /**
   * Unsubscribe from the cancel signal
   */

  unsubscribe(listener) {
    if (!this._listeners) {
      return;
    }
    const index = this._listeners.indexOf(listener);
    if (index !== -1) {
      this._listeners.splice(index, 1);
    }
  }

  /**
   * Returns an object that contains a new `CancelToken` and a function that, when called,
   * cancels the `CancelToken`.
   */
  static source() {
    let cancel;
    const token = new CancelToken(function executor(c) {
      cancel = c;
    });
    return {
      token,
      cancel
    };
  }
}

var CancelToken$1 = CancelToken;

/**
 * Syntactic sugar for invoking a function and expanding an array for arguments.
 *
 * Common use case would be to use `Function.prototype.apply`.
 *
 *  ```js
 *  function f(x, y, z) {}
 *  var args = [1, 2, 3];
 *  f.apply(null, args);
 *  ```
 *
 * With `spread` this example can be re-written.
 *
 *  ```js
 *  spread(function(x, y, z) {})([1, 2, 3]);
 *  ```
 *
 * @param {Function} callback
 *
 * @returns {Function}
 */
function spread(callback) {
  return function wrap(arr) {
    return callback.apply(null, arr);
  };
}

/**
 * Determines whether the payload is an error thrown by Axios
 *
 * @param {*} payload The value to test
 *
 * @returns {boolean} True if the payload is an error thrown by Axios, otherwise false
 */
function isAxiosError(payload) {
  return utils.isObject(payload) && (payload.isAxiosError === true);
}

const HttpStatusCode = {
  Continue: 100,
  SwitchingProtocols: 101,
  Processing: 102,
  EarlyHints: 103,
  Ok: 200,
  Created: 201,
  Accepted: 202,
  NonAuthoritativeInformation: 203,
  NoContent: 204,
  ResetContent: 205,
  PartialContent: 206,
  MultiStatus: 207,
  AlreadyReported: 208,
  ImUsed: 226,
  MultipleChoices: 300,
  MovedPermanently: 301,
  Found: 302,
  SeeOther: 303,
  NotModified: 304,
  UseProxy: 305,
  Unused: 306,
  TemporaryRedirect: 307,
  PermanentRedirect: 308,
  BadRequest: 400,
  Unauthorized: 401,
  PaymentRequired: 402,
  Forbidden: 403,
  NotFound: 404,
  MethodNotAllowed: 405,
  NotAcceptable: 406,
  ProxyAuthenticationRequired: 407,
  RequestTimeout: 408,
  Conflict: 409,
  Gone: 410,
  LengthRequired: 411,
  PreconditionFailed: 412,
  PayloadTooLarge: 413,
  UriTooLong: 414,
  UnsupportedMediaType: 415,
  RangeNotSatisfiable: 416,
  ExpectationFailed: 417,
  ImATeapot: 418,
  MisdirectedRequest: 421,
  UnprocessableEntity: 422,
  Locked: 423,
  FailedDependency: 424,
  TooEarly: 425,
  UpgradeRequired: 426,
  PreconditionRequired: 428,
  TooManyRequests: 429,
  RequestHeaderFieldsTooLarge: 431,
  UnavailableForLegalReasons: 451,
  InternalServerError: 500,
  NotImplemented: 501,
  BadGateway: 502,
  ServiceUnavailable: 503,
  GatewayTimeout: 504,
  HttpVersionNotSupported: 505,
  VariantAlsoNegotiates: 506,
  InsufficientStorage: 507,
  LoopDetected: 508,
  NotExtended: 510,
  NetworkAuthenticationRequired: 511,
};

Object.entries(HttpStatusCode).forEach(([key, value]) => {
  HttpStatusCode[value] = key;
});

var HttpStatusCode$1 = HttpStatusCode;

/**
 * Create an instance of Axios
 *
 * @param {Object} defaultConfig The default config for the instance
 *
 * @returns {Axios} A new instance of Axios
 */
function createInstance(defaultConfig) {
  const context = new Axios$1(defaultConfig);
  const instance = bind(Axios$1.prototype.request, context);

  // Copy axios.prototype to instance
  utils.extend(instance, Axios$1.prototype, context, {allOwnKeys: true});

  // Copy context to instance
  utils.extend(instance, context, null, {allOwnKeys: true});

  // Factory for creating new instances
  instance.create = function create(instanceConfig) {
    return createInstance(mergeConfig(defaultConfig, instanceConfig));
  };

  return instance;
}

// Create the default instance to be exported
const axios = createInstance(defaults$1);

// Expose Axios class to allow class inheritance
axios.Axios = Axios$1;

// Expose Cancel & CancelToken
axios.CanceledError = CanceledError;
axios.CancelToken = CancelToken$1;
axios.isCancel = isCancel;
axios.VERSION = VERSION;
axios.toFormData = toFormData;

// Expose AxiosError class
axios.AxiosError = AxiosError;

// alias for CanceledError for backward compatibility
axios.Cancel = axios.CanceledError;

// Expose all/spread
axios.all = function all(promises) {
  return Promise.all(promises);
};

axios.spread = spread;

// Expose isAxiosError
axios.isAxiosError = isAxiosError;

// Expose mergeConfig
axios.mergeConfig = mergeConfig;

axios.AxiosHeaders = AxiosHeaders$1;

axios.formToJSON = thing => formDataToJSON(utils.isHTMLForm(thing) ? new FormData(thing) : thing);

axios.HttpStatusCode = HttpStatusCode$1;

axios.default = axios;

// this module should only have a default export
var globalAxios = axios;

/* tslint:disable */
/* eslint-disable */
/**
 * Guardian
 * Guardian API
 *
 * The version of the OpenAPI document: 1.0.0
 * Contact: support@immutable.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
// Some imports not used depending on template conditions
// @ts-ignore
const BASE_PATH = "https://guardian.sandbox.imtbl.com".replace(/\/+$/, "");
/**
 *
 * @export
 * @class BaseAPI
 */
class BaseAPI {
    basePath;
    axios;
    configuration;
    constructor(configuration, basePath = BASE_PATH, axios = globalAxios) {
        this.basePath = basePath;
        this.axios = axios;
        if (configuration) {
            this.configuration = configuration;
            this.basePath = configuration.basePath || this.basePath;
        }
    }
}
/**
 *
 * @export
 * @class RequiredError
 * @extends {Error}
 */
class RequiredError extends Error {
    field;
    name = "RequiredError";
    constructor(field, msg) {
        super(msg);
        this.field = field;
    }
}

/* tslint:disable */
/* eslint-disable */
/**
 * Guardian
 * Guardian API
 *
 * The version of the OpenAPI document: 1.0.0
 * Contact: support@immutable.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
/**
 *
 * @export
 */
const DUMMY_BASE_URL = 'https://example.com';
/**
 *
 * @throws {RequiredError}
 * @export
 */
const assertParamExists = function (functionName, paramName, paramValue) {
    if (paramValue === null || paramValue === undefined) {
        throw new RequiredError(paramName, `Required parameter ${paramName} was null or undefined when calling ${functionName}.`);
    }
};
/**
 *
 * @export
 */
const setBearerAuthToObject = async function (object, configuration) {
    if (configuration && configuration.accessToken) {
        const accessToken = typeof configuration.accessToken === 'function'
            ? await configuration.accessToken()
            : await configuration.accessToken;
        object["Authorization"] = "Bearer " + accessToken;
    }
};
function setFlattenedQueryParams(urlSearchParams, parameter, key = "") {
    if (typeof parameter === "object") {
        if (Array.isArray(parameter)) {
            parameter.forEach(item => setFlattenedQueryParams(urlSearchParams, item, key));
        }
        else {
            Object.keys(parameter).forEach(currentKey => setFlattenedQueryParams(urlSearchParams, parameter[currentKey], `${key}${key !== '' ? '.' : ''}${currentKey}`));
        }
    }
    else {
        if (urlSearchParams.has(key)) {
            urlSearchParams.append(key, parameter);
        }
        else {
            urlSearchParams.set(key, parameter);
        }
    }
}
/**
 *
 * @export
 */
const setSearchParams = function (url, ...objects) {
    const searchParams = new URLSearchParams(url.search);
    setFlattenedQueryParams(searchParams, objects);
    url.search = searchParams.toString();
};
/**
 *
 * @export
 */
const serializeDataIfNeeded = function (value, requestOptions, configuration) {
    const nonString = typeof value !== 'string';
    const needsSerialization = nonString && configuration && configuration.isJsonMime
        ? configuration.isJsonMime(requestOptions.headers['Content-Type'])
        : nonString;
    return needsSerialization
        ? JSON.stringify(value !== undefined ? value : {})
        : (value || "");
};
/**
 *
 * @export
 */
const toPathString = function (url) {
    return url.pathname + url.search + url.hash;
};
/**
 *
 * @export
 */
const createRequestFunction = function (axiosArgs, globalAxios, BASE_PATH, configuration) {
    return (axios = globalAxios, basePath = BASE_PATH) => {
        const axiosRequestArgs = { ...axiosArgs.options, url: (configuration?.basePath || basePath) + axiosArgs.url };
        return axios.request(axiosRequestArgs);
    };
};

/* tslint:disable */
/* eslint-disable */
/**
 * Guardian
 * Guardian API
 *
 * The version of the OpenAPI document: 1.0.0
 * Contact: support@immutable.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
/**
 * MessagesApi - axios parameter creator
 * @export
 */
const MessagesApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * Approve a pending evm message
         * @summary Approve a pending evm message
         * @param {string} messageID id for the message
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        approvePendingMessage: async (messageID, options = {}) => {
            // verify required parameter 'messageID' is not null or undefined
            assertParamExists('approvePendingMessage', 'messageID', messageID);
            const localVarPath = `/guardian/v1/messages/{messageID}/approve`
                .replace(`{${"messageID"}}`, encodeURIComponent(String(messageID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration);
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Check if a given message is valid  for EVM
         * @summary Evaluate an evm message to sign
         * @param {MessageEvaluationRequest} messageEvaluationRequest Specifies the kind of transaction
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        evaluateMessage: async (messageEvaluationRequest, options = {}) => {
            // verify required parameter 'messageEvaluationRequest' is not null or undefined
            assertParamExists('evaluateMessage', 'messageEvaluationRequest', messageEvaluationRequest);
            const localVarPath = `/guardian/v1/messages/evaluate`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = serializeDataIfNeeded(messageEvaluationRequest, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get an evm message by id
         * @summary Info for a specific evm message
         * @param {string} messageID The id of the evm message
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMessageByID: async (messageID, options = {}) => {
            // verify required parameter 'messageID' is not null or undefined
            assertParamExists('getMessageByID', 'messageID', messageID);
            const localVarPath = `/guardian/v1/messages/{messageID}`
                .replace(`{${"messageID"}}`, encodeURIComponent(String(messageID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration);
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
/**
 * MessagesApi - functional programming interface
 * @export
 */
const MessagesApiFp = function (configuration) {
    const localVarAxiosParamCreator = MessagesApiAxiosParamCreator(configuration);
    return {
        /**
         * Approve a pending evm message
         * @summary Approve a pending evm message
         * @param {string} messageID id for the message
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async approvePendingMessage(messageID, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.approvePendingMessage(messageID, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Check if a given message is valid  for EVM
         * @summary Evaluate an evm message to sign
         * @param {MessageEvaluationRequest} messageEvaluationRequest Specifies the kind of transaction
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async evaluateMessage(messageEvaluationRequest, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.evaluateMessage(messageEvaluationRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get an evm message by id
         * @summary Info for a specific evm message
         * @param {string} messageID The id of the evm message
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMessageByID(messageID, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getMessageByID(messageID, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    };
};
/**
 * MessagesApi - object-oriented interface
 * @export
 * @class MessagesApi
 * @extends {BaseAPI}
 */
class MessagesApi extends BaseAPI {
    /**
     * Approve a pending evm message
     * @summary Approve a pending evm message
     * @param {MessagesApiApprovePendingMessageRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MessagesApi
     */
    approvePendingMessage(requestParameters, options) {
        return MessagesApiFp(this.configuration).approvePendingMessage(requestParameters.messageID, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Check if a given message is valid  for EVM
     * @summary Evaluate an evm message to sign
     * @param {MessagesApiEvaluateMessageRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MessagesApi
     */
    evaluateMessage(requestParameters, options) {
        return MessagesApiFp(this.configuration).evaluateMessage(requestParameters.messageEvaluationRequest, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Get an evm message by id
     * @summary Info for a specific evm message
     * @param {MessagesApiGetMessageByIDRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MessagesApi
     */
    getMessageByID(requestParameters, options) {
        return MessagesApiFp(this.configuration).getMessageByID(requestParameters.messageID, options).then((request) => request(this.axios, this.basePath));
    }
}

/* tslint:disable */
/* eslint-disable */
/**
 * Guardian
 * Guardian API
 *
 * The version of the OpenAPI document: 1.0.0
 * Contact: support@immutable.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
/**
 * TransactionsApi - axios parameter creator
 * @export
 */
const TransactionsApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * Approve a pending transaction
         * @summary Approve a pending transaction given chain
         * @param {string} payloadHash Hash for the payload
         * @param {TransactionApprovalRequest} transactionApprovalRequest request body for approving a pending transaction
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        approvePendingTransaction: async (payloadHash, transactionApprovalRequest, options = {}) => {
            // verify required parameter 'payloadHash' is not null or undefined
            assertParamExists('approvePendingTransaction', 'payloadHash', payloadHash);
            // verify required parameter 'transactionApprovalRequest' is not null or undefined
            assertParamExists('approvePendingTransaction', 'transactionApprovalRequest', transactionApprovalRequest);
            const localVarPath = `/guardian/v1/transactions/{payloadHash}/approve`
                .replace(`{${"payloadHash"}}`, encodeURIComponent(String(payloadHash)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = serializeDataIfNeeded(transactionApprovalRequest, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Check if the transaction is valid by transaction ID for both StarkEx and EVM
         * @summary Evaluate a transaction
         * @param {string} id Transaction identifier: payloadHash on StarkEx or EVM ID
         * @param {TransactionEvaluationRequest} transactionEvaluationRequest Specifies the kind of transaction
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        evaluateTransaction: async (id, transactionEvaluationRequest, options = {}) => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('evaluateTransaction', 'id', id);
            // verify required parameter 'transactionEvaluationRequest' is not null or undefined
            assertParamExists('evaluateTransaction', 'transactionEvaluationRequest', transactionEvaluationRequest);
            const localVarPath = `/guardian/v1/transactions/{id}/evaluate`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = serializeDataIfNeeded(transactionEvaluationRequest, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a transaction by payload hash
         * @summary Info for a specific transaction
         * @param {string} transactionID The id of the starkex transaction to retrieve
         * @param {'starkex' | 'evm'} chainType roll up type
         * @param {string} [chainID] ID of evm chain
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTransactionByID: async (transactionID, chainType, chainID, options = {}) => {
            // verify required parameter 'transactionID' is not null or undefined
            assertParamExists('getTransactionByID', 'transactionID', transactionID);
            // verify required parameter 'chainType' is not null or undefined
            assertParamExists('getTransactionByID', 'chainType', chainType);
            const localVarPath = `/guardian/v1/transactions/{transactionID}`
                .replace(`{${"transactionID"}}`, encodeURIComponent(String(transactionID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration);
            if (chainType !== undefined) {
                localVarQueryParameter['chainType'] = chainType;
            }
            if (chainID !== undefined) {
                localVarQueryParameter['chainID'] = chainID;
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
/**
 * TransactionsApi - functional programming interface
 * @export
 */
const TransactionsApiFp = function (configuration) {
    const localVarAxiosParamCreator = TransactionsApiAxiosParamCreator(configuration);
    return {
        /**
         * Approve a pending transaction
         * @summary Approve a pending transaction given chain
         * @param {string} payloadHash Hash for the payload
         * @param {TransactionApprovalRequest} transactionApprovalRequest request body for approving a pending transaction
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async approvePendingTransaction(payloadHash, transactionApprovalRequest, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.approvePendingTransaction(payloadHash, transactionApprovalRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Check if the transaction is valid by transaction ID for both StarkEx and EVM
         * @summary Evaluate a transaction
         * @param {string} id Transaction identifier: payloadHash on StarkEx or EVM ID
         * @param {TransactionEvaluationRequest} transactionEvaluationRequest Specifies the kind of transaction
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async evaluateTransaction(id, transactionEvaluationRequest, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.evaluateTransaction(id, transactionEvaluationRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get a transaction by payload hash
         * @summary Info for a specific transaction
         * @param {string} transactionID The id of the starkex transaction to retrieve
         * @param {'starkex' | 'evm'} chainType roll up type
         * @param {string} [chainID] ID of evm chain
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTransactionByID(transactionID, chainType, chainID, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTransactionByID(transactionID, chainType, chainID, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    };
};
/**
 * TransactionsApi - object-oriented interface
 * @export
 * @class TransactionsApi
 * @extends {BaseAPI}
 */
class TransactionsApi extends BaseAPI {
    /**
     * Approve a pending transaction
     * @summary Approve a pending transaction given chain
     * @param {TransactionsApiApprovePendingTransactionRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TransactionsApi
     */
    approvePendingTransaction(requestParameters, options) {
        return TransactionsApiFp(this.configuration).approvePendingTransaction(requestParameters.payloadHash, requestParameters.transactionApprovalRequest, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Check if the transaction is valid by transaction ID for both StarkEx and EVM
     * @summary Evaluate a transaction
     * @param {TransactionsApiEvaluateTransactionRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TransactionsApi
     */
    evaluateTransaction(requestParameters, options) {
        return TransactionsApiFp(this.configuration).evaluateTransaction(requestParameters.id, requestParameters.transactionEvaluationRequest, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Get a transaction by payload hash
     * @summary Info for a specific transaction
     * @param {TransactionsApiGetTransactionByIDRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TransactionsApi
     */
    getTransactionByID(requestParameters, options) {
        return TransactionsApiFp(this.configuration).getTransactionByID(requestParameters.transactionID, requestParameters.chainType, requestParameters.chainID, options).then((request) => request(this.axios, this.basePath));
    }
}

/* tslint:disable */
/* eslint-disable */
/**
 * Guardian
 * Guardian API
 *
 * The version of the OpenAPI document: 1.0.0
 * Contact: support@immutable.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
class Configuration {
    /**
     * parameter for apiKey security
     * @param name security name
     * @memberof Configuration
     */
    apiKey;
    /**
     * parameter for basic security
     *
     * @type {string}
     * @memberof Configuration
     */
    username;
    /**
     * parameter for basic security
     *
     * @type {string}
     * @memberof Configuration
     */
    password;
    /**
     * parameter for oauth2 security
     * @param name security name
     * @param scopes oauth2 scope
     * @memberof Configuration
     */
    accessToken;
    /**
     * override base path
     *
     * @type {string}
     * @memberof Configuration
     */
    basePath;
    /**
     * base options for axios calls
     *
     * @type {any}
     * @memberof Configuration
     */
    baseOptions;
    /**
     * The FormData constructor that will be used to create multipart form data
     * requests. You can inject this here so that execution environments that
     * do not support the FormData class can still run the generated client.
     *
     * @type {new () => FormData}
     */
    formDataCtor;
    constructor(param = {}) {
        this.apiKey = param.apiKey;
        this.username = param.username;
        this.password = param.password;
        this.accessToken = param.accessToken;
        this.basePath = param.basePath;
        this.baseOptions = param.baseOptions;
        this.formDataCtor = param.formDataCtor;
    }
    /**
     * Check if the given MIME is a JSON MIME.
     * JSON MIME examples:
     *   application/json
     *   application/json; charset=UTF8
     *   APPLICATION/JSON
     *   application/vnd.company+json
     * @param mime - MIME (Multipurpose Internet Mail Extensions)
     * @return True if the given MIME is JSON, false otherwise.
     */
    isJsonMime(mime) {
        const jsonMime = new RegExp('^(application\/json|[^;/ \t]+\/[^;/ \t]+[+]json)[ \t]*(;.*)?$', 'i');
        return mime !== null && (jsonMime.test(mime) || mime.toLowerCase() === 'application/json-patch+json');
    }
}

/* tslint:disable */
/* eslint-disable */
/**
 * Guardian
 * Guardian API
 *
 * The version of the OpenAPI document: 1.0.0
 * Contact: support@immutable.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
const TransactionApprovalRequestChainTypeEnum = {
    Starkex: 'starkex',
    Evm: 'evm'
};

// used to sign message with L1 keys. Used for registration
function serializeEthSignature(sig) {
    // This is because golang appends a recovery param
    // https://github.com/ethers-io/ethers.js/issues/823
    return encUtils.addHexPrefix(encUtils.padLeft(sig.r.toString(16), 64)
        + encUtils.padLeft(sig.s.toString(16), 64)
        + encUtils.padLeft(sig.recoveryParam?.toString(16) || '', 2));
}
function importRecoveryParam(v) {
    const isValidBigNumber = new BN$2(v, 16).cmp(new BN$2(27)) !== -1
        ? new BN$2(v, 16).sub(new BN$2(27)).toNumber()
        : new BN$2(v, 16).toNumber();
    return v.trim()
        ? isValidBigNumber
        : undefined;
}
// used chained with serializeEthSignature. serializeEthSignature(deserializeSignature(...))
function deserializeSignature(sig, size = 64) {
    const removedHexPrefixSig = encUtils.removeHexPrefix(sig);
    return {
        r: new BN$2(removedHexPrefixSig.substring(0, size), 'hex'),
        s: new BN$2(removedHexPrefixSig.substring(size, size * 2), 'hex'),
        recoveryParam: importRecoveryParam(removedHexPrefixSig.substring(size * 2, size * 2 + 2)),
    };
}
async function signRaw(payload, signer) {
    const signature = deserializeSignature(await signer.signMessage(payload));
    return serializeEthSignature(signature);
}
async function signMessage(message, signer) {
    const ethAddress = await signer.getAddress();
    const ethSignature = await signRaw(message, signer);
    return {
        message,
        ethAddress,
        ethSignature,
    };
}

/**
 * Helper method to convert token type to a SignableToken type
 * @param token - the token type to convert to a SignableToken type
 * @returns the converted SignableToken
 */
function convertToSignableToken(token) {
    switch (token.type) {
        case 'ERC721':
            return {
                type: 'ERC721',
                data: {
                    token_id: token.tokenId,
                    token_address: token.tokenAddress,
                },
            };
        case 'ERC20':
            return {
                type: 'ERC20',
                data: {
                    token_address: token.tokenAddress,
                },
            };
        case 'ETH':
        default:
            return {
                type: 'ETH',
                data: {
                    decimals: 18,
                },
            };
    }
}

var PassportErrorType;
(function (PassportErrorType) {
    PassportErrorType["AUTHENTICATION_ERROR"] = "AUTHENTICATION_ERROR";
    PassportErrorType["INVALID_CONFIGURATION"] = "INVALID_CONFIGURATION";
    PassportErrorType["WALLET_CONNECTION_ERROR"] = "WALLET_CONNECTION_ERROR";
    PassportErrorType["NOT_LOGGED_IN_ERROR"] = "NOT_LOGGED_IN_ERROR";
    PassportErrorType["SILENT_LOGIN_ERROR"] = "SILENT_LOGIN_ERROR";
    PassportErrorType["REFRESH_TOKEN_ERROR"] = "REFRESH_TOKEN_ERROR";
    PassportErrorType["USER_REGISTRATION_ERROR"] = "USER_REGISTRATION_ERROR";
    PassportErrorType["LOGOUT_ERROR"] = "LOGOUT_ERROR";
    PassportErrorType["TRANSFER_ERROR"] = "TRANSFER_ERROR";
    PassportErrorType["CREATE_ORDER_ERROR"] = "CREATE_ORDER_ERROR";
    PassportErrorType["CANCEL_ORDER_ERROR"] = "CANCEL_ORDER_ERROR";
    PassportErrorType["EXCHANGE_TRANSFER_ERROR"] = "EXCHANGE_TRANSFER_ERROR";
    PassportErrorType["CREATE_TRADE_ERROR"] = "CREATE_TRADE_ERROR";
    PassportErrorType["OPERATION_NOT_SUPPORTED_ERROR"] = "OPERATION_NOT_SUPPORTED_ERROR";
})(PassportErrorType || (PassportErrorType = {}));
function isAPIError(error) {
    return 'code' in error && 'message' in error;
}
class PassportError extends Error {
    type;
    constructor(message, type) {
        super(message);
        this.type = type;
    }
}
const withPassportError = async (fn, customErrorType) => {
    try {
        return await fn();
    }
    catch (error) {
        let errorMessage;
        if (isAxiosError$1(error) && error.response?.data && isAPIError(error.response.data)) {
            errorMessage = error.response.data.message;
        }
        else {
            errorMessage = error.message;
        }
        throw new PassportError(errorMessage, customErrorType);
    }
};

const keyCrendentials = 'passport_credentials';
const KEY_PKCE_STATE = 'pkce_state';
const KEY_PKCE_VERIFIER = 'pkce_verifier';
const validCredentialsMinTtlSec = 3600; // 1 hour
class DeviceCredentialsManager {
    saveCredentials(tokenResponse) {
        if (this.areValid(tokenResponse)) {
            localStorage.setItem(keyCrendentials, JSON.stringify(tokenResponse));
        }
        else {
            throw Error('Invalid credentials.');
        }
    }
    getCredentials() {
        const credentialsJson = localStorage.getItem(keyCrendentials);
        if (credentialsJson) {
            return JSON.parse(credentialsJson);
        }
        return null;
    }
    areValid(tokenResponse) {
        if (tokenResponse) {
            const accessTokenValid = this.isTokenValid(tokenResponse.access_token);
            const idTokenValid = this.isTokenValid(tokenResponse.id_token);
            return accessTokenValid && idTokenValid;
        }
        return false;
    }
    isTokenValid(jwt) {
        try {
            const tokenPayload = jwt_decode(jwt);
            const expiresAt = tokenPayload.exp ?? 0;
            const now = (Date.now() / 1000) + validCredentialsMinTtlSec;
            return expiresAt > now;
        }
        catch (error) {
            return false;
        }
    }
    clearCredentials() {
        localStorage.removeItem(keyCrendentials);
    }
    savePKCEData(data) {
        localStorage.setItem(KEY_PKCE_STATE, data.state);
        localStorage.setItem(KEY_PKCE_VERIFIER, data.verifier);
    }
    getPKCEData() {
        const state = localStorage.getItem(KEY_PKCE_STATE);
        const verifier = localStorage.getItem(KEY_PKCE_VERIFIER);
        if (state && verifier) {
            return { state, verifier };
        }
        return null;
    }
}

const formUrlEncodedHeader = {
    headers: {
        'Content-Type': 'application/x-www-form-urlencoded',
    },
};
const getAuthConfiguration = ({ oidcConfiguration, authenticationDomain, }) => {
    const store = typeof window !== 'undefined' ? window.localStorage : new InMemoryWebStorage();
    const userStore = new WebStorageStateStore({ store });
    const baseConfiguration = {
        authority: authenticationDomain,
        redirect_uri: oidcConfiguration.redirectUri,
        popup_redirect_uri: oidcConfiguration.redirectUri,
        client_id: oidcConfiguration.clientId,
        metadata: {
            authorization_endpoint: `${authenticationDomain}/authorize`,
            token_endpoint: `${authenticationDomain}/oauth/token`,
            userinfo_endpoint: `${authenticationDomain}/userinfo`,
            end_session_endpoint: `${authenticationDomain}/v2/logout`
                + `?returnTo=${encodeURIComponent(oidcConfiguration.logoutRedirectUri)}`
                + `&client_id=${oidcConfiguration.clientId}`,
        },
        mergeClaims: true,
        loadUserInfo: true,
        scope: oidcConfiguration.scope,
        userStore,
    };
    if (oidcConfiguration.audience) {
        baseConfiguration.extraQueryParams = {
            audience: oidcConfiguration.audience,
        };
    }
    return baseConfiguration;
};
function wait$1(ms) {
    return new Promise((resolve) => {
        setTimeout(resolve, ms);
    });
}
class AuthManager {
    userManager;
    config;
    deviceCredentialsManager;
    logoutMode;
    constructor(config) {
        this.config = config;
        this.userManager = new UserManager(getAuthConfiguration(config));
        this.deviceCredentialsManager = new DeviceCredentialsManager();
        this.logoutMode = config.oidcConfiguration.logoutMode || 'redirect';
    }
    static mapOidcUserToDomainModel = (oidcUser) => {
        const passport = oidcUser.profile?.passport;
        const user = {
            expired: oidcUser.expired,
            idToken: oidcUser.id_token,
            accessToken: oidcUser.access_token,
            refreshToken: oidcUser.refresh_token,
            profile: {
                sub: oidcUser.profile.sub,
                email: oidcUser.profile.email,
                nickname: oidcUser.profile.nickname,
            },
        };
        if (passport?.imx_eth_address) {
            user.imx = {
                ethAddress: passport?.imx_eth_address,
                starkAddress: passport?.imx_stark_address,
                userAdminAddress: passport?.imx_user_admin_address,
            };
        }
        if (passport?.zkevm_eth_address) {
            user.zkEvm = {
                ethAddress: passport?.zkevm_eth_address,
                userAdminAddress: passport?.zkevm_user_admin_address,
            };
        }
        return user;
    };
    static mapDeviceTokenResponseToDomainUserModel = (tokenResponse) => {
        const idTokenPayload = jwt_decode(tokenResponse.id_token);
        const user = {
            idToken: tokenResponse.id_token,
            accessToken: tokenResponse.access_token,
            refreshToken: tokenResponse.refresh_token,
            profile: {
                sub: idTokenPayload.sub,
                email: idTokenPayload.email,
                nickname: idTokenPayload.nickname,
            },
        };
        if (idTokenPayload?.passport?.imx_eth_address) {
            user.imx = {
                ethAddress: idTokenPayload?.passport?.imx_eth_address,
                starkAddress: idTokenPayload?.passport?.imx_stark_address,
                userAdminAddress: idTokenPayload?.passport?.imx_user_admin_address,
            };
        }
        if (idTokenPayload?.passport?.zkevm_eth_address) {
            user.zkEvm = {
                ethAddress: idTokenPayload?.passport?.zkevm_eth_address,
                userAdminAddress: idTokenPayload?.passport?.zkevm_user_admin_address,
            };
        }
        return user;
    };
    async login() {
        return withPassportError(async () => {
            const popupWindowFeatures = { width: 410, height: 450 };
            const oidcUser = await this.userManager.signinPopup({
                popupWindowFeatures,
            });
            return AuthManager.mapOidcUserToDomainModel(oidcUser);
        }, PassportErrorType.AUTHENTICATION_ERROR);
    }
    async loginCallback() {
        return withPassportError(async () => this.userManager.signinPopupCallback(), PassportErrorType.AUTHENTICATION_ERROR);
    }
    async loginWithDeviceFlow() {
        return withPassportError(async () => {
            const response = await globalAxios$1.post(`${this.config.authenticationDomain}/oauth/device/code`, {
                client_id: this.config.oidcConfiguration.clientId,
                scope: this.config.oidcConfiguration.scope,
                audience: this.config.oidcConfiguration.audience,
            }, formUrlEncodedHeader);
            return {
                code: response.data.user_code,
                deviceCode: response.data.device_code,
                url: response.data.verification_uri_complete,
                interval: response.data.interval,
            };
        }, PassportErrorType.AUTHENTICATION_ERROR);
    }
    /* eslint-disable no-await-in-loop */
    async connectImxDeviceFlow(deviceCode, interval, timeoutMs) {
        return withPassportError(async () => {
            const startTime = Date.now();
            const loopCondition = true;
            while (loopCondition) {
                if (timeoutMs != null && Date.now() - startTime > timeoutMs) {
                    throw new Error('Timed out');
                }
                await wait$1(interval * 1000);
                try {
                    const tokenResponse = await this.getDeviceFlowToken(deviceCode);
                    const user = AuthManager.mapDeviceTokenResponseToDomainUserModel(tokenResponse);
                    // Only persist credentials that contain the necessary data
                    if (user.imx?.ethAddress && user.imx?.starkAddress && user.imx?.userAdminAddress) {
                        this.deviceCredentialsManager.saveCredentials(tokenResponse);
                    }
                    return user;
                }
                catch (error) {
                    if (globalAxios$1.isAxiosError(error)) {
                        const responseError = error.response?.data;
                        switch (responseError.error) {
                            case 'authorization_pending':
                                break;
                            case 'slow_down':
                                break;
                            case 'expired_token':
                                throw new Error('Token expired, please log in again');
                            case 'access_denied':
                                throw new Error('User denied access');
                            default:
                                throw new Error('Error getting token');
                        }
                    }
                    else {
                        throw error;
                    }
                }
            }
            throw new Error('Failed to get credentials');
        }, PassportErrorType.AUTHENTICATION_ERROR);
    }
    /* eslint-enable no-await-in-loop */
    async getDeviceFlowToken(deviceCode) {
        const response = await globalAxios$1.post(`${this.config.authenticationDomain}/oauth/token`, {
            client_id: this.config.oidcConfiguration.clientId,
            grant_type: 'urn:ietf:params:oauth:grant-type:device_code',
            device_code: deviceCode,
        }, formUrlEncodedHeader);
        return response.data;
    }
    static base64URLEncode(str) {
        return str.toString('base64')
            .replace(/\+/g, '-')
            .replace(/\//g, '_')
            .replace(/=/g, '');
    }
    static sha256(buffer) {
        return crypto.createHash('sha256').update(buffer).digest();
    }
    getPKCEAuthorizationUrl() {
        const verifier = AuthManager.base64URLEncode(crypto.randomBytes(32));
        const challenge = AuthManager.base64URLEncode(AuthManager.sha256(verifier));
        // https://auth0.com/docs/secure/attack-protection/state-parameters
        const state = AuthManager.base64URLEncode(crypto.randomBytes(32));
        this.deviceCredentialsManager.savePKCEData({ state, verifier });
        return `${this.config.authenticationDomain}/authorize?`
            + 'response_type=code'
            + `&code_challenge=${challenge}`
            + '&code_challenge_method=S256'
            + `&client_id=${this.config.oidcConfiguration.clientId}`
            + `&redirect_uri=${this.config.oidcConfiguration.redirectUri}`
            + `&scope=${this.config.oidcConfiguration.scope}`
            + `&state=${state}`
            + `&audience=${this.config.oidcConfiguration.audience}`;
    }
    async connectImxPKCEFlow(authorizationCode, state) {
        return withPassportError(async () => {
            const pkceData = this.deviceCredentialsManager.getPKCEData();
            if (!pkceData) {
                throw new Error('No code verifier or state for PKCE');
            }
            if (state !== pkceData.state) {
                throw new Error('Provided state does not match stored state');
            }
            const tokenResponse = await this.getPKCEToken(authorizationCode, pkceData.verifier);
            const user = AuthManager.mapDeviceTokenResponseToDomainUserModel(tokenResponse);
            // Only persist credentials that contain the necessary data
            if (user.imx?.ethAddress && user.imx?.starkAddress && user.imx?.userAdminAddress) {
                this.deviceCredentialsManager.saveCredentials(tokenResponse);
            }
            return user;
        }, PassportErrorType.AUTHENTICATION_ERROR);
    }
    async getPKCEToken(authorizationCode, codeVerifier) {
        const response = await globalAxios$1.post(`${this.config.authenticationDomain}/oauth/token`, {
            client_id: this.config.oidcConfiguration.clientId,
            grant_type: 'authorization_code',
            code_verifier: codeVerifier,
            code: authorizationCode,
            redirect_uri: this.config.oidcConfiguration.redirectUri,
        }, formUrlEncodedHeader);
        return response.data;
    }
    async connectImxWithCredentials(tokenResponse) {
        return withPassportError(async () => {
            if (this.deviceCredentialsManager.areValid(tokenResponse)) {
                // Credentials exist and are still valid
                return AuthManager.mapDeviceTokenResponseToDomainUserModel(tokenResponse);
            }
            const refreshToken = tokenResponse?.refresh_token ?? null;
            if (refreshToken) {
                // Token is no longer valid, but refresh token can be used to a new one
                const user = await this.refreshToken(refreshToken);
                return user;
            }
            return null;
        }, PassportErrorType.AUTHENTICATION_ERROR);
    }
    async refreshToken(refreshToken) {
        const response = await globalAxios$1.post(`${this.config.authenticationDomain}/oauth/token`, {
            client_id: this.config.oidcConfiguration.clientId,
            grant_type: 'refresh_token',
            refresh_token: refreshToken,
        }, formUrlEncodedHeader);
        const newTokenResponse = response.data;
        return AuthManager.mapDeviceTokenResponseToDomainUserModel(newTokenResponse);
    }
    async logout() {
        return withPassportError(async () => {
            if (this.logoutMode === 'silent') {
                return this.userManager.signoutSilent();
            }
            return this.userManager.signoutRedirect();
        }, PassportErrorType.LOGOUT_ERROR);
    }
    async logoutSilentCallback(url) {
        return this.userManager.signoutSilentCallback(url);
    }
    async logoutDeviceFlow() {
        return withPassportError(async () => {
            this.deviceCredentialsManager.clearCredentials();
        }, PassportErrorType.LOGOUT_ERROR);
    }
    async loginSilent() {
        return withPassportError(async () => {
            const existedUser = await this.getUser();
            if (!existedUser) {
                return null;
            }
            const oidcUser = await this.userManager.signinSilent();
            if (!oidcUser) {
                return null;
            }
            return AuthManager.mapOidcUserToDomainModel(oidcUser);
        }, PassportErrorType.SILENT_LOGIN_ERROR);
    }
    async getUser() {
        return withPassportError(async () => {
            const oidcUser = await this.userManager.getUser();
            if (oidcUser) {
                return AuthManager.mapOidcUserToDomainModel(oidcUser);
            }
            const deviceToken = this.deviceCredentialsManager.getCredentials();
            if (deviceToken) {
                return AuthManager.mapDeviceTokenResponseToDomainUserModel(deviceToken);
            }
            return null;
        }, PassportErrorType.NOT_LOGGED_IN_ERROR);
    }
    async getUserDeviceFlow() {
        return withPassportError(async () => {
            const deviceToken = this.deviceCredentialsManager.getCredentials();
            if (deviceToken) {
                return AuthManager.mapDeviceTokenResponseToDomainUserModel(deviceToken);
            }
            return null;
        }, PassportErrorType.NOT_LOGGED_IN_ERROR);
    }
    checkStoredDeviceFlowCredentials() {
        return this.deviceCredentialsManager.getCredentials();
    }
}

class MagicAdapter {
    config;
    magicClient;
    constructor(config) {
        this.config = config;
    }
    async login(idToken, network) {
        return withPassportError(async () => {
            this.magicClient = new Magic(this.config.magicPublishableApiKey, {
                extensions: [new OpenIdExtension()],
                network,
            });
            await this.magicClient.openid.loginWithOIDC({
                jwt: idToken,
                providerId: this.config.magicProviderId,
            });
            return this.magicClient.rpcProvider;
        }, PassportErrorType.WALLET_CONNECTION_ERROR);
    }
    async logout() {
        if (this.magicClient?.user) {
            await this.magicClient.user.logout();
        }
    }
}

const getStarkSigner = async (signer) => withPassportError(async () => {
    const privateKey = await generateLegacyStarkPrivateKey(signer);
    return createStarkSigner(privateKey);
}, PassportErrorType.WALLET_CONNECTION_ERROR);

const POLL_INTERVAL = 1 * 1000; // every 1 second
const MAX_RETRIES = 3;
const wait = (ms) => new Promise((resolve) => {
    setTimeout(() => resolve(), ms);
});
const retryWithDelay = async (fn, options) => {
    const { retries = MAX_RETRIES, interval = POLL_INTERVAL, finalErr = Error('Retry failed'), finallyFn = () => { }, } = options || {};
    try {
        return await fn();
    }
    catch (err) {
        if (retries <= 0) {
            return Promise.reject(finalErr);
        }
        await wait(interval);
        return retryWithDelay(fn, { retries: retries - 1, finalErr, finallyFn });
    }
    finally {
        if (retries <= 0) {
            finallyFn();
        }
    }
};

/**
 * ProviderErrors should take priority over RpcErrorCodes
 * https://eips.ethereum.org/EIPS/eip-1193#provider-errors
 * https://eips.ethereum.org/EIPS/eip-1474#error-codes
 */
var ProviderErrorCode;
(function (ProviderErrorCode) {
    ProviderErrorCode[ProviderErrorCode["USER_REJECTED_REQUEST"] = 4001] = "USER_REJECTED_REQUEST";
    ProviderErrorCode[ProviderErrorCode["UNAUTHORIZED"] = 4100] = "UNAUTHORIZED";
    ProviderErrorCode[ProviderErrorCode["UNSUPPORTED_METHOD"] = 4200] = "UNSUPPORTED_METHOD";
    ProviderErrorCode[ProviderErrorCode["DISCONNECTED"] = 4900] = "DISCONNECTED";
})(ProviderErrorCode || (ProviderErrorCode = {}));
var RpcErrorCode;
(function (RpcErrorCode) {
    RpcErrorCode[RpcErrorCode["RPC_SERVER_ERROR"] = -32000] = "RPC_SERVER_ERROR";
    RpcErrorCode[RpcErrorCode["INVALID_REQUEST"] = -32600] = "INVALID_REQUEST";
    RpcErrorCode[RpcErrorCode["METHOD_NOT_FOUND"] = -32601] = "METHOD_NOT_FOUND";
    RpcErrorCode[RpcErrorCode["INVALID_PARAMS"] = -32602] = "INVALID_PARAMS";
    RpcErrorCode[RpcErrorCode["INTERNAL_ERROR"] = -32603] = "INTERNAL_ERROR";
    RpcErrorCode[RpcErrorCode["PARSE_ERROR"] = -32700] = "PARSE_ERROR";
    RpcErrorCode[RpcErrorCode["TRANSACTION_REJECTED"] = -32003] = "TRANSACTION_REJECTED";
})(RpcErrorCode || (RpcErrorCode = {}));
class JsonRpcError extends Error {
    message;
    code;
    constructor(code, message) {
        super(message);
        this.message = message;
        this.code = code;
    }
}

const transactionRejectedCrossSdkBridgeError = 'Transaction requires confirmation but this functionality is not'
    + ' supported in this environment. Please contact Immutable support if you need to enable this feature.';
const convertBigNumberishToString = (value) => BigNumber$1.from(value).toString();
const transformGuardianTransactions = (txs) => {
    try {
        return txs.map((t) => ({
            delegateCall: t.delegateCall === true,
            revertOnError: t.revertOnError === true,
            gasLimit: t.gasLimit ? convertBigNumberishToString(t.gasLimit) : '0',
            target: t.to ?? ethers.constants.AddressZero,
            value: t.value ? convertBigNumberishToString(t.value) : '0',
            data: t.data ? t.data.toString() : '0x',
        }));
    }
    catch (error) {
        const errorMessage = error instanceof Error ? error.message : String(error);
        throw new JsonRpcError(RpcErrorCode.INVALID_PARAMS, `Transaction failed to parsing: ${errorMessage}`);
    }
};
class GuardianClient {
    transactionAPI;
    messageAPI;
    confirmationScreen;
    // TODO: ID-977, make this rollup agnostic
    imxEtherAddress;
    crossSdkBridgeEnabled;
    constructor({ accessToken, confirmationScreen, imxEtherAddress, config, }) {
        const guardianConfiguration = new Configuration({ accessToken, basePath: config.imxPublicApiDomain });
        this.confirmationScreen = confirmationScreen;
        this.transactionAPI = new TransactionsApi(new Configuration(guardianConfiguration));
        this.imxEtherAddress = imxEtherAddress;
        this.crossSdkBridgeEnabled = config.crossSdkBridgeEnabled;
        this.messageAPI = new MessagesApi(guardianConfiguration);
    }
    /**
     * Open confirmation screen and close it automatically if the
     * underlying task fails.
     */
    withConfirmationScreen(popupWindowSize) {
        return (task) => this.withConfirmationScreenTask(popupWindowSize)(task)();
    }
    withConfirmationScreenTask(popupWindowSize) {
        return (task) => async () => {
            this.confirmationScreen.loading(popupWindowSize);
            try {
                return await task();
            }
            catch (err) {
                this.confirmationScreen.closeWindow();
                throw err;
            }
        };
    }
    withDefaultConfirmationScreenTask(task) {
        return this.withConfirmationScreenTask()(task);
    }
    async validate({ payloadHash }) {
        const finallyFn = () => {
            this.confirmationScreen.closeWindow();
        };
        const transactionRes = await retryWithDelay(async () => this.transactionAPI.getTransactionByID({
            transactionID: payloadHash,
            chainType: 'starkex',
        }), { finallyFn });
        if (!transactionRes.data.id) {
            throw new Error("Transaction doesn't exists");
        }
        const evaluateStarkexRes = await this.transactionAPI.evaluateTransaction({
            id: payloadHash,
            transactionEvaluationRequest: {
                chainType: 'starkex',
            },
        });
        const { confirmationRequired } = evaluateStarkexRes.data;
        if (confirmationRequired) {
            if (this.crossSdkBridgeEnabled) {
                throw new Error(transactionRejectedCrossSdkBridgeError);
            }
            const confirmationResult = await this.confirmationScreen.requestConfirmation(payloadHash, this.imxEtherAddress, TransactionApprovalRequestChainTypeEnum.Starkex);
            if (!confirmationResult.confirmed) {
                throw new Error('Transaction rejected by user');
            }
        }
        else {
            this.confirmationScreen.closeWindow();
        }
    }
    async evaluateEVMTransaction({ chainId, nonce, user, metaTransactions, }) {
        const headers = { Authorization: `Bearer ${user.accessToken}` };
        const guardianTransactions = transformGuardianTransactions(metaTransactions);
        try {
            const transactionEvaluationResponseAxiosResponse = await this.transactionAPI.evaluateTransaction({
                id: 'evm',
                transactionEvaluationRequest: {
                    chainType: 'evm',
                    chainId,
                    transactionData: {
                        nonce,
                        userAddress: user.zkEvm.ethAddress,
                        metaTransactions: guardianTransactions,
                    },
                },
            }, { headers });
            return transactionEvaluationResponseAxiosResponse.data;
        }
        catch (error) {
            const errorMessage = error instanceof Error ? error.message : String(error);
            throw new JsonRpcError(RpcErrorCode.INTERNAL_ERROR, `Transaction failed to validate with error: ${errorMessage}`);
        }
    }
    async validateEVMTransaction({ chainId, nonce, user, metaTransactions, }) {
        const transactionEvaluationResponse = await this.evaluateEVMTransaction({
            chainId,
            nonce,
            user,
            metaTransactions,
        });
        const { confirmationRequired, transactionId } = transactionEvaluationResponse;
        if (confirmationRequired && this.crossSdkBridgeEnabled) {
            throw new JsonRpcError(RpcErrorCode.TRANSACTION_REJECTED, transactionRejectedCrossSdkBridgeError);
        }
        if (confirmationRequired && !!transactionId) {
            const confirmationResult = await this.confirmationScreen.requestConfirmation(transactionId, this.imxEtherAddress, TransactionApprovalRequestChainTypeEnum.Evm, chainId);
            if (!confirmationResult.confirmed) {
                throw new JsonRpcError(RpcErrorCode.TRANSACTION_REJECTED, 'Transaction rejected by user');
            }
        }
        else {
            this.confirmationScreen.closeWindow();
        }
    }
    async evaluateMessage({ chainID, payload, user }) {
        try {
            const messageEvalResponse = await this.messageAPI.evaluateMessage({ messageEvaluationRequest: { chainID, payload } }, { headers: { Authorization: `Bearer ${user.accessToken}` } });
            return messageEvalResponse.data;
        }
        catch (error) {
            const errorMessage = error instanceof Error ? error.message : String(error);
            throw new JsonRpcError(RpcErrorCode.INTERNAL_ERROR, `Message failed to validate with error: ${errorMessage}`);
        }
    }
    async validateMessage({ chainID, payload, user }) {
        const { messageId, confirmationRequired } = await this.evaluateMessage({ chainID, payload, user });
        if (confirmationRequired && this.crossSdkBridgeEnabled) {
            throw new JsonRpcError(RpcErrorCode.TRANSACTION_REJECTED, transactionRejectedCrossSdkBridgeError);
        }
        if (confirmationRequired && !!messageId) {
            const confirmationResult = await this.confirmationScreen.requestMessageConfirmation(messageId);
            if (!confirmationResult.confirmed) {
                throw new JsonRpcError(RpcErrorCode.TRANSACTION_REJECTED, 'Signature rejected by user');
            }
        }
        else {
            this.confirmationScreen.closeWindow();
        }
    }
}

var PassportEvents;
(function (PassportEvents) {
    PassportEvents["LOGGED_OUT"] = "loggedOut";
})(PassportEvents || (PassportEvents = {}));
var Networks;
(function (Networks) {
    Networks["PRODUCTION"] = "mainnet";
    Networks["SANDBOX"] = "goerli";
})(Networks || (Networks = {}));

async function exchangeTransfer$1({ user, starkSigner, request, exchangesApi, }) {
    return withPassportError(async () => {
        const { ethAddress } = user.imx;
        const transferAmount = request.amount;
        const signableResult = await exchangesApi.getExchangeSignableTransfer({
            id: request.transactionID,
            getSignableTransferRequest: {
                sender: ethAddress,
                token: convertToSignableToken(request),
                amount: transferAmount,
                receiver: request.receiver,
            },
        });
        const starkAddress = await starkSigner.getAddress();
        const { payload_hash: payloadHash } = signableResult.data;
        const starkSignature = await starkSigner.signMessage(payloadHash);
        const transferSigningParams = {
            sender_stark_key: signableResult.data.sender_stark_key || starkAddress,
            sender_vault_id: signableResult.data.sender_vault_id,
            receiver_stark_key: signableResult.data.receiver_stark_key,
            receiver_vault_id: signableResult.data.receiver_vault_id,
            asset_id: signableResult.data.asset_id,
            amount: signableResult.data.amount,
            nonce: signableResult.data.nonce,
            expiration_timestamp: signableResult.data.expiration_timestamp,
            stark_signature: starkSignature,
        };
        const headers = {
            // eslint-disable-next-line @typescript-eslint/naming-convention
            Authorization: `Bearer ${user.accessToken}`,
        };
        const response = await exchangesApi.createExchangeTransfer({
            id: request.transactionID,
            createTransferRequest: transferSigningParams,
        }, { headers });
        return {
            sent_signature: response?.data.sent_signature,
            status: response?.data.status?.toString(),
            time: response?.data.time,
            transfer_id: response?.data.transfer_id,
        };
    }, PassportErrorType.EXCHANGE_TRANSFER_ERROR);
}

const ERC721$1 = 'ERC721';
async function createOrder$1({ starkSigner, user, request, ordersApi, guardianClient, }) {
    return withPassportError(guardianClient.withDefaultConfirmationScreenTask(async () => {
        const { ethAddress } = user.imx;
        const amountSell = request.sell.type === ERC721$1 ? '1' : request.sell.amount;
        const amountBuy = request.buy.type === ERC721$1 ? '1' : request.buy.amount;
        const headers = {
            // eslint-disable-next-line @typescript-eslint/naming-convention
            Authorization: `Bearer ${user.accessToken}`,
        };
        const getSignableOrderRequestV3 = {
            user: ethAddress,
            amount_buy: amountBuy,
            token_buy: convertToSignableToken(request.buy),
            amount_sell: amountSell,
            token_sell: convertToSignableToken(request.sell),
            fees: request.fees,
            split_fees: true,
            expiration_timestamp: request.expiration_timestamp,
        };
        const getSignableOrderResponse = await ordersApi.getSignableOrder({
            getSignableOrderRequestV3,
        }, { headers });
        await guardianClient.validate({
            payloadHash: getSignableOrderResponse.data.payload_hash,
        });
        const { payload_hash: payloadHash } = getSignableOrderResponse.data;
        const starkSignature = await starkSigner.signMessage(payloadHash);
        const signableResultData = getSignableOrderResponse.data;
        const orderParams = {
            createOrderRequest: {
                include_fees: true,
                fees: request.fees,
                stark_signature: starkSignature,
                amount_buy: signableResultData.amount_buy,
                amount_sell: signableResultData.amount_sell,
                asset_id_buy: signableResultData.asset_id_buy,
                asset_id_sell: signableResultData.asset_id_sell,
                expiration_timestamp: signableResultData.expiration_timestamp,
                nonce: signableResultData.nonce,
                stark_key: signableResultData.stark_key,
                vault_id_buy: signableResultData.vault_id_buy,
                vault_id_sell: signableResultData.vault_id_sell,
            },
        };
        const createOrderResponse = await ordersApi.createOrderV3(orderParams, {
            headers,
        });
        return {
            ...createOrderResponse.data,
        };
    }), PassportErrorType.CREATE_ORDER_ERROR);
}
async function cancelOrder$1({ user, starkSigner, request, ordersApi, guardianClient, }) {
    return withPassportError(guardianClient.withDefaultConfirmationScreenTask(async () => {
        const getSignableCancelOrderRequest = {
            order_id: request.order_id,
        };
        const headers = {
            // eslint-disable-next-line @typescript-eslint/naming-convention
            Authorization: `Bearer ${user.accessToken}`,
        };
        const getSignableCancelOrderResponse = await ordersApi.getSignableCancelOrderV3({
            getSignableCancelOrderRequest,
        }, { headers });
        await guardianClient.validate({
            payloadHash: getSignableCancelOrderResponse.data.payload_hash,
        });
        const { payload_hash: payloadHash } = getSignableCancelOrderResponse.data;
        const starkSignature = await starkSigner.signMessage(payloadHash);
        const cancelOrderResponse = await ordersApi.cancelOrderV3({
            id: request.order_id.toString(),
            cancelOrderRequest: {
                order_id: request.order_id,
                stark_signature: starkSignature,
            },
        }, { headers });
        return {
            order_id: cancelOrderResponse.data.order_id,
            status: cancelOrderResponse.data.status,
        };
    }), PassportErrorType.CANCEL_ORDER_ERROR);
}

async function registerPassport({ ethSigner, starkSigner, usersApi }, authorization) {
    return withPassportError(async () => {
        const userAddress = await ethSigner.getAddress();
        const starkPublicKey = await starkSigner.getAddress();
        const signableResult = await usersApi.getSignableRegistrationOffchain({
            getSignableRegistrationRequest: {
                ether_key: userAddress,
                stark_key: starkPublicKey,
            },
        });
        const { signable_message: signableMessage, payload_hash: payloadHash } = signableResult.data;
        const ethSignature = await signRaw(signableMessage, ethSigner);
        const starkSignature = await starkSigner.signMessage(payloadHash);
        const response = await usersApi.registerPassportUser({
            authorization: `Bearer ${authorization}`,
            registerPassportUserRequest: {
                eth_signature: ethSignature,
                ether_key: userAddress,
                stark_signature: starkSignature,
                stark_key: starkPublicKey,
            },
        });
        return response.statusText;
    }, PassportErrorType.USER_REGISTRATION_ERROR);
}

async function createTrade$1({ request, tradesApi, user, starkSigner, guardianClient, }) {
    return withPassportError(guardianClient.withDefaultConfirmationScreenTask(async () => {
        const { ethAddress } = user.imx;
        const getSignableTradeRequest = {
            expiration_timestamp: request.expiration_timestamp,
            fees: request.fees,
            order_id: request.order_id,
            user: ethAddress,
        };
        // eslint-disable-next-line @typescript-eslint/naming-convention
        const headers = { Authorization: `Bearer ${user.accessToken}` };
        const getSignableTradeResponse = await tradesApi.getSignableTrade({
            getSignableTradeRequest,
        }, { headers });
        await guardianClient.validate({
            payloadHash: getSignableTradeResponse.data.payload_hash,
        });
        const { payload_hash: payloadHash } = getSignableTradeResponse.data;
        const starkSignature = await starkSigner.signMessage(payloadHash);
        const { data: signableResultData } = getSignableTradeResponse;
        const tradeParams = {
            createTradeRequest: {
                include_fees: true,
                fees: request?.fees,
                stark_signature: starkSignature,
                order_id: request?.order_id,
                fee_info: signableResultData.fee_info,
                amount_buy: signableResultData.amount_buy,
                amount_sell: signableResultData.amount_sell,
                asset_id_buy: signableResultData.asset_id_buy,
                asset_id_sell: signableResultData.asset_id_sell,
                expiration_timestamp: signableResultData.expiration_timestamp,
                nonce: signableResultData.nonce,
                stark_key: signableResultData.stark_key,
                vault_id_buy: signableResultData.vault_id_buy,
                vault_id_sell: signableResultData.vault_id_sell,
            },
        };
        const { data: createTradeResponse } = await tradesApi.createTradeV3(tradeParams, {
            headers,
        });
        return createTradeResponse;
    }), PassportErrorType.CREATE_TRADE_ERROR);
}

const ERC721 = 'ERC721';
async function transfer$1({ request, transfersApi, starkSigner, user, guardianClient, }) {
    return withPassportError(guardianClient.withDefaultConfirmationScreenTask(async () => {
        const transferAmount = request.type === ERC721 ? '1' : request.amount;
        const getSignableTransferRequest = {
            sender: user.imx.ethAddress,
            token: convertToSignableToken(request),
            amount: transferAmount,
            receiver: request.receiver,
        };
        const headers = {
            Authorization: `Bearer ${user.accessToken}`,
        };
        const signableResult = await transfersApi.getSignableTransferV1({
            getSignableTransferRequest,
        }, { headers });
        await guardianClient.validate({
            payloadHash: signableResult.data.payload_hash,
        });
        const signableResultData = signableResult.data;
        const { payload_hash: payloadHash } = signableResultData;
        const starkSignature = await starkSigner.signMessage(payloadHash);
        const senderStarkKey = await starkSigner.getAddress();
        const transferSigningParams = {
            sender_stark_key: signableResultData.sender_stark_key || senderStarkKey,
            sender_vault_id: signableResultData.sender_vault_id,
            receiver_stark_key: signableResultData.receiver_stark_key,
            receiver_vault_id: signableResultData.receiver_vault_id,
            asset_id: signableResultData.asset_id,
            amount: signableResultData.amount,
            nonce: signableResultData.nonce,
            expiration_timestamp: signableResultData.expiration_timestamp,
            stark_signature: starkSignature,
        };
        const createTransferRequest = {
            createTransferRequest: transferSigningParams,
        };
        const { data: responseData } = await transfersApi.createTransferV1(createTransferRequest, { headers });
        return {
            sent_signature: responseData.sent_signature,
            status: responseData.status?.toString(),
            time: responseData.time,
            transfer_id: responseData.transfer_id,
        };
    }), PassportErrorType.TRANSFER_ERROR);
}
async function batchNftTransfer({ user, starkSigner, request, transfersApi, guardianClient, }) {
    // eslint-disable-next-line function-paren-newline
    return withPassportError(guardianClient.withConfirmationScreenTask({ width: 480, height: 784 })(async () => {
        const { ethAddress } = user.imx;
        const signableRequests = request.map((nftTransfer) => ({
            amount: '1',
            token: convertToSignableToken({
                type: ERC721,
                tokenId: nftTransfer.tokenId,
                tokenAddress: nftTransfer.tokenAddress,
            }),
            receiver: nftTransfer.receiver,
        }));
        const getSignableTransferRequestV2 = {
            sender_ether_key: ethAddress,
            signable_requests: signableRequests,
        };
        const headers = {
            // eslint-disable-next-line @typescript-eslint/naming-convention
            Authorization: `Bearer ${user.accessToken}`,
        };
        const signableResult = await transfersApi.getSignableTransfer({
            getSignableTransferRequestV2,
        }, { headers });
        await guardianClient.validate({
            payloadHash: signableResult.data.signable_responses[0]?.payload_hash,
        });
        const requests = await Promise.all(signableResult.data.signable_responses.map(async (resp) => {
            const starkSignature = await starkSigner.signMessage(resp.payload_hash);
            return {
                sender_vault_id: resp.sender_vault_id,
                receiver_stark_key: resp.receiver_stark_key,
                receiver_vault_id: resp.receiver_vault_id,
                asset_id: resp.asset_id,
                amount: resp.amount,
                nonce: resp.nonce,
                expiration_timestamp: resp.expiration_timestamp,
                stark_signature: starkSignature,
            };
        }));
        const transferSigningParams = {
            sender_stark_key: signableResult.data.sender_stark_key,
            requests,
        };
        const response = await transfersApi.createTransfer({
            createTransferRequestV2: transferSigningParams,
        }, { headers });
        return {
            transfer_ids: response?.data.transfer_ids,
        };
    }), PassportErrorType.TRANSFER_ERROR);
}

class PassportImxProvider {
    user;
    starkSigner;
    immutableXClient;
    confirmationScreen;
    guardianClient;
    constructor({ user, starkSigner, immutableXClient, confirmationScreen, config, passportEventEmitter, }) {
        this.user = user;
        this.starkSigner = starkSigner;
        this.immutableXClient = immutableXClient;
        this.confirmationScreen = confirmationScreen;
        this.guardianClient = new GuardianClient({
            accessToken: user.accessToken,
            confirmationScreen,
            imxEtherAddress: user.imx.ethAddress,
            config,
        });
        passportEventEmitter.on(PassportEvents.LOGGED_OUT, this.handleLogout);
    }
    handleLogout = () => {
        this.user = undefined;
        this.starkSigner = undefined;
    };
    checkIsLoggedIn() {
        if (this.user === undefined || this.starkSigner === undefined) {
            throw new PassportError('User has been logged out', PassportErrorType.NOT_LOGGED_IN_ERROR);
        }
    }
    async transfer(request) {
        this.checkIsLoggedIn();
        return transfer$1({
            request,
            user: this.user,
            starkSigner: this.starkSigner,
            transfersApi: this.immutableXClient.transfersApi,
            guardianClient: this.guardianClient,
        });
    }
    // TODO: Remove once implemented
    // eslint-disable-next-line class-methods-use-this
    registerOffchain() {
        throw new PassportError('Operation not supported', PassportErrorType.OPERATION_NOT_SUPPORTED_ERROR);
    }
    // TODO: Remove once implemented
    // eslint-disable-next-line class-methods-use-this
    isRegisteredOnchain() {
        throw new PassportError('Operation not supported', PassportErrorType.OPERATION_NOT_SUPPORTED_ERROR);
    }
    createOrder(request) {
        this.checkIsLoggedIn();
        return createOrder$1({
            request,
            user: this.user,
            starkSigner: this.starkSigner,
            ordersApi: this.immutableXClient.ordersApi,
            guardianClient: this.guardianClient,
        });
    }
    cancelOrder(request) {
        this.checkIsLoggedIn();
        return cancelOrder$1({
            request,
            user: this.user,
            starkSigner: this.starkSigner,
            ordersApi: this.immutableXClient.ordersApi,
            guardianClient: this.guardianClient,
        });
    }
    createTrade(request) {
        this.checkIsLoggedIn();
        return createTrade$1({
            request,
            user: this.user,
            starkSigner: this.starkSigner,
            tradesApi: this.immutableXClient.tradesApi,
            guardianClient: this.guardianClient,
        });
    }
    batchNftTransfer(request) {
        this.checkIsLoggedIn();
        return batchNftTransfer({
            request,
            user: this.user,
            starkSigner: this.starkSigner,
            transfersApi: this.immutableXClient.transfersApi,
            guardianClient: this.guardianClient,
        });
    }
    exchangeTransfer(request) {
        this.checkIsLoggedIn();
        return exchangeTransfer$1({
            request,
            user: this.user,
            starkSigner: this.starkSigner,
            exchangesApi: this.immutableXClient.exchangeApi,
        });
    }
    // TODO: Remove once implemented
    // eslint-disable-next-line class-methods-use-this, @typescript-eslint/no-unused-vars
    deposit(deposit) {
        throw new PassportError('Operation not supported', PassportErrorType.OPERATION_NOT_SUPPORTED_ERROR);
    }
    // TODO: Remove once implemented
    // eslint-disable-next-line class-methods-use-this, @typescript-eslint/no-unused-vars
    prepareWithdrawal(request) {
        throw new PassportError('Operation not supported', PassportErrorType.OPERATION_NOT_SUPPORTED_ERROR);
    }
    // TODO: Remove once implemented
    // eslint-disable-next-line class-methods-use-this
    completeWithdrawal(
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    starkPublicKey, 
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    token) {
        throw new PassportError('Operation not supported', PassportErrorType.OPERATION_NOT_SUPPORTED_ERROR);
    }
    getAddress() {
        this.checkIsLoggedIn();
        return Promise.resolve(this.user.imx.ethAddress);
    }
}

class PassportImxProviderFactory {
    authManager;
    config;
    confirmationScreen;
    immutableXClient;
    magicAdapter;
    passportEventEmitter;
    constructor({ authManager, config, confirmationScreen, immutableXClient, magicAdapter, passportEventEmitter, }) {
        this.authManager = authManager;
        this.config = config;
        this.confirmationScreen = confirmationScreen;
        this.immutableXClient = immutableXClient;
        this.magicAdapter = magicAdapter;
        this.passportEventEmitter = passportEventEmitter;
    }
    async getProvider() {
        const user = await this.authManager.login();
        return this.createProviderInstance(user);
    }
    async getProviderSilent() {
        const user = await this.authManager.loginSilent();
        if (!user) {
            return null;
        }
        return this.createProviderInstance(user);
    }
    async getProviderWithDeviceFlow(deviceCode, interval, timeoutMs) {
        const user = await this.authManager.connectImxDeviceFlow(deviceCode, interval, timeoutMs);
        return this.createProviderInstance(user);
    }
    async getProviderWithPKCEFlow(authorizationCode, state) {
        const user = await this.authManager.connectImxPKCEFlow(authorizationCode, state);
        return this.createProviderInstance(user);
    }
    async getProviderWithCredentials(tokenResponse) {
        const user = await this.authManager.connectImxWithCredentials(tokenResponse);
        if (!user) {
            return null;
        }
        return this.createProviderInstance(user);
    }
    async createProviderInstance(user) {
        if (!user.idToken) {
            throw new PassportError('Failed to initialise', PassportErrorType.WALLET_CONNECTION_ERROR);
        }
        const magicRpcProvider = await this.magicAdapter.login(user.idToken, this.config.network);
        const web3Provider = new Web3Provider(magicRpcProvider);
        const ethSigner = web3Provider.getSigner();
        const starkSigner = await getStarkSigner(ethSigner);
        if (!user.imx?.ethAddress) {
            const userImx = await this.registerStarkEx(ethSigner, starkSigner, user.accessToken);
            return new PassportImxProvider({
                user: userImx,
                starkSigner,
                immutableXClient: this.immutableXClient,
                confirmationScreen: this.confirmationScreen,
                config: this.config,
                passportEventEmitter: this.passportEventEmitter,
            });
        }
        return new PassportImxProvider({
            user: user,
            starkSigner,
            immutableXClient: this.immutableXClient,
            confirmationScreen: this.confirmationScreen,
            config: this.config,
            passportEventEmitter: this.passportEventEmitter,
        });
    }
    async registerStarkEx(userAdminKeySigner, starkSigner, jwt) {
        return withPassportError(async () => {
            await registerPassport({
                ethSigner: userAdminKeySigner,
                starkSigner,
                usersApi: this.immutableXClient.usersApi,
            }, jwt);
            // User metadata is updated asynchronously. Poll userinfo endpoint until it is updated.
            const updatedUser = await retryWithDelay(async () => {
                const user = await this.authManager.loginSilent();
                const metadataExists = !!user?.imx;
                if (metadataExists) {
                    return user;
                }
                return Promise.reject(new Error('user wallet addresses not exist'));
            });
            return updatedUser;
        }, PassportErrorType.REFRESH_TOKEN_ERROR);
    }
}

const validateConfiguration = (configuration, requiredKeys, prefix) => {
    const missingKeys = requiredKeys
        .map((key) => !configuration[key] && key)
        .filter((n) => n)
        .join(', ');
    if (missingKeys !== '') {
        const errorMessage = prefix
            ? `${prefix} - ${missingKeys} cannot be null`
            : `${missingKeys} cannot be null`;
        throw new PassportError(errorMessage, PassportErrorType.INVALID_CONFIGURATION);
    }
};
class PassportConfiguration {
    network;
    authenticationDomain;
    passportDomain;
    imxPublicApiDomain;
    magicPublishableApiKey;
    magicProviderId;
    oidcConfiguration;
    baseConfig;
    zkEvmRpcUrl;
    relayerUrl;
    multiRollupConfig;
    crossSdkBridgeEnabled;
    constructor({ baseConfig, overrides, crossSdkBridgeEnabled, ...oidcConfiguration }) {
        validateConfiguration(oidcConfiguration, [
            'clientId',
            'logoutRedirectUri',
            'redirectUri',
        ]);
        this.oidcConfiguration = oidcConfiguration;
        this.baseConfig = baseConfig;
        this.crossSdkBridgeEnabled = crossSdkBridgeEnabled || false;
        if (overrides) {
            validateConfiguration(overrides, [
                'network',
                'authenticationDomain',
                'passportDomain',
                'magicPublishableApiKey',
                'magicProviderId',
                'zkEvmRpcUrl',
                'relayerUrl',
                'imxPublicApiDomain',
                'indexerMrBasePath',
                'orderBookMrBasePath',
                'passportMrBasePath',
            ], 'overrides');
            this.network = overrides.network;
            this.authenticationDomain = overrides.authenticationDomain;
            this.passportDomain = overrides.passportDomain;
            this.imxPublicApiDomain = overrides.imxPublicApiDomain;
            this.magicPublishableApiKey = overrides.magicPublishableApiKey;
            this.magicProviderId = overrides.magicProviderId;
            this.zkEvmRpcUrl = overrides.zkEvmRpcUrl;
            this.relayerUrl = overrides.relayerUrl;
            this.multiRollupConfig = {
                indexer: createConfig({
                    basePath: overrides.indexerMrBasePath,
                }),
                orderBook: createConfig({
                    basePath: overrides.orderBookMrBasePath,
                }),
                passport: createConfig({
                    basePath: overrides.passportMrBasePath,
                }),
            };
        }
        else {
            switch (baseConfig.environment) {
                case Environment$1.PRODUCTION: {
                    this.network = Networks.PRODUCTION;
                    this.authenticationDomain = 'https://auth.immutable.com';
                    this.magicPublishableApiKey = 'pk_live_10F423798A540ED7';
                    this.magicProviderId = 'fSMzaRQ4O7p4fttl7pCyGVtJS_G70P8SNsLXtPPGHo0=';
                    this.passportDomain = 'https://passport.immutable.com';
                    this.imxPublicApiDomain = 'https://api.immutable.com';
                    this.zkEvmRpcUrl = ''; // TODO: ID-785 Update once mainnet has been deployed
                    this.relayerUrl = 'https://api.immutable.com/relayer-mr';
                    this.multiRollupConfig = multiRollupConfig.getProduction();
                    break;
                }
                case Environment$1.SANDBOX:
                default: {
                    this.network = Networks.SANDBOX;
                    this.authenticationDomain = 'https://auth.immutable.com';
                    this.magicPublishableApiKey = 'pk_live_10F423798A540ED7';
                    this.magicProviderId = 'fSMzaRQ4O7p4fttl7pCyGVtJS_G70P8SNsLXtPPGHo0=';
                    this.passportDomain = 'https://passport.sandbox.immutable.com';
                    this.imxPublicApiDomain = 'https://api.sandbox.immutable.com';
                    this.zkEvmRpcUrl = 'https://rpc.testnet.immutable.com';
                    this.relayerUrl = 'https://api.sandbox.immutable.com/relayer-mr';
                    this.multiRollupConfig = multiRollupConfig.getSandbox();
                    break;
                }
            }
        }
    }
}

var ReceiveMessage;
(function (ReceiveMessage) {
    ReceiveMessage["CONFIRMATION_WINDOW_READY"] = "confirmation_window_ready";
    ReceiveMessage["TRANSACTION_CONFIRMED"] = "transaction_confirmed";
    ReceiveMessage["TRANSACTION_ERROR"] = "transaction_error";
    ReceiveMessage["MESSAGE_CONFIRMED"] = "message_confirmed";
    ReceiveMessage["MESSAGE_REJECTED"] = "message_rejected";
    ReceiveMessage["LOGOUT_SUCCESS"] = "logout_success";
})(ReceiveMessage || (ReceiveMessage = {}));
const PASSPORT_EVENT_TYPE = 'imx_passport_confirmation';

const openPopupCenter = ({ url, title, width, height, }) => {
    const left = Math.max(0, Math.round(window.screenX + (window.outerWidth - width) / 2));
    const top = Math.max(0, Math.round(window.screenY + (window.outerHeight - height) / 2));
    const newWindow = window.open(url, title, `
      scrollbars=yes,
      width=${width}, 
      height=${height}, 
      top=${top}, 
      left=${left}
     `);
    if (!newWindow) {
        throw new Error('Failed to open confirmation screen');
    }
    newWindow.focus();
    return newWindow;
};

const CONFIRMATION_WINDOW_TITLE = 'Confirm this transaction';
const CONFIRMATION_WINDOW_HEIGHT = 380;
const CONFIRMATION_WINDOW_WIDTH = 480;
const CONFIRMATION_WINDOW_CLOSED_POLLING_DURATION = 1000;
const CONFIRMATION_IFRAME_ID = 'passport-confirm';
const CONFIRMATION_IFRAME_STYLE = 'display: none; position: absolute;width:0px;height:0px;border:0;';
class ConfirmationScreen {
    config;
    confirmationWindow;
    constructor(config) {
        this.config = config;
    }
    requestConfirmation(transactionId, imxEtherAddress, chainType, chainId) {
        return new Promise((resolve, reject) => {
            const messageHandler = ({ data, origin }) => {
                if (origin !== this.config.passportDomain
                    || data.eventType !== PASSPORT_EVENT_TYPE) {
                    return;
                }
                switch (data.messageType) {
                    case ReceiveMessage.CONFIRMATION_WINDOW_READY: {
                        break;
                    }
                    case ReceiveMessage.TRANSACTION_CONFIRMED: {
                        resolve({ confirmed: true });
                        break;
                    }
                    case ReceiveMessage.TRANSACTION_ERROR: {
                        reject(new Error('Transaction error'));
                        break;
                    }
                    default:
                        reject(new Error('Unsupported message type'));
                }
            };
            if (!this.confirmationWindow) {
                resolve({ confirmed: false });
                return;
            }
            window.addEventListener('message', messageHandler);
            let href = '';
            if (chainType === TransactionApprovalRequestChainTypeEnum.Starkex) {
                // eslint-disable-next-line max-len
                href = `${this.config.passportDomain}/transaction-confirmation/transaction?transactionId=${transactionId}&imxEtherAddress=${imxEtherAddress}&chainType=starkex`;
            }
            else {
                // eslint-disable-next-line max-len
                href = `${this.config.passportDomain}/transaction-confirmation/zkevm?transactionId=${transactionId}&imxEtherAddress=${imxEtherAddress}&chainType=evm&chainId=${chainId}`;
            }
            this.showConfirmationScreen(href, messageHandler, resolve);
        });
    }
    requestMessageConfirmation(messageId) {
        return new Promise((resolve, reject) => {
            const messageHandler = ({ data, origin }) => {
                if (origin !== this.config.passportDomain
                    || data.eventType !== PASSPORT_EVENT_TYPE) {
                    return;
                }
                switch (data.messageType) {
                    case ReceiveMessage.CONFIRMATION_WINDOW_READY: {
                        break;
                    }
                    case ReceiveMessage.MESSAGE_CONFIRMED: {
                        resolve({ confirmed: true });
                        break;
                    }
                    case ReceiveMessage.MESSAGE_REJECTED: {
                        reject(new Error('Message rejected'));
                        break;
                    }
                    default:
                        reject(new Error('Unsupported message type'));
                }
            };
            if (!this.confirmationWindow) {
                resolve({ confirmed: false });
                return;
            }
            window.addEventListener('message', messageHandler);
            const href = `${this.config.passportDomain}/transaction-confirmation/zkevm/message?messageID=${messageId}`;
            this.showConfirmationScreen(href, messageHandler, resolve);
        });
    }
    loading(popupOptions) {
        if (this.config.crossSdkBridgeEnabled) {
            // There is no need to open a confirmation window if cross-sdk bridge is enabled
            return;
        }
        this.confirmationWindow = openPopupCenter({
            url: `${this.config.passportDomain}/transaction-confirmation/loading`,
            title: CONFIRMATION_WINDOW_TITLE,
            width: popupOptions?.width || CONFIRMATION_WINDOW_WIDTH,
            height: popupOptions?.height || CONFIRMATION_WINDOW_HEIGHT,
        });
    }
    closeWindow() {
        this.confirmationWindow?.close();
    }
    logout() {
        return new Promise((resolve, rejects) => {
            const iframe = document.createElement('iframe');
            iframe.setAttribute('id', CONFIRMATION_IFRAME_ID);
            iframe.setAttribute('src', `${this.config.passportDomain}/transaction-confirmation/logout`);
            iframe.setAttribute('style', CONFIRMATION_IFRAME_STYLE);
            const logoutHandler = ({ data, origin }) => {
                if (origin !== this.config.passportDomain
                    || data.eventType !== PASSPORT_EVENT_TYPE) {
                    return;
                }
                window.removeEventListener('message', logoutHandler);
                iframe.remove();
                if (data.messageType === ReceiveMessage.LOGOUT_SUCCESS) {
                    resolve({ logout: true });
                }
                rejects(new Error('Unsupported logout type'));
            };
            window.addEventListener('message', logoutHandler);
            document.body.appendChild(iframe);
        });
    }
    showConfirmationScreen(href, messageHandler, resolve) {
        this.confirmationWindow.location.href = href;
        // https://stackoverflow.com/questions/9388380/capture-the-close-event-of-popup-window-in-javascript/48240128#48240128
        const timer = setInterval(() => {
            if (this.confirmationWindow?.closed) {
                clearInterval(timer);
                window.removeEventListener('message', messageHandler);
                resolve({ confirmed: false });
            }
        }, CONFIRMATION_WINDOW_CLOSED_POLLING_DURATION);
    }
}

var RelayerTransactionStatus;
(function (RelayerTransactionStatus) {
    RelayerTransactionStatus["PENDING"] = "PENDING";
    RelayerTransactionStatus["SUBMITTED"] = "SUBMITTED";
    RelayerTransactionStatus["SUCCESSFUL"] = "SUCCESSFUL";
    RelayerTransactionStatus["REVERTED"] = "REVERTED";
    RelayerTransactionStatus["FAILED"] = "FAILED";
})(RelayerTransactionStatus || (RelayerTransactionStatus = {}));
var ProviderEvent;
(function (ProviderEvent) {
    ProviderEvent["ACCOUNTS_CHANGED"] = "accountsChanged";
})(ProviderEvent || (ProviderEvent = {}));

class TypedEventEmitter {
    emitter = new EventEmitter();
    emit(eventName, ...eventArg) {
        this.emitter.emit(eventName, ...eventArg);
    }
    on(eventName, handler) {
        this.emitter.on(eventName, handler);
    }
    removeListener(eventName, handler) {
        this.emitter.removeListener(eventName, handler);
    }
}

const SIGNATURE_WEIGHT = 1; // Weight of a single signature in the multi-sig
const TRANSACTION_SIGNATURE_THRESHOLD = 1; // Total required weight in the multi-sig for a transaction
const EIP712_SIGNATURE_THRESHOLD = 2; // Total required weight in the multi-sig for data signing
const ETH_SIGN_FLAG = '02';
const ETH_SIGN_PREFIX = '\x19\x01';
const META_TRANSACTIONS_TYPE = `tuple(
  bool delegateCall,
  bool revertOnError,
  uint256 gasLimit,
  address target,
  uint256 value,
  bytes data
)[]`;
function getNormalisedTransactions(txs) {
    return txs.map((t) => ({
        delegateCall: t.delegateCall === true,
        revertOnError: t.revertOnError === true,
        gasLimit: t.gasLimit ?? ethers.constants.Zero,
        target: t.to ?? ethers.constants.AddressZero,
        value: t.value ?? ethers.constants.Zero,
        data: t.data ?? [],
    }));
}
function digestOfTransactionsAndNonce(nonce, normalisedTransactions) {
    const packMetaTransactionsNonceData = ethers.utils.defaultAbiCoder.encode(['uint256', META_TRANSACTIONS_TYPE], [nonce, normalisedTransactions]);
    return ethers.utils.keccak256(packMetaTransactionsNonceData);
}
const getNonce = async (jsonRpcProvider, smartContractWalletAddress) => {
    const code = await jsonRpcProvider.send('eth_getCode', [smartContractWalletAddress, 'latest']);
    if (code && code !== '0x') {
        const contract = new ethers.Contract(smartContractWalletAddress, walletContracts.mainModule.abi, jsonRpcProvider);
        return contract.nonce();
    }
    return 0;
};
const encodeMessageSubDigest = (chainId, walletAddress, digest) => (ethers.utils.solidityPack(['string', 'uint256', 'address', 'bytes32'], [ETH_SIGN_PREFIX, chainId, walletAddress, digest]));
const getSignedMetaTransactions = async (metaTransactions, nonce, chainId, walletAddress, signer) => {
    const normalisedMetaTransactions = getNormalisedTransactions(metaTransactions);
    // Get the hash
    const digest = digestOfTransactionsAndNonce(nonce, normalisedMetaTransactions);
    const completePayload = encodeMessageSubDigest(chainId, walletAddress, digest);
    const hash = ethers.utils.keccak256(completePayload);
    // Sign the digest
    const hashArray = ethers.utils.arrayify(hash);
    const ethsigNoType = await signer.signMessage(hashArray);
    const signedDigest = `${ethsigNoType}${ETH_SIGN_FLAG}`;
    // Add metadata
    const encodedSignature = encodeSignature({
        threshold: TRANSACTION_SIGNATURE_THRESHOLD,
        signers: [
            {
                weight: SIGNATURE_WEIGHT,
                signature: signedDigest,
            },
        ],
    });
    // Encode the transaction;
    const walletInterface = new ethers.utils.Interface(walletContracts.mainModule.abi);
    return walletInterface.encodeFunctionData(walletInterface.getFunction('execute'), [
        normalisedMetaTransactions,
        nonce,
        encodedSignature,
    ]);
};
const decodeRelayerTypedDataSignature = (relayerSignature) => {
    const signatureWithThreshold = `0000${relayerSignature}`;
    return decodeSignature(signatureWithThreshold);
};
const getSignedTypedData = async (typedData, relayerSignature, chainId, walletAddress, signer) => {
    // Ethers auto-generates the EIP712Domain type in the TypedDataEncoder, and so it needs to be removed
    const types = { ...typedData.types };
    // @ts-ignore
    delete types.EIP712Domain;
    // eslint-disable-next-line no-underscore-dangle
    const digest = ethers.utils._TypedDataEncoder.hash(typedData.domain, types, typedData.message);
    const completePayload = encodeMessageSubDigest(chainId, walletAddress, digest);
    const hash = ethers.utils.keccak256(completePayload);
    // Sign the digest
    const hashArray = ethers.utils.arrayify(hash);
    const ethsigNoType = await signer.signMessage(hashArray);
    const signedDigest = `${ethsigNoType}${ETH_SIGN_FLAG}`;
    const { signers } = decodeRelayerTypedDataSignature(relayerSignature);
    return encodeSignature({
        threshold: EIP712_SIGNATURE_THRESHOLD,
        signers: [
            ...signers,
            {
                weight: SIGNATURE_WEIGHT,
                signature: signedDigest,
            },
        ],
    });
};
const getEip155ChainId = (chainId) => `eip155:${chainId}`;

class RelayerClient {
    config;
    jsonRpcProvider;
    user;
    constructor({ config, jsonRpcProvider, user }) {
        this.config = config;
        this.jsonRpcProvider = jsonRpcProvider;
        this.user = user;
    }
    async postToRelayer(request) {
        const body = {
            id: 1,
            jsonrpc: '2.0',
            ...request,
        };
        const response = await fetch(`${this.config.relayerUrl}/v1/transactions`, {
            method: 'POST',
            headers: {
                Authorization: `Bearer ${this.user.accessToken}`,
                'Content-Type': 'application/json',
            },
            body: JSON.stringify(body),
        });
        const jsonResponse = await response.json();
        if (jsonResponse.error) {
            throw jsonResponse.error;
        }
        return jsonResponse;
    }
    async ethSendTransaction(to, data) {
        const { chainId } = await this.jsonRpcProvider.ready;
        const payload = {
            method: 'eth_sendTransaction',
            params: [{
                    to,
                    data,
                    chainId: getEip155ChainId(chainId),
                }],
        };
        const { result } = await this.postToRelayer(payload);
        return result;
    }
    async imGetTransactionByHash(hash) {
        const payload = {
            method: 'im_getTransactionByHash',
            params: [hash],
        };
        const { result } = await this.postToRelayer(payload);
        return result;
    }
    async imGetFeeOptions(userAddress, data) {
        const { chainId } = await this.jsonRpcProvider.ready;
        const payload = {
            method: 'im_getFeeOptions',
            params: [{
                    userAddress,
                    data,
                    chainId: getEip155ChainId(chainId),
                }],
        };
        const { result } = await this.postToRelayer(payload);
        return result;
    }
    async imSignTypedData(address, eip712Payload) {
        const { chainId } = await this.jsonRpcProvider.ready;
        const payload = {
            method: 'im_signTypedData',
            params: [{
                    address,
                    eip712Payload,
                    chainId: getEip155ChainId(chainId),
                }],
        };
        const { result } = await this.postToRelayer(payload);
        return result;
    }
}

const MESSAGE_TO_SIGN = 'Only sign this message from Immutable Passport';
async function registerZkEvmUser({ authManager, config, magicProvider, multiRollupApiClients, accessToken, }) {
    const web3Provider = new Web3Provider(magicProvider);
    const ethSigner = web3Provider.getSigner();
    const ethereumAddress = await ethSigner.getAddress();
    const ethereumSignature = await signRaw(MESSAGE_TO_SIGN, ethSigner);
    const headers = { Authorization: `Bearer ${accessToken}` };
    try {
        await multiRollupApiClients.passportApi.createCounterfactualAddress({
            createCounterfactualAddressRequest: {
                ethereumAddress,
                ethereumSignature,
            },
        }, { headers });
    }
    catch (error) {
        throw new JsonRpcError(RpcErrorCode.INTERNAL_ERROR, `Failed to create counterfactual address: ${error}`);
    }
    let user;
    if (config.crossSdkBridgeEnabled) {
        const credentials = authManager.checkStoredDeviceFlowCredentials();
        if (!credentials || !credentials.refresh_token) {
            throw new JsonRpcError(RpcErrorCode.INTERNAL_ERROR, 'Cross SDK bridge: Failed to refresh user details');
        }
        user = await authManager.refreshToken(credentials.refresh_token);
    }
    else {
        user = await authManager.loginSilent();
    }
    if (!user?.zkEvm) {
        throw new JsonRpcError(RpcErrorCode.INTERNAL_ERROR, 'Failed to refresh user details');
    }
    return user;
}

const loginZkEvmUser = async ({ authManager, config, magicAdapter, multiRollupApiClients, }) => {
    const user = await authManager.getUser() || await authManager.getUserDeviceFlow() || await authManager.login();
    if (!user.idToken) {
        throw new Error('User is missing idToken');
    }
    const magicProvider = await magicAdapter.login(user.idToken, config.network);
    if (!user.zkEvm) {
        // Generate counterfactual address and retrieve updated Auth0 user
        const userZkevm = await registerZkEvmUser({
            authManager,
            config,
            magicProvider,
            multiRollupApiClients,
            accessToken: user.accessToken,
        });
        return {
            user: userZkevm,
            magicProvider,
        };
    }
    return {
        user: user,
        magicProvider,
    };
};

const MAX_TRANSACTION_HASH_RETRIEVAL_RETRIES = 30;
const TRANSACTION_HASH_RETRIEVAL_WAIT = 1000;
const sendTransaction = ({ params, magicProvider, jsonRpcProvider, relayerClient, guardianClient, user, }) => guardianClient
    .withConfirmationScreen({ width: 480, height: 520 })(async () => {
    const transactionRequest = params[0];
    if (!transactionRequest.to) {
        throw new JsonRpcError(RpcErrorCode.INVALID_PARAMS, 'eth_sendTransaction requires a "to" field');
    }
    const { chainId } = await jsonRpcProvider.ready;
    const chainIdBigNumber = BigNumber$1.from(chainId);
    const magicWeb3Provider = new Web3Provider(magicProvider);
    const signer = magicWeb3Provider.getSigner();
    const nonce = await getNonce(jsonRpcProvider, user.zkEvm.ethAddress);
    const metaTransaction = {
        to: transactionRequest.to,
        data: transactionRequest.data,
        nonce,
        value: transactionRequest.value,
        revertOnError: true,
    };
    // NOTE: We sign the transaction before getting the fee options because
    // accurate estimation of a transaction gas cost is only possible if the smart
    // wallet contract can actually execute it (in a simulated environment) - and
    // it can only execute signed transactions.
    const signedTransaction = await getSignedMetaTransactions([metaTransaction], nonce, chainIdBigNumber, user.zkEvm.ethAddress, signer);
    // TODO: ID-698 Add support for non-native gas payments (e.g ERC20, feeTransaction initialisation must change)
    // NOTE: "Fee Options" represent the multiple ways we could pay for the gas
    // used in this transaction. Each fee option has a "recipientAddress" we
    // should transfer the payment to, an amount and a currency. We choose one
    // option and build a transaction that sends the expected currency amount for
    // that option to the specified address.
    const feeOptions = await relayerClient.imGetFeeOptions(user.zkEvm.ethAddress, signedTransaction);
    const imxFeeOption = feeOptions.find((feeOption) => feeOption.tokenSymbol === 'IMX');
    if (!imxFeeOption) {
        throw new Error('Failed to retrieve fees for IMX token');
    }
    const feeMetaTransaction = {
        nonce,
        to: imxFeeOption.recipientAddress,
        value: imxFeeOption.tokenPrice,
        revertOnError: true,
    };
    await guardianClient.validateEVMTransaction({
        chainId: getEip155ChainId(chainId),
        nonce: convertBigNumberishToString(nonce),
        user,
        metaTransactions: [metaTransaction, feeMetaTransaction],
    });
    // NOTE: We sign again because we now are adding the fee transaction, so the
    // whole payload is different and needs a new signature.
    const signedTransactions = await getSignedMetaTransactions([metaTransaction, feeMetaTransaction], nonce, chainIdBigNumber, user.zkEvm.ethAddress, signer);
    const relayerId = await relayerClient.ethSendTransaction(user.zkEvm.ethAddress, signedTransactions);
    const retrieveRelayerTransaction = async () => {
        const tx = await relayerClient.imGetTransactionByHash(relayerId);
        // NOTE: The transaction hash is only available from the Relayer once the
        // transaction is actually submitted onchain. Hence we need to poll the
        // Relayer get transaction endpoint until the status transitions to one that
        // has the hash available.
        if (tx.status === RelayerTransactionStatus.PENDING) {
            throw new Error();
        }
        return tx;
    };
    const relayerTransaction = await retryWithDelay(retrieveRelayerTransaction, {
        retries: MAX_TRANSACTION_HASH_RETRIEVAL_RETRIES,
        interval: TRANSACTION_HASH_RETRIEVAL_WAIT,
        finalErr: new JsonRpcError(RpcErrorCode.RPC_SERVER_ERROR, 'transaction hash not generated in time'),
    });
    if (![
        RelayerTransactionStatus.SUBMITTED,
        RelayerTransactionStatus.SUCCESSFUL,
    ].includes(relayerTransaction.status)) {
        let errorMessage = `Transaction failed to submit with status ${relayerTransaction.status}.`;
        if (relayerTransaction.statusMessage) {
            errorMessage += ` Error message: ${relayerTransaction.statusMessage}`;
        }
        throw new JsonRpcError(RpcErrorCode.RPC_SERVER_ERROR, errorMessage);
    }
    return relayerTransaction.hash;
});

const REQUIRED_TYPED_DATA_PROPERTIES = ['types', 'domain', 'primaryType', 'message'];
const isValidTypedDataPayload = (typedData) => (REQUIRED_TYPED_DATA_PROPERTIES.every((key) => key in typedData));
const transformTypedData = (typedData, chainId) => {
    let transformedTypedData;
    if (typeof typedData === 'string') {
        try {
            transformedTypedData = JSON.parse(typedData);
        }
        catch (err) {
            throw new JsonRpcError(RpcErrorCode.INVALID_PARAMS, `Failed to parse typed data JSON: ${err}`);
        }
    }
    else if (typeof typedData === 'object') {
        transformedTypedData = typedData;
    }
    else {
        throw new JsonRpcError(RpcErrorCode.INVALID_PARAMS, `Invalid typed data argument: ${typedData}`);
    }
    if (!isValidTypedDataPayload(transformedTypedData)) {
        throw new JsonRpcError(RpcErrorCode.INVALID_PARAMS, `Invalid typed data argument. The following properties are required: ${REQUIRED_TYPED_DATA_PROPERTIES.join(', ')}`);
    }
    const providedChainId = transformedTypedData.domain?.chainId;
    if (providedChainId) {
        // domain.chainId (if defined) can be a number, string, or hex value, but the relayer & guardian only accept a number.
        if (typeof providedChainId === 'string') {
            if (providedChainId.startsWith('0x')) {
                transformedTypedData.domain.chainId = parseInt(providedChainId, 16);
            }
            else {
                transformedTypedData.domain.chainId = parseInt(providedChainId, 10);
            }
        }
        if (transformedTypedData.domain.chainId !== chainId) {
            throw new JsonRpcError(RpcErrorCode.INVALID_PARAMS, `Invalid chainId, expected ${chainId}`);
        }
    }
    return transformedTypedData;
};
const signTypedDataV4 = async ({ params, method, magicProvider, jsonRpcProvider, relayerClient, guardianClient, user, }) => guardianClient
    .withConfirmationScreen({ width: 480, height: 730 })(async () => {
    const fromAddress = params[0];
    const typedDataParam = params[1];
    if (!fromAddress || !typedDataParam) {
        throw new JsonRpcError(RpcErrorCode.INVALID_PARAMS, `${method} requires an address and a typed data JSON`);
    }
    const { chainId } = await jsonRpcProvider.ready;
    const typedData = transformTypedData(typedDataParam, chainId);
    await guardianClient.validateMessage({ chainID: String(chainId), payload: typedData, user });
    const relayerSignature = await relayerClient.imSignTypedData(fromAddress, typedData);
    const magicWeb3Provider = new Web3Provider(magicProvider);
    const signer = magicWeb3Provider.getSigner();
    return getSignedTypedData(typedData, relayerSignature, BigNumber$1.from(chainId), fromAddress, signer);
});

class ZkEvmProvider {
    authManager;
    config;
    confirmationScreen;
    magicAdapter;
    multiRollupApiClients;
    jsonRpcProvider; // Used for read
    eventEmitter;
    guardianClient;
    relayerClient;
    magicProvider; // Used for signing
    user;
    isPassport = true;
    constructor({ authManager, magicAdapter, config, confirmationScreen, multiRollupApiClients, passportEventEmitter, }) {
        this.authManager = authManager;
        this.magicAdapter = magicAdapter;
        this.config = config;
        this.confirmationScreen = confirmationScreen;
        this.jsonRpcProvider = new JsonRpcProvider(this.config.zkEvmRpcUrl);
        this.multiRollupApiClients = multiRollupApiClients;
        this.eventEmitter = new TypedEventEmitter();
        passportEventEmitter.on(PassportEvents.LOGGED_OUT, this.handleLogout);
    }
    handleLogout = () => {
        const shouldEmitAccountsChanged = this.isLoggedIn();
        this.magicProvider = undefined;
        this.user = undefined;
        this.relayerClient = undefined;
        this.guardianClient = undefined;
        if (shouldEmitAccountsChanged) {
            this.eventEmitter.emit(ProviderEvent.ACCOUNTS_CHANGED, []);
        }
    };
    isLoggedIn() {
        return this.magicProvider !== undefined
            && this.user !== undefined
            && this.relayerClient !== undefined
            && this.guardianClient !== undefined;
    }
    async performRequest(request) {
        switch (request.method) {
            case 'eth_requestAccounts': {
                if (this.isLoggedIn()) {
                    return [this.user.zkEvm.ethAddress];
                }
                const { magicProvider, user } = await loginZkEvmUser({
                    authManager: this.authManager,
                    config: this.config,
                    magicAdapter: this.magicAdapter,
                    multiRollupApiClients: this.multiRollupApiClients,
                });
                this.user = user;
                this.magicProvider = magicProvider;
                this.relayerClient = new RelayerClient({
                    config: this.config,
                    jsonRpcProvider: this.jsonRpcProvider,
                    user: this.user,
                });
                this.guardianClient = new GuardianClient({
                    accessToken: this.user.accessToken,
                    confirmationScreen: this.confirmationScreen,
                    imxEtherAddress: this.user.zkEvm.ethAddress,
                    config: this.config,
                });
                this.eventEmitter.emit(ProviderEvent.ACCOUNTS_CHANGED, [this.user.zkEvm.ethAddress]);
                return [this.user.zkEvm.ethAddress];
            }
            case 'eth_sendTransaction': {
                if (!this.isLoggedIn()) {
                    throw new JsonRpcError(ProviderErrorCode.UNAUTHORIZED, 'Unauthorised - call eth_requestAccounts first');
                }
                return sendTransaction({
                    params: request.params || [],
                    magicProvider: this.magicProvider,
                    guardianClient: this.guardianClient,
                    jsonRpcProvider: this.jsonRpcProvider,
                    relayerClient: this.relayerClient,
                    user: this.user,
                });
            }
            case 'eth_accounts': {
                return this.isLoggedIn() ? [this.user.zkEvm.ethAddress] : [];
            }
            case 'eth_signTypedData':
            case 'eth_signTypedData_v4': {
                if (!this.isLoggedIn()) {
                    throw new JsonRpcError(ProviderErrorCode.UNAUTHORIZED, 'Unauthorised - call eth_requestAccounts first');
                }
                return signTypedDataV4({
                    method: request.method,
                    params: request.params || [],
                    magicProvider: this.magicProvider,
                    jsonRpcProvider: this.jsonRpcProvider,
                    relayerClient: this.relayerClient,
                    user: this.user,
                    guardianClient: this.guardianClient,
                });
            }
            // Pass through methods
            case 'eth_gasPrice':
            case 'eth_getBalance':
            case 'eth_getCode':
            case 'eth_getStorageAt':
            case 'eth_estimateGas':
            case 'eth_call':
            case 'eth_blockNumber':
            case 'eth_chainId':
            case 'eth_getBlockByHash':
            case 'eth_getBlockByNumber':
            case 'eth_getTransactionByHash':
            case 'eth_getTransactionReceipt':
            case 'eth_getTransactionCount': {
                return this.jsonRpcProvider.send(request.method, request.params || []);
            }
            default: {
                throw new JsonRpcError(ProviderErrorCode.UNSUPPORTED_METHOD, 'Method not supported');
            }
        }
    }
    async performJsonRpcRequest(request) {
        const { id, jsonrpc } = request;
        try {
            const result = await this.performRequest(request);
            return {
                id,
                jsonrpc,
                result,
            };
        }
        catch (error) {
            let jsonRpcError;
            if (error instanceof JsonRpcError) {
                jsonRpcError = error;
            }
            else if (error instanceof Error) {
                jsonRpcError = new JsonRpcError(RpcErrorCode.INTERNAL_ERROR, error.message);
            }
            else {
                jsonRpcError = new JsonRpcError(RpcErrorCode.INTERNAL_ERROR, 'Internal error');
            }
            return {
                id,
                jsonrpc,
                error: jsonRpcError,
            };
        }
    }
    async request(request) {
        try {
            return this.performRequest(request);
        }
        catch (error) {
            if (error instanceof JsonRpcError) {
                throw error;
            }
            if (error instanceof Error) {
                throw new JsonRpcError(RpcErrorCode.INTERNAL_ERROR, error.message);
            }
            throw new JsonRpcError(RpcErrorCode.INTERNAL_ERROR, 'Internal error');
        }
    }
    sendAsync(request, callback) {
        if (!callback) {
            throw new Error('No callback provided');
        }
        if (Array.isArray(request)) {
            Promise.all(request.map(this.performJsonRpcRequest)).then((result) => {
                callback(null, result);
            }).catch((error) => {
                callback(error, []);
            });
        }
        else {
            this.performJsonRpcRequest(request).then((result) => {
                callback(null, result);
            }).catch((error) => {
                callback(error, null);
            });
        }
    }
    async send(request, callbackOrParams, callback) {
        // Web3 >= 1.0.0-beta.38 calls `send` with method and parameters.
        if (typeof request === 'string') {
            if (typeof callbackOrParams === 'function') {
                return this.sendAsync({
                    method: request,
                    params: [],
                }, callbackOrParams);
            }
            if (callback) {
                return this.sendAsync({
                    method: request,
                    params: Array.isArray(callbackOrParams) ? callbackOrParams : [],
                }, callback);
            }
            return this.request({
                method: request,
                params: Array.isArray(callbackOrParams) ? callbackOrParams : [],
            });
        }
        // Web3 <= 1.0.0-beta.37 uses `send` with a callback for async queries.
        if (typeof callbackOrParams === 'function') {
            return this.sendAsync(request, callbackOrParams);
        }
        if (!Array.isArray(request) && typeof request === 'object') {
            return this.performJsonRpcRequest(request);
        }
        throw new JsonRpcError(RpcErrorCode.INVALID_REQUEST, 'Invalid request');
    }
    on(event, listener) {
        this.eventEmitter.on(event, listener);
    }
    removeListener(event, listener) {
        this.eventEmitter.removeListener(event, listener);
    }
}

class Passport {
    authManager;
    config;
    confirmationScreen;
    immutableXClient;
    magicAdapter;
    multiRollupApiClients;
    passportImxProviderFactory;
    passportEventEmitter;
    constructor(passportModuleConfiguration) {
        this.config = new PassportConfiguration(passportModuleConfiguration);
        this.authManager = new AuthManager(this.config);
        this.magicAdapter = new MagicAdapter(this.config);
        this.confirmationScreen = new ConfirmationScreen(this.config);
        this.immutableXClient = passportModuleConfiguration.overrides?.immutableXClient
            || new ImmutableXClient({
                baseConfig: passportModuleConfiguration.baseConfig,
            });
        this.multiRollupApiClients = new MultiRollupApiClients(this.config.multiRollupConfig);
        this.passportEventEmitter = new TypedEventEmitter();
        this.passportImxProviderFactory = new PassportImxProviderFactory({
            authManager: this.authManager,
            config: this.config,
            confirmationScreen: this.confirmationScreen,
            immutableXClient: this.immutableXClient,
            magicAdapter: this.magicAdapter,
            passportEventEmitter: this.passportEventEmitter,
        });
    }
    async connectImxSilent() {
        return this.passportImxProviderFactory.getProviderSilent();
    }
    async connectImx() {
        return this.passportImxProviderFactory.getProvider();
    }
    async loginWithDeviceFlow() {
        return this.authManager.loginWithDeviceFlow();
    }
    async connectImxDeviceFlow(deviceCode, interval, timeoutMs) {
        return this.passportImxProviderFactory.getProviderWithDeviceFlow(deviceCode, interval, timeoutMs);
    }
    getPKCEAuthorizationUrl() {
        return this.authManager.getPKCEAuthorizationUrl();
    }
    async connectImxPKCEFlow(authorizationCode, state) {
        return this.passportImxProviderFactory.getProviderWithPKCEFlow(authorizationCode, state);
    }
    /**
     * @returns {boolean} the stored device flow credentials if they exist
     */
    checkStoredDeviceFlowCredentials() {
        return this.authManager.checkStoredDeviceFlowCredentials();
    }
    async connectImxWithCredentials(tokenResponse) {
        return this.passportImxProviderFactory.getProviderWithCredentials(tokenResponse);
    }
    connectEvm() {
        if (this.config.network === Networks.PRODUCTION) {
            throw new Error('EVM is not supported on production network');
        }
        return new ZkEvmProvider({
            passportEventEmitter: this.passportEventEmitter,
            authManager: this.authManager,
            magicAdapter: this.magicAdapter,
            config: this.config,
            confirmationScreen: this.confirmationScreen,
            multiRollupApiClients: this.multiRollupApiClients,
        });
    }
    async loginCallback() {
        return this.authManager.loginCallback();
    }
    async logout() {
        await this.authManager.logout();
        await this.confirmationScreen.logout();
        // Code after this point is only executed if the logout mode is silent
        await this.magicAdapter.logout();
        this.passportEventEmitter.emit(PassportEvents.LOGGED_OUT);
    }
    /**
     * This method should only be called from the logout redirect uri
     * when logout mode is 'silent'.
     */
    async logoutSilentCallback(url) {
        return this.authManager.logoutSilentCallback(url);
    }
    async logoutDeviceFlow() {
        return this.authManager.logoutDeviceFlow();
    }
    async getUserInfo() {
        const user = await this.authManager.getUser();
        return user?.profile;
    }
    async getUserInfoDeviceFlow() {
        const user = await this.authManager.getUserDeviceFlow();
        return user?.profile;
    }
    async getIdToken() {
        const user = await this.authManager.getUser();
        return user?.idToken;
    }
    async getAccessToken() {
        const user = await this.authManager.getUser();
        return user?.accessToken;
    }
    async getLinkedAddresses() {
        const user = await this.authManager.getUser();
        if (!user?.profile.sub) {
            return [];
        }
        const headers = { Authorization: `Bearer ${user.accessToken}` };
        const linkedAddressesResult = await this.multiRollupApiClients.passportApi.getLinkedAddresses({
            userId: user?.profile.sub,
        }, { headers });
        return linkedAddressesResult.data.linkedAddresses;
    }
}

var passport = /*#__PURE__*/Object.freeze({
    __proto__: null,
    JsonRpcError: JsonRpcError,
    get Networks () { return Networks; },
    Passport: Passport,
    PassportError: PassportError,
    get ProviderErrorCode () { return ProviderErrorCode; },
    get ProviderEvent () { return ProviderEvent; },
    get RpcErrorCode () { return RpcErrorCode; }
});

class BaseHttpRequest {
    config;
    constructor(config) {
        this.config = config;
    }
}

class ApiError extends Error {
    url;
    status;
    statusText;
    body;
    request;
    constructor(request, response, message) {
        super(message);
        this.name = 'ApiError';
        this.url = response.url;
        this.status = response.status;
        this.statusText = response.statusText;
        this.body = response.body;
        this.request = request;
    }
}

/* istanbul ignore file */
/* tslint:disable */
/* eslint-disable */
class CancelError extends Error {
    constructor(message) {
        super(message);
        this.name = 'CancelError';
    }
    get isCancelled() {
        return true;
    }
}
class CancelablePromise {
    [Symbol.toStringTag];
    _isResolved;
    _isRejected;
    _isCancelled;
    _cancelHandlers;
    _promise;
    _resolve;
    _reject;
    constructor(executor) {
        this._isResolved = false;
        this._isRejected = false;
        this._isCancelled = false;
        this._cancelHandlers = [];
        this._promise = new Promise((resolve, reject) => {
            this._resolve = resolve;
            this._reject = reject;
            const onResolve = (value) => {
                if (this._isResolved || this._isRejected || this._isCancelled) {
                    return;
                }
                this._isResolved = true;
                this._resolve?.(value);
            };
            const onReject = (reason) => {
                if (this._isResolved || this._isRejected || this._isCancelled) {
                    return;
                }
                this._isRejected = true;
                this._reject?.(reason);
            };
            const onCancel = (cancelHandler) => {
                if (this._isResolved || this._isRejected || this._isCancelled) {
                    return;
                }
                this._cancelHandlers.push(cancelHandler);
            };
            Object.defineProperty(onCancel, 'isResolved', {
                get: () => this._isResolved,
            });
            Object.defineProperty(onCancel, 'isRejected', {
                get: () => this._isRejected,
            });
            Object.defineProperty(onCancel, 'isCancelled', {
                get: () => this._isCancelled,
            });
            return executor(onResolve, onReject, onCancel);
        });
    }
    then(onFulfilled, onRejected) {
        return this._promise.then(onFulfilled, onRejected);
    }
    catch(onRejected) {
        return this._promise.catch(onRejected);
    }
    finally(onFinally) {
        return this._promise.finally(onFinally);
    }
    cancel() {
        if (this._isResolved || this._isRejected || this._isCancelled) {
            return;
        }
        this._isCancelled = true;
        if (this._cancelHandlers.length) {
            try {
                for (const cancelHandler of this._cancelHandlers) {
                    cancelHandler();
                }
            }
            catch (error) {
                console.warn('Cancellation threw an error', error);
                return;
            }
        }
        this._cancelHandlers.length = 0;
        this._reject?.(new CancelError('Request aborted'));
    }
    get isCancelled() {
        return this._isCancelled;
    }
}

/* istanbul ignore file */
/* tslint:disable */
/* eslint-disable */
const isDefined = (value) => {
    return value !== undefined && value !== null;
};
const isString = (value) => {
    return typeof value === 'string';
};
const isStringWithValue = (value) => {
    return isString(value) && value !== '';
};
const isBlob = (value) => {
    return (typeof value === 'object' &&
        typeof value.type === 'string' &&
        typeof value.stream === 'function' &&
        typeof value.arrayBuffer === 'function' &&
        typeof value.constructor === 'function' &&
        typeof value.constructor.name === 'string' &&
        /^(Blob|File)$/.test(value.constructor.name) &&
        /^(Blob|File)$/.test(value[Symbol.toStringTag]));
};
const isFormData = (value) => {
    return value instanceof FormData$2;
};
const isSuccess = (status) => {
    return status >= 200 && status < 300;
};
const base64 = (str) => {
    try {
        return btoa(str);
    }
    catch (err) {
        // @ts-ignore
        return Buffer.from(str).toString('base64');
    }
};
const getQueryString = (params) => {
    const qs = [];
    const append = (key, value) => {
        qs.push(`${encodeURIComponent(key)}=${encodeURIComponent(String(value))}`);
    };
    const process = (key, value) => {
        if (isDefined(value)) {
            if (Array.isArray(value)) {
                value.forEach(v => {
                    process(key, v);
                });
            }
            else if (typeof value === 'object') {
                Object.entries(value).forEach(([k, v]) => {
                    process(`${key}[${k}]`, v);
                });
            }
            else {
                append(key, value);
            }
        }
    };
    Object.entries(params).forEach(([key, value]) => {
        process(key, value);
    });
    if (qs.length > 0) {
        return `?${qs.join('&')}`;
    }
    return '';
};
const getUrl = (config, options) => {
    const encoder = config.ENCODE_PATH || encodeURI;
    const path = options.url
        .replace('{api-version}', config.VERSION)
        .replace(/{(.*?)}/g, (substring, group) => {
        if (options.path?.hasOwnProperty(group)) {
            return encoder(String(options.path[group]));
        }
        return substring;
    });
    const url = `${config.BASE}${path}`;
    if (options.query) {
        return `${url}${getQueryString(options.query)}`;
    }
    return url;
};
const getFormData = (options) => {
    if (options.formData) {
        const formData = new FormData$2();
        const process = (key, value) => {
            if (isString(value) || isBlob(value)) {
                formData.append(key, value);
            }
            else {
                formData.append(key, JSON.stringify(value));
            }
        };
        Object.entries(options.formData)
            .filter(([_, value]) => isDefined(value))
            .forEach(([key, value]) => {
            if (Array.isArray(value)) {
                value.forEach(v => process(key, v));
            }
            else {
                process(key, value);
            }
        });
        return formData;
    }
    return undefined;
};
const resolve = async (options, resolver) => {
    if (typeof resolver === 'function') {
        return resolver(options);
    }
    return resolver;
};
const getHeaders = async (config, options, formData) => {
    const token = await resolve(options, config.TOKEN);
    const username = await resolve(options, config.USERNAME);
    const password = await resolve(options, config.PASSWORD);
    const additionalHeaders = await resolve(options, config.HEADERS);
    const formHeaders = typeof formData?.getHeaders === 'function' && formData?.getHeaders() || {};
    const headers = Object.entries({
        Accept: 'application/json',
        ...additionalHeaders,
        ...options.headers,
        ...formHeaders,
    })
        .filter(([_, value]) => isDefined(value))
        .reduce((headers, [key, value]) => ({
        ...headers,
        [key]: String(value),
    }), {});
    if (isStringWithValue(token)) {
        headers['Authorization'] = `Bearer ${token}`;
    }
    if (isStringWithValue(username) && isStringWithValue(password)) {
        const credentials = base64(`${username}:${password}`);
        headers['Authorization'] = `Basic ${credentials}`;
    }
    if (options.body) {
        if (options.mediaType) {
            headers['Content-Type'] = options.mediaType;
        }
        else if (isBlob(options.body)) {
            headers['Content-Type'] = options.body.type || 'application/octet-stream';
        }
        else if (isString(options.body)) {
            headers['Content-Type'] = 'text/plain';
        }
        else if (!isFormData(options.body)) {
            headers['Content-Type'] = 'application/json';
        }
    }
    return headers;
};
const getRequestBody = (options) => {
    if (options.body) {
        return options.body;
    }
    return undefined;
};
const sendRequest = async (config, options, url, body, formData, headers, onCancel) => {
    const source = globalAxios$1.CancelToken.source();
    const requestConfig = {
        url,
        headers,
        data: body ?? formData,
        method: options.method,
        withCredentials: config.WITH_CREDENTIALS,
        cancelToken: source.token,
    };
    onCancel(() => source.cancel('The user aborted a request.'));
    try {
        return await globalAxios$1.request(requestConfig);
    }
    catch (error) {
        const axiosError = error;
        if (axiosError.response) {
            return axiosError.response;
        }
        throw error;
    }
};
const getResponseHeader = (response, responseHeader) => {
    if (responseHeader) {
        const content = response.headers[responseHeader];
        if (isString(content)) {
            return content;
        }
    }
    return undefined;
};
const getResponseBody = (response) => {
    if (response.status !== 204) {
        return response.data;
    }
    return undefined;
};
const catchErrorCodes = (options, result) => {
    const errors = {
        400: 'Bad Request',
        401: 'Unauthorized',
        403: 'Forbidden',
        404: 'Not Found',
        500: 'Internal Server Error',
        502: 'Bad Gateway',
        503: 'Service Unavailable',
        ...options.errors,
    };
    const error = errors[result.status];
    if (error) {
        throw new ApiError(options, result, error);
    }
    if (!result.ok) {
        throw new ApiError(options, result, 'Generic Error');
    }
};
/**
 * Request method
 * @param config The OpenAPI configuration object
 * @param options The request options from the service
 * @returns CancelablePromise<T>
 * @throws ApiError
 */
const request = (config, options) => {
    return new CancelablePromise(async (resolve, reject, onCancel) => {
        try {
            const url = getUrl(config, options);
            const formData = getFormData(options);
            const body = getRequestBody(options);
            const headers = await getHeaders(config, options, formData);
            if (!onCancel.isCancelled) {
                const response = await sendRequest(config, options, url, body, formData, headers, onCancel);
                const responseBody = getResponseBody(response);
                const responseHeader = getResponseHeader(response, options.responseHeader);
                const result = {
                    url,
                    ok: isSuccess(response.status),
                    status: response.status,
                    statusText: response.statusText,
                    body: responseHeader ?? responseBody,
                };
                catchErrorCodes(options, result);
                resolve(result.body);
            }
        }
        catch (error) {
            reject(error);
        }
    });
};

class AxiosHttpRequest extends BaseHttpRequest {
    constructor(config) {
        super(config);
    }
    /**
     * Request method
     * @param options The request options from the service
     * @returns CancelablePromise<T>
     * @throws ApiError
     */
    request(options) {
        return request(this.config, options);
    }
}

class OrdersService {
    httpRequest;
    constructor(httpRequest) {
        this.httpRequest = httpRequest;
    }
    /**
     * List all listings
     * List all listings
     * @returns ListListingsResult OK response.
     * @throws ApiError
     */
    listListings({ chainName, status, sellItemContractAddress, buyItemContractAddress, sellItemTokenId, pageSize, sortBy, sortDirection, pageCursor, }) {
        return this.httpRequest.request({
            method: 'GET',
            url: '/v1/chains/{chain_name}/orders/listings',
            path: {
                'chain_name': chainName,
            },
            query: {
                'status': status,
                'sell_item_contract_address': sellItemContractAddress,
                'buy_item_contract_address': buyItemContractAddress,
                'sell_item_token_id': sellItemTokenId,
                'page_size': pageSize,
                'sort_by': sortBy,
                'sort_direction': sortDirection,
                'page_cursor': pageCursor,
            },
            errors: {
                400: `Bad Request (400)`,
                404: `The specified resource was not found (404)`,
                500: `Internal Server Error (500)`,
            },
        });
    }
    /**
     * Create a listing
     * Create a listing
     * @returns ListingResult Created response.
     * @throws ApiError
     */
    createListing({ chainName, requestBody, }) {
        return this.httpRequest.request({
            method: 'POST',
            url: '/v1/chains/{chain_name}/orders/listings',
            path: {
                'chain_name': chainName,
            },
            body: requestBody,
            mediaType: 'application/json',
            errors: {
                400: `Bad Request (400)`,
                404: `The specified resource was not found (404)`,
                500: `Internal Server Error (500)`,
            },
        });
    }
    /**
     * Get a single listing by ID
     * Get a single listing by ID
     * @returns ListingResult OK response.
     * @throws ApiError
     */
    getListing({ chainName, listingId, }) {
        return this.httpRequest.request({
            method: 'GET',
            url: '/v1/chains/{chain_name}/orders/listings/{listing_id}',
            path: {
                'chain_name': chainName,
                'listing_id': listingId,
            },
            errors: {
                400: `Bad Request (400)`,
                404: `The specified resource was not found (404)`,
                500: `Internal Server Error (500)`,
            },
        });
    }
    /**
     * Retrieve fulfillment data for orders
     * Retrieve signed fulfillment data based on the list of order IDs and corresponding fees.
     * @returns any Successful response
     * @throws ApiError
     */
    fulfillmentData({ chainName, requestBody, }) {
        return this.httpRequest.request({
            method: 'POST',
            url: '/v1/chains/{chain_name}/orders/fulfillment-data',
            path: {
                'chain_name': chainName,
            },
            body: requestBody,
            mediaType: 'application/json',
            errors: {
                400: `Bad Request (400)`,
                404: `The specified resource was not found (404)`,
                500: `Internal Server Error (500)`,
            },
        });
    }
    /**
     * List all trades
     * List all trades
     * @returns ListTradeResult OK response.
     * @throws ApiError
     */
    listTrades({ chainName, accountAddress, pageSize, sortBy, sortDirection, pageCursor, }) {
        return this.httpRequest.request({
            method: 'GET',
            url: '/v1/chains/{chain_name}/trades',
            path: {
                'chain_name': chainName,
            },
            query: {
                'account_address': accountAddress,
                'page_size': pageSize,
                'sort_by': sortBy,
                'sort_direction': sortDirection,
                'page_cursor': pageCursor,
            },
            errors: {
                400: `Bad Request (400)`,
                404: `The specified resource was not found (404)`,
                500: `Internal Server Error (500)`,
            },
        });
    }
    /**
     * Get a single trade by ID
     * Get a single trade by ID
     * @returns TradeResult OK response.
     * @throws ApiError
     */
    getTrade({ chainName, tradeId, }) {
        return this.httpRequest.request({
            method: 'GET',
            url: '/v1/chains/{chain_name}/trades/{trade_id}',
            path: {
                'chain_name': chainName,
                'trade_id': tradeId,
            },
            errors: {
                400: `Bad Request (400)`,
                404: `The specified resource was not found (404)`,
                500: `Internal Server Error (500)`,
            },
        });
    }
}

class OrderBookClient {
    orders;
    request;
    constructor(config, HttpRequest = AxiosHttpRequest) {
        this.request = new HttpRequest({
            BASE: config?.BASE ?? 'https://api.sandbox.immutable.com',
            VERSION: config?.VERSION ?? '1.0.0',
            WITH_CREDENTIALS: config?.WITH_CREDENTIALS ?? false,
            CREDENTIALS: config?.CREDENTIALS ?? 'include',
            TOKEN: config?.TOKEN,
            USERNAME: config?.USERNAME,
            PASSWORD: config?.PASSWORD,
            HEADERS: config?.HEADERS,
            ENCODE_PATH: config?.ENCODE_PATH,
        });
        this.orders = new OrdersService(this.request);
    }
}

/* istanbul ignore file */
/* tslint:disable */
/* eslint-disable */
var Fee;
(function (Fee) {
    (function (fee_type) {
        fee_type["ROYALTY"] = "ROYALTY";
        fee_type["MAKER_ECOSYSTEM"] = "MAKER_ECOSYSTEM";
        fee_type["TAKER_ECOSYSTEM"] = "TAKER_ECOSYSTEM";
        fee_type["PROTOCOL"] = "PROTOCOL";
    })(Fee.fee_type || (Fee.fee_type = {}));
})(Fee || (Fee = {}));

/* istanbul ignore file */
/* tslint:disable */
/* eslint-disable */
/**
 * The Order status
 */
var OrderStatus;
(function (OrderStatus) {
    OrderStatus["PENDING"] = "PENDING";
    OrderStatus["ACTIVE"] = "ACTIVE";
    OrderStatus["INACTIVE"] = "INACTIVE";
    OrderStatus["FILLED"] = "FILLED";
    OrderStatus["CANCELLED"] = "CANCELLED";
    OrderStatus["EXPIRED"] = "EXPIRED";
})(OrderStatus || (OrderStatus = {}));

/* istanbul ignore file */
/* tslint:disable */
/* eslint-disable */
var ProtocolData;
(function (ProtocolData) {
    (function (order_type) {
        order_type["FULL_RESTRICTED"] = "FULL_RESTRICTED";
    })(ProtocolData.order_type || (ProtocolData.order_type = {}));
})(ProtocolData || (ProtocolData = {}));

var FeeType;
(function (FeeType) {
    FeeType["MAKER_ECOSYSTEM"] = "MAKER_ECOSYSTEM";
    FeeType["TAKER_ECOSYSTEM"] = "TAKER_ECOSYSTEM";
    FeeType["PROTOCOL"] = "PROTOCOL";
    FeeType["ROYALTY"] = "ROYALTY";
})(FeeType || (FeeType = {}));
var TransactionPurpose;
(function (TransactionPurpose) {
    TransactionPurpose["APPROVAL"] = "APPROVAL";
    TransactionPurpose["FULFILL_ORDER"] = "FULFILL_ORDER";
})(TransactionPurpose || (TransactionPurpose = {}));
var SignablePurpose;
(function (SignablePurpose) {
    SignablePurpose["CREATE_LISTING"] = "CREATE_LISTING";
})(SignablePurpose || (SignablePurpose = {}));
var ActionType;
(function (ActionType) {
    ActionType["TRANSACTION"] = "TRANSACTION";
    ActionType["SIGNABLE"] = "SIGNABLE";
})(ActionType || (ActionType = {}));

function mapFromOpenApiOrder(order) {
    const buyItems = order.buy.map((item) => {
        if (item.item_type === 'ERC20') {
            return {
                type: 'ERC20',
                contractAddress: item.contract_address,
                amount: item.start_amount,
            };
        }
        if (item.item_type === 'NATIVE') {
            return {
                type: 'NATIVE',
                amount: item.start_amount,
            };
        }
        throw new Error('Buy items must be either ERC20 or NATIVE');
    });
    const sellItems = order.sell.map((item) => {
        if (item.item_type === 'ERC721') {
            return {
                type: 'ERC721',
                contractAddress: item.contract_address,
                tokenId: item.token_id,
            };
        }
        throw new Error('Sell items must ERC721');
    });
    return {
        id: order.id,
        accountAddress: order.account_address,
        buy: buyItems,
        sell: sellItems,
        fees: order.fees.map((fee) => ({
            amount: fee.amount,
            recipient: fee.recipient,
            type: fee.fee_type,
        })),
        chain: order.chain,
        createdAt: order.created_at,
        endAt: order.end_at,
        protocolData: {
            counter: order.protocol_data.counter,
            orderType: order.protocol_data.order_type,
            seaportAddress: order.protocol_data.seaport_address,
            seaportVersion: order.protocol_data.seaport_version,
            zoneAddress: order.protocol_data.zone_address,
        },
        salt: order.salt,
        signature: order.signature,
        startAt: order.start_at,
        status: order.status,
        updatedAt: order.updated_at,
    };
}
function mapFromOpenApiTrade(trade) {
    const buyItems = trade.buy.map((item) => {
        if (item.item_type === 'ERC20') {
            return {
                type: 'ERC20',
                contractAddress: item.contract_address,
                amount: item.start_amount,
            };
        }
        if (item.item_type === 'NATIVE') {
            return {
                type: 'NATIVE',
                amount: item.start_amount,
            };
        }
        throw new Error('Buy items must be either ERC20 or NATIVE');
    });
    const sellItems = trade.sell.map((item) => {
        if (item.item_type === 'ERC721') {
            return {
                type: 'ERC721',
                contractAddress: item.contract_address,
                tokenId: item.token_id,
            };
        }
        throw new Error('Sell items must ERC721');
    });
    return {
        id: trade.id,
        orderId: trade.order_id,
        buy: buyItems,
        sell: sellItems,
        buyerFees: trade.buyer_fees.map((fee) => ({
            amount: fee.amount,
            recipient: fee.recipient,
            type: fee.fee_type,
        })),
        chain: trade.chain,
        indexedAt: trade.indexed_at,
        blockchainMetadata: {
            blockNumber: trade.blockchain_metadata.block_number,
            logIndex: trade.blockchain_metadata.log_index,
            transactionHash: trade.blockchain_metadata.transaction_hash,
            transactionIndex: trade.blockchain_metadata.transaction_index,
        },
        buyerAddress: trade.buyer_address,
        makerAddress: trade.maker_address,
        sellerAddress: trade.seller_address,
        takerAddress: trade.taker_address,
    };
}
function mapFromOpenApiPage(page) {
    return {
        nextCursor: page.next_cursor,
        previousCursor: page.previous_cursor,
    };
}

/* eslint-disable */
// TODO: Resolve these from seaport-js.
// There is some bundling issue that is preventing this from working
const SEAPORT_CONTRACT_NAME = 'ImmutableSeaport';
// export const SEAPORT_CONTRACT_VERSION_V1_4 = '1.4';
const SEAPORT_CONTRACT_VERSION_V1_5 = '1.5';
const EIP_712_ORDER_TYPE = {
    OrderComponents: [
        { name: 'offerer', type: 'address' },
        { name: 'zone', type: 'address' },
        { name: 'offer', type: 'OfferItem[]' },
        { name: 'consideration', type: 'ConsiderationItem[]' },
        { name: 'orderType', type: 'uint8' },
        { name: 'startTime', type: 'uint256' },
        { name: 'endTime', type: 'uint256' },
        { name: 'zoneHash', type: 'bytes32' },
        { name: 'salt', type: 'uint256' },
        { name: 'conduitKey', type: 'bytes32' },
        { name: 'counter', type: 'uint256' },
    ],
    OfferItem: [
        { name: 'itemType', type: 'uint8' },
        { name: 'token', type: 'address' },
        { name: 'identifierOrCriteria', type: 'uint256' },
        { name: 'startAmount', type: 'uint256' },
        { name: 'endAmount', type: 'uint256' },
    ],
    ConsiderationItem: [
        { name: 'itemType', type: 'uint8' },
        { name: 'token', type: 'address' },
        { name: 'identifierOrCriteria', type: 'uint256' },
        { name: 'startAmount', type: 'uint256' },
        { name: 'endAmount', type: 'uint256' },
        { name: 'recipient', type: 'address' },
    ],
};
var OrderType;
(function (OrderType) {
    OrderType[OrderType["FULL_OPEN"] = 0] = "FULL_OPEN";
    OrderType[OrderType["PARTIAL_OPEN"] = 1] = "PARTIAL_OPEN";
    OrderType[OrderType["FULL_RESTRICTED"] = 2] = "FULL_RESTRICTED";
    OrderType[OrderType["PARTIAL_RESTRICTED"] = 3] = "PARTIAL_RESTRICTED";
})(OrderType || (OrderType = {}));
var ItemType;
(function (ItemType) {
    ItemType[ItemType["NATIVE"] = 0] = "NATIVE";
    ItemType[ItemType["ERC20"] = 1] = "ERC20";
    ItemType[ItemType["ERC721"] = 2] = "ERC721";
    ItemType[ItemType["ERC1155"] = 3] = "ERC1155";
    ItemType[ItemType["ERC721_WITH_CRITERIA"] = 4] = "ERC721_WITH_CRITERIA";
    ItemType[ItemType["ERC1155_WITH_CRITERIA"] = 5] = "ERC1155_WITH_CRITERIA";
})(ItemType || (ItemType = {}));
var Side;
(function (Side) {
    Side[Side["OFFER"] = 0] = "OFFER";
    Side[Side["CONSIDERATION"] = 1] = "CONSIDERATION";
})(Side || (Side = {}));
var BasicOrderRouteType;
(function (BasicOrderRouteType) {
    BasicOrderRouteType[BasicOrderRouteType["ETH_TO_ERC721"] = 0] = "ETH_TO_ERC721";
    BasicOrderRouteType[BasicOrderRouteType["ETH_TO_ERC1155"] = 1] = "ETH_TO_ERC1155";
    BasicOrderRouteType[BasicOrderRouteType["ERC20_TO_ERC721"] = 2] = "ERC20_TO_ERC721";
    BasicOrderRouteType[BasicOrderRouteType["ERC20_TO_ERC1155"] = 3] = "ERC20_TO_ERC1155";
    BasicOrderRouteType[BasicOrderRouteType["ERC721_TO_ERC20"] = 4] = "ERC721_TO_ERC20";
    BasicOrderRouteType[BasicOrderRouteType["ERC1155_TO_ERC20"] = 5] = "ERC1155_TO_ERC20";
})(BasicOrderRouteType || (BasicOrderRouteType = {}));

function getOrderComponentsFromMessage(orderMessage) {
    const data = JSON.parse(orderMessage);
    const orderComponents = data.message;
    orderComponents.salt = BigNumber$1.from(orderComponents.salt).toHexString();
    return orderComponents;
}

// Add 20% more gas than estimate to prevent out of gas errors
// This can always be overwritten by the user signing the transaction
function prepareTransaction(transactionMethods) {
    return async () => {
        const transaction = await transactionMethods.buildTransaction();
        transaction.gasLimit = await transactionMethods.estimateGas();
        transaction.gasLimit = transaction.gasLimit
            .add(transaction.gasLimit.div(5));
        return transaction;
    };
}

function mapImmutableOrderToSeaportOrderComponents(order, counter, zoneAddress) {
    const considerationItems = order.buy.map((buyItem) => {
        switch (buyItem.item_type) {
            case 'NATIVE':
                return {
                    startAmount: buyItem.start_amount,
                    endAmount: buyItem.start_amount,
                    itemType: ItemType.NATIVE,
                    recipient: order.account_address,
                    token: constants$1.AddressZero,
                    identifierOrCriteria: '0',
                };
            case 'ERC20':
                return {
                    startAmount: buyItem.start_amount,
                    endAmount: buyItem.start_amount,
                    itemType: ItemType.ERC20,
                    recipient: order.account_address,
                    token: buyItem.contract_address || constants$1.AddressZero,
                    identifierOrCriteria: '0',
                };
            default: // ERC721
                return {
                    startAmount: '1',
                    endAmount: '1',
                    itemType: ItemType.ERC721,
                    recipient: order.account_address,
                    token: buyItem.contract_address || constants$1.AddressZero,
                    identifierOrCriteria: '0',
                };
        }
    });
    const fees = order.fees.map((fee) => ({
        amount: fee.amount,
        itemType: order.buy[0].item_type === 'ERC20' ? ItemType.ERC20 : ItemType.NATIVE,
        recipient: fee.recipient,
        token: order.buy[0].item_type === 'ERC20'
            ? order.buy[0].contract_address
            : constants$1.AddressZero,
        identifierOrCriteria: '0',
    }));
    return {
        orderComponents: {
            conduitKey: constants$1.HashZero,
            consideration: [...considerationItems],
            offer: order.sell.map((sellItem) => {
                const erc721Item = sellItem;
                return {
                    startAmount: '1',
                    endAmount: '1',
                    itemType: ItemType.ERC721,
                    token: erc721Item.contract_address,
                    identifierOrCriteria: erc721Item.token_id,
                };
            }),
            counter,
            endTime: Math.round(new Date(order.end_at).getTime() / 1000).toString(),
            startTime: Math.round(new Date(order.start_at).getTime() / 1000).toString(),
            salt: order.salt,
            offerer: order.account_address,
            zone: zoneAddress,
            // this should be the fee exclusive number of items the user signed for
            totalOriginalConsiderationItems: considerationItems.length,
            orderType: OrderType.FULL_RESTRICTED,
            zoneHash: constants$1.HashZero,
        },
        tips: fees,
    };
}

class Seaport {
    seaportLibFactory;
    provider;
    seaportContractAddress;
    zoneContractAddress;
    constructor(seaportLibFactory, provider, seaportContractAddress, zoneContractAddress) {
        this.seaportLibFactory = seaportLibFactory;
        this.provider = provider;
        this.seaportContractAddress = seaportContractAddress;
        this.zoneContractAddress = zoneContractAddress;
    }
    async prepareSeaportOrder(offerer, listingItem, considerationItem, orderStart, orderExpiry) {
        const { actions: seaportActions } = await this.createSeaportOrder(offerer, listingItem, considerationItem, orderStart, orderExpiry);
        const listingActions = [];
        const approvalAction = seaportActions.find((action) => action.type === 'approval');
        if (approvalAction) {
            listingActions.push({
                type: ActionType.TRANSACTION,
                purpose: TransactionPurpose.APPROVAL,
                buildTransaction: prepareTransaction(approvalAction.transactionMethods),
            });
        }
        const createAction = seaportActions.find((action) => action.type === 'create');
        if (!createAction) {
            throw new Error('No create order action found');
        }
        const orderMessageToSign = await createAction.getMessageToSign();
        const orderComponents = getOrderComponentsFromMessage(orderMessageToSign);
        listingActions.push({
            type: ActionType.SIGNABLE,
            purpose: SignablePurpose.CREATE_LISTING,
            message: await this.getTypedDataFromOrderComponents(orderComponents),
        });
        return {
            actions: listingActions,
            orderComponents,
            orderHash: this.getSeaportLib().getOrderHash(orderComponents),
        };
    }
    async fulfillOrder(order, account, extraData) {
        const { orderComponents, tips } = this.mapImmutableOrderToSeaportOrderComponents(order);
        const seaportLib = this.getSeaportLib(order);
        const { actions: seaportActions } = await seaportLib.fulfillOrders({
            accountAddress: account,
            fulfillOrderDetails: [
                {
                    order: {
                        parameters: orderComponents,
                        signature: order.signature,
                    },
                    extraData,
                    tips,
                },
            ],
        });
        const fulfillmentActions = [];
        const approvalAction = seaportActions.find((action) => action.type === 'approval');
        if (approvalAction) {
            fulfillmentActions.push({
                type: ActionType.TRANSACTION,
                buildTransaction: prepareTransaction(approvalAction.transactionMethods),
                purpose: TransactionPurpose.APPROVAL,
            });
        }
        const fulfilOrderAction = seaportActions.find((action) => action.type === 'exchange');
        if (!fulfilOrderAction) {
            throw new Error('No exchange action found');
        }
        fulfillmentActions.push({
            type: ActionType.TRANSACTION,
            buildTransaction: prepareTransaction(fulfilOrderAction.transactionMethods),
            purpose: TransactionPurpose.FULFILL_ORDER,
        });
        // Expirtaion bytes in SIP7 extra data [21:29]
        // In hex string -> [21 * 2 + 2 (0x) : 29 * 2]
        // In JS slice (start, end_inclusive), (44,60)
        // 8 bytes uint64 epoch time in seconds
        const expirationHex = extraData.slice(44, 60);
        const expirationInSeconds = parseInt(expirationHex, 16);
        return {
            actions: fulfillmentActions,
            expiration: (new Date(expirationInSeconds * 1000)).toISOString(),
            order: mapFromOpenApiOrder(order),
        };
    }
    async cancelOrder(order, account) {
        const { orderComponents } = this.mapImmutableOrderToSeaportOrderComponents(order);
        const seaportLib = this.getSeaportLib(order);
        const cancellationTransaction = await seaportLib.cancelOrders([orderComponents], account);
        return prepareTransaction(cancellationTransaction)();
    }
    mapImmutableOrderToSeaportOrderComponents(order) {
        const orderCounter = order.protocol_data.counter;
        return mapImmutableOrderToSeaportOrderComponents(order, orderCounter, this.zoneContractAddress);
    }
    createSeaportOrder(offerer, listingItem, considerationItem, orderStart, orderExpiry) {
        const seaportLib = this.getSeaportLib();
        return seaportLib.createOrder({
            allowPartialFills: false,
            offer: [
                {
                    itemType: ItemType.ERC721,
                    token: listingItem.contractAddress,
                    identifier: listingItem.tokenId,
                },
            ],
            consideration: [
                {
                    token: considerationItem.type === 'ERC20'
                        ? considerationItem.contractAddress
                        : undefined,
                    amount: considerationItem.amount,
                    recipient: offerer,
                },
            ],
            startTime: (orderStart.getTime() / 1000).toFixed(0),
            endTime: (orderExpiry.getTime() / 1000).toFixed(0),
            zone: this.zoneContractAddress,
            restrictedByZone: true,
        }, offerer);
    }
    async getTypedDataFromOrderComponents(orderComponents) {
        const { chainId } = await this.provider.getNetwork();
        const domainData = {
            name: SEAPORT_CONTRACT_NAME,
            version: SEAPORT_CONTRACT_VERSION_V1_5,
            chainId,
            verifyingContract: this.seaportContractAddress,
        };
        return {
            domain: domainData,
            types: EIP_712_ORDER_TYPE,
            value: orderComponents,
        };
    }
    getSeaportLib(order) {
        const seaportAddress = order?.protocol_data?.seaport_address ?? this.seaportContractAddress;
        const seaportVersion = SEAPORT_CONTRACT_VERSION_V1_5;
        // if (order?.protocol_data?.seaport_version === SEAPORT_CONTRACT_VERSION_V1_5) {
        //   seaportVersion = SEAPORT_CONTRACT_VERSION_V1_5;
        // }
        return this.seaportLibFactory.create(seaportVersion, seaportAddress);
    }
}

class ImmutableApiClient {
    orderbookService;
    chainName;
    seaportAddress;
    constructor(orderbookService, chainName, seaportAddress) {
        this.orderbookService = orderbookService;
        this.chainName = chainName;
        this.seaportAddress = seaportAddress;
    }
    async fulfillmentData(requests) {
        return this.orderbookService.fulfillmentData({
            chainName: this.chainName,
            requestBody: requests,
        });
    }
    async getListing(listingId) {
        return this.orderbookService.getListing({
            chainName: this.chainName,
            listingId,
        });
    }
    async getTrade(tradeId) {
        return this.orderbookService.getTrade({
            chainName: this.chainName,
            tradeId,
        });
    }
    async listListings(listOrderParams) {
        return this.orderbookService.listListings({
            chainName: this.chainName,
            ...listOrderParams,
        });
    }
    async listTrades(listTradesParams) {
        return this.orderbookService.listTrades({
            chainName: this.chainName,
            ...listTradesParams,
        });
    }
    async createListing({ orderHash, orderComponents, orderSignature, makerFees, }) {
        if (orderComponents.offer.length !== 1) {
            throw new Error('Only one item can be listed at a time');
        }
        if (Number(orderComponents.offer[0].itemType) !== ItemType.ERC721) {
            throw new Error('Only ERC721 tokens can be listed');
        }
        const orderTypes = [
            ...orderComponents.consideration.map((c) => c.itemType),
        ];
        const isSameConsiderationType = new Set(orderTypes).size === 1;
        if (!isSameConsiderationType) {
            throw new Error('All consideration items must be of the same type');
        }
        return this.orderbookService.createListing({
            chainName: this.chainName,
            requestBody: {
                order_hash: orderHash,
                account_address: orderComponents.offerer,
                buy: [
                    {
                        item_type: Number(orderComponents.consideration[0].itemType)
                            === ItemType.NATIVE
                            ? 'NATIVE'
                            : 'ERC20',
                        start_amount: orderComponents.consideration[0].startAmount,
                        contract_address: orderComponents.consideration[0].token,
                    },
                ],
                fees: makerFees.map((x) => ({
                    amount: x.amount,
                    fee_type: FeeType.MAKER_ECOSYSTEM,
                    recipient: x.recipient,
                })),
                end_at: new Date(parseInt(`${orderComponents.endTime.toString()}000`, 10)).toISOString(),
                protocol_data: {
                    order_type: ProtocolData.order_type.FULL_RESTRICTED,
                    zone_address: orderComponents.zone,
                    seaport_address: this.seaportAddress,
                    seaport_version: SEAPORT_CONTRACT_VERSION_V1_5,
                    counter: orderComponents.counter.toString(),
                },
                salt: orderComponents.salt,
                sell: [
                    {
                        contract_address: orderComponents.offer[0].token,
                        token_id: orderComponents.offer[0].identifierOrCriteria,
                        item_type: 'ERC721',
                    },
                ],
                signature: orderSignature,
                start_at: new Date(parseInt(`${orderComponents.startTime.toString()}000`, 10)).toISOString(),
            },
        });
    }
}

class ImmutableApiClientFactory {
    chainName;
    seaportAddress;
    orderbookClient;
    constructor(apiEndpoint, chainName, seaportAddress) {
        this.chainName = chainName;
        this.seaportAddress = seaportAddress;
        this.orderbookClient = new OrderBookClient({
            // eslint-disable-next-line @typescript-eslint/naming-convention
            BASE: apiEndpoint,
        });
    }
    create() {
        return new ImmutableApiClient(this.orderbookClient.orders, this.chainName, this.seaportAddress);
    }
}

const TESTNET_CHAIN_NAME = 'imtbl-zkevm-testnet';
const MAINNET_CHAIN_NAME = 'imtbl-zkevm-mainnet';
function getOrderbookConfig(environment) {
    switch (environment) {
        case Environment$1.SANDBOX:
            return {
                seaportContractAddress: '0x7Fb7Da6De152597830eD16361633e362A2F59410',
                zoneContractAddress: '0x63441cBfBd15Dd8f5E92598E535661Ac5aCB808E',
                apiEndpoint: 'https://api.sandbox.immutable.com',
                chainName: TESTNET_CHAIN_NAME,
                provider: new providers.JsonRpcProvider('https://rpc.testnet.immutable.com'),
            };
        // not yet deployed
        case Environment$1.PRODUCTION:
            return {
                seaportContractAddress: '',
                zoneContractAddress: '',
                apiEndpoint: 'https://api.immutable.com',
                chainName: MAINNET_CHAIN_NAME,
                provider: new providers.JsonRpcProvider('https://rpc.immutable.com'),
            };
        default:
            return null;
    }
}

class SeaportLibFactory {
    defaultSeaportContractAddress;
    provider;
    constructor(defaultSeaportContractAddress, provider) {
        this.defaultSeaportContractAddress = defaultSeaportContractAddress;
        this.provider = provider;
    }
    create(orderSeaportVersion, orderSeaportAddress) {
        const seaportVersion = orderSeaportVersion ?? SEAPORT_CONTRACT_VERSION_V1_5;
        const seaportContractAddress = orderSeaportAddress ?? this.defaultSeaportContractAddress;
        return new Seaport$1(this.provider, {
            seaportVersion,
            balanceAndApprovalChecksOnOrderCreation: true,
            overrides: {
                contractAddress: seaportContractAddress,
            },
        });
    }
}

/**
 * zkEVM orderbook SDK
 * @constructor
 * @param {OrderbookModuleConfiguration} config - Configuration for Immutable services.
 */
class Orderbook {
    apiClient;
    seaport;
    orderbookConfig;
    constructor(config) {
        const obConfig = getOrderbookConfig(config.baseConfig.environment);
        const finalConfig = {
            ...obConfig,
            ...config.overrides,
        };
        if (!finalConfig) {
            throw new Error('Orderbook configuration not passed, please specify the environment under config.baseConfig.environment');
        }
        this.orderbookConfig = finalConfig;
        const { apiEndpoint, chainName } = this.orderbookConfig;
        if (!apiEndpoint) {
            throw new Error('API endpoint must be provided');
        }
        this.apiClient = new ImmutableApiClientFactory(apiEndpoint, chainName, this.orderbookConfig.seaportContractAddress).create();
        const seaportLibFactory = new SeaportLibFactory(this.orderbookConfig.seaportContractAddress, this.orderbookConfig.provider);
        this.seaport = new Seaport(seaportLibFactory, this.orderbookConfig.provider, this.orderbookConfig.seaportContractAddress, this.orderbookConfig.zoneContractAddress);
    }
    /**
     * Return the configuration for the orderbook module.
     * @return {OrderbookModuleConfiguration} The configuration for the orderbook module.
     */
    config() {
        return this.orderbookConfig;
    }
    /**
     * Get an order by ID
     * @param {string} listingId - The listingId to find.
     * @return {ListingResult} The returned order result.
     */
    async getListing(listingId) {
        const apiListing = await this.apiClient.getListing(listingId);
        return {
            result: mapFromOpenApiOrder(apiListing.result),
        };
    }
    /**
     * Get a trade by ID
     * @param {string} tradeId - The tradeId to find.
     * @return {TradeResult} The returned order result.
     */
    async getTrade(tradeId) {
        const apiListing = await this.apiClient.getTrade(tradeId);
        return {
            result: mapFromOpenApiTrade(apiListing.result),
        };
    }
    /**
     * List orders. This method is used to get a list of orders filtered by conditions specified
     * in the params object.
     * @param {ListListingsParams} listOrderParams - Filtering, ordering and page parameters.
     * @return {ListListingsResult} The paged orders.
     */
    async listListings(listOrderParams) {
        const apiListings = await this.apiClient.listListings(listOrderParams);
        return {
            page: mapFromOpenApiPage(apiListings.page),
            result: apiListings.result.map(mapFromOpenApiOrder),
        };
    }
    /**
     * List trades. This method is used to get a list of trades filtered by conditions specified
     * in the params object
     * @param {ListTradesParams} listTradesParams - Filtering, ordering and page parameters.
     * @return {ListTradesResult} The paged trades.
     */
    async listTrades(listTradesParams) {
        const apiListings = await this.apiClient.listTrades(listTradesParams);
        return {
            page: mapFromOpenApiPage(apiListings.page),
            result: apiListings.result.map(mapFromOpenApiTrade),
        };
    }
    /**
     * Get required transactions and messages for signing prior to creating a listing
     * through the createListing method
     * @param {PrepareListingParams} prepareListingParams - Details about the listing to be created.
     * @return {PrepareListingResponse} PrepareListingResponse includes
     * the unsigned approval transaction, the typed order message for signing and
     * the order components that can be submitted to `createListing` with a signature.
     */
    async prepareListing({ makerAddress, sell, buy, orderExpiry, }) {
        return this.seaport.prepareSeaportOrder(makerAddress, sell, buy, 
        // Default order start to now
        new Date(), 
        // Default order expiry to 2 years from now
        orderExpiry || new Date(Date.now() + 1000 * 60 * 60 * 24 * 365 * 2));
    }
    /**
     * Create an order
     * @param {CreateListingParams} createListingParams - create an order with the given params.
     * @return {ListingResult} The result of the order created in the Immutable services.
     */
    async createListing(createListingParams) {
        const apiListingResponse = await this.apiClient.createListing({
            ...createListingParams,
        });
        return {
            result: mapFromOpenApiOrder(apiListingResponse.result),
        };
    }
    /**
     * Get unsigned transactions that can be submitted to fulfil an open order. If the approval
     * transaction exists it must be signed and submitted to the chain before the fulfilment
     * transaction can be submitted or it will be reverted.
     * @param {string} listingId - The listingId to fulfil.
     * @param {string} fulfillerAddress - The address of the account fulfilling the order.
     * @return {FulfillOrderResponse} Approval and fulfilment transactions.
     */
    async fulfillOrder(listingId, takerAddress, takerFees) {
        const fulfillmentDataRes = await this.apiClient.fulfillmentData([
            {
                order_id: listingId,
                fees: takerFees.map((fee) => ({
                    amount: fee.amount,
                    fee_type: FeeType.TAKER_ECOSYSTEM,
                    recipient: fee.recipient,
                })),
            },
        ]);
        if (fulfillmentDataRes.result.length !== 1) {
            throw new Error('unexpected fulfillment data result length');
        }
        const extraData = fulfillmentDataRes.result[0].extra_data;
        const orderResult = fulfillmentDataRes.result[0].order;
        if (orderResult.status !== OrderStatus.ACTIVE) {
            throw new Error(`Cannot fulfil order that is not active. Current status: ${orderResult.status}`);
        }
        return this.seaport.fulfillOrder(orderResult, takerAddress, extraData);
    }
    /**
     * Get an unsigned cancel order transaction. Orders can only be cancelled by
     * the account that created them.
     * @param {string} listingId - The listingId to cancel.
     * @param {string} accountAddress - The address of the account cancelling the order.
     * @return {CancelOrderResponse} The unsigned cancel order transaction
     */
    async cancelOrder(listingId, accountAddress) {
        const orderResult = await this.apiClient.getListing(listingId);
        if (orderResult.result.status !== OrderStatus.ACTIVE
            && orderResult.result.status !== OrderStatus.INACTIVE
            && orderResult.result.status !== OrderStatus.PENDING) {
            throw new Error(`Cannot cancel order with status ${orderResult.result.status}`);
        }
        if (orderResult.result.account_address !== accountAddress.toLowerCase()) {
            throw new Error(`Only account ${orderResult.result.account_address} can cancel order ${listingId}`);
        }
        const cancelOrderTransaction = await this.seaport.cancelOrder(orderResult.result, accountAddress);
        return { unsignedCancelOrderTransaction: cancelOrderTransaction };
    }
}

// Consumers might want an estimated gas limit for fulfilling an order
// without calling the transaction builder. This is an estimate that
// should work for all fulfillment scenarios.
const ESTIMATED_FULFILLMENT_GAS_GWEI = 400000;
const constants = {
    estimatedFulfillmentGasGwei: ESTIMATED_FULFILLMENT_GAS_GWEI,
};

var orderbook = /*#__PURE__*/Object.freeze({
    __proto__: null,
    get ActionType () { return ActionType; },
    get FeeType () { return FeeType; },
    get OrderStatus () { return OrderStatus; },
    Orderbook: Orderbook,
    get SignablePurpose () { return SignablePurpose; },
    get TransactionPurpose () { return TransactionPurpose; },
    constants: constants
});

function isChainValid(chainID, config) {
    return chainID === config.ethConfiguration.chainID;
}
async function validateChain(signer, config) {
    const chainID = await signer.getChainId();
    if (!isChainValid(chainID, config)) {
        throw new Error('The wallet used for this operation is not connected to the correct network.');
    }
}

async function transfer({ signers: { ethSigner, starkSigner }, request, config, }) {
    await validateChain(ethSigner, config.immutableXConfig);
    const ethAddress = await ethSigner.getAddress();
    const transfersApi = new TransfersApi(config.immutableXConfig.apiConfiguration);
    const transferAmount = request.type === 'ERC721' ? '1' : request.amount;
    const signableResult = await transfersApi.getSignableTransferV1({
        getSignableTransferRequest: {
            sender: ethAddress,
            token: convertToSignableToken(request),
            amount: transferAmount,
            receiver: request.receiver,
        },
    });
    const { signable_message: signableMessage, payload_hash: payloadHash } = signableResult.data;
    const ethSignature = await signRaw(signableMessage, ethSigner);
    const starkSignature = await starkSigner.signMessage(payloadHash);
    const transferSigningParams = {
        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
        sender_stark_key: signableResult.data.sender_stark_key,
        sender_vault_id: signableResult.data.sender_vault_id,
        receiver_stark_key: signableResult.data.receiver_stark_key,
        receiver_vault_id: signableResult.data.receiver_vault_id,
        asset_id: signableResult.data.asset_id,
        amount: signableResult.data.amount,
        nonce: signableResult.data.nonce,
        expiration_timestamp: signableResult.data.expiration_timestamp,
        stark_signature: starkSignature,
    };
    const response = await transfersApi.createTransferV1({
        createTransferRequest: transferSigningParams,
        xImxEthAddress: ethAddress,
        xImxEthSignature: ethSignature,
    });
    return {
        sent_signature: response?.data.sent_signature,
        status: response?.data.status?.toString(),
        time: response?.data.time,
        transfer_id: response?.data.transfer_id,
    };
}
async function batchTransfer({ signers: { ethSigner, starkSigner }, request, config, }) {
    await validateChain(ethSigner, config.immutableXConfig);
    const ethAddress = await ethSigner.getAddress();
    const transfersApi = new TransfersApi(config.immutableXConfig.apiConfiguration);
    const signableRequests = request.map((nftTransfer) => ({
        amount: '1',
        token: convertToSignableToken({
            type: 'ERC721',
            tokenId: nftTransfer.tokenId,
            tokenAddress: nftTransfer.tokenAddress,
        }),
        receiver: nftTransfer.receiver,
    }));
    const signableResult = await transfersApi.getSignableTransfer({
        getSignableTransferRequestV2: {
            sender_ether_key: ethAddress,
            signable_requests: signableRequests,
        },
    });
    const signableMessage = signableResult.data.signable_message;
    if (signableMessage === undefined) {
        throw new Error('Invalid response from Signable registration offchain');
    }
    const ethSignature = await signRaw(signableMessage, ethSigner);
    const requests = [];
    for (const resp of signableResult.data.signable_responses) {
        // TODO: remove once fixed
        // eslint-disable-next-line no-await-in-loop
        const starkSignature = await starkSigner.signMessage(resp.payload_hash);
        const req = {
            sender_vault_id: resp.sender_vault_id,
            receiver_stark_key: resp.receiver_stark_key,
            receiver_vault_id: resp.receiver_vault_id,
            asset_id: resp.asset_id,
            amount: resp.amount,
            nonce: resp.nonce,
            expiration_timestamp: resp.expiration_timestamp,
            stark_signature: starkSignature,
        };
        requests.push(req);
    }
    // TODO: throw error on missing payload hash?
    const transferSigningParams = {
        sender_stark_key: signableResult.data.sender_stark_key,
        requests,
    };
    const response = await transfersApi.createTransfer({
        createTransferRequestV2: transferSigningParams,
        xImxEthAddress: ethAddress,
        xImxEthSignature: ethSignature,
    });
    return {
        transfer_ids: response?.data.transfer_ids,
    };
}

async function createOrder({ signers, request, config, }) {
    await validateChain(signers.ethSigner, config.immutableXConfig);
    const ethAddress = await signers.ethSigner.getAddress();
    const ordersApi = new OrdersApi$1(config.immutableXConfig.apiConfiguration);
    const amountSell = request.sell.type === 'ERC721' ? '1' : request.sell.amount;
    const amountBuy = request.buy.type === 'ERC721' ? '1' : request.buy.amount;
    const getSignableOrderRequest = {
        user: ethAddress,
        amount_buy: amountBuy,
        token_buy: convertToSignableToken(request.buy),
        amount_sell: amountSell,
        token_sell: convertToSignableToken(request.sell),
        fees: request.fees,
        expiration_timestamp: request.expiration_timestamp,
    };
    const getSignableOrderResponse = await ordersApi.getSignableOrder({
        getSignableOrderRequestV3: getSignableOrderRequest,
    });
    const { signable_message: signableMessage, payload_hash: payloadHash } = getSignableOrderResponse.data;
    const ethSignature = await signRaw(signableMessage, signers.ethSigner);
    const starkSignature = await signers.starkSigner.signMessage(payloadHash);
    const resp = getSignableOrderResponse.data;
    const orderParams = {
        createOrderRequest: {
            amount_buy: resp.amount_buy,
            amount_sell: resp.amount_sell,
            asset_id_buy: resp.asset_id_buy,
            asset_id_sell: resp.asset_id_sell,
            expiration_timestamp: resp.expiration_timestamp,
            include_fees: true,
            fees: request.fees,
            nonce: resp.nonce,
            stark_key: resp.stark_key,
            stark_signature: starkSignature,
            vault_id_buy: resp.vault_id_buy,
            vault_id_sell: resp.vault_id_sell,
        },
        xImxEthAddress: ethAddress,
        xImxEthSignature: ethSignature,
    };
    const createOrderResponse = await ordersApi.createOrder(orderParams);
    return {
        ...createOrderResponse.data,
    };
}
async function cancelOrder({ signers, request, config, }) {
    const ordersApi = new OrdersApi$1(config.immutableXConfig.apiConfiguration);
    const getSignableCancelOrderResponse = await ordersApi.getSignableCancelOrder({
        getSignableCancelOrderRequest: {
            order_id: request.order_id,
        },
    });
    const { signable_message: signableMessage, payload_hash: payloadHash } = getSignableCancelOrderResponse.data;
    const ethSignature = await signRaw(signableMessage, signers.ethSigner);
    const starkSignature = await signers.starkSigner.signMessage(payloadHash);
    const ethAddress = await signers.ethSigner.getAddress();
    const cancelOrderResponse = await ordersApi.cancelOrder({
        id: request.order_id.toString(),
        cancelOrderRequest: {
            order_id: request.order_id,
            stark_signature: starkSignature,
        },
        xImxEthAddress: ethAddress,
        xImxEthSignature: ethSignature,
    });
    return {
        order_id: cancelOrderResponse.data.order_id,
        status: cancelOrderResponse.data.status,
    };
}

async function registerOffchain(signers, config) {
    await validateChain(signers.ethSigner, config.immutableXConfig);
    const usersApi = new UsersApi(config.immutableXConfig.apiConfiguration);
    const userAddress = await signers.ethSigner.getAddress();
    const starkPublicKey = await signers.starkSigner.getAddress();
    const signableResult = await usersApi.getSignableRegistrationOffchain({
        getSignableRegistrationRequest: {
            ether_key: userAddress,
            stark_key: starkPublicKey,
        },
    });
    const { signable_message: signableMessage, payload_hash: payloadHash } = signableResult.data;
    const ethSignature = await signRaw(signableMessage, signers.ethSigner);
    const starkSignature = await signers.starkSigner.signMessage(payloadHash);
    const registeredUser = await usersApi.registerUser({
        registerUserRequest: {
            eth_signature: ethSignature,
            ether_key: userAddress,
            stark_signature: starkSignature,
            stark_key: starkPublicKey,
        },
    });
    return registeredUser.data;
}
async function isRegisteredOnChain(starkPublicKey, ethSigner, config) {
    await validateChain(ethSigner, config.immutableXConfig);
    const registrationContract = Contracts.Registration.connect(config.immutableXConfig.ethConfiguration.registrationContractAddress, ethSigner);
    try {
        return await registrationContract.isRegistered(starkPublicKey);
    }
    catch (ex) {
        if (ex.reason === 'USER_UNREGISTERED') {
            return false;
        }
        throw ex;
    }
}
async function getSignableRegistrationOnchain(etherKey, starkPublicKey, usersApi) {
    const response = await usersApi.getSignableRegistration({
        getSignableRegistrationRequest: {
            ether_key: etherKey,
            stark_key: starkPublicKey,
        },
    });
    return {
        operator_signature: response.data.operator_signature,
        payload_hash: response.data.payload_hash,
    };
}

const assertIsDefined = (value) => {
    if (value !== undefined)
        return value;
    throw new Error('undefined field exception');
};
async function prepareWithdrawalAction(params) {
    const { signers: { ethSigner, starkSigner }, type, config, } = params;
    await validateChain(ethSigner, params.config);
    const withdrawalsApi = new WithdrawalsApi(config.apiConfiguration);
    const withdrawalAmount = type === 'ERC721' ? '1' : params.amount;
    const signableWithdrawalResult = await withdrawalsApi.getSignableWithdrawal({
        getSignableWithdrawalRequest: {
            user: await ethSigner.getAddress(),
            token: convertToSignableToken(params),
            amount: withdrawalAmount,
        },
    });
    const { signable_message: signableMessage, payload_hash: payloadHash } = signableWithdrawalResult.data;
    const starkSignature = await starkSigner.signMessage(payloadHash);
    const { ethAddress, ethSignature } = await signMessage(signableMessage, ethSigner);
    const prepareWithdrawalResponse = await withdrawalsApi.createWithdrawal({
        createWithdrawalRequest: {
            stark_key: assertIsDefined(signableWithdrawalResult.data.stark_key),
            amount: withdrawalAmount,
            asset_id: assertIsDefined(signableWithdrawalResult.data.asset_id),
            vault_id: assertIsDefined(signableWithdrawalResult.data.vault_id),
            nonce: assertIsDefined(signableWithdrawalResult.data.nonce),
            stark_signature: starkSignature,
        },
        xImxEthAddress: ethAddress,
        xImxEthSignature: ethSignature,
    });
    return prepareWithdrawalResponse.data;
}

async function getEncodeAssetInfo(assetType, tokenType, config, tokenData) {
    const encodingApi = new EncodingApi(config.apiConfiguration);
    const result = await encodingApi.encodeAsset({
        assetType,
        encodeAssetRequest: {
            token: {
                type: tokenType,
                ...(tokenData && { data: tokenData }),
            },
        },
    });
    return result.data;
}

async function executeRegisterAndWithdrawERC20({ ethSigner, assetType, starkPublicKey, config, }) {
    const etherKey = await ethSigner.getAddress();
    const imxConfig = config.immutableXConfig;
    const usersApi = new UsersApi(imxConfig.apiConfiguration);
    const signableResult = await getSignableRegistrationOnchain(etherKey, starkPublicKey, usersApi);
    const contract = Contracts.Registration.connect(config.immutableXConfig.ethConfiguration.registrationContractAddress, ethSigner);
    const populatedTransaction = await contract.populateTransaction.registerAndWithdraw(etherKey, starkPublicKey, signableResult.operator_signature, assetType);
    return ethSigner.sendTransaction(populatedTransaction);
}
async function executeWithdrawERC20(ethSigner, assetType, starkPublicKey, config) {
    const contract = Contracts.Core.connect(config.ethConfiguration.coreContractAddress, ethSigner);
    const populatedTransaction = await contract.populateTransaction.withdraw(starkPublicKey, assetType);
    return ethSigner.sendTransaction(populatedTransaction);
}
async function completeERC20WithdrawalAction({ ethSigner, starkPublicKey, token, config, }) {
    await validateChain(ethSigner, config.immutableXConfig);
    const imxConfig = config.immutableXConfig;
    const assetType = await getEncodeAssetInfo('asset', 'ERC20', imxConfig, {
        token_address: token.tokenAddress,
    });
    const isRegistered = await isRegisteredOnChain(starkPublicKey, ethSigner, config);
    if (!isRegistered) {
        return executeRegisterAndWithdrawERC20({
            ethSigner,
            assetType: assetType.asset_type,
            starkPublicKey,
            config,
        });
    }
    return executeWithdrawERC20(ethSigner, assetType.asset_type, starkPublicKey, imxConfig);
}

async function executeWithdrawMintableERC721(ethSigner, assetType, starkPublicKey, mintingBlob, config) {
    const contract = Contracts.Core.connect(config.ethConfiguration.coreContractAddress, ethSigner);
    const populatedTransaction = await contract.populateTransaction.withdrawAndMint(starkPublicKey, assetType, mintingBlob);
    return ethSigner.sendTransaction(populatedTransaction);
}
async function executeRegisterAndWithdrawMintableERC721(ethSigner, assetType, starkPublicKey, mintingBlob, config) {
    const etherKey = await ethSigner.getAddress();
    const usersApi = new UsersApi(config.apiConfiguration);
    const signableResult = await getSignableRegistrationOnchain(etherKey, starkPublicKey, usersApi);
    const contract = Contracts.Registration.connect(config.ethConfiguration.registrationContractAddress, ethSigner);
    const populatedTransaction = await contract.populateTransaction.regsiterAndWithdrawAndMint(etherKey, starkPublicKey, signableResult.operator_signature, assetType, mintingBlob);
    return ethSigner.sendTransaction(populatedTransaction);
}
function getMintingBlob(token) {
    const { id } = token.data;
    const blueprint = token.data.blueprint || '';
    return encUtils.sanitizeHex(encUtils.utf8ToHex(`{${id}}:{${blueprint}}`));
}
async function completeMintableERC721Withdrawal(ethSigner, starkPublicKey, token, config) {
    const imxConfig = config.immutableXConfig;
    const assetType = await getEncodeAssetInfo('mintable-asset', 'ERC721', imxConfig, {
        id: token.data.id,
        token_address: token.data.tokenAddress,
        ...(token.data.blueprint && { blueprint: token.data.blueprint }),
    });
    const mintingBlob = getMintingBlob(token);
    const isRegistered = await isRegisteredOnChain(starkPublicKey, ethSigner, config);
    if (!isRegistered) {
        return executeRegisterAndWithdrawMintableERC721(ethSigner, assetType.asset_type, starkPublicKey, mintingBlob, imxConfig);
    }
    return executeWithdrawMintableERC721(ethSigner, assetType.asset_type, starkPublicKey, mintingBlob, imxConfig);
}
async function executeRegisterAndWithdrawERC721(ethSigner, assetType, starkPublicKey, tokenId, config) {
    const etherKey = await ethSigner.getAddress();
    const usersApi = new UsersApi(config.apiConfiguration);
    const signableResult = await getSignableRegistrationOnchain(etherKey, starkPublicKey, usersApi);
    const contract = Contracts.Registration.connect(config.ethConfiguration.registrationContractAddress, ethSigner);
    const populatedTransaction = await contract.populateTransaction.registerAndWithdrawNft(etherKey, starkPublicKey, signableResult.operator_signature, assetType, tokenId);
    return ethSigner.sendTransaction(populatedTransaction);
}
async function executeWithdrawERC721(ethSigner, assetType, starkPublicKey, tokenId, config) {
    const contract = Contracts.Core.connect(config.ethConfiguration.coreContractAddress, ethSigner);
    const populatedTransaction = await contract.populateTransaction.withdrawNft(starkPublicKey, assetType, tokenId);
    return ethSigner.sendTransaction(populatedTransaction);
}
async function completeERC721Withdrawal(ethSigner, starkPublicKey, token, config) {
    const imxConfig = config.immutableXConfig;
    const assetType = await getEncodeAssetInfo('asset', 'ERC721', imxConfig, {
        token_id: token.tokenId,
        token_address: token.tokenAddress,
    });
    const isRegistered = await isRegisteredOnChain(starkPublicKey, ethSigner, config);
    if (!isRegistered) {
        return executeRegisterAndWithdrawERC721(ethSigner, assetType.asset_type, starkPublicKey, token.tokenId, imxConfig);
    }
    return executeWithdrawERC721(ethSigner, assetType.asset_type, starkPublicKey, token.tokenId, imxConfig);
}
async function completeERC721WithdrawalAction({ ethSigner, starkPublicKey, token, config, }) {
    await validateChain(ethSigner, config.immutableXConfig);
    const { tokenAddress } = token;
    const { tokenId } = token;
    const imxConfig = config.immutableXConfig;
    const mintsApi = new MintsApi(imxConfig.apiConfiguration);
    return await mintsApi
        .getMintableTokenDetailsByClientTokenId({
        tokenAddress,
        tokenId,
    })
        .then((mintableToken) => completeMintableERC721Withdrawal(ethSigner, starkPublicKey, {
        type: 'ERC721',
        data: {
            id: tokenId,
            tokenAddress,
            blueprint: mintableToken.data.blueprint,
        },
    }, config))
        .catch((error) => {
        if (error.response?.status === 404) {
            // token is already minted on L1
            return completeERC721Withdrawal(ethSigner, starkPublicKey, token, config);
        }
        throw error; // unable to recover from any other kind of error
    });
}

async function executeRegisterAndWithdrawEth(ethSigner, assetType, starkPublicKey, config) {
    const etherKey = await ethSigner.getAddress();
    const usersApi = new UsersApi(config.apiConfiguration);
    const signableResult = await getSignableRegistrationOnchain(etherKey, starkPublicKey, usersApi);
    const contract = Contracts.Registration.connect(config.ethConfiguration.registrationContractAddress, ethSigner);
    const populatedTransaction = await contract.populateTransaction.registerAndWithdraw(etherKey, starkPublicKey, signableResult.operator_signature, assetType);
    return ethSigner.sendTransaction(populatedTransaction);
}
async function executeWithdrawEth(ethSigner, assetType, starkPublicKey, config) {
    const contract = Contracts.Core.connect(config.ethConfiguration.coreContractAddress, ethSigner);
    const populatedTransaction = await contract.populateTransaction.withdraw(starkPublicKey, assetType);
    return ethSigner.sendTransaction(populatedTransaction);
}
async function completeEthWithdrawalAction({ ethSigner, starkPublicKey, config, }) {
    await validateChain(ethSigner, config.immutableXConfig);
    const imxConfig = config.immutableXConfig;
    const assetType = await getEncodeAssetInfo('asset', 'ETH', imxConfig);
    const isRegistered = await isRegisteredOnChain(starkPublicKey, ethSigner, config);
    if (!isRegistered) {
        return executeRegisterAndWithdrawEth(ethSigner, assetType.asset_type, starkPublicKey, imxConfig);
    }
    return executeWithdrawEth(ethSigner, assetType.asset_type, starkPublicKey, imxConfig);
}

async function prepareWithdrawal({ signers, withdrawal, config, }) {
    return prepareWithdrawalAction({
        signers,
        config: config.immutableXConfig,
        ...withdrawal,
    });
}
// TODO: remove once fixed
// eslint-disable-next-line consistent-return
async function completeWithdrawal({ signers: { ethSigner }, starkPublicKey, token, config, }) {
    // TODO: please add a reasonable default here
    // eslint-disable-next-line default-case
    switch (token.type) {
        case 'ETH':
            return completeEthWithdrawalAction({ ethSigner, starkPublicKey, config });
        case 'ERC20':
            return completeERC20WithdrawalAction({
                ethSigner,
                starkPublicKey,
                token,
                config,
            });
        case 'ERC721':
            return completeERC721WithdrawalAction({
                ethSigner,
                starkPublicKey,
                token,
                config,
            });
    }
}

async function createTrade({ signers: { ethSigner, starkSigner }, request, config, }) {
    await validateChain(ethSigner, config.immutableXConfig);
    const ethAddress = await ethSigner.getAddress();
    const tradesApi = new TradesApi(config.immutableXConfig.apiConfiguration);
    const signableResult = await tradesApi.getSignableTrade({
        getSignableTradeRequest: {
            user: ethAddress,
            order_id: request.order_id,
            fees: request.fees,
        },
    });
    const { signable_message: signableMessage, payload_hash: payloadHash } = signableResult.data;
    const ethSignature = await signRaw(signableMessage, ethSigner);
    const starkSignature = await starkSigner.signMessage(payloadHash);
    const createTradeResponse = await tradesApi.createTrade({
        createTradeRequest: {
            amount_buy: signableResult.data.amount_buy,
            amount_sell: signableResult.data.amount_sell,
            asset_id_buy: signableResult.data.asset_id_buy,
            asset_id_sell: signableResult.data.asset_id_sell,
            expiration_timestamp: signableResult.data.expiration_timestamp,
            fee_info: signableResult.data.fee_info,
            fees: request.fees,
            include_fees: true,
            nonce: signableResult.data.nonce,
            order_id: request.order_id,
            stark_key: signableResult.data.stark_key,
            vault_id_buy: signableResult.data.vault_id_buy,
            vault_id_sell: signableResult.data.vault_id_sell,
            stark_signature: starkSignature,
        },
        xImxEthAddress: ethAddress,
        xImxEthSignature: ethSignature,
    });
    return createTradeResponse.data;
}

async function executeRegisterAndDepositEth(ethSigner, amount, assetType, starkPublicKey, vaultId, config, usersApi) {
    const etherKey = await ethSigner.getAddress();
    const coreContract = Contracts.Core.connect(config.ethConfiguration.coreContractAddress, ethSigner);
    const signableResult = await getSignableRegistrationOnchain(etherKey, starkPublicKey, usersApi);
    const populatedTransaction = await coreContract.populateTransaction.registerAndDepositEth(etherKey, starkPublicKey, signableResult.operator_signature, assetType, vaultId);
    return ethSigner.sendTransaction({ ...populatedTransaction, value: amount });
}
async function executeDepositEth(ethSigner, amount, assetType, starkPublicKey, vaultId, config) {
    const coreContract = Contracts.Core.connect(config.ethConfiguration.coreContractAddress, ethSigner);
    const populatedTransaction = await coreContract.populateTransaction['deposit(uint256,uint256,uint256)'](starkPublicKey, assetType, vaultId);
    return ethSigner.sendTransaction({ ...populatedTransaction, value: amount });
}
async function depositEth({ signers: { ethSigner }, deposit, config, }) {
    await validateChain(ethSigner, config.immutableXConfig);
    const user = await ethSigner.getAddress();
    const data = {
        decimals: 18,
    };
    const amount = parseUnits(deposit.amount, 'wei');
    const imxConfig = config.immutableXConfig;
    const depositsApi = new DepositsApi(imxConfig.apiConfiguration);
    const encodingApi = new EncodingApi(imxConfig.apiConfiguration);
    const usersApi = new UsersApi(imxConfig.apiConfiguration);
    const getSignableDepositRequest = {
        user,
        token: {
            type: deposit.type,
            data,
        },
        amount: amount.toString(),
    };
    const signableDepositResult = await depositsApi.getSignableDeposit({
        getSignableDepositRequest,
    });
    const encodingResult = await encodingApi.encodeAsset({
        assetType: 'asset',
        encodeAssetRequest: {
            token: {
                type: deposit.type,
            },
        },
    });
    const assetType = encodingResult.data.asset_type;
    const starkPublicKey = signableDepositResult.data.stark_key;
    const vaultId = signableDepositResult.data.vault_id;
    const isRegistered = await isRegisteredOnChain(starkPublicKey, ethSigner, config);
    if (!isRegistered) {
        return executeRegisterAndDepositEth(ethSigner, amount, assetType, starkPublicKey, vaultId, imxConfig, usersApi);
    }
    return executeDepositEth(ethSigner, amount, assetType, starkPublicKey, vaultId, imxConfig);
}

async function executeRegisterAndDepositERC20(ethSigner, quantizedAmount, assetType, starkPublicKey, vaultId, config, usersApi) {
    const etherKey = await ethSigner.getAddress();
    const coreContract = Contracts.Core.connect(config.coreContractAddress, ethSigner);
    const signableResult = await getSignableRegistrationOnchain(etherKey, starkPublicKey, usersApi);
    const populatedTransaction = await coreContract.populateTransaction.registerAndDepositERC20(etherKey, starkPublicKey, signableResult.operator_signature, assetType, vaultId, quantizedAmount);
    return ethSigner.sendTransaction(populatedTransaction);
}
async function executeDepositERC20(ethSigner, quantizedAmount, assetType, starkPublicKey, vaultId, config) {
    const coreContract = Contracts.Core.connect(config.coreContractAddress, ethSigner);
    const populatedTransaction = await coreContract.populateTransaction.depositERC20(starkPublicKey, assetType, vaultId, quantizedAmount);
    return ethSigner.sendTransaction(populatedTransaction);
}
async function depositERC20({ signers: { ethSigner }, deposit, config, }) {
    await validateChain(ethSigner, config.immutableXConfig);
    const { apiConfiguration, ethConfiguration } = config.immutableXConfig;
    const user = await ethSigner.getAddress();
    const tokensApi = new TokensApi$1(apiConfiguration);
    const depositsApi = new DepositsApi(apiConfiguration);
    const encodingApi = new EncodingApi(apiConfiguration);
    const usersApi = new UsersApi(apiConfiguration);
    // Get decimals for this specific ERC20
    const token = await tokensApi.getToken({ address: deposit.tokenAddress });
    // TODO: remove once fixed
    // eslint-disable-next-line radix
    const decimals = parseInt(token.data.decimals);
    const data = {
        decimals,
        token_address: deposit.tokenAddress,
    };
    const amount = parseUnits(deposit.amount, 0); // 0 to always use undecimalized value
    // Approve whether an amount of token from an account can be spent by a third-party account
    const tokenContract = Contracts.IERC20.connect(deposit.tokenAddress, ethSigner);
    const approveTransaction = await tokenContract.populateTransaction.approve(ethConfiguration.coreContractAddress, amount);
    await ethSigner.sendTransaction(approveTransaction);
    const getSignableDepositRequest = {
        user,
        token: {
            type: deposit.type,
            data,
        },
        amount: amount.toString(),
    };
    const signableDepositResult = await depositsApi.getSignableDeposit({
        getSignableDepositRequest,
    });
    // Perform encoding on asset details to get an assetType (required for stark contract request)
    const encodingResult = await encodingApi.encodeAsset({
        assetType: 'asset',
        encodeAssetRequest: {
            token: {
                type: deposit.type,
                data: {
                    token_address: deposit.tokenAddress,
                },
            },
        },
    });
    const assetType = encodingResult.data.asset_type;
    const starkPublicKey = signableDepositResult.data.stark_key;
    const vaultId = signableDepositResult.data.vault_id;
    const quantizedAmount = BigNumber$2.from(signableDepositResult.data.amount);
    const isRegistered = await isRegisteredOnChain(starkPublicKey, ethSigner, config);
    if (!isRegistered) {
        return executeRegisterAndDepositERC20(ethSigner, quantizedAmount, assetType, starkPublicKey, vaultId, ethConfiguration, usersApi);
    }
    return executeDepositERC20(ethSigner, quantizedAmount, assetType, starkPublicKey, vaultId, ethConfiguration);
}

async function executeDepositERC721(ethSigner, tokenId, assetType, starkPublicKey, vaultId, config) {
    const coreContract = Contracts.Core.connect(config.ethConfiguration.coreContractAddress, ethSigner);
    const populatedTransaction = await coreContract.populateTransaction.depositNft(starkPublicKey, assetType, vaultId, tokenId);
    return ethSigner.sendTransaction(populatedTransaction);
}
async function depositERC721({ signers: { ethSigner }, deposit, config, }) {
    await validateChain(ethSigner, config.immutableXConfig);
    const user = await ethSigner.getAddress();
    const { immutableXConfig } = config;
    const depositsApi = new DepositsApi(immutableXConfig.apiConfiguration);
    const encodingApi = new EncodingApi(immutableXConfig.apiConfiguration);
    const usersApi = new UsersApi(immutableXConfig.apiConfiguration);
    const data = {
        token_address: deposit.tokenAddress,
        token_id: deposit.tokenId,
    };
    const amount = '1';
    const getSignableDepositRequest = {
        user,
        token: {
            type: deposit.type,
            data,
        },
        amount: amount.toString(),
    };
    const signableDepositResult = await depositsApi.getSignableDeposit({
        getSignableDepositRequest,
    });
    // Perform encoding on asset details to get an assetType (required for stark contract request)
    const encodingResult = await encodingApi.encodeAsset({
        assetType: 'asset',
        encodeAssetRequest: {
            token: {
                type: deposit.type,
                data: {
                    token_address: deposit.tokenAddress,
                    token_id: deposit.tokenId,
                },
            },
        },
    });
    const assetType = encodingResult.data.asset_type;
    const starkPublicKey = signableDepositResult.data.stark_key;
    const vaultId = signableDepositResult.data.vault_id;
    const isRegistered = await isRegisteredOnChain(starkPublicKey, ethSigner, config);
    // Approve whether an amount of token from an account can be spent by a third-party account
    const tokenContract = Contracts.IERC721.connect(deposit.tokenAddress, ethSigner);
    const operator = immutableXConfig.ethConfiguration.coreContractAddress;
    const isApprovedForAll = await tokenContract.isApprovedForAll(user, operator);
    if (!isApprovedForAll) {
        await tokenContract.setApprovalForAll(operator, true);
    }
    if (!isRegistered) {
        const signableResult = await getSignableRegistrationOnchain(user, starkPublicKey, usersApi);
        const coreContract = Contracts.Core.connect(immutableXConfig.ethConfiguration.coreContractAddress, ethSigner);
        // Note: proxy registration contract registerAndDepositNft method is not used as
        // it currently fails erc721 transfer ownership check
        await coreContract.registerUser(user, starkPublicKey, signableResult.operator_signature);
    }
    return executeDepositERC721(ethSigner, deposit.tokenId, assetType, starkPublicKey, vaultId, immutableXConfig);
}

// TODO: remove once fixed deposit variable shadowing
// eslint-disable-next-line consistent-return, @typescript-eslint/no-shadow
async function deposit({ signers, deposit, config }) {
    // TODO: please add a reasonable default here
    // eslint-disable-next-line default-case
    switch (deposit.type) {
        case 'ETH':
            return depositEth({ signers, deposit, config });
        case 'ERC20':
            return depositERC20({ signers, deposit, config });
        case 'ERC721':
            return depositERC721({ signers, deposit, config });
    }
}

async function exchangeTransfer({ signers, request, config, }) {
    await validateChain(signers.ethSigner, config.immutableXConfig);
    const exchangeApi = new ExchangesApi(config.immutableXConfig.apiConfiguration);
    const ethAddress = await signers.ethSigner.getAddress();
    const transferAmount = request.amount;
    const signableResult = await exchangeApi.getExchangeSignableTransfer({
        id: request.transactionID,
        getSignableTransferRequest: {
            sender: ethAddress,
            token: convertToSignableToken(request),
            amount: transferAmount,
            receiver: request.receiver,
        },
    });
    const { signable_message: signableMessage, payload_hash: payloadHash } = signableResult.data;
    const ethSignature = await signRaw(signableMessage, signers.ethSigner);
    const starkSignature = await signers.starkSigner.signMessage(payloadHash);
    const transferSigningParams = {
        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
        sender_stark_key: signableResult.data.sender_stark_key,
        sender_vault_id: signableResult.data.sender_vault_id,
        receiver_stark_key: signableResult.data.receiver_stark_key,
        receiver_vault_id: signableResult.data.receiver_vault_id,
        asset_id: signableResult.data.asset_id,
        amount: signableResult.data.amount,
        nonce: signableResult.data.nonce,
        expiration_timestamp: signableResult.data.expiration_timestamp,
        stark_signature: starkSignature,
    };
    const response = await exchangeApi.createExchangeTransfer({
        id: request.transactionID,
        createTransferRequest: transferSigningParams,
        xImxEthAddress: ethAddress,
        xImxEthSignature: ethSignature,
    });
    return {
        sent_signature: response?.data.sent_signature,
        status: response?.data.status?.toString(),
        time: response?.data.time,
        transfer_id: response?.data.transfer_id,
    };
}

class GenericIMXProvider {
    config;
    signers;
    constructor(config, ethSigner, starkSigner) {
        this.config = config;
        this.signers = { ethSigner, starkSigner };
    }
    async getAddress() {
        return await this.signers.ethSigner.getAddress();
    }
    registerOffchain() {
        return registerOffchain(this.signers, this.config);
    }
    batchNftTransfer(request) {
        return batchTransfer({
            signers: this.signers,
            request,
            config: this.config,
        });
    }
    cancelOrder(request) {
        return cancelOrder({
            signers: this.signers,
            request,
            config: this.config,
        });
    }
    completeWithdrawal(starkPublicKey, token) {
        return completeWithdrawal({
            config: this.config,
            signers: this.signers,
            token,
            starkPublicKey,
        });
    }
    createOrder(request) {
        return createOrder({
            signers: this.signers,
            request,
            config: this.config,
        });
    }
    createTrade(request) {
        return createTrade({
            signers: this.signers,
            request,
            config: this.config,
        });
    }
    deposit(tokenAmount) {
        return deposit({
            signers: this.signers,
            deposit: tokenAmount,
            config: this.config,
        });
    }
    exchangeTransfer(request) {
        return exchangeTransfer({
            signers: this.signers,
            request,
            config: this.config,
        });
    }
    async isRegisteredOnchain() {
        const starkPublicKey = await this.signers.starkSigner.getAddress();
        return isRegisteredOnChain(starkPublicKey, this.signers.ethSigner, this.config);
    }
    prepareWithdrawal(request) {
        return prepareWithdrawal({
            signers: this.signers,
            withdrawal: request,
            config: this.config,
        });
    }
    transfer(request) {
        return transfer({
            signers: this.signers,
            request,
            config: this.config,
        });
    }
}

const WALLET_ACTION = {
    // TODO: remove once fixed - consider using an enum
    // eslint-disable-next-line @typescript-eslint/naming-convention
    SWITCH_CHAIN: 'wallet_switchEthereumChain',
    // eslint-disable-next-line @typescript-eslint/naming-convention
    CONNECT: 'eth_requestAccounts',
};
function isRequestableProvider(provider) {
    return !!provider?.request;
}
async function connectProvider(provider, chainID) {
    await provider.request({ method: WALLET_ACTION.CONNECT });
    if (chainID) {
        await provider.request({
            method: WALLET_ACTION.SWITCH_CHAIN,
            params: [{ chainId: `0x${chainID.toString(16)}` }],
        });
    }
}

const ERRORS = {
    // TODO: remove once fixed - consider using something in line with the naming convention
    // eslint-disable-next-line @typescript-eslint/naming-convention
    PROVIDER_NOT_FOUND: 'The Metamask provider was not found',
};
async function connect$1({ chainID, }) {
    const provider = (await detectEthereumProvider());
    if (!isRequestableProvider(provider)) {
        throw new Error(ERRORS.PROVIDER_NOT_FOUND);
    }
    await connectProvider(provider, chainID);
    // NOTE: if we want to listen to Metamask events in the future, we can add a
    // listener here.
    return new ethers.providers.Web3Provider(provider);
}

const COMMUNICATION_TYPE = 'message';
var RequestEventType;
(function (RequestEventType) {
    RequestEventType["GET_CONNECTION_REQUEST"] = "GET_CONNECTION_REQUEST";
    RequestEventType["CONNECT_WALLET_REQUEST"] = "CONNECT_WALLET_REQUEST";
    RequestEventType["SIGN_MESSAGE_REQUEST"] = "SIGN_MESSAGE_REQUEST";
    RequestEventType["DISCONNECT_WALLET_REQUEST"] = "DISCONNECT_WALLET_REQUEST";
})(RequestEventType || (RequestEventType = {}));
var ResponseEventType;
(function (ResponseEventType) {
    ResponseEventType["CONNECT_WALLET_RESPONSE"] = "CONNECT_WALLET_RESPONSE";
    ResponseEventType["SIGN_MESSAGE_RESPONSE"] = "SIGN_MESSAGE_RESPONSE";
    ResponseEventType["GET_CONNECTION_RESPONSE"] = "GET_CONNECTION_RESPONSE";
    ResponseEventType["DISCONNECT_WALLET_RESPONSE"] = "DISCONNECT_WALLET_RESPONSE";
})(ResponseEventType || (ResponseEventType = {}));

function postRequestMessage(iframe, payload) {
    if (iframe && iframe.contentWindow) {
        iframe.contentWindow.postMessage(payload, new URL(iframe.src).origin);
    }
}

function messageResponseListener(iframe, event, eventType, callback) {
    if (iframe && event.source !== iframe.contentWindow) {
        return;
    }
    const l2WalletMessage = event.data;
    if (l2WalletMessage.type !== eventType) {
        return;
    }
    callback(l2WalletMessage.details);
}

class ImxSigner {
    publicAddress;
    iframe;
    constructor(publicAddress, iframe) {
        this.publicAddress = publicAddress;
        this.iframe = iframe;
    }
    getAddress() {
        return this.publicAddress;
    }
    signMessage(rawMessage) {
        return new Promise((resolve, reject) => {
            const listener = (event) => {
                messageResponseListener(this.iframe, event, ResponseEventType.SIGN_MESSAGE_RESPONSE, (messageDetails) => {
                    window.removeEventListener(COMMUNICATION_TYPE, listener);
                    if (!messageDetails.success) {
                        reject(new Error(messageDetails.error?.message));
                    }
                    resolve(messageDetails.data.signedMessage);
                });
            };
            window.addEventListener(COMMUNICATION_TYPE, listener);
            postRequestMessage(this.iframe, {
                type: RequestEventType.SIGN_MESSAGE_REQUEST,
                details: { starkPublicKey: this.publicAddress, message: rawMessage },
            });
        });
    }
    getIFrame() {
        return this.iframe;
    }
}

const IMX_WALLET_IFRAME_ID = 'imx-wallet-app';
const IMX_WALLET_IFRAME_HOSTS = {
    [Environment$1.SANDBOX]: 'https://wallets.sandbox.immutable.com',
    [Environment$1.PRODUCTION]: 'https://wallets.immutable.com',
};
const IMX_WALLET_IFRAME_STYLE = 'display: none;';
function getIFrame() {
    return document.querySelector(`iframe#${IMX_WALLET_IFRAME_ID}`);
}
async function setupIFrame(env) {
    return new Promise((resolve) => {
        const iframe = document.createElement('iframe');
        iframe.setAttribute('id', IMX_WALLET_IFRAME_ID);
        iframe.setAttribute('src', IMX_WALLET_IFRAME_HOSTS[env]);
        iframe.setAttribute('style', IMX_WALLET_IFRAME_STYLE);
        document.body.appendChild(iframe);
        iframe.onload = () => resolve(iframe);
    });
}
async function getOrSetupIFrame(env) {
    const iframe = getIFrame();
    if (iframe)
        return iframe;
    return await setupIFrame(env);
}

const DEFAULT_CONNECTION_MESSAGE = 'Only sign this request if youve initiated an action with Immutable X.';
const CONNECTION_FAILED_ERROR = 'The L2 IMX Wallet connection has failed';
async function connect(l1Provider, env) {
    const l1Signer = l1Provider.getSigner();
    const address = await l1Signer.getAddress();
    const signature = await l1Signer.signMessage(DEFAULT_CONNECTION_MESSAGE);
    const iframe = await getOrSetupIFrame(env);
    return new Promise((resolve, reject) => {
        const listener = (event) => {
            messageResponseListener(iframe, event, ResponseEventType.CONNECT_WALLET_RESPONSE, (messageDetails) => {
                window.removeEventListener(COMMUNICATION_TYPE, listener);
                if (!messageDetails.success) {
                    reject(new Error(CONNECTION_FAILED_ERROR));
                }
                resolve(new ImxSigner(messageDetails.data.starkPublicKey, iframe));
            });
        };
        window.addEventListener(COMMUNICATION_TYPE, listener);
        postRequestMessage(iframe, {
            type: RequestEventType.CONNECT_WALLET_REQUEST,
            details: { ethAddress: address, signature },
        });
    });
}
async function disconnect(imxSigner) {
    const iframe = imxSigner.getIFrame();
    return new Promise((resolve, reject) => {
        const listener = (event) => {
            messageResponseListener(iframe, event, ResponseEventType.DISCONNECT_WALLET_RESPONSE, (messageDetails) => {
                window.removeEventListener(COMMUNICATION_TYPE, listener);
                if (!messageDetails.success && messageDetails.error) {
                    reject(messageDetails.error);
                }
                iframe.remove();
                resolve();
            });
        };
        window.addEventListener(COMMUNICATION_TYPE, listener);
        postRequestMessage(iframe, {
            type: RequestEventType.DISCONNECT_WALLET_REQUEST,
            details: { starkPublicKey: imxSigner.getAddress() },
        });
    });
}

var ProviderErrorType;
(function (ProviderErrorType) {
    ProviderErrorType["PROVIDER_CONNECTION_ERROR"] = "PROVIDER_CONNECTION_ERROR";
    ProviderErrorType["WALLET_CONNECTION_ERROR"] = "WALLET_CONNECTION_ERROR";
})(ProviderErrorType || (ProviderErrorType = {}));
class ProviderError extends Error {
    type;
    constructor(message, type) {
        super(message);
        this.type = type;
    }
}
const withProviderError = async (fn, customError) => {
    try {
        return await fn();
    }
    catch (error) {
        const errorMessage = customError.message || `${error.message}` || 'UnknownError';
        throw new ProviderError(errorMessage, customError.type);
    }
};

class MetaMaskIMXProvider extends GenericIMXProvider {
    static imxSigner;
    static async connect(config) {
        return await withProviderError(async () => {
            const metaMaskProvider = await connect$1({
                chainID: config.immutableXConfig.ethConfiguration.chainID,
            });
            this.imxSigner = await connect(metaMaskProvider, config.baseConfig.environment);
            return new MetaMaskIMXProvider(config, metaMaskProvider.getSigner(), this.imxSigner);
        }, { type: ProviderErrorType.WALLET_CONNECTION_ERROR });
    }
    static async disconnect() {
        if (!this.imxSigner) {
            throw new ProviderError('Attempted to disconnect from the MetaMask IMX provider without an established connection', ProviderErrorType.PROVIDER_CONNECTION_ERROR);
        }
        return withProviderError(async () => {
            await disconnect(this.imxSigner);
        }, { type: ProviderErrorType.PROVIDER_CONNECTION_ERROR });
    }
    static async signMessage(message) {
        if (!this.imxSigner) {
            throw new ProviderError('Attempted to sign a message with the MetaMask IMX provider without an established connection', ProviderErrorType.PROVIDER_CONNECTION_ERROR);
        }
        return withProviderError(async () => await this.imxSigner.signMessage(message), { type: ProviderErrorType.PROVIDER_CONNECTION_ERROR });
    }
}

class ProviderConfiguration {
    immutableXConfig;
    baseConfig;
    constructor({ baseConfig, overrides }) {
        this.baseConfig = baseConfig;
        if (overrides) {
            this.immutableXConfig = overrides.immutableXConfig;
        }
        else {
            // TODO: remove once a sensible default is chosen
            // eslint-disable-next-line default-case
            switch (baseConfig.environment) {
                case Environment$1.SANDBOX: {
                    this.immutableXConfig = Config.SANDBOX;
                    break;
                }
                case Environment$1.PRODUCTION: {
                    this.immutableXConfig = Config.PRODUCTION;
                    break;
                }
            }
        }
    }
}

var provider = /*#__PURE__*/Object.freeze({
    __proto__: null,
    GenericIMXProvider: GenericIMXProvider,
    MetaMaskIMXProvider: MetaMaskIMXProvider,
    ProviderConfiguration: ProviderConfiguration
});

/**
 * @constant {string} ETH_SEPOLIA_CHAIN_ID - The chain ID for the Ethereum Sepolia testnet (EIP-155 compatible format).
 */
const ETH_SEPOLIA_CHAIN_ID = '11155111';
/**
 * @constant {string} ETH_MAINNET_CHAIN_ID - The chain ID for the Ethereum mainnet (EIP-155 compatible format).
 */
const ETH_MAINNET_CHAIN_ID = '1';
/**
 * @constant {string} ZKEVM_DEVNET_CHAIN_ID - The chain ID for the zkEVM devnet (EIP-155 compatible format).
 */
const ZKEVM_DEVNET_CHAIN_ID = '13473';
/**
 * @constant {string} ZKEVM_TESTNET_CHAIN_ID - The chain ID for the zkEVM testnet (EIP-155 compatible format).
 */
const ZKEVM_TESTNET_CHAIN_ID = '13472';
/**
 * @constant {string} ZKEVM_MAINNET_CHAIN_ID - The chain ID for the zkEVM mainnet (EIP-155 compatible format).
 */
const ZKEVM_MAINNET_CHAIN_ID = '13371';
/**
 * @constant {string} L2_STATE_SENDER_ADDRESS - Address of bridge contract to the rootchain
 */
const L2_STATE_SENDER_ADDRESS = '0x0000000000000000000000000000000000001002';
/**
 * The constant value representing the native token in the token bridge context.
 * The key is used to indicate the native token of a blockchain network (like Ether in Ethereum)
 *  in methods that normally require a token address.
 * @constant {string}
 */
const NATIVE_TOKEN_BRIDGE_KEY = '0x0000000000000000000000000000000000000001';
/**
 * @constant {BridgeInstance} ETH_SEPOLIA_TO_ZKEVM_DEVNET - A bridge instance configuration for bridging between
 * the Ethereum Sepolia testnet and the zkEVM devnet.
 */
const ETH_SEPOLIA_TO_ZKEVM_DEVNET = {
    rootChainID: ETH_SEPOLIA_CHAIN_ID,
    childChainID: ZKEVM_DEVNET_CHAIN_ID,
};
/**
 * @constant {BridgeInstance} ETH_SEPOLIA_TO_ZKEVM_TESTNET - A bridge instance configuration for bridging
 * between the Ethereum Sepolia testnet and the zkEVM testnet.
 */
const ETH_SEPOLIA_TO_ZKEVM_TESTNET = {
    rootChainID: ETH_SEPOLIA_CHAIN_ID,
    childChainID: ZKEVM_TESTNET_CHAIN_ID,
};
/**
 * @constant {BridgeInstance} ETH_MAINNET_TO_ZKEVM_MAINNET - A bridge instance configuration for bridging
 * between the Ethereum mainnet and the zkEVM mainnet.
 */
const ETH_MAINNET_TO_ZKEVM_MAINNET = {
    rootChainID: ETH_MAINNET_CHAIN_ID,
    childChainID: ZKEVM_MAINNET_CHAIN_ID,
};

var commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};

function getDefaultExportFromCjs (x) {
	return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, 'default') ? x['default'] : x;
}

var bn = {exports: {}};

(function (module) {
	(function (module, exports) {

	  // Utils
	  function assert (val, msg) {
	    if (!val) throw new Error(msg || 'Assertion failed');
	  }

	  // Could use `inherits` module, but don't want to move from single file
	  // architecture yet.
	  function inherits (ctor, superCtor) {
	    ctor.super_ = superCtor;
	    var TempCtor = function () {};
	    TempCtor.prototype = superCtor.prototype;
	    ctor.prototype = new TempCtor();
	    ctor.prototype.constructor = ctor;
	  }

	  // BN

	  function BN (number, base, endian) {
	    if (BN.isBN(number)) {
	      return number;
	    }

	    this.negative = 0;
	    this.words = null;
	    this.length = 0;

	    // Reduction context
	    this.red = null;

	    if (number !== null) {
	      if (base === 'le' || base === 'be') {
	        endian = base;
	        base = 10;
	      }

	      this._init(number || 0, base || 10, endian || 'be');
	    }
	  }
	  if (typeof module === 'object') {
	    module.exports = BN;
	  } else {
	    exports.BN = BN;
	  }

	  BN.BN = BN;
	  BN.wordSize = 26;

	  var Buffer;
	  try {
	    if (typeof window !== 'undefined' && typeof window.Buffer !== 'undefined') {
	      Buffer = window.Buffer;
	    } else {
	      Buffer = require('buffer').Buffer;
	    }
	  } catch (e) {
	  }

	  BN.isBN = function isBN (num) {
	    if (num instanceof BN) {
	      return true;
	    }

	    return num !== null && typeof num === 'object' &&
	      num.constructor.wordSize === BN.wordSize && Array.isArray(num.words);
	  };

	  BN.max = function max (left, right) {
	    if (left.cmp(right) > 0) return left;
	    return right;
	  };

	  BN.min = function min (left, right) {
	    if (left.cmp(right) < 0) return left;
	    return right;
	  };

	  BN.prototype._init = function init (number, base, endian) {
	    if (typeof number === 'number') {
	      return this._initNumber(number, base, endian);
	    }

	    if (typeof number === 'object') {
	      return this._initArray(number, base, endian);
	    }

	    if (base === 'hex') {
	      base = 16;
	    }
	    assert(base === (base | 0) && base >= 2 && base <= 36);

	    number = number.toString().replace(/\s+/g, '');
	    var start = 0;
	    if (number[0] === '-') {
	      start++;
	      this.negative = 1;
	    }

	    if (start < number.length) {
	      if (base === 16) {
	        this._parseHex(number, start, endian);
	      } else {
	        this._parseBase(number, base, start);
	        if (endian === 'le') {
	          this._initArray(this.toArray(), base, endian);
	        }
	      }
	    }
	  };

	  BN.prototype._initNumber = function _initNumber (number, base, endian) {
	    if (number < 0) {
	      this.negative = 1;
	      number = -number;
	    }
	    if (number < 0x4000000) {
	      this.words = [number & 0x3ffffff];
	      this.length = 1;
	    } else if (number < 0x10000000000000) {
	      this.words = [
	        number & 0x3ffffff,
	        (number / 0x4000000) & 0x3ffffff
	      ];
	      this.length = 2;
	    } else {
	      assert(number < 0x20000000000000); // 2 ^ 53 (unsafe)
	      this.words = [
	        number & 0x3ffffff,
	        (number / 0x4000000) & 0x3ffffff,
	        1
	      ];
	      this.length = 3;
	    }

	    if (endian !== 'le') return;

	    // Reverse the bytes
	    this._initArray(this.toArray(), base, endian);
	  };

	  BN.prototype._initArray = function _initArray (number, base, endian) {
	    // Perhaps a Uint8Array
	    assert(typeof number.length === 'number');
	    if (number.length <= 0) {
	      this.words = [0];
	      this.length = 1;
	      return this;
	    }

	    this.length = Math.ceil(number.length / 3);
	    this.words = new Array(this.length);
	    for (var i = 0; i < this.length; i++) {
	      this.words[i] = 0;
	    }

	    var j, w;
	    var off = 0;
	    if (endian === 'be') {
	      for (i = number.length - 1, j = 0; i >= 0; i -= 3) {
	        w = number[i] | (number[i - 1] << 8) | (number[i - 2] << 16);
	        this.words[j] |= (w << off) & 0x3ffffff;
	        this.words[j + 1] = (w >>> (26 - off)) & 0x3ffffff;
	        off += 24;
	        if (off >= 26) {
	          off -= 26;
	          j++;
	        }
	      }
	    } else if (endian === 'le') {
	      for (i = 0, j = 0; i < number.length; i += 3) {
	        w = number[i] | (number[i + 1] << 8) | (number[i + 2] << 16);
	        this.words[j] |= (w << off) & 0x3ffffff;
	        this.words[j + 1] = (w >>> (26 - off)) & 0x3ffffff;
	        off += 24;
	        if (off >= 26) {
	          off -= 26;
	          j++;
	        }
	      }
	    }
	    return this._strip();
	  };

	  function parseHex4Bits (string, index) {
	    var c = string.charCodeAt(index);
	    // '0' - '9'
	    if (c >= 48 && c <= 57) {
	      return c - 48;
	    // 'A' - 'F'
	    } else if (c >= 65 && c <= 70) {
	      return c - 55;
	    // 'a' - 'f'
	    } else if (c >= 97 && c <= 102) {
	      return c - 87;
	    } else {
	      assert(false, 'Invalid character in ' + string);
	    }
	  }

	  function parseHexByte (string, lowerBound, index) {
	    var r = parseHex4Bits(string, index);
	    if (index - 1 >= lowerBound) {
	      r |= parseHex4Bits(string, index - 1) << 4;
	    }
	    return r;
	  }

	  BN.prototype._parseHex = function _parseHex (number, start, endian) {
	    // Create possibly bigger array to ensure that it fits the number
	    this.length = Math.ceil((number.length - start) / 6);
	    this.words = new Array(this.length);
	    for (var i = 0; i < this.length; i++) {
	      this.words[i] = 0;
	    }

	    // 24-bits chunks
	    var off = 0;
	    var j = 0;

	    var w;
	    if (endian === 'be') {
	      for (i = number.length - 1; i >= start; i -= 2) {
	        w = parseHexByte(number, start, i) << off;
	        this.words[j] |= w & 0x3ffffff;
	        if (off >= 18) {
	          off -= 18;
	          j += 1;
	          this.words[j] |= w >>> 26;
	        } else {
	          off += 8;
	        }
	      }
	    } else {
	      var parseLength = number.length - start;
	      for (i = parseLength % 2 === 0 ? start + 1 : start; i < number.length; i += 2) {
	        w = parseHexByte(number, start, i) << off;
	        this.words[j] |= w & 0x3ffffff;
	        if (off >= 18) {
	          off -= 18;
	          j += 1;
	          this.words[j] |= w >>> 26;
	        } else {
	          off += 8;
	        }
	      }
	    }

	    this._strip();
	  };

	  function parseBase (str, start, end, mul) {
	    var r = 0;
	    var b = 0;
	    var len = Math.min(str.length, end);
	    for (var i = start; i < len; i++) {
	      var c = str.charCodeAt(i) - 48;

	      r *= mul;

	      // 'a'
	      if (c >= 49) {
	        b = c - 49 + 0xa;

	      // 'A'
	      } else if (c >= 17) {
	        b = c - 17 + 0xa;

	      // '0' - '9'
	      } else {
	        b = c;
	      }
	      assert(c >= 0 && b < mul, 'Invalid character');
	      r += b;
	    }
	    return r;
	  }

	  BN.prototype._parseBase = function _parseBase (number, base, start) {
	    // Initialize as zero
	    this.words = [0];
	    this.length = 1;

	    // Find length of limb in base
	    for (var limbLen = 0, limbPow = 1; limbPow <= 0x3ffffff; limbPow *= base) {
	      limbLen++;
	    }
	    limbLen--;
	    limbPow = (limbPow / base) | 0;

	    var total = number.length - start;
	    var mod = total % limbLen;
	    var end = Math.min(total, total - mod) + start;

	    var word = 0;
	    for (var i = start; i < end; i += limbLen) {
	      word = parseBase(number, i, i + limbLen, base);

	      this.imuln(limbPow);
	      if (this.words[0] + word < 0x4000000) {
	        this.words[0] += word;
	      } else {
	        this._iaddn(word);
	      }
	    }

	    if (mod !== 0) {
	      var pow = 1;
	      word = parseBase(number, i, number.length, base);

	      for (i = 0; i < mod; i++) {
	        pow *= base;
	      }

	      this.imuln(pow);
	      if (this.words[0] + word < 0x4000000) {
	        this.words[0] += word;
	      } else {
	        this._iaddn(word);
	      }
	    }

	    this._strip();
	  };

	  BN.prototype.copy = function copy (dest) {
	    dest.words = new Array(this.length);
	    for (var i = 0; i < this.length; i++) {
	      dest.words[i] = this.words[i];
	    }
	    dest.length = this.length;
	    dest.negative = this.negative;
	    dest.red = this.red;
	  };

	  function move (dest, src) {
	    dest.words = src.words;
	    dest.length = src.length;
	    dest.negative = src.negative;
	    dest.red = src.red;
	  }

	  BN.prototype._move = function _move (dest) {
	    move(dest, this);
	  };

	  BN.prototype.clone = function clone () {
	    var r = new BN(null);
	    this.copy(r);
	    return r;
	  };

	  BN.prototype._expand = function _expand (size) {
	    while (this.length < size) {
	      this.words[this.length++] = 0;
	    }
	    return this;
	  };

	  // Remove leading `0` from `this`
	  BN.prototype._strip = function strip () {
	    while (this.length > 1 && this.words[this.length - 1] === 0) {
	      this.length--;
	    }
	    return this._normSign();
	  };

	  BN.prototype._normSign = function _normSign () {
	    // -0 = 0
	    if (this.length === 1 && this.words[0] === 0) {
	      this.negative = 0;
	    }
	    return this;
	  };

	  // Check Symbol.for because not everywhere where Symbol defined
	  // See https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Symbol#Browser_compatibility
	  if (typeof Symbol !== 'undefined' && typeof Symbol.for === 'function') {
	    try {
	      BN.prototype[Symbol.for('nodejs.util.inspect.custom')] = inspect;
	    } catch (e) {
	      BN.prototype.inspect = inspect;
	    }
	  } else {
	    BN.prototype.inspect = inspect;
	  }

	  function inspect () {
	    return (this.red ? '<BN-R: ' : '<BN: ') + this.toString(16) + '>';
	  }

	  /*

	  var zeros = [];
	  var groupSizes = [];
	  var groupBases = [];

	  var s = '';
	  var i = -1;
	  while (++i < BN.wordSize) {
	    zeros[i] = s;
	    s += '0';
	  }
	  groupSizes[0] = 0;
	  groupSizes[1] = 0;
	  groupBases[0] = 0;
	  groupBases[1] = 0;
	  var base = 2 - 1;
	  while (++base < 36 + 1) {
	    var groupSize = 0;
	    var groupBase = 1;
	    while (groupBase < (1 << BN.wordSize) / base) {
	      groupBase *= base;
	      groupSize += 1;
	    }
	    groupSizes[base] = groupSize;
	    groupBases[base] = groupBase;
	  }

	  */

	  var zeros = [
	    '',
	    '0',
	    '00',
	    '000',
	    '0000',
	    '00000',
	    '000000',
	    '0000000',
	    '00000000',
	    '000000000',
	    '0000000000',
	    '00000000000',
	    '000000000000',
	    '0000000000000',
	    '00000000000000',
	    '000000000000000',
	    '0000000000000000',
	    '00000000000000000',
	    '000000000000000000',
	    '0000000000000000000',
	    '00000000000000000000',
	    '000000000000000000000',
	    '0000000000000000000000',
	    '00000000000000000000000',
	    '000000000000000000000000',
	    '0000000000000000000000000'
	  ];

	  var groupSizes = [
	    0, 0,
	    25, 16, 12, 11, 10, 9, 8,
	    8, 7, 7, 7, 7, 6, 6,
	    6, 6, 6, 6, 6, 5, 5,
	    5, 5, 5, 5, 5, 5, 5,
	    5, 5, 5, 5, 5, 5, 5
	  ];

	  var groupBases = [
	    0, 0,
	    33554432, 43046721, 16777216, 48828125, 60466176, 40353607, 16777216,
	    43046721, 10000000, 19487171, 35831808, 62748517, 7529536, 11390625,
	    16777216, 24137569, 34012224, 47045881, 64000000, 4084101, 5153632,
	    6436343, 7962624, 9765625, 11881376, 14348907, 17210368, 20511149,
	    24300000, 28629151, 33554432, 39135393, 45435424, 52521875, 60466176
	  ];

	  BN.prototype.toString = function toString (base, padding) {
	    base = base || 10;
	    padding = padding | 0 || 1;

	    var out;
	    if (base === 16 || base === 'hex') {
	      out = '';
	      var off = 0;
	      var carry = 0;
	      for (var i = 0; i < this.length; i++) {
	        var w = this.words[i];
	        var word = (((w << off) | carry) & 0xffffff).toString(16);
	        carry = (w >>> (24 - off)) & 0xffffff;
	        off += 2;
	        if (off >= 26) {
	          off -= 26;
	          i--;
	        }
	        if (carry !== 0 || i !== this.length - 1) {
	          out = zeros[6 - word.length] + word + out;
	        } else {
	          out = word + out;
	        }
	      }
	      if (carry !== 0) {
	        out = carry.toString(16) + out;
	      }
	      while (out.length % padding !== 0) {
	        out = '0' + out;
	      }
	      if (this.negative !== 0) {
	        out = '-' + out;
	      }
	      return out;
	    }

	    if (base === (base | 0) && base >= 2 && base <= 36) {
	      // var groupSize = Math.floor(BN.wordSize * Math.LN2 / Math.log(base));
	      var groupSize = groupSizes[base];
	      // var groupBase = Math.pow(base, groupSize);
	      var groupBase = groupBases[base];
	      out = '';
	      var c = this.clone();
	      c.negative = 0;
	      while (!c.isZero()) {
	        var r = c.modrn(groupBase).toString(base);
	        c = c.idivn(groupBase);

	        if (!c.isZero()) {
	          out = zeros[groupSize - r.length] + r + out;
	        } else {
	          out = r + out;
	        }
	      }
	      if (this.isZero()) {
	        out = '0' + out;
	      }
	      while (out.length % padding !== 0) {
	        out = '0' + out;
	      }
	      if (this.negative !== 0) {
	        out = '-' + out;
	      }
	      return out;
	    }

	    assert(false, 'Base should be between 2 and 36');
	  };

	  BN.prototype.toNumber = function toNumber () {
	    var ret = this.words[0];
	    if (this.length === 2) {
	      ret += this.words[1] * 0x4000000;
	    } else if (this.length === 3 && this.words[2] === 0x01) {
	      // NOTE: at this stage it is known that the top bit is set
	      ret += 0x10000000000000 + (this.words[1] * 0x4000000);
	    } else if (this.length > 2) {
	      assert(false, 'Number can only safely store up to 53 bits');
	    }
	    return (this.negative !== 0) ? -ret : ret;
	  };

	  BN.prototype.toJSON = function toJSON () {
	    return this.toString(16, 2);
	  };

	  if (Buffer) {
	    BN.prototype.toBuffer = function toBuffer (endian, length) {
	      return this.toArrayLike(Buffer, endian, length);
	    };
	  }

	  BN.prototype.toArray = function toArray (endian, length) {
	    return this.toArrayLike(Array, endian, length);
	  };

	  var allocate = function allocate (ArrayType, size) {
	    if (ArrayType.allocUnsafe) {
	      return ArrayType.allocUnsafe(size);
	    }
	    return new ArrayType(size);
	  };

	  BN.prototype.toArrayLike = function toArrayLike (ArrayType, endian, length) {
	    this._strip();

	    var byteLength = this.byteLength();
	    var reqLength = length || Math.max(1, byteLength);
	    assert(byteLength <= reqLength, 'byte array longer than desired length');
	    assert(reqLength > 0, 'Requested array length <= 0');

	    var res = allocate(ArrayType, reqLength);
	    var postfix = endian === 'le' ? 'LE' : 'BE';
	    this['_toArrayLike' + postfix](res, byteLength);
	    return res;
	  };

	  BN.prototype._toArrayLikeLE = function _toArrayLikeLE (res, byteLength) {
	    var position = 0;
	    var carry = 0;

	    for (var i = 0, shift = 0; i < this.length; i++) {
	      var word = (this.words[i] << shift) | carry;

	      res[position++] = word & 0xff;
	      if (position < res.length) {
	        res[position++] = (word >> 8) & 0xff;
	      }
	      if (position < res.length) {
	        res[position++] = (word >> 16) & 0xff;
	      }

	      if (shift === 6) {
	        if (position < res.length) {
	          res[position++] = (word >> 24) & 0xff;
	        }
	        carry = 0;
	        shift = 0;
	      } else {
	        carry = word >>> 24;
	        shift += 2;
	      }
	    }

	    if (position < res.length) {
	      res[position++] = carry;

	      while (position < res.length) {
	        res[position++] = 0;
	      }
	    }
	  };

	  BN.prototype._toArrayLikeBE = function _toArrayLikeBE (res, byteLength) {
	    var position = res.length - 1;
	    var carry = 0;

	    for (var i = 0, shift = 0; i < this.length; i++) {
	      var word = (this.words[i] << shift) | carry;

	      res[position--] = word & 0xff;
	      if (position >= 0) {
	        res[position--] = (word >> 8) & 0xff;
	      }
	      if (position >= 0) {
	        res[position--] = (word >> 16) & 0xff;
	      }

	      if (shift === 6) {
	        if (position >= 0) {
	          res[position--] = (word >> 24) & 0xff;
	        }
	        carry = 0;
	        shift = 0;
	      } else {
	        carry = word >>> 24;
	        shift += 2;
	      }
	    }

	    if (position >= 0) {
	      res[position--] = carry;

	      while (position >= 0) {
	        res[position--] = 0;
	      }
	    }
	  };

	  if (Math.clz32) {
	    BN.prototype._countBits = function _countBits (w) {
	      return 32 - Math.clz32(w);
	    };
	  } else {
	    BN.prototype._countBits = function _countBits (w) {
	      var t = w;
	      var r = 0;
	      if (t >= 0x1000) {
	        r += 13;
	        t >>>= 13;
	      }
	      if (t >= 0x40) {
	        r += 7;
	        t >>>= 7;
	      }
	      if (t >= 0x8) {
	        r += 4;
	        t >>>= 4;
	      }
	      if (t >= 0x02) {
	        r += 2;
	        t >>>= 2;
	      }
	      return r + t;
	    };
	  }

	  BN.prototype._zeroBits = function _zeroBits (w) {
	    // Short-cut
	    if (w === 0) return 26;

	    var t = w;
	    var r = 0;
	    if ((t & 0x1fff) === 0) {
	      r += 13;
	      t >>>= 13;
	    }
	    if ((t & 0x7f) === 0) {
	      r += 7;
	      t >>>= 7;
	    }
	    if ((t & 0xf) === 0) {
	      r += 4;
	      t >>>= 4;
	    }
	    if ((t & 0x3) === 0) {
	      r += 2;
	      t >>>= 2;
	    }
	    if ((t & 0x1) === 0) {
	      r++;
	    }
	    return r;
	  };

	  // Return number of used bits in a BN
	  BN.prototype.bitLength = function bitLength () {
	    var w = this.words[this.length - 1];
	    var hi = this._countBits(w);
	    return (this.length - 1) * 26 + hi;
	  };

	  function toBitArray (num) {
	    var w = new Array(num.bitLength());

	    for (var bit = 0; bit < w.length; bit++) {
	      var off = (bit / 26) | 0;
	      var wbit = bit % 26;

	      w[bit] = (num.words[off] >>> wbit) & 0x01;
	    }

	    return w;
	  }

	  // Number of trailing zero bits
	  BN.prototype.zeroBits = function zeroBits () {
	    if (this.isZero()) return 0;

	    var r = 0;
	    for (var i = 0; i < this.length; i++) {
	      var b = this._zeroBits(this.words[i]);
	      r += b;
	      if (b !== 26) break;
	    }
	    return r;
	  };

	  BN.prototype.byteLength = function byteLength () {
	    return Math.ceil(this.bitLength() / 8);
	  };

	  BN.prototype.toTwos = function toTwos (width) {
	    if (this.negative !== 0) {
	      return this.abs().inotn(width).iaddn(1);
	    }
	    return this.clone();
	  };

	  BN.prototype.fromTwos = function fromTwos (width) {
	    if (this.testn(width - 1)) {
	      return this.notn(width).iaddn(1).ineg();
	    }
	    return this.clone();
	  };

	  BN.prototype.isNeg = function isNeg () {
	    return this.negative !== 0;
	  };

	  // Return negative clone of `this`
	  BN.prototype.neg = function neg () {
	    return this.clone().ineg();
	  };

	  BN.prototype.ineg = function ineg () {
	    if (!this.isZero()) {
	      this.negative ^= 1;
	    }

	    return this;
	  };

	  // Or `num` with `this` in-place
	  BN.prototype.iuor = function iuor (num) {
	    while (this.length < num.length) {
	      this.words[this.length++] = 0;
	    }

	    for (var i = 0; i < num.length; i++) {
	      this.words[i] = this.words[i] | num.words[i];
	    }

	    return this._strip();
	  };

	  BN.prototype.ior = function ior (num) {
	    assert((this.negative | num.negative) === 0);
	    return this.iuor(num);
	  };

	  // Or `num` with `this`
	  BN.prototype.or = function or (num) {
	    if (this.length > num.length) return this.clone().ior(num);
	    return num.clone().ior(this);
	  };

	  BN.prototype.uor = function uor (num) {
	    if (this.length > num.length) return this.clone().iuor(num);
	    return num.clone().iuor(this);
	  };

	  // And `num` with `this` in-place
	  BN.prototype.iuand = function iuand (num) {
	    // b = min-length(num, this)
	    var b;
	    if (this.length > num.length) {
	      b = num;
	    } else {
	      b = this;
	    }

	    for (var i = 0; i < b.length; i++) {
	      this.words[i] = this.words[i] & num.words[i];
	    }

	    this.length = b.length;

	    return this._strip();
	  };

	  BN.prototype.iand = function iand (num) {
	    assert((this.negative | num.negative) === 0);
	    return this.iuand(num);
	  };

	  // And `num` with `this`
	  BN.prototype.and = function and (num) {
	    if (this.length > num.length) return this.clone().iand(num);
	    return num.clone().iand(this);
	  };

	  BN.prototype.uand = function uand (num) {
	    if (this.length > num.length) return this.clone().iuand(num);
	    return num.clone().iuand(this);
	  };

	  // Xor `num` with `this` in-place
	  BN.prototype.iuxor = function iuxor (num) {
	    // a.length > b.length
	    var a;
	    var b;
	    if (this.length > num.length) {
	      a = this;
	      b = num;
	    } else {
	      a = num;
	      b = this;
	    }

	    for (var i = 0; i < b.length; i++) {
	      this.words[i] = a.words[i] ^ b.words[i];
	    }

	    if (this !== a) {
	      for (; i < a.length; i++) {
	        this.words[i] = a.words[i];
	      }
	    }

	    this.length = a.length;

	    return this._strip();
	  };

	  BN.prototype.ixor = function ixor (num) {
	    assert((this.negative | num.negative) === 0);
	    return this.iuxor(num);
	  };

	  // Xor `num` with `this`
	  BN.prototype.xor = function xor (num) {
	    if (this.length > num.length) return this.clone().ixor(num);
	    return num.clone().ixor(this);
	  };

	  BN.prototype.uxor = function uxor (num) {
	    if (this.length > num.length) return this.clone().iuxor(num);
	    return num.clone().iuxor(this);
	  };

	  // Not ``this`` with ``width`` bitwidth
	  BN.prototype.inotn = function inotn (width) {
	    assert(typeof width === 'number' && width >= 0);

	    var bytesNeeded = Math.ceil(width / 26) | 0;
	    var bitsLeft = width % 26;

	    // Extend the buffer with leading zeroes
	    this._expand(bytesNeeded);

	    if (bitsLeft > 0) {
	      bytesNeeded--;
	    }

	    // Handle complete words
	    for (var i = 0; i < bytesNeeded; i++) {
	      this.words[i] = ~this.words[i] & 0x3ffffff;
	    }

	    // Handle the residue
	    if (bitsLeft > 0) {
	      this.words[i] = ~this.words[i] & (0x3ffffff >> (26 - bitsLeft));
	    }

	    // And remove leading zeroes
	    return this._strip();
	  };

	  BN.prototype.notn = function notn (width) {
	    return this.clone().inotn(width);
	  };

	  // Set `bit` of `this`
	  BN.prototype.setn = function setn (bit, val) {
	    assert(typeof bit === 'number' && bit >= 0);

	    var off = (bit / 26) | 0;
	    var wbit = bit % 26;

	    this._expand(off + 1);

	    if (val) {
	      this.words[off] = this.words[off] | (1 << wbit);
	    } else {
	      this.words[off] = this.words[off] & ~(1 << wbit);
	    }

	    return this._strip();
	  };

	  // Add `num` to `this` in-place
	  BN.prototype.iadd = function iadd (num) {
	    var r;

	    // negative + positive
	    if (this.negative !== 0 && num.negative === 0) {
	      this.negative = 0;
	      r = this.isub(num);
	      this.negative ^= 1;
	      return this._normSign();

	    // positive + negative
	    } else if (this.negative === 0 && num.negative !== 0) {
	      num.negative = 0;
	      r = this.isub(num);
	      num.negative = 1;
	      return r._normSign();
	    }

	    // a.length > b.length
	    var a, b;
	    if (this.length > num.length) {
	      a = this;
	      b = num;
	    } else {
	      a = num;
	      b = this;
	    }

	    var carry = 0;
	    for (var i = 0; i < b.length; i++) {
	      r = (a.words[i] | 0) + (b.words[i] | 0) + carry;
	      this.words[i] = r & 0x3ffffff;
	      carry = r >>> 26;
	    }
	    for (; carry !== 0 && i < a.length; i++) {
	      r = (a.words[i] | 0) + carry;
	      this.words[i] = r & 0x3ffffff;
	      carry = r >>> 26;
	    }

	    this.length = a.length;
	    if (carry !== 0) {
	      this.words[this.length] = carry;
	      this.length++;
	    // Copy the rest of the words
	    } else if (a !== this) {
	      for (; i < a.length; i++) {
	        this.words[i] = a.words[i];
	      }
	    }

	    return this;
	  };

	  // Add `num` to `this`
	  BN.prototype.add = function add (num) {
	    var res;
	    if (num.negative !== 0 && this.negative === 0) {
	      num.negative = 0;
	      res = this.sub(num);
	      num.negative ^= 1;
	      return res;
	    } else if (num.negative === 0 && this.negative !== 0) {
	      this.negative = 0;
	      res = num.sub(this);
	      this.negative = 1;
	      return res;
	    }

	    if (this.length > num.length) return this.clone().iadd(num);

	    return num.clone().iadd(this);
	  };

	  // Subtract `num` from `this` in-place
	  BN.prototype.isub = function isub (num) {
	    // this - (-num) = this + num
	    if (num.negative !== 0) {
	      num.negative = 0;
	      var r = this.iadd(num);
	      num.negative = 1;
	      return r._normSign();

	    // -this - num = -(this + num)
	    } else if (this.negative !== 0) {
	      this.negative = 0;
	      this.iadd(num);
	      this.negative = 1;
	      return this._normSign();
	    }

	    // At this point both numbers are positive
	    var cmp = this.cmp(num);

	    // Optimization - zeroify
	    if (cmp === 0) {
	      this.negative = 0;
	      this.length = 1;
	      this.words[0] = 0;
	      return this;
	    }

	    // a > b
	    var a, b;
	    if (cmp > 0) {
	      a = this;
	      b = num;
	    } else {
	      a = num;
	      b = this;
	    }

	    var carry = 0;
	    for (var i = 0; i < b.length; i++) {
	      r = (a.words[i] | 0) - (b.words[i] | 0) + carry;
	      carry = r >> 26;
	      this.words[i] = r & 0x3ffffff;
	    }
	    for (; carry !== 0 && i < a.length; i++) {
	      r = (a.words[i] | 0) + carry;
	      carry = r >> 26;
	      this.words[i] = r & 0x3ffffff;
	    }

	    // Copy rest of the words
	    if (carry === 0 && i < a.length && a !== this) {
	      for (; i < a.length; i++) {
	        this.words[i] = a.words[i];
	      }
	    }

	    this.length = Math.max(this.length, i);

	    if (a !== this) {
	      this.negative = 1;
	    }

	    return this._strip();
	  };

	  // Subtract `num` from `this`
	  BN.prototype.sub = function sub (num) {
	    return this.clone().isub(num);
	  };

	  function smallMulTo (self, num, out) {
	    out.negative = num.negative ^ self.negative;
	    var len = (self.length + num.length) | 0;
	    out.length = len;
	    len = (len - 1) | 0;

	    // Peel one iteration (compiler can't do it, because of code complexity)
	    var a = self.words[0] | 0;
	    var b = num.words[0] | 0;
	    var r = a * b;

	    var lo = r & 0x3ffffff;
	    var carry = (r / 0x4000000) | 0;
	    out.words[0] = lo;

	    for (var k = 1; k < len; k++) {
	      // Sum all words with the same `i + j = k` and accumulate `ncarry`,
	      // note that ncarry could be >= 0x3ffffff
	      var ncarry = carry >>> 26;
	      var rword = carry & 0x3ffffff;
	      var maxJ = Math.min(k, num.length - 1);
	      for (var j = Math.max(0, k - self.length + 1); j <= maxJ; j++) {
	        var i = (k - j) | 0;
	        a = self.words[i] | 0;
	        b = num.words[j] | 0;
	        r = a * b + rword;
	        ncarry += (r / 0x4000000) | 0;
	        rword = r & 0x3ffffff;
	      }
	      out.words[k] = rword | 0;
	      carry = ncarry | 0;
	    }
	    if (carry !== 0) {
	      out.words[k] = carry | 0;
	    } else {
	      out.length--;
	    }

	    return out._strip();
	  }

	  // TODO(indutny): it may be reasonable to omit it for users who don't need
	  // to work with 256-bit numbers, otherwise it gives 20% improvement for 256-bit
	  // multiplication (like elliptic secp256k1).
	  var comb10MulTo = function comb10MulTo (self, num, out) {
	    var a = self.words;
	    var b = num.words;
	    var o = out.words;
	    var c = 0;
	    var lo;
	    var mid;
	    var hi;
	    var a0 = a[0] | 0;
	    var al0 = a0 & 0x1fff;
	    var ah0 = a0 >>> 13;
	    var a1 = a[1] | 0;
	    var al1 = a1 & 0x1fff;
	    var ah1 = a1 >>> 13;
	    var a2 = a[2] | 0;
	    var al2 = a2 & 0x1fff;
	    var ah2 = a2 >>> 13;
	    var a3 = a[3] | 0;
	    var al3 = a3 & 0x1fff;
	    var ah3 = a3 >>> 13;
	    var a4 = a[4] | 0;
	    var al4 = a4 & 0x1fff;
	    var ah4 = a4 >>> 13;
	    var a5 = a[5] | 0;
	    var al5 = a5 & 0x1fff;
	    var ah5 = a5 >>> 13;
	    var a6 = a[6] | 0;
	    var al6 = a6 & 0x1fff;
	    var ah6 = a6 >>> 13;
	    var a7 = a[7] | 0;
	    var al7 = a7 & 0x1fff;
	    var ah7 = a7 >>> 13;
	    var a8 = a[8] | 0;
	    var al8 = a8 & 0x1fff;
	    var ah8 = a8 >>> 13;
	    var a9 = a[9] | 0;
	    var al9 = a9 & 0x1fff;
	    var ah9 = a9 >>> 13;
	    var b0 = b[0] | 0;
	    var bl0 = b0 & 0x1fff;
	    var bh0 = b0 >>> 13;
	    var b1 = b[1] | 0;
	    var bl1 = b1 & 0x1fff;
	    var bh1 = b1 >>> 13;
	    var b2 = b[2] | 0;
	    var bl2 = b2 & 0x1fff;
	    var bh2 = b2 >>> 13;
	    var b3 = b[3] | 0;
	    var bl3 = b3 & 0x1fff;
	    var bh3 = b3 >>> 13;
	    var b4 = b[4] | 0;
	    var bl4 = b4 & 0x1fff;
	    var bh4 = b4 >>> 13;
	    var b5 = b[5] | 0;
	    var bl5 = b5 & 0x1fff;
	    var bh5 = b5 >>> 13;
	    var b6 = b[6] | 0;
	    var bl6 = b6 & 0x1fff;
	    var bh6 = b6 >>> 13;
	    var b7 = b[7] | 0;
	    var bl7 = b7 & 0x1fff;
	    var bh7 = b7 >>> 13;
	    var b8 = b[8] | 0;
	    var bl8 = b8 & 0x1fff;
	    var bh8 = b8 >>> 13;
	    var b9 = b[9] | 0;
	    var bl9 = b9 & 0x1fff;
	    var bh9 = b9 >>> 13;

	    out.negative = self.negative ^ num.negative;
	    out.length = 19;
	    /* k = 0 */
	    lo = Math.imul(al0, bl0);
	    mid = Math.imul(al0, bh0);
	    mid = (mid + Math.imul(ah0, bl0)) | 0;
	    hi = Math.imul(ah0, bh0);
	    var w0 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
	    c = (((hi + (mid >>> 13)) | 0) + (w0 >>> 26)) | 0;
	    w0 &= 0x3ffffff;
	    /* k = 1 */
	    lo = Math.imul(al1, bl0);
	    mid = Math.imul(al1, bh0);
	    mid = (mid + Math.imul(ah1, bl0)) | 0;
	    hi = Math.imul(ah1, bh0);
	    lo = (lo + Math.imul(al0, bl1)) | 0;
	    mid = (mid + Math.imul(al0, bh1)) | 0;
	    mid = (mid + Math.imul(ah0, bl1)) | 0;
	    hi = (hi + Math.imul(ah0, bh1)) | 0;
	    var w1 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
	    c = (((hi + (mid >>> 13)) | 0) + (w1 >>> 26)) | 0;
	    w1 &= 0x3ffffff;
	    /* k = 2 */
	    lo = Math.imul(al2, bl0);
	    mid = Math.imul(al2, bh0);
	    mid = (mid + Math.imul(ah2, bl0)) | 0;
	    hi = Math.imul(ah2, bh0);
	    lo = (lo + Math.imul(al1, bl1)) | 0;
	    mid = (mid + Math.imul(al1, bh1)) | 0;
	    mid = (mid + Math.imul(ah1, bl1)) | 0;
	    hi = (hi + Math.imul(ah1, bh1)) | 0;
	    lo = (lo + Math.imul(al0, bl2)) | 0;
	    mid = (mid + Math.imul(al0, bh2)) | 0;
	    mid = (mid + Math.imul(ah0, bl2)) | 0;
	    hi = (hi + Math.imul(ah0, bh2)) | 0;
	    var w2 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
	    c = (((hi + (mid >>> 13)) | 0) + (w2 >>> 26)) | 0;
	    w2 &= 0x3ffffff;
	    /* k = 3 */
	    lo = Math.imul(al3, bl0);
	    mid = Math.imul(al3, bh0);
	    mid = (mid + Math.imul(ah3, bl0)) | 0;
	    hi = Math.imul(ah3, bh0);
	    lo = (lo + Math.imul(al2, bl1)) | 0;
	    mid = (mid + Math.imul(al2, bh1)) | 0;
	    mid = (mid + Math.imul(ah2, bl1)) | 0;
	    hi = (hi + Math.imul(ah2, bh1)) | 0;
	    lo = (lo + Math.imul(al1, bl2)) | 0;
	    mid = (mid + Math.imul(al1, bh2)) | 0;
	    mid = (mid + Math.imul(ah1, bl2)) | 0;
	    hi = (hi + Math.imul(ah1, bh2)) | 0;
	    lo = (lo + Math.imul(al0, bl3)) | 0;
	    mid = (mid + Math.imul(al0, bh3)) | 0;
	    mid = (mid + Math.imul(ah0, bl3)) | 0;
	    hi = (hi + Math.imul(ah0, bh3)) | 0;
	    var w3 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
	    c = (((hi + (mid >>> 13)) | 0) + (w3 >>> 26)) | 0;
	    w3 &= 0x3ffffff;
	    /* k = 4 */
	    lo = Math.imul(al4, bl0);
	    mid = Math.imul(al4, bh0);
	    mid = (mid + Math.imul(ah4, bl0)) | 0;
	    hi = Math.imul(ah4, bh0);
	    lo = (lo + Math.imul(al3, bl1)) | 0;
	    mid = (mid + Math.imul(al3, bh1)) | 0;
	    mid = (mid + Math.imul(ah3, bl1)) | 0;
	    hi = (hi + Math.imul(ah3, bh1)) | 0;
	    lo = (lo + Math.imul(al2, bl2)) | 0;
	    mid = (mid + Math.imul(al2, bh2)) | 0;
	    mid = (mid + Math.imul(ah2, bl2)) | 0;
	    hi = (hi + Math.imul(ah2, bh2)) | 0;
	    lo = (lo + Math.imul(al1, bl3)) | 0;
	    mid = (mid + Math.imul(al1, bh3)) | 0;
	    mid = (mid + Math.imul(ah1, bl3)) | 0;
	    hi = (hi + Math.imul(ah1, bh3)) | 0;
	    lo = (lo + Math.imul(al0, bl4)) | 0;
	    mid = (mid + Math.imul(al0, bh4)) | 0;
	    mid = (mid + Math.imul(ah0, bl4)) | 0;
	    hi = (hi + Math.imul(ah0, bh4)) | 0;
	    var w4 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
	    c = (((hi + (mid >>> 13)) | 0) + (w4 >>> 26)) | 0;
	    w4 &= 0x3ffffff;
	    /* k = 5 */
	    lo = Math.imul(al5, bl0);
	    mid = Math.imul(al5, bh0);
	    mid = (mid + Math.imul(ah5, bl0)) | 0;
	    hi = Math.imul(ah5, bh0);
	    lo = (lo + Math.imul(al4, bl1)) | 0;
	    mid = (mid + Math.imul(al4, bh1)) | 0;
	    mid = (mid + Math.imul(ah4, bl1)) | 0;
	    hi = (hi + Math.imul(ah4, bh1)) | 0;
	    lo = (lo + Math.imul(al3, bl2)) | 0;
	    mid = (mid + Math.imul(al3, bh2)) | 0;
	    mid = (mid + Math.imul(ah3, bl2)) | 0;
	    hi = (hi + Math.imul(ah3, bh2)) | 0;
	    lo = (lo + Math.imul(al2, bl3)) | 0;
	    mid = (mid + Math.imul(al2, bh3)) | 0;
	    mid = (mid + Math.imul(ah2, bl3)) | 0;
	    hi = (hi + Math.imul(ah2, bh3)) | 0;
	    lo = (lo + Math.imul(al1, bl4)) | 0;
	    mid = (mid + Math.imul(al1, bh4)) | 0;
	    mid = (mid + Math.imul(ah1, bl4)) | 0;
	    hi = (hi + Math.imul(ah1, bh4)) | 0;
	    lo = (lo + Math.imul(al0, bl5)) | 0;
	    mid = (mid + Math.imul(al0, bh5)) | 0;
	    mid = (mid + Math.imul(ah0, bl5)) | 0;
	    hi = (hi + Math.imul(ah0, bh5)) | 0;
	    var w5 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
	    c = (((hi + (mid >>> 13)) | 0) + (w5 >>> 26)) | 0;
	    w5 &= 0x3ffffff;
	    /* k = 6 */
	    lo = Math.imul(al6, bl0);
	    mid = Math.imul(al6, bh0);
	    mid = (mid + Math.imul(ah6, bl0)) | 0;
	    hi = Math.imul(ah6, bh0);
	    lo = (lo + Math.imul(al5, bl1)) | 0;
	    mid = (mid + Math.imul(al5, bh1)) | 0;
	    mid = (mid + Math.imul(ah5, bl1)) | 0;
	    hi = (hi + Math.imul(ah5, bh1)) | 0;
	    lo = (lo + Math.imul(al4, bl2)) | 0;
	    mid = (mid + Math.imul(al4, bh2)) | 0;
	    mid = (mid + Math.imul(ah4, bl2)) | 0;
	    hi = (hi + Math.imul(ah4, bh2)) | 0;
	    lo = (lo + Math.imul(al3, bl3)) | 0;
	    mid = (mid + Math.imul(al3, bh3)) | 0;
	    mid = (mid + Math.imul(ah3, bl3)) | 0;
	    hi = (hi + Math.imul(ah3, bh3)) | 0;
	    lo = (lo + Math.imul(al2, bl4)) | 0;
	    mid = (mid + Math.imul(al2, bh4)) | 0;
	    mid = (mid + Math.imul(ah2, bl4)) | 0;
	    hi = (hi + Math.imul(ah2, bh4)) | 0;
	    lo = (lo + Math.imul(al1, bl5)) | 0;
	    mid = (mid + Math.imul(al1, bh5)) | 0;
	    mid = (mid + Math.imul(ah1, bl5)) | 0;
	    hi = (hi + Math.imul(ah1, bh5)) | 0;
	    lo = (lo + Math.imul(al0, bl6)) | 0;
	    mid = (mid + Math.imul(al0, bh6)) | 0;
	    mid = (mid + Math.imul(ah0, bl6)) | 0;
	    hi = (hi + Math.imul(ah0, bh6)) | 0;
	    var w6 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
	    c = (((hi + (mid >>> 13)) | 0) + (w6 >>> 26)) | 0;
	    w6 &= 0x3ffffff;
	    /* k = 7 */
	    lo = Math.imul(al7, bl0);
	    mid = Math.imul(al7, bh0);
	    mid = (mid + Math.imul(ah7, bl0)) | 0;
	    hi = Math.imul(ah7, bh0);
	    lo = (lo + Math.imul(al6, bl1)) | 0;
	    mid = (mid + Math.imul(al6, bh1)) | 0;
	    mid = (mid + Math.imul(ah6, bl1)) | 0;
	    hi = (hi + Math.imul(ah6, bh1)) | 0;
	    lo = (lo + Math.imul(al5, bl2)) | 0;
	    mid = (mid + Math.imul(al5, bh2)) | 0;
	    mid = (mid + Math.imul(ah5, bl2)) | 0;
	    hi = (hi + Math.imul(ah5, bh2)) | 0;
	    lo = (lo + Math.imul(al4, bl3)) | 0;
	    mid = (mid + Math.imul(al4, bh3)) | 0;
	    mid = (mid + Math.imul(ah4, bl3)) | 0;
	    hi = (hi + Math.imul(ah4, bh3)) | 0;
	    lo = (lo + Math.imul(al3, bl4)) | 0;
	    mid = (mid + Math.imul(al3, bh4)) | 0;
	    mid = (mid + Math.imul(ah3, bl4)) | 0;
	    hi = (hi + Math.imul(ah3, bh4)) | 0;
	    lo = (lo + Math.imul(al2, bl5)) | 0;
	    mid = (mid + Math.imul(al2, bh5)) | 0;
	    mid = (mid + Math.imul(ah2, bl5)) | 0;
	    hi = (hi + Math.imul(ah2, bh5)) | 0;
	    lo = (lo + Math.imul(al1, bl6)) | 0;
	    mid = (mid + Math.imul(al1, bh6)) | 0;
	    mid = (mid + Math.imul(ah1, bl6)) | 0;
	    hi = (hi + Math.imul(ah1, bh6)) | 0;
	    lo = (lo + Math.imul(al0, bl7)) | 0;
	    mid = (mid + Math.imul(al0, bh7)) | 0;
	    mid = (mid + Math.imul(ah0, bl7)) | 0;
	    hi = (hi + Math.imul(ah0, bh7)) | 0;
	    var w7 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
	    c = (((hi + (mid >>> 13)) | 0) + (w7 >>> 26)) | 0;
	    w7 &= 0x3ffffff;
	    /* k = 8 */
	    lo = Math.imul(al8, bl0);
	    mid = Math.imul(al8, bh0);
	    mid = (mid + Math.imul(ah8, bl0)) | 0;
	    hi = Math.imul(ah8, bh0);
	    lo = (lo + Math.imul(al7, bl1)) | 0;
	    mid = (mid + Math.imul(al7, bh1)) | 0;
	    mid = (mid + Math.imul(ah7, bl1)) | 0;
	    hi = (hi + Math.imul(ah7, bh1)) | 0;
	    lo = (lo + Math.imul(al6, bl2)) | 0;
	    mid = (mid + Math.imul(al6, bh2)) | 0;
	    mid = (mid + Math.imul(ah6, bl2)) | 0;
	    hi = (hi + Math.imul(ah6, bh2)) | 0;
	    lo = (lo + Math.imul(al5, bl3)) | 0;
	    mid = (mid + Math.imul(al5, bh3)) | 0;
	    mid = (mid + Math.imul(ah5, bl3)) | 0;
	    hi = (hi + Math.imul(ah5, bh3)) | 0;
	    lo = (lo + Math.imul(al4, bl4)) | 0;
	    mid = (mid + Math.imul(al4, bh4)) | 0;
	    mid = (mid + Math.imul(ah4, bl4)) | 0;
	    hi = (hi + Math.imul(ah4, bh4)) | 0;
	    lo = (lo + Math.imul(al3, bl5)) | 0;
	    mid = (mid + Math.imul(al3, bh5)) | 0;
	    mid = (mid + Math.imul(ah3, bl5)) | 0;
	    hi = (hi + Math.imul(ah3, bh5)) | 0;
	    lo = (lo + Math.imul(al2, bl6)) | 0;
	    mid = (mid + Math.imul(al2, bh6)) | 0;
	    mid = (mid + Math.imul(ah2, bl6)) | 0;
	    hi = (hi + Math.imul(ah2, bh6)) | 0;
	    lo = (lo + Math.imul(al1, bl7)) | 0;
	    mid = (mid + Math.imul(al1, bh7)) | 0;
	    mid = (mid + Math.imul(ah1, bl7)) | 0;
	    hi = (hi + Math.imul(ah1, bh7)) | 0;
	    lo = (lo + Math.imul(al0, bl8)) | 0;
	    mid = (mid + Math.imul(al0, bh8)) | 0;
	    mid = (mid + Math.imul(ah0, bl8)) | 0;
	    hi = (hi + Math.imul(ah0, bh8)) | 0;
	    var w8 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
	    c = (((hi + (mid >>> 13)) | 0) + (w8 >>> 26)) | 0;
	    w8 &= 0x3ffffff;
	    /* k = 9 */
	    lo = Math.imul(al9, bl0);
	    mid = Math.imul(al9, bh0);
	    mid = (mid + Math.imul(ah9, bl0)) | 0;
	    hi = Math.imul(ah9, bh0);
	    lo = (lo + Math.imul(al8, bl1)) | 0;
	    mid = (mid + Math.imul(al8, bh1)) | 0;
	    mid = (mid + Math.imul(ah8, bl1)) | 0;
	    hi = (hi + Math.imul(ah8, bh1)) | 0;
	    lo = (lo + Math.imul(al7, bl2)) | 0;
	    mid = (mid + Math.imul(al7, bh2)) | 0;
	    mid = (mid + Math.imul(ah7, bl2)) | 0;
	    hi = (hi + Math.imul(ah7, bh2)) | 0;
	    lo = (lo + Math.imul(al6, bl3)) | 0;
	    mid = (mid + Math.imul(al6, bh3)) | 0;
	    mid = (mid + Math.imul(ah6, bl3)) | 0;
	    hi = (hi + Math.imul(ah6, bh3)) | 0;
	    lo = (lo + Math.imul(al5, bl4)) | 0;
	    mid = (mid + Math.imul(al5, bh4)) | 0;
	    mid = (mid + Math.imul(ah5, bl4)) | 0;
	    hi = (hi + Math.imul(ah5, bh4)) | 0;
	    lo = (lo + Math.imul(al4, bl5)) | 0;
	    mid = (mid + Math.imul(al4, bh5)) | 0;
	    mid = (mid + Math.imul(ah4, bl5)) | 0;
	    hi = (hi + Math.imul(ah4, bh5)) | 0;
	    lo = (lo + Math.imul(al3, bl6)) | 0;
	    mid = (mid + Math.imul(al3, bh6)) | 0;
	    mid = (mid + Math.imul(ah3, bl6)) | 0;
	    hi = (hi + Math.imul(ah3, bh6)) | 0;
	    lo = (lo + Math.imul(al2, bl7)) | 0;
	    mid = (mid + Math.imul(al2, bh7)) | 0;
	    mid = (mid + Math.imul(ah2, bl7)) | 0;
	    hi = (hi + Math.imul(ah2, bh7)) | 0;
	    lo = (lo + Math.imul(al1, bl8)) | 0;
	    mid = (mid + Math.imul(al1, bh8)) | 0;
	    mid = (mid + Math.imul(ah1, bl8)) | 0;
	    hi = (hi + Math.imul(ah1, bh8)) | 0;
	    lo = (lo + Math.imul(al0, bl9)) | 0;
	    mid = (mid + Math.imul(al0, bh9)) | 0;
	    mid = (mid + Math.imul(ah0, bl9)) | 0;
	    hi = (hi + Math.imul(ah0, bh9)) | 0;
	    var w9 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
	    c = (((hi + (mid >>> 13)) | 0) + (w9 >>> 26)) | 0;
	    w9 &= 0x3ffffff;
	    /* k = 10 */
	    lo = Math.imul(al9, bl1);
	    mid = Math.imul(al9, bh1);
	    mid = (mid + Math.imul(ah9, bl1)) | 0;
	    hi = Math.imul(ah9, bh1);
	    lo = (lo + Math.imul(al8, bl2)) | 0;
	    mid = (mid + Math.imul(al8, bh2)) | 0;
	    mid = (mid + Math.imul(ah8, bl2)) | 0;
	    hi = (hi + Math.imul(ah8, bh2)) | 0;
	    lo = (lo + Math.imul(al7, bl3)) | 0;
	    mid = (mid + Math.imul(al7, bh3)) | 0;
	    mid = (mid + Math.imul(ah7, bl3)) | 0;
	    hi = (hi + Math.imul(ah7, bh3)) | 0;
	    lo = (lo + Math.imul(al6, bl4)) | 0;
	    mid = (mid + Math.imul(al6, bh4)) | 0;
	    mid = (mid + Math.imul(ah6, bl4)) | 0;
	    hi = (hi + Math.imul(ah6, bh4)) | 0;
	    lo = (lo + Math.imul(al5, bl5)) | 0;
	    mid = (mid + Math.imul(al5, bh5)) | 0;
	    mid = (mid + Math.imul(ah5, bl5)) | 0;
	    hi = (hi + Math.imul(ah5, bh5)) | 0;
	    lo = (lo + Math.imul(al4, bl6)) | 0;
	    mid = (mid + Math.imul(al4, bh6)) | 0;
	    mid = (mid + Math.imul(ah4, bl6)) | 0;
	    hi = (hi + Math.imul(ah4, bh6)) | 0;
	    lo = (lo + Math.imul(al3, bl7)) | 0;
	    mid = (mid + Math.imul(al3, bh7)) | 0;
	    mid = (mid + Math.imul(ah3, bl7)) | 0;
	    hi = (hi + Math.imul(ah3, bh7)) | 0;
	    lo = (lo + Math.imul(al2, bl8)) | 0;
	    mid = (mid + Math.imul(al2, bh8)) | 0;
	    mid = (mid + Math.imul(ah2, bl8)) | 0;
	    hi = (hi + Math.imul(ah2, bh8)) | 0;
	    lo = (lo + Math.imul(al1, bl9)) | 0;
	    mid = (mid + Math.imul(al1, bh9)) | 0;
	    mid = (mid + Math.imul(ah1, bl9)) | 0;
	    hi = (hi + Math.imul(ah1, bh9)) | 0;
	    var w10 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
	    c = (((hi + (mid >>> 13)) | 0) + (w10 >>> 26)) | 0;
	    w10 &= 0x3ffffff;
	    /* k = 11 */
	    lo = Math.imul(al9, bl2);
	    mid = Math.imul(al9, bh2);
	    mid = (mid + Math.imul(ah9, bl2)) | 0;
	    hi = Math.imul(ah9, bh2);
	    lo = (lo + Math.imul(al8, bl3)) | 0;
	    mid = (mid + Math.imul(al8, bh3)) | 0;
	    mid = (mid + Math.imul(ah8, bl3)) | 0;
	    hi = (hi + Math.imul(ah8, bh3)) | 0;
	    lo = (lo + Math.imul(al7, bl4)) | 0;
	    mid = (mid + Math.imul(al7, bh4)) | 0;
	    mid = (mid + Math.imul(ah7, bl4)) | 0;
	    hi = (hi + Math.imul(ah7, bh4)) | 0;
	    lo = (lo + Math.imul(al6, bl5)) | 0;
	    mid = (mid + Math.imul(al6, bh5)) | 0;
	    mid = (mid + Math.imul(ah6, bl5)) | 0;
	    hi = (hi + Math.imul(ah6, bh5)) | 0;
	    lo = (lo + Math.imul(al5, bl6)) | 0;
	    mid = (mid + Math.imul(al5, bh6)) | 0;
	    mid = (mid + Math.imul(ah5, bl6)) | 0;
	    hi = (hi + Math.imul(ah5, bh6)) | 0;
	    lo = (lo + Math.imul(al4, bl7)) | 0;
	    mid = (mid + Math.imul(al4, bh7)) | 0;
	    mid = (mid + Math.imul(ah4, bl7)) | 0;
	    hi = (hi + Math.imul(ah4, bh7)) | 0;
	    lo = (lo + Math.imul(al3, bl8)) | 0;
	    mid = (mid + Math.imul(al3, bh8)) | 0;
	    mid = (mid + Math.imul(ah3, bl8)) | 0;
	    hi = (hi + Math.imul(ah3, bh8)) | 0;
	    lo = (lo + Math.imul(al2, bl9)) | 0;
	    mid = (mid + Math.imul(al2, bh9)) | 0;
	    mid = (mid + Math.imul(ah2, bl9)) | 0;
	    hi = (hi + Math.imul(ah2, bh9)) | 0;
	    var w11 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
	    c = (((hi + (mid >>> 13)) | 0) + (w11 >>> 26)) | 0;
	    w11 &= 0x3ffffff;
	    /* k = 12 */
	    lo = Math.imul(al9, bl3);
	    mid = Math.imul(al9, bh3);
	    mid = (mid + Math.imul(ah9, bl3)) | 0;
	    hi = Math.imul(ah9, bh3);
	    lo = (lo + Math.imul(al8, bl4)) | 0;
	    mid = (mid + Math.imul(al8, bh4)) | 0;
	    mid = (mid + Math.imul(ah8, bl4)) | 0;
	    hi = (hi + Math.imul(ah8, bh4)) | 0;
	    lo = (lo + Math.imul(al7, bl5)) | 0;
	    mid = (mid + Math.imul(al7, bh5)) | 0;
	    mid = (mid + Math.imul(ah7, bl5)) | 0;
	    hi = (hi + Math.imul(ah7, bh5)) | 0;
	    lo = (lo + Math.imul(al6, bl6)) | 0;
	    mid = (mid + Math.imul(al6, bh6)) | 0;
	    mid = (mid + Math.imul(ah6, bl6)) | 0;
	    hi = (hi + Math.imul(ah6, bh6)) | 0;
	    lo = (lo + Math.imul(al5, bl7)) | 0;
	    mid = (mid + Math.imul(al5, bh7)) | 0;
	    mid = (mid + Math.imul(ah5, bl7)) | 0;
	    hi = (hi + Math.imul(ah5, bh7)) | 0;
	    lo = (lo + Math.imul(al4, bl8)) | 0;
	    mid = (mid + Math.imul(al4, bh8)) | 0;
	    mid = (mid + Math.imul(ah4, bl8)) | 0;
	    hi = (hi + Math.imul(ah4, bh8)) | 0;
	    lo = (lo + Math.imul(al3, bl9)) | 0;
	    mid = (mid + Math.imul(al3, bh9)) | 0;
	    mid = (mid + Math.imul(ah3, bl9)) | 0;
	    hi = (hi + Math.imul(ah3, bh9)) | 0;
	    var w12 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
	    c = (((hi + (mid >>> 13)) | 0) + (w12 >>> 26)) | 0;
	    w12 &= 0x3ffffff;
	    /* k = 13 */
	    lo = Math.imul(al9, bl4);
	    mid = Math.imul(al9, bh4);
	    mid = (mid + Math.imul(ah9, bl4)) | 0;
	    hi = Math.imul(ah9, bh4);
	    lo = (lo + Math.imul(al8, bl5)) | 0;
	    mid = (mid + Math.imul(al8, bh5)) | 0;
	    mid = (mid + Math.imul(ah8, bl5)) | 0;
	    hi = (hi + Math.imul(ah8, bh5)) | 0;
	    lo = (lo + Math.imul(al7, bl6)) | 0;
	    mid = (mid + Math.imul(al7, bh6)) | 0;
	    mid = (mid + Math.imul(ah7, bl6)) | 0;
	    hi = (hi + Math.imul(ah7, bh6)) | 0;
	    lo = (lo + Math.imul(al6, bl7)) | 0;
	    mid = (mid + Math.imul(al6, bh7)) | 0;
	    mid = (mid + Math.imul(ah6, bl7)) | 0;
	    hi = (hi + Math.imul(ah6, bh7)) | 0;
	    lo = (lo + Math.imul(al5, bl8)) | 0;
	    mid = (mid + Math.imul(al5, bh8)) | 0;
	    mid = (mid + Math.imul(ah5, bl8)) | 0;
	    hi = (hi + Math.imul(ah5, bh8)) | 0;
	    lo = (lo + Math.imul(al4, bl9)) | 0;
	    mid = (mid + Math.imul(al4, bh9)) | 0;
	    mid = (mid + Math.imul(ah4, bl9)) | 0;
	    hi = (hi + Math.imul(ah4, bh9)) | 0;
	    var w13 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
	    c = (((hi + (mid >>> 13)) | 0) + (w13 >>> 26)) | 0;
	    w13 &= 0x3ffffff;
	    /* k = 14 */
	    lo = Math.imul(al9, bl5);
	    mid = Math.imul(al9, bh5);
	    mid = (mid + Math.imul(ah9, bl5)) | 0;
	    hi = Math.imul(ah9, bh5);
	    lo = (lo + Math.imul(al8, bl6)) | 0;
	    mid = (mid + Math.imul(al8, bh6)) | 0;
	    mid = (mid + Math.imul(ah8, bl6)) | 0;
	    hi = (hi + Math.imul(ah8, bh6)) | 0;
	    lo = (lo + Math.imul(al7, bl7)) | 0;
	    mid = (mid + Math.imul(al7, bh7)) | 0;
	    mid = (mid + Math.imul(ah7, bl7)) | 0;
	    hi = (hi + Math.imul(ah7, bh7)) | 0;
	    lo = (lo + Math.imul(al6, bl8)) | 0;
	    mid = (mid + Math.imul(al6, bh8)) | 0;
	    mid = (mid + Math.imul(ah6, bl8)) | 0;
	    hi = (hi + Math.imul(ah6, bh8)) | 0;
	    lo = (lo + Math.imul(al5, bl9)) | 0;
	    mid = (mid + Math.imul(al5, bh9)) | 0;
	    mid = (mid + Math.imul(ah5, bl9)) | 0;
	    hi = (hi + Math.imul(ah5, bh9)) | 0;
	    var w14 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
	    c = (((hi + (mid >>> 13)) | 0) + (w14 >>> 26)) | 0;
	    w14 &= 0x3ffffff;
	    /* k = 15 */
	    lo = Math.imul(al9, bl6);
	    mid = Math.imul(al9, bh6);
	    mid = (mid + Math.imul(ah9, bl6)) | 0;
	    hi = Math.imul(ah9, bh6);
	    lo = (lo + Math.imul(al8, bl7)) | 0;
	    mid = (mid + Math.imul(al8, bh7)) | 0;
	    mid = (mid + Math.imul(ah8, bl7)) | 0;
	    hi = (hi + Math.imul(ah8, bh7)) | 0;
	    lo = (lo + Math.imul(al7, bl8)) | 0;
	    mid = (mid + Math.imul(al7, bh8)) | 0;
	    mid = (mid + Math.imul(ah7, bl8)) | 0;
	    hi = (hi + Math.imul(ah7, bh8)) | 0;
	    lo = (lo + Math.imul(al6, bl9)) | 0;
	    mid = (mid + Math.imul(al6, bh9)) | 0;
	    mid = (mid + Math.imul(ah6, bl9)) | 0;
	    hi = (hi + Math.imul(ah6, bh9)) | 0;
	    var w15 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
	    c = (((hi + (mid >>> 13)) | 0) + (w15 >>> 26)) | 0;
	    w15 &= 0x3ffffff;
	    /* k = 16 */
	    lo = Math.imul(al9, bl7);
	    mid = Math.imul(al9, bh7);
	    mid = (mid + Math.imul(ah9, bl7)) | 0;
	    hi = Math.imul(ah9, bh7);
	    lo = (lo + Math.imul(al8, bl8)) | 0;
	    mid = (mid + Math.imul(al8, bh8)) | 0;
	    mid = (mid + Math.imul(ah8, bl8)) | 0;
	    hi = (hi + Math.imul(ah8, bh8)) | 0;
	    lo = (lo + Math.imul(al7, bl9)) | 0;
	    mid = (mid + Math.imul(al7, bh9)) | 0;
	    mid = (mid + Math.imul(ah7, bl9)) | 0;
	    hi = (hi + Math.imul(ah7, bh9)) | 0;
	    var w16 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
	    c = (((hi + (mid >>> 13)) | 0) + (w16 >>> 26)) | 0;
	    w16 &= 0x3ffffff;
	    /* k = 17 */
	    lo = Math.imul(al9, bl8);
	    mid = Math.imul(al9, bh8);
	    mid = (mid + Math.imul(ah9, bl8)) | 0;
	    hi = Math.imul(ah9, bh8);
	    lo = (lo + Math.imul(al8, bl9)) | 0;
	    mid = (mid + Math.imul(al8, bh9)) | 0;
	    mid = (mid + Math.imul(ah8, bl9)) | 0;
	    hi = (hi + Math.imul(ah8, bh9)) | 0;
	    var w17 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
	    c = (((hi + (mid >>> 13)) | 0) + (w17 >>> 26)) | 0;
	    w17 &= 0x3ffffff;
	    /* k = 18 */
	    lo = Math.imul(al9, bl9);
	    mid = Math.imul(al9, bh9);
	    mid = (mid + Math.imul(ah9, bl9)) | 0;
	    hi = Math.imul(ah9, bh9);
	    var w18 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
	    c = (((hi + (mid >>> 13)) | 0) + (w18 >>> 26)) | 0;
	    w18 &= 0x3ffffff;
	    o[0] = w0;
	    o[1] = w1;
	    o[2] = w2;
	    o[3] = w3;
	    o[4] = w4;
	    o[5] = w5;
	    o[6] = w6;
	    o[7] = w7;
	    o[8] = w8;
	    o[9] = w9;
	    o[10] = w10;
	    o[11] = w11;
	    o[12] = w12;
	    o[13] = w13;
	    o[14] = w14;
	    o[15] = w15;
	    o[16] = w16;
	    o[17] = w17;
	    o[18] = w18;
	    if (c !== 0) {
	      o[19] = c;
	      out.length++;
	    }
	    return out;
	  };

	  // Polyfill comb
	  if (!Math.imul) {
	    comb10MulTo = smallMulTo;
	  }

	  function bigMulTo (self, num, out) {
	    out.negative = num.negative ^ self.negative;
	    out.length = self.length + num.length;

	    var carry = 0;
	    var hncarry = 0;
	    for (var k = 0; k < out.length - 1; k++) {
	      // Sum all words with the same `i + j = k` and accumulate `ncarry`,
	      // note that ncarry could be >= 0x3ffffff
	      var ncarry = hncarry;
	      hncarry = 0;
	      var rword = carry & 0x3ffffff;
	      var maxJ = Math.min(k, num.length - 1);
	      for (var j = Math.max(0, k - self.length + 1); j <= maxJ; j++) {
	        var i = k - j;
	        var a = self.words[i] | 0;
	        var b = num.words[j] | 0;
	        var r = a * b;

	        var lo = r & 0x3ffffff;
	        ncarry = (ncarry + ((r / 0x4000000) | 0)) | 0;
	        lo = (lo + rword) | 0;
	        rword = lo & 0x3ffffff;
	        ncarry = (ncarry + (lo >>> 26)) | 0;

	        hncarry += ncarry >>> 26;
	        ncarry &= 0x3ffffff;
	      }
	      out.words[k] = rword;
	      carry = ncarry;
	      ncarry = hncarry;
	    }
	    if (carry !== 0) {
	      out.words[k] = carry;
	    } else {
	      out.length--;
	    }

	    return out._strip();
	  }

	  function jumboMulTo (self, num, out) {
	    // Temporary disable, see https://github.com/indutny/bn.js/issues/211
	    // var fftm = new FFTM();
	    // return fftm.mulp(self, num, out);
	    return bigMulTo(self, num, out);
	  }

	  BN.prototype.mulTo = function mulTo (num, out) {
	    var res;
	    var len = this.length + num.length;
	    if (this.length === 10 && num.length === 10) {
	      res = comb10MulTo(this, num, out);
	    } else if (len < 63) {
	      res = smallMulTo(this, num, out);
	    } else if (len < 1024) {
	      res = bigMulTo(this, num, out);
	    } else {
	      res = jumboMulTo(this, num, out);
	    }

	    return res;
	  };

	  // Multiply `this` by `num`
	  BN.prototype.mul = function mul (num) {
	    var out = new BN(null);
	    out.words = new Array(this.length + num.length);
	    return this.mulTo(num, out);
	  };

	  // Multiply employing FFT
	  BN.prototype.mulf = function mulf (num) {
	    var out = new BN(null);
	    out.words = new Array(this.length + num.length);
	    return jumboMulTo(this, num, out);
	  };

	  // In-place Multiplication
	  BN.prototype.imul = function imul (num) {
	    return this.clone().mulTo(num, this);
	  };

	  BN.prototype.imuln = function imuln (num) {
	    var isNegNum = num < 0;
	    if (isNegNum) num = -num;

	    assert(typeof num === 'number');
	    assert(num < 0x4000000);

	    // Carry
	    var carry = 0;
	    for (var i = 0; i < this.length; i++) {
	      var w = (this.words[i] | 0) * num;
	      var lo = (w & 0x3ffffff) + (carry & 0x3ffffff);
	      carry >>= 26;
	      carry += (w / 0x4000000) | 0;
	      // NOTE: lo is 27bit maximum
	      carry += lo >>> 26;
	      this.words[i] = lo & 0x3ffffff;
	    }

	    if (carry !== 0) {
	      this.words[i] = carry;
	      this.length++;
	    }

	    return isNegNum ? this.ineg() : this;
	  };

	  BN.prototype.muln = function muln (num) {
	    return this.clone().imuln(num);
	  };

	  // `this` * `this`
	  BN.prototype.sqr = function sqr () {
	    return this.mul(this);
	  };

	  // `this` * `this` in-place
	  BN.prototype.isqr = function isqr () {
	    return this.imul(this.clone());
	  };

	  // Math.pow(`this`, `num`)
	  BN.prototype.pow = function pow (num) {
	    var w = toBitArray(num);
	    if (w.length === 0) return new BN(1);

	    // Skip leading zeroes
	    var res = this;
	    for (var i = 0; i < w.length; i++, res = res.sqr()) {
	      if (w[i] !== 0) break;
	    }

	    if (++i < w.length) {
	      for (var q = res.sqr(); i < w.length; i++, q = q.sqr()) {
	        if (w[i] === 0) continue;

	        res = res.mul(q);
	      }
	    }

	    return res;
	  };

	  // Shift-left in-place
	  BN.prototype.iushln = function iushln (bits) {
	    assert(typeof bits === 'number' && bits >= 0);
	    var r = bits % 26;
	    var s = (bits - r) / 26;
	    var carryMask = (0x3ffffff >>> (26 - r)) << (26 - r);
	    var i;

	    if (r !== 0) {
	      var carry = 0;

	      for (i = 0; i < this.length; i++) {
	        var newCarry = this.words[i] & carryMask;
	        var c = ((this.words[i] | 0) - newCarry) << r;
	        this.words[i] = c | carry;
	        carry = newCarry >>> (26 - r);
	      }

	      if (carry) {
	        this.words[i] = carry;
	        this.length++;
	      }
	    }

	    if (s !== 0) {
	      for (i = this.length - 1; i >= 0; i--) {
	        this.words[i + s] = this.words[i];
	      }

	      for (i = 0; i < s; i++) {
	        this.words[i] = 0;
	      }

	      this.length += s;
	    }

	    return this._strip();
	  };

	  BN.prototype.ishln = function ishln (bits) {
	    // TODO(indutny): implement me
	    assert(this.negative === 0);
	    return this.iushln(bits);
	  };

	  // Shift-right in-place
	  // NOTE: `hint` is a lowest bit before trailing zeroes
	  // NOTE: if `extended` is present - it will be filled with destroyed bits
	  BN.prototype.iushrn = function iushrn (bits, hint, extended) {
	    assert(typeof bits === 'number' && bits >= 0);
	    var h;
	    if (hint) {
	      h = (hint - (hint % 26)) / 26;
	    } else {
	      h = 0;
	    }

	    var r = bits % 26;
	    var s = Math.min((bits - r) / 26, this.length);
	    var mask = 0x3ffffff ^ ((0x3ffffff >>> r) << r);
	    var maskedWords = extended;

	    h -= s;
	    h = Math.max(0, h);

	    // Extended mode, copy masked part
	    if (maskedWords) {
	      for (var i = 0; i < s; i++) {
	        maskedWords.words[i] = this.words[i];
	      }
	      maskedWords.length = s;
	    }

	    if (s === 0) ; else if (this.length > s) {
	      this.length -= s;
	      for (i = 0; i < this.length; i++) {
	        this.words[i] = this.words[i + s];
	      }
	    } else {
	      this.words[0] = 0;
	      this.length = 1;
	    }

	    var carry = 0;
	    for (i = this.length - 1; i >= 0 && (carry !== 0 || i >= h); i--) {
	      var word = this.words[i] | 0;
	      this.words[i] = (carry << (26 - r)) | (word >>> r);
	      carry = word & mask;
	    }

	    // Push carried bits as a mask
	    if (maskedWords && carry !== 0) {
	      maskedWords.words[maskedWords.length++] = carry;
	    }

	    if (this.length === 0) {
	      this.words[0] = 0;
	      this.length = 1;
	    }

	    return this._strip();
	  };

	  BN.prototype.ishrn = function ishrn (bits, hint, extended) {
	    // TODO(indutny): implement me
	    assert(this.negative === 0);
	    return this.iushrn(bits, hint, extended);
	  };

	  // Shift-left
	  BN.prototype.shln = function shln (bits) {
	    return this.clone().ishln(bits);
	  };

	  BN.prototype.ushln = function ushln (bits) {
	    return this.clone().iushln(bits);
	  };

	  // Shift-right
	  BN.prototype.shrn = function shrn (bits) {
	    return this.clone().ishrn(bits);
	  };

	  BN.prototype.ushrn = function ushrn (bits) {
	    return this.clone().iushrn(bits);
	  };

	  // Test if n bit is set
	  BN.prototype.testn = function testn (bit) {
	    assert(typeof bit === 'number' && bit >= 0);
	    var r = bit % 26;
	    var s = (bit - r) / 26;
	    var q = 1 << r;

	    // Fast case: bit is much higher than all existing words
	    if (this.length <= s) return false;

	    // Check bit and return
	    var w = this.words[s];

	    return !!(w & q);
	  };

	  // Return only lowers bits of number (in-place)
	  BN.prototype.imaskn = function imaskn (bits) {
	    assert(typeof bits === 'number' && bits >= 0);
	    var r = bits % 26;
	    var s = (bits - r) / 26;

	    assert(this.negative === 0, 'imaskn works only with positive numbers');

	    if (this.length <= s) {
	      return this;
	    }

	    if (r !== 0) {
	      s++;
	    }
	    this.length = Math.min(s, this.length);

	    if (r !== 0) {
	      var mask = 0x3ffffff ^ ((0x3ffffff >>> r) << r);
	      this.words[this.length - 1] &= mask;
	    }

	    return this._strip();
	  };

	  // Return only lowers bits of number
	  BN.prototype.maskn = function maskn (bits) {
	    return this.clone().imaskn(bits);
	  };

	  // Add plain number `num` to `this`
	  BN.prototype.iaddn = function iaddn (num) {
	    assert(typeof num === 'number');
	    assert(num < 0x4000000);
	    if (num < 0) return this.isubn(-num);

	    // Possible sign change
	    if (this.negative !== 0) {
	      if (this.length === 1 && (this.words[0] | 0) <= num) {
	        this.words[0] = num - (this.words[0] | 0);
	        this.negative = 0;
	        return this;
	      }

	      this.negative = 0;
	      this.isubn(num);
	      this.negative = 1;
	      return this;
	    }

	    // Add without checks
	    return this._iaddn(num);
	  };

	  BN.prototype._iaddn = function _iaddn (num) {
	    this.words[0] += num;

	    // Carry
	    for (var i = 0; i < this.length && this.words[i] >= 0x4000000; i++) {
	      this.words[i] -= 0x4000000;
	      if (i === this.length - 1) {
	        this.words[i + 1] = 1;
	      } else {
	        this.words[i + 1]++;
	      }
	    }
	    this.length = Math.max(this.length, i + 1);

	    return this;
	  };

	  // Subtract plain number `num` from `this`
	  BN.prototype.isubn = function isubn (num) {
	    assert(typeof num === 'number');
	    assert(num < 0x4000000);
	    if (num < 0) return this.iaddn(-num);

	    if (this.negative !== 0) {
	      this.negative = 0;
	      this.iaddn(num);
	      this.negative = 1;
	      return this;
	    }

	    this.words[0] -= num;

	    if (this.length === 1 && this.words[0] < 0) {
	      this.words[0] = -this.words[0];
	      this.negative = 1;
	    } else {
	      // Carry
	      for (var i = 0; i < this.length && this.words[i] < 0; i++) {
	        this.words[i] += 0x4000000;
	        this.words[i + 1] -= 1;
	      }
	    }

	    return this._strip();
	  };

	  BN.prototype.addn = function addn (num) {
	    return this.clone().iaddn(num);
	  };

	  BN.prototype.subn = function subn (num) {
	    return this.clone().isubn(num);
	  };

	  BN.prototype.iabs = function iabs () {
	    this.negative = 0;

	    return this;
	  };

	  BN.prototype.abs = function abs () {
	    return this.clone().iabs();
	  };

	  BN.prototype._ishlnsubmul = function _ishlnsubmul (num, mul, shift) {
	    var len = num.length + shift;
	    var i;

	    this._expand(len);

	    var w;
	    var carry = 0;
	    for (i = 0; i < num.length; i++) {
	      w = (this.words[i + shift] | 0) + carry;
	      var right = (num.words[i] | 0) * mul;
	      w -= right & 0x3ffffff;
	      carry = (w >> 26) - ((right / 0x4000000) | 0);
	      this.words[i + shift] = w & 0x3ffffff;
	    }
	    for (; i < this.length - shift; i++) {
	      w = (this.words[i + shift] | 0) + carry;
	      carry = w >> 26;
	      this.words[i + shift] = w & 0x3ffffff;
	    }

	    if (carry === 0) return this._strip();

	    // Subtraction overflow
	    assert(carry === -1);
	    carry = 0;
	    for (i = 0; i < this.length; i++) {
	      w = -(this.words[i] | 0) + carry;
	      carry = w >> 26;
	      this.words[i] = w & 0x3ffffff;
	    }
	    this.negative = 1;

	    return this._strip();
	  };

	  BN.prototype._wordDiv = function _wordDiv (num, mode) {
	    var shift = this.length - num.length;

	    var a = this.clone();
	    var b = num;

	    // Normalize
	    var bhi = b.words[b.length - 1] | 0;
	    var bhiBits = this._countBits(bhi);
	    shift = 26 - bhiBits;
	    if (shift !== 0) {
	      b = b.ushln(shift);
	      a.iushln(shift);
	      bhi = b.words[b.length - 1] | 0;
	    }

	    // Initialize quotient
	    var m = a.length - b.length;
	    var q;

	    if (mode !== 'mod') {
	      q = new BN(null);
	      q.length = m + 1;
	      q.words = new Array(q.length);
	      for (var i = 0; i < q.length; i++) {
	        q.words[i] = 0;
	      }
	    }

	    var diff = a.clone()._ishlnsubmul(b, 1, m);
	    if (diff.negative === 0) {
	      a = diff;
	      if (q) {
	        q.words[m] = 1;
	      }
	    }

	    for (var j = m - 1; j >= 0; j--) {
	      var qj = (a.words[b.length + j] | 0) * 0x4000000 +
	        (a.words[b.length + j - 1] | 0);

	      // NOTE: (qj / bhi) is (0x3ffffff * 0x4000000 + 0x3ffffff) / 0x2000000 max
	      // (0x7ffffff)
	      qj = Math.min((qj / bhi) | 0, 0x3ffffff);

	      a._ishlnsubmul(b, qj, j);
	      while (a.negative !== 0) {
	        qj--;
	        a.negative = 0;
	        a._ishlnsubmul(b, 1, j);
	        if (!a.isZero()) {
	          a.negative ^= 1;
	        }
	      }
	      if (q) {
	        q.words[j] = qj;
	      }
	    }
	    if (q) {
	      q._strip();
	    }
	    a._strip();

	    // Denormalize
	    if (mode !== 'div' && shift !== 0) {
	      a.iushrn(shift);
	    }

	    return {
	      div: q || null,
	      mod: a
	    };
	  };

	  // NOTE: 1) `mode` can be set to `mod` to request mod only,
	  //       to `div` to request div only, or be absent to
	  //       request both div & mod
	  //       2) `positive` is true if unsigned mod is requested
	  BN.prototype.divmod = function divmod (num, mode, positive) {
	    assert(!num.isZero());

	    if (this.isZero()) {
	      return {
	        div: new BN(0),
	        mod: new BN(0)
	      };
	    }

	    var div, mod, res;
	    if (this.negative !== 0 && num.negative === 0) {
	      res = this.neg().divmod(num, mode);

	      if (mode !== 'mod') {
	        div = res.div.neg();
	      }

	      if (mode !== 'div') {
	        mod = res.mod.neg();
	        if (positive && mod.negative !== 0) {
	          mod.iadd(num);
	        }
	      }

	      return {
	        div: div,
	        mod: mod
	      };
	    }

	    if (this.negative === 0 && num.negative !== 0) {
	      res = this.divmod(num.neg(), mode);

	      if (mode !== 'mod') {
	        div = res.div.neg();
	      }

	      return {
	        div: div,
	        mod: res.mod
	      };
	    }

	    if ((this.negative & num.negative) !== 0) {
	      res = this.neg().divmod(num.neg(), mode);

	      if (mode !== 'div') {
	        mod = res.mod.neg();
	        if (positive && mod.negative !== 0) {
	          mod.isub(num);
	        }
	      }

	      return {
	        div: res.div,
	        mod: mod
	      };
	    }

	    // Both numbers are positive at this point

	    // Strip both numbers to approximate shift value
	    if (num.length > this.length || this.cmp(num) < 0) {
	      return {
	        div: new BN(0),
	        mod: this
	      };
	    }

	    // Very short reduction
	    if (num.length === 1) {
	      if (mode === 'div') {
	        return {
	          div: this.divn(num.words[0]),
	          mod: null
	        };
	      }

	      if (mode === 'mod') {
	        return {
	          div: null,
	          mod: new BN(this.modrn(num.words[0]))
	        };
	      }

	      return {
	        div: this.divn(num.words[0]),
	        mod: new BN(this.modrn(num.words[0]))
	      };
	    }

	    return this._wordDiv(num, mode);
	  };

	  // Find `this` / `num`
	  BN.prototype.div = function div (num) {
	    return this.divmod(num, 'div', false).div;
	  };

	  // Find `this` % `num`
	  BN.prototype.mod = function mod (num) {
	    return this.divmod(num, 'mod', false).mod;
	  };

	  BN.prototype.umod = function umod (num) {
	    return this.divmod(num, 'mod', true).mod;
	  };

	  // Find Round(`this` / `num`)
	  BN.prototype.divRound = function divRound (num) {
	    var dm = this.divmod(num);

	    // Fast case - exact division
	    if (dm.mod.isZero()) return dm.div;

	    var mod = dm.div.negative !== 0 ? dm.mod.isub(num) : dm.mod;

	    var half = num.ushrn(1);
	    var r2 = num.andln(1);
	    var cmp = mod.cmp(half);

	    // Round down
	    if (cmp < 0 || (r2 === 1 && cmp === 0)) return dm.div;

	    // Round up
	    return dm.div.negative !== 0 ? dm.div.isubn(1) : dm.div.iaddn(1);
	  };

	  BN.prototype.modrn = function modrn (num) {
	    var isNegNum = num < 0;
	    if (isNegNum) num = -num;

	    assert(num <= 0x3ffffff);
	    var p = (1 << 26) % num;

	    var acc = 0;
	    for (var i = this.length - 1; i >= 0; i--) {
	      acc = (p * acc + (this.words[i] | 0)) % num;
	    }

	    return isNegNum ? -acc : acc;
	  };

	  // WARNING: DEPRECATED
	  BN.prototype.modn = function modn (num) {
	    return this.modrn(num);
	  };

	  // In-place division by number
	  BN.prototype.idivn = function idivn (num) {
	    var isNegNum = num < 0;
	    if (isNegNum) num = -num;

	    assert(num <= 0x3ffffff);

	    var carry = 0;
	    for (var i = this.length - 1; i >= 0; i--) {
	      var w = (this.words[i] | 0) + carry * 0x4000000;
	      this.words[i] = (w / num) | 0;
	      carry = w % num;
	    }

	    this._strip();
	    return isNegNum ? this.ineg() : this;
	  };

	  BN.prototype.divn = function divn (num) {
	    return this.clone().idivn(num);
	  };

	  BN.prototype.egcd = function egcd (p) {
	    assert(p.negative === 0);
	    assert(!p.isZero());

	    var x = this;
	    var y = p.clone();

	    if (x.negative !== 0) {
	      x = x.umod(p);
	    } else {
	      x = x.clone();
	    }

	    // A * x + B * y = x
	    var A = new BN(1);
	    var B = new BN(0);

	    // C * x + D * y = y
	    var C = new BN(0);
	    var D = new BN(1);

	    var g = 0;

	    while (x.isEven() && y.isEven()) {
	      x.iushrn(1);
	      y.iushrn(1);
	      ++g;
	    }

	    var yp = y.clone();
	    var xp = x.clone();

	    while (!x.isZero()) {
	      for (var i = 0, im = 1; (x.words[0] & im) === 0 && i < 26; ++i, im <<= 1);
	      if (i > 0) {
	        x.iushrn(i);
	        while (i-- > 0) {
	          if (A.isOdd() || B.isOdd()) {
	            A.iadd(yp);
	            B.isub(xp);
	          }

	          A.iushrn(1);
	          B.iushrn(1);
	        }
	      }

	      for (var j = 0, jm = 1; (y.words[0] & jm) === 0 && j < 26; ++j, jm <<= 1);
	      if (j > 0) {
	        y.iushrn(j);
	        while (j-- > 0) {
	          if (C.isOdd() || D.isOdd()) {
	            C.iadd(yp);
	            D.isub(xp);
	          }

	          C.iushrn(1);
	          D.iushrn(1);
	        }
	      }

	      if (x.cmp(y) >= 0) {
	        x.isub(y);
	        A.isub(C);
	        B.isub(D);
	      } else {
	        y.isub(x);
	        C.isub(A);
	        D.isub(B);
	      }
	    }

	    return {
	      a: C,
	      b: D,
	      gcd: y.iushln(g)
	    };
	  };

	  // This is reduced incarnation of the binary EEA
	  // above, designated to invert members of the
	  // _prime_ fields F(p) at a maximal speed
	  BN.prototype._invmp = function _invmp (p) {
	    assert(p.negative === 0);
	    assert(!p.isZero());

	    var a = this;
	    var b = p.clone();

	    if (a.negative !== 0) {
	      a = a.umod(p);
	    } else {
	      a = a.clone();
	    }

	    var x1 = new BN(1);
	    var x2 = new BN(0);

	    var delta = b.clone();

	    while (a.cmpn(1) > 0 && b.cmpn(1) > 0) {
	      for (var i = 0, im = 1; (a.words[0] & im) === 0 && i < 26; ++i, im <<= 1);
	      if (i > 0) {
	        a.iushrn(i);
	        while (i-- > 0) {
	          if (x1.isOdd()) {
	            x1.iadd(delta);
	          }

	          x1.iushrn(1);
	        }
	      }

	      for (var j = 0, jm = 1; (b.words[0] & jm) === 0 && j < 26; ++j, jm <<= 1);
	      if (j > 0) {
	        b.iushrn(j);
	        while (j-- > 0) {
	          if (x2.isOdd()) {
	            x2.iadd(delta);
	          }

	          x2.iushrn(1);
	        }
	      }

	      if (a.cmp(b) >= 0) {
	        a.isub(b);
	        x1.isub(x2);
	      } else {
	        b.isub(a);
	        x2.isub(x1);
	      }
	    }

	    var res;
	    if (a.cmpn(1) === 0) {
	      res = x1;
	    } else {
	      res = x2;
	    }

	    if (res.cmpn(0) < 0) {
	      res.iadd(p);
	    }

	    return res;
	  };

	  BN.prototype.gcd = function gcd (num) {
	    if (this.isZero()) return num.abs();
	    if (num.isZero()) return this.abs();

	    var a = this.clone();
	    var b = num.clone();
	    a.negative = 0;
	    b.negative = 0;

	    // Remove common factor of two
	    for (var shift = 0; a.isEven() && b.isEven(); shift++) {
	      a.iushrn(1);
	      b.iushrn(1);
	    }

	    do {
	      while (a.isEven()) {
	        a.iushrn(1);
	      }
	      while (b.isEven()) {
	        b.iushrn(1);
	      }

	      var r = a.cmp(b);
	      if (r < 0) {
	        // Swap `a` and `b` to make `a` always bigger than `b`
	        var t = a;
	        a = b;
	        b = t;
	      } else if (r === 0 || b.cmpn(1) === 0) {
	        break;
	      }

	      a.isub(b);
	    } while (true);

	    return b.iushln(shift);
	  };

	  // Invert number in the field F(num)
	  BN.prototype.invm = function invm (num) {
	    return this.egcd(num).a.umod(num);
	  };

	  BN.prototype.isEven = function isEven () {
	    return (this.words[0] & 1) === 0;
	  };

	  BN.prototype.isOdd = function isOdd () {
	    return (this.words[0] & 1) === 1;
	  };

	  // And first word and num
	  BN.prototype.andln = function andln (num) {
	    return this.words[0] & num;
	  };

	  // Increment at the bit position in-line
	  BN.prototype.bincn = function bincn (bit) {
	    assert(typeof bit === 'number');
	    var r = bit % 26;
	    var s = (bit - r) / 26;
	    var q = 1 << r;

	    // Fast case: bit is much higher than all existing words
	    if (this.length <= s) {
	      this._expand(s + 1);
	      this.words[s] |= q;
	      return this;
	    }

	    // Add bit and propagate, if needed
	    var carry = q;
	    for (var i = s; carry !== 0 && i < this.length; i++) {
	      var w = this.words[i] | 0;
	      w += carry;
	      carry = w >>> 26;
	      w &= 0x3ffffff;
	      this.words[i] = w;
	    }
	    if (carry !== 0) {
	      this.words[i] = carry;
	      this.length++;
	    }
	    return this;
	  };

	  BN.prototype.isZero = function isZero () {
	    return this.length === 1 && this.words[0] === 0;
	  };

	  BN.prototype.cmpn = function cmpn (num) {
	    var negative = num < 0;

	    if (this.negative !== 0 && !negative) return -1;
	    if (this.negative === 0 && negative) return 1;

	    this._strip();

	    var res;
	    if (this.length > 1) {
	      res = 1;
	    } else {
	      if (negative) {
	        num = -num;
	      }

	      assert(num <= 0x3ffffff, 'Number is too big');

	      var w = this.words[0] | 0;
	      res = w === num ? 0 : w < num ? -1 : 1;
	    }
	    if (this.negative !== 0) return -res | 0;
	    return res;
	  };

	  // Compare two numbers and return:
	  // 1 - if `this` > `num`
	  // 0 - if `this` == `num`
	  // -1 - if `this` < `num`
	  BN.prototype.cmp = function cmp (num) {
	    if (this.negative !== 0 && num.negative === 0) return -1;
	    if (this.negative === 0 && num.negative !== 0) return 1;

	    var res = this.ucmp(num);
	    if (this.negative !== 0) return -res | 0;
	    return res;
	  };

	  // Unsigned comparison
	  BN.prototype.ucmp = function ucmp (num) {
	    // At this point both numbers have the same sign
	    if (this.length > num.length) return 1;
	    if (this.length < num.length) return -1;

	    var res = 0;
	    for (var i = this.length - 1; i >= 0; i--) {
	      var a = this.words[i] | 0;
	      var b = num.words[i] | 0;

	      if (a === b) continue;
	      if (a < b) {
	        res = -1;
	      } else if (a > b) {
	        res = 1;
	      }
	      break;
	    }
	    return res;
	  };

	  BN.prototype.gtn = function gtn (num) {
	    return this.cmpn(num) === 1;
	  };

	  BN.prototype.gt = function gt (num) {
	    return this.cmp(num) === 1;
	  };

	  BN.prototype.gten = function gten (num) {
	    return this.cmpn(num) >= 0;
	  };

	  BN.prototype.gte = function gte (num) {
	    return this.cmp(num) >= 0;
	  };

	  BN.prototype.ltn = function ltn (num) {
	    return this.cmpn(num) === -1;
	  };

	  BN.prototype.lt = function lt (num) {
	    return this.cmp(num) === -1;
	  };

	  BN.prototype.lten = function lten (num) {
	    return this.cmpn(num) <= 0;
	  };

	  BN.prototype.lte = function lte (num) {
	    return this.cmp(num) <= 0;
	  };

	  BN.prototype.eqn = function eqn (num) {
	    return this.cmpn(num) === 0;
	  };

	  BN.prototype.eq = function eq (num) {
	    return this.cmp(num) === 0;
	  };

	  //
	  // A reduce context, could be using montgomery or something better, depending
	  // on the `m` itself.
	  //
	  BN.red = function red (num) {
	    return new Red(num);
	  };

	  BN.prototype.toRed = function toRed (ctx) {
	    assert(!this.red, 'Already a number in reduction context');
	    assert(this.negative === 0, 'red works only with positives');
	    return ctx.convertTo(this)._forceRed(ctx);
	  };

	  BN.prototype.fromRed = function fromRed () {
	    assert(this.red, 'fromRed works only with numbers in reduction context');
	    return this.red.convertFrom(this);
	  };

	  BN.prototype._forceRed = function _forceRed (ctx) {
	    this.red = ctx;
	    return this;
	  };

	  BN.prototype.forceRed = function forceRed (ctx) {
	    assert(!this.red, 'Already a number in reduction context');
	    return this._forceRed(ctx);
	  };

	  BN.prototype.redAdd = function redAdd (num) {
	    assert(this.red, 'redAdd works only with red numbers');
	    return this.red.add(this, num);
	  };

	  BN.prototype.redIAdd = function redIAdd (num) {
	    assert(this.red, 'redIAdd works only with red numbers');
	    return this.red.iadd(this, num);
	  };

	  BN.prototype.redSub = function redSub (num) {
	    assert(this.red, 'redSub works only with red numbers');
	    return this.red.sub(this, num);
	  };

	  BN.prototype.redISub = function redISub (num) {
	    assert(this.red, 'redISub works only with red numbers');
	    return this.red.isub(this, num);
	  };

	  BN.prototype.redShl = function redShl (num) {
	    assert(this.red, 'redShl works only with red numbers');
	    return this.red.shl(this, num);
	  };

	  BN.prototype.redMul = function redMul (num) {
	    assert(this.red, 'redMul works only with red numbers');
	    this.red._verify2(this, num);
	    return this.red.mul(this, num);
	  };

	  BN.prototype.redIMul = function redIMul (num) {
	    assert(this.red, 'redMul works only with red numbers');
	    this.red._verify2(this, num);
	    return this.red.imul(this, num);
	  };

	  BN.prototype.redSqr = function redSqr () {
	    assert(this.red, 'redSqr works only with red numbers');
	    this.red._verify1(this);
	    return this.red.sqr(this);
	  };

	  BN.prototype.redISqr = function redISqr () {
	    assert(this.red, 'redISqr works only with red numbers');
	    this.red._verify1(this);
	    return this.red.isqr(this);
	  };

	  // Square root over p
	  BN.prototype.redSqrt = function redSqrt () {
	    assert(this.red, 'redSqrt works only with red numbers');
	    this.red._verify1(this);
	    return this.red.sqrt(this);
	  };

	  BN.prototype.redInvm = function redInvm () {
	    assert(this.red, 'redInvm works only with red numbers');
	    this.red._verify1(this);
	    return this.red.invm(this);
	  };

	  // Return negative clone of `this` % `red modulo`
	  BN.prototype.redNeg = function redNeg () {
	    assert(this.red, 'redNeg works only with red numbers');
	    this.red._verify1(this);
	    return this.red.neg(this);
	  };

	  BN.prototype.redPow = function redPow (num) {
	    assert(this.red && !num.red, 'redPow(normalNum)');
	    this.red._verify1(this);
	    return this.red.pow(this, num);
	  };

	  // Prime numbers with efficient reduction
	  var primes = {
	    k256: null,
	    p224: null,
	    p192: null,
	    p25519: null
	  };

	  // Pseudo-Mersenne prime
	  function MPrime (name, p) {
	    // P = 2 ^ N - K
	    this.name = name;
	    this.p = new BN(p, 16);
	    this.n = this.p.bitLength();
	    this.k = new BN(1).iushln(this.n).isub(this.p);

	    this.tmp = this._tmp();
	  }

	  MPrime.prototype._tmp = function _tmp () {
	    var tmp = new BN(null);
	    tmp.words = new Array(Math.ceil(this.n / 13));
	    return tmp;
	  };

	  MPrime.prototype.ireduce = function ireduce (num) {
	    // Assumes that `num` is less than `P^2`
	    // num = HI * (2 ^ N - K) + HI * K + LO = HI * K + LO (mod P)
	    var r = num;
	    var rlen;

	    do {
	      this.split(r, this.tmp);
	      r = this.imulK(r);
	      r = r.iadd(this.tmp);
	      rlen = r.bitLength();
	    } while (rlen > this.n);

	    var cmp = rlen < this.n ? -1 : r.ucmp(this.p);
	    if (cmp === 0) {
	      r.words[0] = 0;
	      r.length = 1;
	    } else if (cmp > 0) {
	      r.isub(this.p);
	    } else {
	      if (r.strip !== undefined) {
	        // r is a BN v4 instance
	        r.strip();
	      } else {
	        // r is a BN v5 instance
	        r._strip();
	      }
	    }

	    return r;
	  };

	  MPrime.prototype.split = function split (input, out) {
	    input.iushrn(this.n, 0, out);
	  };

	  MPrime.prototype.imulK = function imulK (num) {
	    return num.imul(this.k);
	  };

	  function K256 () {
	    MPrime.call(
	      this,
	      'k256',
	      'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f');
	  }
	  inherits(K256, MPrime);

	  K256.prototype.split = function split (input, output) {
	    // 256 = 9 * 26 + 22
	    var mask = 0x3fffff;

	    var outLen = Math.min(input.length, 9);
	    for (var i = 0; i < outLen; i++) {
	      output.words[i] = input.words[i];
	    }
	    output.length = outLen;

	    if (input.length <= 9) {
	      input.words[0] = 0;
	      input.length = 1;
	      return;
	    }

	    // Shift by 9 limbs
	    var prev = input.words[9];
	    output.words[output.length++] = prev & mask;

	    for (i = 10; i < input.length; i++) {
	      var next = input.words[i] | 0;
	      input.words[i - 10] = ((next & mask) << 4) | (prev >>> 22);
	      prev = next;
	    }
	    prev >>>= 22;
	    input.words[i - 10] = prev;
	    if (prev === 0 && input.length > 10) {
	      input.length -= 10;
	    } else {
	      input.length -= 9;
	    }
	  };

	  K256.prototype.imulK = function imulK (num) {
	    // K = 0x1000003d1 = [ 0x40, 0x3d1 ]
	    num.words[num.length] = 0;
	    num.words[num.length + 1] = 0;
	    num.length += 2;

	    // bounded at: 0x40 * 0x3ffffff + 0x3d0 = 0x100000390
	    var lo = 0;
	    for (var i = 0; i < num.length; i++) {
	      var w = num.words[i] | 0;
	      lo += w * 0x3d1;
	      num.words[i] = lo & 0x3ffffff;
	      lo = w * 0x40 + ((lo / 0x4000000) | 0);
	    }

	    // Fast length reduction
	    if (num.words[num.length - 1] === 0) {
	      num.length--;
	      if (num.words[num.length - 1] === 0) {
	        num.length--;
	      }
	    }
	    return num;
	  };

	  function P224 () {
	    MPrime.call(
	      this,
	      'p224',
	      'ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001');
	  }
	  inherits(P224, MPrime);

	  function P192 () {
	    MPrime.call(
	      this,
	      'p192',
	      'ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff');
	  }
	  inherits(P192, MPrime);

	  function P25519 () {
	    // 2 ^ 255 - 19
	    MPrime.call(
	      this,
	      '25519',
	      '7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed');
	  }
	  inherits(P25519, MPrime);

	  P25519.prototype.imulK = function imulK (num) {
	    // K = 0x13
	    var carry = 0;
	    for (var i = 0; i < num.length; i++) {
	      var hi = (num.words[i] | 0) * 0x13 + carry;
	      var lo = hi & 0x3ffffff;
	      hi >>>= 26;

	      num.words[i] = lo;
	      carry = hi;
	    }
	    if (carry !== 0) {
	      num.words[num.length++] = carry;
	    }
	    return num;
	  };

	  // Exported mostly for testing purposes, use plain name instead
	  BN._prime = function prime (name) {
	    // Cached version of prime
	    if (primes[name]) return primes[name];

	    var prime;
	    if (name === 'k256') {
	      prime = new K256();
	    } else if (name === 'p224') {
	      prime = new P224();
	    } else if (name === 'p192') {
	      prime = new P192();
	    } else if (name === 'p25519') {
	      prime = new P25519();
	    } else {
	      throw new Error('Unknown prime ' + name);
	    }
	    primes[name] = prime;

	    return prime;
	  };

	  //
	  // Base reduction engine
	  //
	  function Red (m) {
	    if (typeof m === 'string') {
	      var prime = BN._prime(m);
	      this.m = prime.p;
	      this.prime = prime;
	    } else {
	      assert(m.gtn(1), 'modulus must be greater than 1');
	      this.m = m;
	      this.prime = null;
	    }
	  }

	  Red.prototype._verify1 = function _verify1 (a) {
	    assert(a.negative === 0, 'red works only with positives');
	    assert(a.red, 'red works only with red numbers');
	  };

	  Red.prototype._verify2 = function _verify2 (a, b) {
	    assert((a.negative | b.negative) === 0, 'red works only with positives');
	    assert(a.red && a.red === b.red,
	      'red works only with red numbers');
	  };

	  Red.prototype.imod = function imod (a) {
	    if (this.prime) return this.prime.ireduce(a)._forceRed(this);

	    move(a, a.umod(this.m)._forceRed(this));
	    return a;
	  };

	  Red.prototype.neg = function neg (a) {
	    if (a.isZero()) {
	      return a.clone();
	    }

	    return this.m.sub(a)._forceRed(this);
	  };

	  Red.prototype.add = function add (a, b) {
	    this._verify2(a, b);

	    var res = a.add(b);
	    if (res.cmp(this.m) >= 0) {
	      res.isub(this.m);
	    }
	    return res._forceRed(this);
	  };

	  Red.prototype.iadd = function iadd (a, b) {
	    this._verify2(a, b);

	    var res = a.iadd(b);
	    if (res.cmp(this.m) >= 0) {
	      res.isub(this.m);
	    }
	    return res;
	  };

	  Red.prototype.sub = function sub (a, b) {
	    this._verify2(a, b);

	    var res = a.sub(b);
	    if (res.cmpn(0) < 0) {
	      res.iadd(this.m);
	    }
	    return res._forceRed(this);
	  };

	  Red.prototype.isub = function isub (a, b) {
	    this._verify2(a, b);

	    var res = a.isub(b);
	    if (res.cmpn(0) < 0) {
	      res.iadd(this.m);
	    }
	    return res;
	  };

	  Red.prototype.shl = function shl (a, num) {
	    this._verify1(a);
	    return this.imod(a.ushln(num));
	  };

	  Red.prototype.imul = function imul (a, b) {
	    this._verify2(a, b);
	    return this.imod(a.imul(b));
	  };

	  Red.prototype.mul = function mul (a, b) {
	    this._verify2(a, b);
	    return this.imod(a.mul(b));
	  };

	  Red.prototype.isqr = function isqr (a) {
	    return this.imul(a, a.clone());
	  };

	  Red.prototype.sqr = function sqr (a) {
	    return this.mul(a, a);
	  };

	  Red.prototype.sqrt = function sqrt (a) {
	    if (a.isZero()) return a.clone();

	    var mod3 = this.m.andln(3);
	    assert(mod3 % 2 === 1);

	    // Fast case
	    if (mod3 === 3) {
	      var pow = this.m.add(new BN(1)).iushrn(2);
	      return this.pow(a, pow);
	    }

	    // Tonelli-Shanks algorithm (Totally unoptimized and slow)
	    //
	    // Find Q and S, that Q * 2 ^ S = (P - 1)
	    var q = this.m.subn(1);
	    var s = 0;
	    while (!q.isZero() && q.andln(1) === 0) {
	      s++;
	      q.iushrn(1);
	    }
	    assert(!q.isZero());

	    var one = new BN(1).toRed(this);
	    var nOne = one.redNeg();

	    // Find quadratic non-residue
	    // NOTE: Max is such because of generalized Riemann hypothesis.
	    var lpow = this.m.subn(1).iushrn(1);
	    var z = this.m.bitLength();
	    z = new BN(2 * z * z).toRed(this);

	    while (this.pow(z, lpow).cmp(nOne) !== 0) {
	      z.redIAdd(nOne);
	    }

	    var c = this.pow(z, q);
	    var r = this.pow(a, q.addn(1).iushrn(1));
	    var t = this.pow(a, q);
	    var m = s;
	    while (t.cmp(one) !== 0) {
	      var tmp = t;
	      for (var i = 0; tmp.cmp(one) !== 0; i++) {
	        tmp = tmp.redSqr();
	      }
	      assert(i < m);
	      var b = this.pow(c, new BN(1).iushln(m - i - 1));

	      r = r.redMul(b);
	      c = b.redSqr();
	      t = t.redMul(c);
	      m = i;
	    }

	    return r;
	  };

	  Red.prototype.invm = function invm (a) {
	    var inv = a._invmp(this.m);
	    if (inv.negative !== 0) {
	      inv.negative = 0;
	      return this.imod(inv).redNeg();
	    } else {
	      return this.imod(inv);
	    }
	  };

	  Red.prototype.pow = function pow (a, num) {
	    if (num.isZero()) return new BN(1).toRed(this);
	    if (num.cmpn(1) === 0) return a.clone();

	    var windowSize = 4;
	    var wnd = new Array(1 << windowSize);
	    wnd[0] = new BN(1).toRed(this);
	    wnd[1] = a;
	    for (var i = 2; i < wnd.length; i++) {
	      wnd[i] = this.mul(wnd[i - 1], a);
	    }

	    var res = wnd[0];
	    var current = 0;
	    var currentLen = 0;
	    var start = num.bitLength() % 26;
	    if (start === 0) {
	      start = 26;
	    }

	    for (i = num.length - 1; i >= 0; i--) {
	      var word = num.words[i];
	      for (var j = start - 1; j >= 0; j--) {
	        var bit = (word >> j) & 1;
	        if (res !== wnd[0]) {
	          res = this.sqr(res);
	        }

	        if (bit === 0 && current === 0) {
	          currentLen = 0;
	          continue;
	        }

	        current <<= 1;
	        current |= bit;
	        currentLen++;
	        if (currentLen !== windowSize && (i !== 0 || j !== 0)) continue;

	        res = this.mul(res, wnd[current]);
	        currentLen = 0;
	        current = 0;
	      }
	      start = 26;
	    }

	    return res;
	  };

	  Red.prototype.convertTo = function convertTo (num) {
	    var r = num.umod(this.m);

	    return r === num ? r.clone() : r;
	  };

	  Red.prototype.convertFrom = function convertFrom (num) {
	    var res = num.clone();
	    res.red = null;
	    return res;
	  };

	  //
	  // Montgomery method engine
	  //

	  BN.mont = function mont (num) {
	    return new Mont(num);
	  };

	  function Mont (m) {
	    Red.call(this, m);

	    this.shift = this.m.bitLength();
	    if (this.shift % 26 !== 0) {
	      this.shift += 26 - (this.shift % 26);
	    }

	    this.r = new BN(1).iushln(this.shift);
	    this.r2 = this.imod(this.r.sqr());
	    this.rinv = this.r._invmp(this.m);

	    this.minv = this.rinv.mul(this.r).isubn(1).div(this.m);
	    this.minv = this.minv.umod(this.r);
	    this.minv = this.r.sub(this.minv);
	  }
	  inherits(Mont, Red);

	  Mont.prototype.convertTo = function convertTo (num) {
	    return this.imod(num.ushln(this.shift));
	  };

	  Mont.prototype.convertFrom = function convertFrom (num) {
	    var r = this.imod(num.mul(this.rinv));
	    r.red = null;
	    return r;
	  };

	  Mont.prototype.imul = function imul (a, b) {
	    if (a.isZero() || b.isZero()) {
	      a.words[0] = 0;
	      a.length = 1;
	      return a;
	    }

	    var t = a.imul(b);
	    var c = t.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
	    var u = t.isub(c).iushrn(this.shift);
	    var res = u;

	    if (u.cmp(this.m) >= 0) {
	      res = u.isub(this.m);
	    } else if (u.cmpn(0) < 0) {
	      res = u.iadd(this.m);
	    }

	    return res._forceRed(this);
	  };

	  Mont.prototype.mul = function mul (a, b) {
	    if (a.isZero() || b.isZero()) return new BN(0)._forceRed(this);

	    var t = a.mul(b);
	    var c = t.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
	    var u = t.isub(c).iushrn(this.shift);
	    var res = u;
	    if (u.cmp(this.m) >= 0) {
	      res = u.isub(this.m);
	    } else if (u.cmpn(0) < 0) {
	      res = u.iadd(this.m);
	    }

	    return res._forceRed(this);
	  };

	  Mont.prototype.invm = function invm (a) {
	    // (AR)^-1 * R^2 = (A^-1 * R^-1) * R^2 = A^-1 * R
	    var res = this.imod(a._invmp(this.m).mul(this.r2));
	    return res._forceRed(this);
	  };
	})(module, commonjsGlobal); 
} (bn));

var bnExports = bn.exports;
var BN$1 = /*@__PURE__*/getDefaultExportFromCjs(bnExports);

const version$b = "logger/5.7.0";

let _permanentCensorErrors = false;
let _censorErrors = false;
const LogLevels = { debug: 1, "default": 2, info: 2, warning: 3, error: 4, off: 5 };
let _logLevel = LogLevels["default"];
let _globalLogger = null;
function _checkNormalize() {
    try {
        const missing = [];
        // Make sure all forms of normalization are supported
        ["NFD", "NFC", "NFKD", "NFKC"].forEach((form) => {
            try {
                if ("test".normalize(form) !== "test") {
                    throw new Error("bad normalize");
                }
                ;
            }
            catch (error) {
                missing.push(form);
            }
        });
        if (missing.length) {
            throw new Error("missing " + missing.join(", "));
        }
        if (String.fromCharCode(0xe9).normalize("NFD") !== String.fromCharCode(0x65, 0x0301)) {
            throw new Error("broken implementation");
        }
    }
    catch (error) {
        return error.message;
    }
    return null;
}
const _normalizeError = _checkNormalize();
var LogLevel;
(function (LogLevel) {
    LogLevel["DEBUG"] = "DEBUG";
    LogLevel["INFO"] = "INFO";
    LogLevel["WARNING"] = "WARNING";
    LogLevel["ERROR"] = "ERROR";
    LogLevel["OFF"] = "OFF";
})(LogLevel || (LogLevel = {}));
var ErrorCode;
(function (ErrorCode) {
    ///////////////////
    // Generic Errors
    // Unknown Error
    ErrorCode["UNKNOWN_ERROR"] = "UNKNOWN_ERROR";
    // Not Implemented
    ErrorCode["NOT_IMPLEMENTED"] = "NOT_IMPLEMENTED";
    // Unsupported Operation
    //   - operation
    ErrorCode["UNSUPPORTED_OPERATION"] = "UNSUPPORTED_OPERATION";
    // Network Error (i.e. Ethereum Network, such as an invalid chain ID)
    //   - event ("noNetwork" is not re-thrown in provider.ready; otherwise thrown)
    ErrorCode["NETWORK_ERROR"] = "NETWORK_ERROR";
    // Some sort of bad response from the server
    ErrorCode["SERVER_ERROR"] = "SERVER_ERROR";
    // Timeout
    ErrorCode["TIMEOUT"] = "TIMEOUT";
    ///////////////////
    // Operational  Errors
    // Buffer Overrun
    ErrorCode["BUFFER_OVERRUN"] = "BUFFER_OVERRUN";
    // Numeric Fault
    //   - operation: the operation being executed
    //   - fault: the reason this faulted
    ErrorCode["NUMERIC_FAULT"] = "NUMERIC_FAULT";
    ///////////////////
    // Argument Errors
    // Missing new operator to an object
    //  - name: The name of the class
    ErrorCode["MISSING_NEW"] = "MISSING_NEW";
    // Invalid argument (e.g. value is incompatible with type) to a function:
    //   - argument: The argument name that was invalid
    //   - value: The value of the argument
    ErrorCode["INVALID_ARGUMENT"] = "INVALID_ARGUMENT";
    // Missing argument to a function:
    //   - count: The number of arguments received
    //   - expectedCount: The number of arguments expected
    ErrorCode["MISSING_ARGUMENT"] = "MISSING_ARGUMENT";
    // Too many arguments
    //   - count: The number of arguments received
    //   - expectedCount: The number of arguments expected
    ErrorCode["UNEXPECTED_ARGUMENT"] = "UNEXPECTED_ARGUMENT";
    ///////////////////
    // Blockchain Errors
    // Call exception
    //  - transaction: the transaction
    //  - address?: the contract address
    //  - args?: The arguments passed into the function
    //  - method?: The Solidity method signature
    //  - errorSignature?: The EIP848 error signature
    //  - errorArgs?: The EIP848 error parameters
    //  - reason: The reason (only for EIP848 "Error(string)")
    ErrorCode["CALL_EXCEPTION"] = "CALL_EXCEPTION";
    // Insufficient funds (< value + gasLimit * gasPrice)
    //   - transaction: the transaction attempted
    ErrorCode["INSUFFICIENT_FUNDS"] = "INSUFFICIENT_FUNDS";
    // Nonce has already been used
    //   - transaction: the transaction attempted
    ErrorCode["NONCE_EXPIRED"] = "NONCE_EXPIRED";
    // The replacement fee for the transaction is too low
    //   - transaction: the transaction attempted
    ErrorCode["REPLACEMENT_UNDERPRICED"] = "REPLACEMENT_UNDERPRICED";
    // The gas limit could not be estimated
    //   - transaction: the transaction passed to estimateGas
    ErrorCode["UNPREDICTABLE_GAS_LIMIT"] = "UNPREDICTABLE_GAS_LIMIT";
    // The transaction was replaced by one with a higher gas price
    //   - reason: "cancelled", "replaced" or "repriced"
    //   - cancelled: true if reason == "cancelled" or reason == "replaced")
    //   - hash: original transaction hash
    //   - replacement: the full TransactionsResponse for the replacement
    //   - receipt: the receipt of the replacement
    ErrorCode["TRANSACTION_REPLACED"] = "TRANSACTION_REPLACED";
    ///////////////////
    // Interaction Errors
    // The user rejected the action, such as signing a message or sending
    // a transaction
    ErrorCode["ACTION_REJECTED"] = "ACTION_REJECTED";
})(ErrorCode || (ErrorCode = {}));
const HEX = "0123456789abcdef";
class Logger {
    constructor(version) {
        Object.defineProperty(this, "version", {
            enumerable: true,
            value: version,
            writable: false
        });
    }
    _log(logLevel, args) {
        const level = logLevel.toLowerCase();
        if (LogLevels[level] == null) {
            this.throwArgumentError("invalid log level name", "logLevel", logLevel);
        }
        if (_logLevel > LogLevels[level]) {
            return;
        }
        console.log.apply(console, args);
    }
    debug(...args) {
        this._log(Logger.levels.DEBUG, args);
    }
    info(...args) {
        this._log(Logger.levels.INFO, args);
    }
    warn(...args) {
        this._log(Logger.levels.WARNING, args);
    }
    makeError(message, code, params) {
        // Errors are being censored
        if (_censorErrors) {
            return this.makeError("censored error", code, {});
        }
        if (!code) {
            code = Logger.errors.UNKNOWN_ERROR;
        }
        if (!params) {
            params = {};
        }
        const messageDetails = [];
        Object.keys(params).forEach((key) => {
            const value = params[key];
            try {
                if (value instanceof Uint8Array) {
                    let hex = "";
                    for (let i = 0; i < value.length; i++) {
                        hex += HEX[value[i] >> 4];
                        hex += HEX[value[i] & 0x0f];
                    }
                    messageDetails.push(key + "=Uint8Array(0x" + hex + ")");
                }
                else {
                    messageDetails.push(key + "=" + JSON.stringify(value));
                }
            }
            catch (error) {
                messageDetails.push(key + "=" + JSON.stringify(params[key].toString()));
            }
        });
        messageDetails.push(`code=${code}`);
        messageDetails.push(`version=${this.version}`);
        const reason = message;
        let url = "";
        switch (code) {
            case ErrorCode.NUMERIC_FAULT: {
                url = "NUMERIC_FAULT";
                const fault = message;
                switch (fault) {
                    case "overflow":
                    case "underflow":
                    case "division-by-zero":
                        url += "-" + fault;
                        break;
                    case "negative-power":
                    case "negative-width":
                        url += "-unsupported";
                        break;
                    case "unbound-bitwise-result":
                        url += "-unbound-result";
                        break;
                }
                break;
            }
            case ErrorCode.CALL_EXCEPTION:
            case ErrorCode.INSUFFICIENT_FUNDS:
            case ErrorCode.MISSING_NEW:
            case ErrorCode.NONCE_EXPIRED:
            case ErrorCode.REPLACEMENT_UNDERPRICED:
            case ErrorCode.TRANSACTION_REPLACED:
            case ErrorCode.UNPREDICTABLE_GAS_LIMIT:
                url = code;
                break;
        }
        if (url) {
            message += " [ See: https:/\/links.ethers.org/v5-errors-" + url + " ]";
        }
        if (messageDetails.length) {
            message += " (" + messageDetails.join(", ") + ")";
        }
        // @TODO: Any??
        const error = new Error(message);
        error.reason = reason;
        error.code = code;
        Object.keys(params).forEach(function (key) {
            error[key] = params[key];
        });
        return error;
    }
    throwError(message, code, params) {
        throw this.makeError(message, code, params);
    }
    throwArgumentError(message, name, value) {
        return this.throwError(message, Logger.errors.INVALID_ARGUMENT, {
            argument: name,
            value: value
        });
    }
    assert(condition, message, code, params) {
        if (!!condition) {
            return;
        }
        this.throwError(message, code, params);
    }
    assertArgument(condition, message, name, value) {
        if (!!condition) {
            return;
        }
        this.throwArgumentError(message, name, value);
    }
    checkNormalize(message) {
        if (_normalizeError) {
            this.throwError("platform missing String.prototype.normalize", Logger.errors.UNSUPPORTED_OPERATION, {
                operation: "String.prototype.normalize", form: _normalizeError
            });
        }
    }
    checkSafeUint53(value, message) {
        if (typeof (value) !== "number") {
            return;
        }
        if (message == null) {
            message = "value not safe";
        }
        if (value < 0 || value >= 0x1fffffffffffff) {
            this.throwError(message, Logger.errors.NUMERIC_FAULT, {
                operation: "checkSafeInteger",
                fault: "out-of-safe-range",
                value: value
            });
        }
        if (value % 1) {
            this.throwError(message, Logger.errors.NUMERIC_FAULT, {
                operation: "checkSafeInteger",
                fault: "non-integer",
                value: value
            });
        }
    }
    checkArgumentCount(count, expectedCount, message) {
        if (message) {
            message = ": " + message;
        }
        else {
            message = "";
        }
        if (count < expectedCount) {
            this.throwError("missing argument" + message, Logger.errors.MISSING_ARGUMENT, {
                count: count,
                expectedCount: expectedCount
            });
        }
        if (count > expectedCount) {
            this.throwError("too many arguments" + message, Logger.errors.UNEXPECTED_ARGUMENT, {
                count: count,
                expectedCount: expectedCount
            });
        }
    }
    checkNew(target, kind) {
        if (target === Object || target == null) {
            this.throwError("missing new", Logger.errors.MISSING_NEW, { name: kind.name });
        }
    }
    checkAbstract(target, kind) {
        if (target === kind) {
            this.throwError("cannot instantiate abstract class " + JSON.stringify(kind.name) + " directly; use a sub-class", Logger.errors.UNSUPPORTED_OPERATION, { name: target.name, operation: "new" });
        }
        else if (target === Object || target == null) {
            this.throwError("missing new", Logger.errors.MISSING_NEW, { name: kind.name });
        }
    }
    static globalLogger() {
        if (!_globalLogger) {
            _globalLogger = new Logger(version$b);
        }
        return _globalLogger;
    }
    static setCensorship(censorship, permanent) {
        if (!censorship && permanent) {
            this.globalLogger().throwError("cannot permanently disable censorship", Logger.errors.UNSUPPORTED_OPERATION, {
                operation: "setCensorship"
            });
        }
        if (_permanentCensorErrors) {
            if (!censorship) {
                return;
            }
            this.globalLogger().throwError("error censorship permanent", Logger.errors.UNSUPPORTED_OPERATION, {
                operation: "setCensorship"
            });
        }
        _censorErrors = !!censorship;
        _permanentCensorErrors = !!permanent;
    }
    static setLogLevel(logLevel) {
        const level = LogLevels[logLevel.toLowerCase()];
        if (level == null) {
            Logger.globalLogger().warn("invalid log level - " + logLevel);
            return;
        }
        _logLevel = level;
    }
    static from(version) {
        return new Logger(version);
    }
}
Logger.errors = ErrorCode;
Logger.levels = LogLevel;

const version$a = "bytes/5.7.0";

const logger$e = new Logger(version$a);
///////////////////////////////
function isHexable(value) {
    return !!(value.toHexString);
}
function addSlice(array) {
    if (array.slice) {
        return array;
    }
    array.slice = function () {
        const args = Array.prototype.slice.call(arguments);
        return addSlice(new Uint8Array(Array.prototype.slice.apply(array, args)));
    };
    return array;
}
function isBytesLike(value) {
    return ((isHexString(value) && !(value.length % 2)) || isBytes(value));
}
function isInteger(value) {
    return (typeof (value) === "number" && value == value && (value % 1) === 0);
}
function isBytes(value) {
    if (value == null) {
        return false;
    }
    if (value.constructor === Uint8Array) {
        return true;
    }
    if (typeof (value) === "string") {
        return false;
    }
    if (!isInteger(value.length) || value.length < 0) {
        return false;
    }
    for (let i = 0; i < value.length; i++) {
        const v = value[i];
        if (!isInteger(v) || v < 0 || v >= 256) {
            return false;
        }
    }
    return true;
}
function arrayify(value, options) {
    if (!options) {
        options = {};
    }
    if (typeof (value) === "number") {
        logger$e.checkSafeUint53(value, "invalid arrayify value");
        const result = [];
        while (value) {
            result.unshift(value & 0xff);
            value = parseInt(String(value / 256));
        }
        if (result.length === 0) {
            result.push(0);
        }
        return addSlice(new Uint8Array(result));
    }
    if (options.allowMissingPrefix && typeof (value) === "string" && value.substring(0, 2) !== "0x") {
        value = "0x" + value;
    }
    if (isHexable(value)) {
        value = value.toHexString();
    }
    if (isHexString(value)) {
        let hex = value.substring(2);
        if (hex.length % 2) {
            if (options.hexPad === "left") {
                hex = "0" + hex;
            }
            else if (options.hexPad === "right") {
                hex += "0";
            }
            else {
                logger$e.throwArgumentError("hex data is odd-length", "value", value);
            }
        }
        const result = [];
        for (let i = 0; i < hex.length; i += 2) {
            result.push(parseInt(hex.substring(i, i + 2), 16));
        }
        return addSlice(new Uint8Array(result));
    }
    if (isBytes(value)) {
        return addSlice(new Uint8Array(value));
    }
    return logger$e.throwArgumentError("invalid arrayify value", "value", value);
}
function concat(items) {
    const objects = items.map(item => arrayify(item));
    const length = objects.reduce((accum, item) => (accum + item.length), 0);
    const result = new Uint8Array(length);
    objects.reduce((offset, object) => {
        result.set(object, offset);
        return offset + object.length;
    }, 0);
    return addSlice(result);
}
function stripZeros(value) {
    let result = arrayify(value);
    if (result.length === 0) {
        return result;
    }
    // Find the first non-zero entry
    let start = 0;
    while (start < result.length && result[start] === 0) {
        start++;
    }
    // If we started with zeros, strip them
    if (start) {
        result = result.slice(start);
    }
    return result;
}
function isHexString(value, length) {
    if (typeof (value) !== "string" || !value.match(/^0x[0-9A-Fa-f]*$/)) {
        return false;
    }
    if (length && value.length !== 2 + 2 * length) {
        return false;
    }
    return true;
}
const HexCharacters = "0123456789abcdef";
function hexlify(value, options) {
    if (!options) {
        options = {};
    }
    if (typeof (value) === "number") {
        logger$e.checkSafeUint53(value, "invalid hexlify value");
        let hex = "";
        while (value) {
            hex = HexCharacters[value & 0xf] + hex;
            value = Math.floor(value / 16);
        }
        if (hex.length) {
            if (hex.length % 2) {
                hex = "0" + hex;
            }
            return "0x" + hex;
        }
        return "0x00";
    }
    if (typeof (value) === "bigint") {
        value = value.toString(16);
        if (value.length % 2) {
            return ("0x0" + value);
        }
        return "0x" + value;
    }
    if (options.allowMissingPrefix && typeof (value) === "string" && value.substring(0, 2) !== "0x") {
        value = "0x" + value;
    }
    if (isHexable(value)) {
        return value.toHexString();
    }
    if (isHexString(value)) {
        if (value.length % 2) {
            if (options.hexPad === "left") {
                value = "0x0" + value.substring(2);
            }
            else if (options.hexPad === "right") {
                value += "0";
            }
            else {
                logger$e.throwArgumentError("hex data is odd-length", "value", value);
            }
        }
        return value.toLowerCase();
    }
    if (isBytes(value)) {
        let result = "0x";
        for (let i = 0; i < value.length; i++) {
            let v = value[i];
            result += HexCharacters[(v & 0xf0) >> 4] + HexCharacters[v & 0x0f];
        }
        return result;
    }
    return logger$e.throwArgumentError("invalid hexlify value", "value", value);
}
/*
function unoddify(value: BytesLike | Hexable | number): BytesLike | Hexable | number {
    if (typeof(value) === "string" && value.length % 2 && value.substring(0, 2) === "0x") {
        return "0x0" + value.substring(2);
    }
    return value;
}
*/
function hexDataLength(data) {
    if (typeof (data) !== "string") {
        data = hexlify(data);
    }
    else if (!isHexString(data) || (data.length % 2)) {
        return null;
    }
    return (data.length - 2) / 2;
}
function hexDataSlice(data, offset, endOffset) {
    if (typeof (data) !== "string") {
        data = hexlify(data);
    }
    else if (!isHexString(data) || (data.length % 2)) {
        logger$e.throwArgumentError("invalid hexData", "value", data);
    }
    offset = 2 + 2 * offset;
    if (endOffset != null) {
        return "0x" + data.substring(offset, 2 + 2 * endOffset);
    }
    return "0x" + data.substring(offset);
}
function hexConcat(items) {
    let result = "0x";
    items.forEach((item) => {
        result += hexlify(item).substring(2);
    });
    return result;
}
function hexZeroPad(value, length) {
    if (typeof (value) !== "string") {
        value = hexlify(value);
    }
    else if (!isHexString(value)) {
        logger$e.throwArgumentError("invalid hex string", "value", value);
    }
    if (value.length > 2 * length + 2) {
        logger$e.throwArgumentError("value out of range", "value", arguments[1]);
    }
    while (value.length < 2 * length + 2) {
        value = "0x0" + value.substring(2);
    }
    return value;
}

const version$9 = "bignumber/5.7.0";

var BN = BN$1.BN;
const logger$d = new Logger(version$9);
const _constructorGuard$1 = {};
const MAX_SAFE = 0x1fffffffffffff;
// Only warn about passing 10 into radix once
let _warnedToStringRadix = false;
class BigNumber {
    constructor(constructorGuard, hex) {
        if (constructorGuard !== _constructorGuard$1) {
            logger$d.throwError("cannot call constructor directly; use BigNumber.from", Logger.errors.UNSUPPORTED_OPERATION, {
                operation: "new (BigNumber)"
            });
        }
        this._hex = hex;
        this._isBigNumber = true;
        Object.freeze(this);
    }
    fromTwos(value) {
        return toBigNumber(toBN(this).fromTwos(value));
    }
    toTwos(value) {
        return toBigNumber(toBN(this).toTwos(value));
    }
    abs() {
        if (this._hex[0] === "-") {
            return BigNumber.from(this._hex.substring(1));
        }
        return this;
    }
    add(other) {
        return toBigNumber(toBN(this).add(toBN(other)));
    }
    sub(other) {
        return toBigNumber(toBN(this).sub(toBN(other)));
    }
    div(other) {
        const o = BigNumber.from(other);
        if (o.isZero()) {
            throwFault("division-by-zero", "div");
        }
        return toBigNumber(toBN(this).div(toBN(other)));
    }
    mul(other) {
        return toBigNumber(toBN(this).mul(toBN(other)));
    }
    mod(other) {
        const value = toBN(other);
        if (value.isNeg()) {
            throwFault("division-by-zero", "mod");
        }
        return toBigNumber(toBN(this).umod(value));
    }
    pow(other) {
        const value = toBN(other);
        if (value.isNeg()) {
            throwFault("negative-power", "pow");
        }
        return toBigNumber(toBN(this).pow(value));
    }
    and(other) {
        const value = toBN(other);
        if (this.isNegative() || value.isNeg()) {
            throwFault("unbound-bitwise-result", "and");
        }
        return toBigNumber(toBN(this).and(value));
    }
    or(other) {
        const value = toBN(other);
        if (this.isNegative() || value.isNeg()) {
            throwFault("unbound-bitwise-result", "or");
        }
        return toBigNumber(toBN(this).or(value));
    }
    xor(other) {
        const value = toBN(other);
        if (this.isNegative() || value.isNeg()) {
            throwFault("unbound-bitwise-result", "xor");
        }
        return toBigNumber(toBN(this).xor(value));
    }
    mask(value) {
        if (this.isNegative() || value < 0) {
            throwFault("negative-width", "mask");
        }
        return toBigNumber(toBN(this).maskn(value));
    }
    shl(value) {
        if (this.isNegative() || value < 0) {
            throwFault("negative-width", "shl");
        }
        return toBigNumber(toBN(this).shln(value));
    }
    shr(value) {
        if (this.isNegative() || value < 0) {
            throwFault("negative-width", "shr");
        }
        return toBigNumber(toBN(this).shrn(value));
    }
    eq(other) {
        return toBN(this).eq(toBN(other));
    }
    lt(other) {
        return toBN(this).lt(toBN(other));
    }
    lte(other) {
        return toBN(this).lte(toBN(other));
    }
    gt(other) {
        return toBN(this).gt(toBN(other));
    }
    gte(other) {
        return toBN(this).gte(toBN(other));
    }
    isNegative() {
        return (this._hex[0] === "-");
    }
    isZero() {
        return toBN(this).isZero();
    }
    toNumber() {
        try {
            return toBN(this).toNumber();
        }
        catch (error) {
            throwFault("overflow", "toNumber", this.toString());
        }
        return null;
    }
    toBigInt() {
        try {
            return BigInt(this.toString());
        }
        catch (e) { }
        return logger$d.throwError("this platform does not support BigInt", Logger.errors.UNSUPPORTED_OPERATION, {
            value: this.toString()
        });
    }
    toString() {
        // Lots of people expect this, which we do not support, so check (See: #889)
        if (arguments.length > 0) {
            if (arguments[0] === 10) {
                if (!_warnedToStringRadix) {
                    _warnedToStringRadix = true;
                    logger$d.warn("BigNumber.toString does not accept any parameters; base-10 is assumed");
                }
            }
            else if (arguments[0] === 16) {
                logger$d.throwError("BigNumber.toString does not accept any parameters; use bigNumber.toHexString()", Logger.errors.UNEXPECTED_ARGUMENT, {});
            }
            else {
                logger$d.throwError("BigNumber.toString does not accept parameters", Logger.errors.UNEXPECTED_ARGUMENT, {});
            }
        }
        return toBN(this).toString(10);
    }
    toHexString() {
        return this._hex;
    }
    toJSON(key) {
        return { type: "BigNumber", hex: this.toHexString() };
    }
    static from(value) {
        if (value instanceof BigNumber) {
            return value;
        }
        if (typeof (value) === "string") {
            if (value.match(/^-?0x[0-9a-f]+$/i)) {
                return new BigNumber(_constructorGuard$1, toHex(value));
            }
            if (value.match(/^-?[0-9]+$/)) {
                return new BigNumber(_constructorGuard$1, toHex(new BN(value)));
            }
            return logger$d.throwArgumentError("invalid BigNumber string", "value", value);
        }
        if (typeof (value) === "number") {
            if (value % 1) {
                throwFault("underflow", "BigNumber.from", value);
            }
            if (value >= MAX_SAFE || value <= -MAX_SAFE) {
                throwFault("overflow", "BigNumber.from", value);
            }
            return BigNumber.from(String(value));
        }
        const anyValue = value;
        if (typeof (anyValue) === "bigint") {
            return BigNumber.from(anyValue.toString());
        }
        if (isBytes(anyValue)) {
            return BigNumber.from(hexlify(anyValue));
        }
        if (anyValue) {
            // Hexable interface (takes priority)
            if (anyValue.toHexString) {
                const hex = anyValue.toHexString();
                if (typeof (hex) === "string") {
                    return BigNumber.from(hex);
                }
            }
            else {
                // For now, handle legacy JSON-ified values (goes away in v6)
                let hex = anyValue._hex;
                // New-form JSON
                if (hex == null && anyValue.type === "BigNumber") {
                    hex = anyValue.hex;
                }
                if (typeof (hex) === "string") {
                    if (isHexString(hex) || (hex[0] === "-" && isHexString(hex.substring(1)))) {
                        return BigNumber.from(hex);
                    }
                }
            }
        }
        return logger$d.throwArgumentError("invalid BigNumber value", "value", value);
    }
    static isBigNumber(value) {
        return !!(value && value._isBigNumber);
    }
}
// Normalize the hex string
function toHex(value) {
    // For BN, call on the hex string
    if (typeof (value) !== "string") {
        return toHex(value.toString(16));
    }
    // If negative, prepend the negative sign to the normalized positive value
    if (value[0] === "-") {
        // Strip off the negative sign
        value = value.substring(1);
        // Cannot have multiple negative signs (e.g. "--0x04")
        if (value[0] === "-") {
            logger$d.throwArgumentError("invalid hex", "value", value);
        }
        // Call toHex on the positive component
        value = toHex(value);
        // Do not allow "-0x00"
        if (value === "0x00") {
            return value;
        }
        // Negate the value
        return "-" + value;
    }
    // Add a "0x" prefix if missing
    if (value.substring(0, 2) !== "0x") {
        value = "0x" + value;
    }
    // Normalize zero
    if (value === "0x") {
        return "0x00";
    }
    // Make the string even length
    if (value.length % 2) {
        value = "0x0" + value.substring(2);
    }
    // Trim to smallest even-length string
    while (value.length > 4 && value.substring(0, 4) === "0x00") {
        value = "0x" + value.substring(4);
    }
    return value;
}
function toBigNumber(value) {
    return BigNumber.from(toHex(value));
}
function toBN(value) {
    const hex = BigNumber.from(value).toHexString();
    if (hex[0] === "-") {
        return (new BN("-" + hex.substring(3), 16));
    }
    return new BN(hex.substring(2), 16);
}
function throwFault(fault, operation, value) {
    const params = { fault: fault, operation: operation };
    if (value != null) {
        params.value = value;
    }
    return logger$d.throwError(fault, Logger.errors.NUMERIC_FAULT, params);
}
// value should have no prefix
function _base36To16(value) {
    return (new BN(value, 36)).toString(16);
}

const version$8 = "properties/5.7.0";

var __awaiter$3 = function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
const logger$c = new Logger(version$8);
function defineReadOnly(object, name, value) {
    Object.defineProperty(object, name, {
        enumerable: true,
        value: value,
        writable: false,
    });
}
// Crawl up the constructor chain to find a static method
function getStatic(ctor, key) {
    for (let i = 0; i < 32; i++) {
        if (ctor[key]) {
            return ctor[key];
        }
        if (!ctor.prototype || typeof (ctor.prototype) !== "object") {
            break;
        }
        ctor = Object.getPrototypeOf(ctor.prototype).constructor;
    }
    return null;
}
function resolveProperties(object) {
    return __awaiter$3(this, void 0, void 0, function* () {
        const promises = Object.keys(object).map((key) => {
            const value = object[key];
            return Promise.resolve(value).then((v) => ({ key: key, value: v }));
        });
        const results = yield Promise.all(promises);
        return results.reduce((accum, result) => {
            accum[(result.key)] = result.value;
            return accum;
        }, {});
    });
}
function shallowCopy(object) {
    const result = {};
    for (const key in object) {
        result[key] = object[key];
    }
    return result;
}
const opaque = { bigint: true, boolean: true, "function": true, number: true, string: true };
function _isFrozen(object) {
    // Opaque objects are not mutable, so safe to copy by assignment
    if (object === undefined || object === null || opaque[typeof (object)]) {
        return true;
    }
    if (Array.isArray(object) || typeof (object) === "object") {
        if (!Object.isFrozen(object)) {
            return false;
        }
        const keys = Object.keys(object);
        for (let i = 0; i < keys.length; i++) {
            let value = null;
            try {
                value = object[keys[i]];
            }
            catch (error) {
                // If accessing a value triggers an error, it is a getter
                // designed to do so (e.g. Result) and is therefore "frozen"
                continue;
            }
            if (!_isFrozen(value)) {
                return false;
            }
        }
        return true;
    }
    return logger$c.throwArgumentError(`Cannot deepCopy ${typeof (object)}`, "object", object);
}
// Returns a new copy of object, such that no properties may be replaced.
// New properties may be added only to objects.
function _deepCopy(object) {
    if (_isFrozen(object)) {
        return object;
    }
    // Arrays are mutable, so we need to create a copy
    if (Array.isArray(object)) {
        return Object.freeze(object.map((item) => deepCopy(item)));
    }
    if (typeof (object) === "object") {
        const result = {};
        for (const key in object) {
            const value = object[key];
            if (value === undefined) {
                continue;
            }
            defineReadOnly(result, key, deepCopy(value));
        }
        return result;
    }
    return logger$c.throwArgumentError(`Cannot deepCopy ${typeof (object)}`, "object", object);
}
function deepCopy(object) {
    return _deepCopy(object);
}
class Description {
    constructor(info) {
        for (const key in info) {
            this[key] = deepCopy(info[key]);
        }
    }
}

const version$7 = "abi/5.7.0";

const logger$b = new Logger(version$7);
const _constructorGuard = {};
let ModifiersBytes = { calldata: true, memory: true, storage: true };
let ModifiersNest = { calldata: true, memory: true };
function checkModifier(type, name) {
    if (type === "bytes" || type === "string") {
        if (ModifiersBytes[name]) {
            return true;
        }
    }
    else if (type === "address") {
        if (name === "payable") {
            return true;
        }
    }
    else if (type.indexOf("[") >= 0 || type === "tuple") {
        if (ModifiersNest[name]) {
            return true;
        }
    }
    if (ModifiersBytes[name] || name === "payable") {
        logger$b.throwArgumentError("invalid modifier", "name", name);
    }
    return false;
}
// @TODO: Make sure that children of an indexed tuple are marked with a null indexed
function parseParamType(param, allowIndexed) {
    let originalParam = param;
    function throwError(i) {
        logger$b.throwArgumentError(`unexpected character at position ${i}`, "param", param);
    }
    param = param.replace(/\s/g, " ");
    function newNode(parent) {
        let node = { type: "", name: "", parent: parent, state: { allowType: true } };
        if (allowIndexed) {
            node.indexed = false;
        }
        return node;
    }
    let parent = { type: "", name: "", state: { allowType: true } };
    let node = parent;
    for (let i = 0; i < param.length; i++) {
        let c = param[i];
        switch (c) {
            case "(":
                if (node.state.allowType && node.type === "") {
                    node.type = "tuple";
                }
                else if (!node.state.allowParams) {
                    throwError(i);
                }
                node.state.allowType = false;
                node.type = verifyType(node.type);
                node.components = [newNode(node)];
                node = node.components[0];
                break;
            case ")":
                delete node.state;
                if (node.name === "indexed") {
                    if (!allowIndexed) {
                        throwError(i);
                    }
                    node.indexed = true;
                    node.name = "";
                }
                if (checkModifier(node.type, node.name)) {
                    node.name = "";
                }
                node.type = verifyType(node.type);
                let child = node;
                node = node.parent;
                if (!node) {
                    throwError(i);
                }
                delete child.parent;
                node.state.allowParams = false;
                node.state.allowName = true;
                node.state.allowArray = true;
                break;
            case ",":
                delete node.state;
                if (node.name === "indexed") {
                    if (!allowIndexed) {
                        throwError(i);
                    }
                    node.indexed = true;
                    node.name = "";
                }
                if (checkModifier(node.type, node.name)) {
                    node.name = "";
                }
                node.type = verifyType(node.type);
                let sibling = newNode(node.parent);
                //{ type: "", name: "", parent: node.parent, state: { allowType: true } };
                node.parent.components.push(sibling);
                delete node.parent;
                node = sibling;
                break;
            // Hit a space...
            case " ":
                // If reading type, the type is done and may read a param or name
                if (node.state.allowType) {
                    if (node.type !== "") {
                        node.type = verifyType(node.type);
                        delete node.state.allowType;
                        node.state.allowName = true;
                        node.state.allowParams = true;
                    }
                }
                // If reading name, the name is done
                if (node.state.allowName) {
                    if (node.name !== "") {
                        if (node.name === "indexed") {
                            if (!allowIndexed) {
                                throwError(i);
                            }
                            if (node.indexed) {
                                throwError(i);
                            }
                            node.indexed = true;
                            node.name = "";
                        }
                        else if (checkModifier(node.type, node.name)) {
                            node.name = "";
                        }
                        else {
                            node.state.allowName = false;
                        }
                    }
                }
                break;
            case "[":
                if (!node.state.allowArray) {
                    throwError(i);
                }
                node.type += c;
                node.state.allowArray = false;
                node.state.allowName = false;
                node.state.readArray = true;
                break;
            case "]":
                if (!node.state.readArray) {
                    throwError(i);
                }
                node.type += c;
                node.state.readArray = false;
                node.state.allowArray = true;
                node.state.allowName = true;
                break;
            default:
                if (node.state.allowType) {
                    node.type += c;
                    node.state.allowParams = true;
                    node.state.allowArray = true;
                }
                else if (node.state.allowName) {
                    node.name += c;
                    delete node.state.allowArray;
                }
                else if (node.state.readArray) {
                    node.type += c;
                }
                else {
                    throwError(i);
                }
        }
    }
    if (node.parent) {
        logger$b.throwArgumentError("unexpected eof", "param", param);
    }
    delete parent.state;
    if (node.name === "indexed") {
        if (!allowIndexed) {
            throwError(originalParam.length - 7);
        }
        if (node.indexed) {
            throwError(originalParam.length - 7);
        }
        node.indexed = true;
        node.name = "";
    }
    else if (checkModifier(node.type, node.name)) {
        node.name = "";
    }
    parent.type = verifyType(parent.type);
    return parent;
}
function populate(object, params) {
    for (let key in params) {
        defineReadOnly(object, key, params[key]);
    }
}
const FormatTypes = Object.freeze({
    // Bare formatting, as is needed for computing a sighash of an event or function
    sighash: "sighash",
    // Human-Readable with Minimal spacing and without names (compact human-readable)
    minimal: "minimal",
    // Human-Readable with nice spacing, including all names
    full: "full",
    // JSON-format a la Solidity
    json: "json"
});
const paramTypeArray = new RegExp(/^(.*)\[([0-9]*)\]$/);
class ParamType {
    constructor(constructorGuard, params) {
        if (constructorGuard !== _constructorGuard) {
            logger$b.throwError("use fromString", Logger.errors.UNSUPPORTED_OPERATION, {
                operation: "new ParamType()"
            });
        }
        populate(this, params);
        let match = this.type.match(paramTypeArray);
        if (match) {
            populate(this, {
                arrayLength: parseInt(match[2] || "-1"),
                arrayChildren: ParamType.fromObject({
                    type: match[1],
                    components: this.components
                }),
                baseType: "array"
            });
        }
        else {
            populate(this, {
                arrayLength: null,
                arrayChildren: null,
                baseType: ((this.components != null) ? "tuple" : this.type)
            });
        }
        this._isParamType = true;
        Object.freeze(this);
    }
    // Format the parameter fragment
    //   - sighash: "(uint256,address)"
    //   - minimal: "tuple(uint256,address) indexed"
    //   - full:    "tuple(uint256 foo, address bar) indexed baz"
    format(format) {
        if (!format) {
            format = FormatTypes.sighash;
        }
        if (!FormatTypes[format]) {
            logger$b.throwArgumentError("invalid format type", "format", format);
        }
        if (format === FormatTypes.json) {
            let result = {
                type: ((this.baseType === "tuple") ? "tuple" : this.type),
                name: (this.name || undefined)
            };
            if (typeof (this.indexed) === "boolean") {
                result.indexed = this.indexed;
            }
            if (this.components) {
                result.components = this.components.map((comp) => JSON.parse(comp.format(format)));
            }
            return JSON.stringify(result);
        }
        let result = "";
        // Array
        if (this.baseType === "array") {
            result += this.arrayChildren.format(format);
            result += "[" + (this.arrayLength < 0 ? "" : String(this.arrayLength)) + "]";
        }
        else {
            if (this.baseType === "tuple") {
                if (format !== FormatTypes.sighash) {
                    result += this.type;
                }
                result += "(" + this.components.map((comp) => comp.format(format)).join((format === FormatTypes.full) ? ", " : ",") + ")";
            }
            else {
                result += this.type;
            }
        }
        if (format !== FormatTypes.sighash) {
            if (this.indexed === true) {
                result += " indexed";
            }
            if (format === FormatTypes.full && this.name) {
                result += " " + this.name;
            }
        }
        return result;
    }
    static from(value, allowIndexed) {
        if (typeof (value) === "string") {
            return ParamType.fromString(value, allowIndexed);
        }
        return ParamType.fromObject(value);
    }
    static fromObject(value) {
        if (ParamType.isParamType(value)) {
            return value;
        }
        return new ParamType(_constructorGuard, {
            name: (value.name || null),
            type: verifyType(value.type),
            indexed: ((value.indexed == null) ? null : !!value.indexed),
            components: (value.components ? value.components.map(ParamType.fromObject) : null)
        });
    }
    static fromString(value, allowIndexed) {
        function ParamTypify(node) {
            return ParamType.fromObject({
                name: node.name,
                type: node.type,
                indexed: node.indexed,
                components: node.components
            });
        }
        return ParamTypify(parseParamType(value, !!allowIndexed));
    }
    static isParamType(value) {
        return !!(value != null && value._isParamType);
    }
}
function parseParams(value, allowIndex) {
    return splitNesting(value).map((param) => ParamType.fromString(param, allowIndex));
}
class Fragment {
    constructor(constructorGuard, params) {
        if (constructorGuard !== _constructorGuard) {
            logger$b.throwError("use a static from method", Logger.errors.UNSUPPORTED_OPERATION, {
                operation: "new Fragment()"
            });
        }
        populate(this, params);
        this._isFragment = true;
        Object.freeze(this);
    }
    static from(value) {
        if (Fragment.isFragment(value)) {
            return value;
        }
        if (typeof (value) === "string") {
            return Fragment.fromString(value);
        }
        return Fragment.fromObject(value);
    }
    static fromObject(value) {
        if (Fragment.isFragment(value)) {
            return value;
        }
        switch (value.type) {
            case "function":
                return FunctionFragment.fromObject(value);
            case "event":
                return EventFragment.fromObject(value);
            case "constructor":
                return ConstructorFragment.fromObject(value);
            case "error":
                return ErrorFragment.fromObject(value);
            case "fallback":
            case "receive":
                // @TODO: Something? Maybe return a FunctionFragment? A custom DefaultFunctionFragment?
                return null;
        }
        return logger$b.throwArgumentError("invalid fragment object", "value", value);
    }
    static fromString(value) {
        // Make sure the "returns" is surrounded by a space and all whitespace is exactly one space
        value = value.replace(/\s/g, " ");
        value = value.replace(/\(/g, " (").replace(/\)/g, ") ").replace(/\s+/g, " ");
        value = value.trim();
        if (value.split(" ")[0] === "event") {
            return EventFragment.fromString(value.substring(5).trim());
        }
        else if (value.split(" ")[0] === "function") {
            return FunctionFragment.fromString(value.substring(8).trim());
        }
        else if (value.split("(")[0].trim() === "constructor") {
            return ConstructorFragment.fromString(value.trim());
        }
        else if (value.split(" ")[0] === "error") {
            return ErrorFragment.fromString(value.substring(5).trim());
        }
        return logger$b.throwArgumentError("unsupported fragment", "value", value);
    }
    static isFragment(value) {
        return !!(value && value._isFragment);
    }
}
class EventFragment extends Fragment {
    format(format) {
        if (!format) {
            format = FormatTypes.sighash;
        }
        if (!FormatTypes[format]) {
            logger$b.throwArgumentError("invalid format type", "format", format);
        }
        if (format === FormatTypes.json) {
            return JSON.stringify({
                type: "event",
                anonymous: this.anonymous,
                name: this.name,
                inputs: this.inputs.map((input) => JSON.parse(input.format(format)))
            });
        }
        let result = "";
        if (format !== FormatTypes.sighash) {
            result += "event ";
        }
        result += this.name + "(" + this.inputs.map((input) => input.format(format)).join((format === FormatTypes.full) ? ", " : ",") + ") ";
        if (format !== FormatTypes.sighash) {
            if (this.anonymous) {
                result += "anonymous ";
            }
        }
        return result.trim();
    }
    static from(value) {
        if (typeof (value) === "string") {
            return EventFragment.fromString(value);
        }
        return EventFragment.fromObject(value);
    }
    static fromObject(value) {
        if (EventFragment.isEventFragment(value)) {
            return value;
        }
        if (value.type !== "event") {
            logger$b.throwArgumentError("invalid event object", "value", value);
        }
        const params = {
            name: verifyIdentifier(value.name),
            anonymous: value.anonymous,
            inputs: (value.inputs ? value.inputs.map(ParamType.fromObject) : []),
            type: "event"
        };
        return new EventFragment(_constructorGuard, params);
    }
    static fromString(value) {
        let match = value.match(regexParen);
        if (!match) {
            logger$b.throwArgumentError("invalid event string", "value", value);
        }
        let anonymous = false;
        match[3].split(" ").forEach((modifier) => {
            switch (modifier.trim()) {
                case "anonymous":
                    anonymous = true;
                    break;
                case "":
                    break;
                default:
                    logger$b.warn("unknown modifier: " + modifier);
            }
        });
        return EventFragment.fromObject({
            name: match[1].trim(),
            anonymous: anonymous,
            inputs: parseParams(match[2], true),
            type: "event"
        });
    }
    static isEventFragment(value) {
        return (value && value._isFragment && value.type === "event");
    }
}
function parseGas(value, params) {
    params.gas = null;
    let comps = value.split("@");
    if (comps.length !== 1) {
        if (comps.length > 2) {
            logger$b.throwArgumentError("invalid human-readable ABI signature", "value", value);
        }
        if (!comps[1].match(/^[0-9]+$/)) {
            logger$b.throwArgumentError("invalid human-readable ABI signature gas", "value", value);
        }
        params.gas = BigNumber.from(comps[1]);
        return comps[0];
    }
    return value;
}
function parseModifiers(value, params) {
    params.constant = false;
    params.payable = false;
    params.stateMutability = "nonpayable";
    value.split(" ").forEach((modifier) => {
        switch (modifier.trim()) {
            case "constant":
                params.constant = true;
                break;
            case "payable":
                params.payable = true;
                params.stateMutability = "payable";
                break;
            case "nonpayable":
                params.payable = false;
                params.stateMutability = "nonpayable";
                break;
            case "pure":
                params.constant = true;
                params.stateMutability = "pure";
                break;
            case "view":
                params.constant = true;
                params.stateMutability = "view";
                break;
            case "external":
            case "public":
            case "":
                break;
            default:
                console.log("unknown modifier: " + modifier);
        }
    });
}
function verifyState(value) {
    let result = {
        constant: false,
        payable: true,
        stateMutability: "payable"
    };
    if (value.stateMutability != null) {
        result.stateMutability = value.stateMutability;
        // Set (and check things are consistent) the constant property
        result.constant = (result.stateMutability === "view" || result.stateMutability === "pure");
        if (value.constant != null) {
            if ((!!value.constant) !== result.constant) {
                logger$b.throwArgumentError("cannot have constant function with mutability " + result.stateMutability, "value", value);
            }
        }
        // Set (and check things are consistent) the payable property
        result.payable = (result.stateMutability === "payable");
        if (value.payable != null) {
            if ((!!value.payable) !== result.payable) {
                logger$b.throwArgumentError("cannot have payable function with mutability " + result.stateMutability, "value", value);
            }
        }
    }
    else if (value.payable != null) {
        result.payable = !!value.payable;
        // If payable we can assume non-constant; otherwise we can't assume
        if (value.constant == null && !result.payable && value.type !== "constructor") {
            logger$b.throwArgumentError("unable to determine stateMutability", "value", value);
        }
        result.constant = !!value.constant;
        if (result.constant) {
            result.stateMutability = "view";
        }
        else {
            result.stateMutability = (result.payable ? "payable" : "nonpayable");
        }
        if (result.payable && result.constant) {
            logger$b.throwArgumentError("cannot have constant payable function", "value", value);
        }
    }
    else if (value.constant != null) {
        result.constant = !!value.constant;
        result.payable = !result.constant;
        result.stateMutability = (result.constant ? "view" : "payable");
    }
    else if (value.type !== "constructor") {
        logger$b.throwArgumentError("unable to determine stateMutability", "value", value);
    }
    return result;
}
class ConstructorFragment extends Fragment {
    format(format) {
        if (!format) {
            format = FormatTypes.sighash;
        }
        if (!FormatTypes[format]) {
            logger$b.throwArgumentError("invalid format type", "format", format);
        }
        if (format === FormatTypes.json) {
            return JSON.stringify({
                type: "constructor",
                stateMutability: ((this.stateMutability !== "nonpayable") ? this.stateMutability : undefined),
                payable: this.payable,
                gas: (this.gas ? this.gas.toNumber() : undefined),
                inputs: this.inputs.map((input) => JSON.parse(input.format(format)))
            });
        }
        if (format === FormatTypes.sighash) {
            logger$b.throwError("cannot format a constructor for sighash", Logger.errors.UNSUPPORTED_OPERATION, {
                operation: "format(sighash)"
            });
        }
        let result = "constructor(" + this.inputs.map((input) => input.format(format)).join((format === FormatTypes.full) ? ", " : ",") + ") ";
        if (this.stateMutability && this.stateMutability !== "nonpayable") {
            result += this.stateMutability + " ";
        }
        return result.trim();
    }
    static from(value) {
        if (typeof (value) === "string") {
            return ConstructorFragment.fromString(value);
        }
        return ConstructorFragment.fromObject(value);
    }
    static fromObject(value) {
        if (ConstructorFragment.isConstructorFragment(value)) {
            return value;
        }
        if (value.type !== "constructor") {
            logger$b.throwArgumentError("invalid constructor object", "value", value);
        }
        let state = verifyState(value);
        if (state.constant) {
            logger$b.throwArgumentError("constructor cannot be constant", "value", value);
        }
        const params = {
            name: null,
            type: value.type,
            inputs: (value.inputs ? value.inputs.map(ParamType.fromObject) : []),
            payable: state.payable,
            stateMutability: state.stateMutability,
            gas: (value.gas ? BigNumber.from(value.gas) : null)
        };
        return new ConstructorFragment(_constructorGuard, params);
    }
    static fromString(value) {
        let params = { type: "constructor" };
        value = parseGas(value, params);
        let parens = value.match(regexParen);
        if (!parens || parens[1].trim() !== "constructor") {
            logger$b.throwArgumentError("invalid constructor string", "value", value);
        }
        params.inputs = parseParams(parens[2].trim(), false);
        parseModifiers(parens[3].trim(), params);
        return ConstructorFragment.fromObject(params);
    }
    static isConstructorFragment(value) {
        return (value && value._isFragment && value.type === "constructor");
    }
}
class FunctionFragment extends ConstructorFragment {
    format(format) {
        if (!format) {
            format = FormatTypes.sighash;
        }
        if (!FormatTypes[format]) {
            logger$b.throwArgumentError("invalid format type", "format", format);
        }
        if (format === FormatTypes.json) {
            return JSON.stringify({
                type: "function",
                name: this.name,
                constant: this.constant,
                stateMutability: ((this.stateMutability !== "nonpayable") ? this.stateMutability : undefined),
                payable: this.payable,
                gas: (this.gas ? this.gas.toNumber() : undefined),
                inputs: this.inputs.map((input) => JSON.parse(input.format(format))),
                outputs: this.outputs.map((output) => JSON.parse(output.format(format))),
            });
        }
        let result = "";
        if (format !== FormatTypes.sighash) {
            result += "function ";
        }
        result += this.name + "(" + this.inputs.map((input) => input.format(format)).join((format === FormatTypes.full) ? ", " : ",") + ") ";
        if (format !== FormatTypes.sighash) {
            if (this.stateMutability) {
                if (this.stateMutability !== "nonpayable") {
                    result += (this.stateMutability + " ");
                }
            }
            else if (this.constant) {
                result += "view ";
            }
            if (this.outputs && this.outputs.length) {
                result += "returns (" + this.outputs.map((output) => output.format(format)).join(", ") + ") ";
            }
            if (this.gas != null) {
                result += "@" + this.gas.toString() + " ";
            }
        }
        return result.trim();
    }
    static from(value) {
        if (typeof (value) === "string") {
            return FunctionFragment.fromString(value);
        }
        return FunctionFragment.fromObject(value);
    }
    static fromObject(value) {
        if (FunctionFragment.isFunctionFragment(value)) {
            return value;
        }
        if (value.type !== "function") {
            logger$b.throwArgumentError("invalid function object", "value", value);
        }
        let state = verifyState(value);
        const params = {
            type: value.type,
            name: verifyIdentifier(value.name),
            constant: state.constant,
            inputs: (value.inputs ? value.inputs.map(ParamType.fromObject) : []),
            outputs: (value.outputs ? value.outputs.map(ParamType.fromObject) : []),
            payable: state.payable,
            stateMutability: state.stateMutability,
            gas: (value.gas ? BigNumber.from(value.gas) : null)
        };
        return new FunctionFragment(_constructorGuard, params);
    }
    static fromString(value) {
        let params = { type: "function" };
        value = parseGas(value, params);
        let comps = value.split(" returns ");
        if (comps.length > 2) {
            logger$b.throwArgumentError("invalid function string", "value", value);
        }
        let parens = comps[0].match(regexParen);
        if (!parens) {
            logger$b.throwArgumentError("invalid function signature", "value", value);
        }
        params.name = parens[1].trim();
        if (params.name) {
            verifyIdentifier(params.name);
        }
        params.inputs = parseParams(parens[2], false);
        parseModifiers(parens[3].trim(), params);
        // We have outputs
        if (comps.length > 1) {
            let returns = comps[1].match(regexParen);
            if (returns[1].trim() != "" || returns[3].trim() != "") {
                logger$b.throwArgumentError("unexpected tokens", "value", value);
            }
            params.outputs = parseParams(returns[2], false);
        }
        else {
            params.outputs = [];
        }
        return FunctionFragment.fromObject(params);
    }
    static isFunctionFragment(value) {
        return (value && value._isFragment && value.type === "function");
    }
}
//export class StructFragment extends Fragment {
//}
function checkForbidden(fragment) {
    const sig = fragment.format();
    if (sig === "Error(string)" || sig === "Panic(uint256)") {
        logger$b.throwArgumentError(`cannot specify user defined ${sig} error`, "fragment", fragment);
    }
    return fragment;
}
class ErrorFragment extends Fragment {
    format(format) {
        if (!format) {
            format = FormatTypes.sighash;
        }
        if (!FormatTypes[format]) {
            logger$b.throwArgumentError("invalid format type", "format", format);
        }
        if (format === FormatTypes.json) {
            return JSON.stringify({
                type: "error",
                name: this.name,
                inputs: this.inputs.map((input) => JSON.parse(input.format(format))),
            });
        }
        let result = "";
        if (format !== FormatTypes.sighash) {
            result += "error ";
        }
        result += this.name + "(" + this.inputs.map((input) => input.format(format)).join((format === FormatTypes.full) ? ", " : ",") + ") ";
        return result.trim();
    }
    static from(value) {
        if (typeof (value) === "string") {
            return ErrorFragment.fromString(value);
        }
        return ErrorFragment.fromObject(value);
    }
    static fromObject(value) {
        if (ErrorFragment.isErrorFragment(value)) {
            return value;
        }
        if (value.type !== "error") {
            logger$b.throwArgumentError("invalid error object", "value", value);
        }
        const params = {
            type: value.type,
            name: verifyIdentifier(value.name),
            inputs: (value.inputs ? value.inputs.map(ParamType.fromObject) : [])
        };
        return checkForbidden(new ErrorFragment(_constructorGuard, params));
    }
    static fromString(value) {
        let params = { type: "error" };
        let parens = value.match(regexParen);
        if (!parens) {
            logger$b.throwArgumentError("invalid error signature", "value", value);
        }
        params.name = parens[1].trim();
        if (params.name) {
            verifyIdentifier(params.name);
        }
        params.inputs = parseParams(parens[2], false);
        return checkForbidden(ErrorFragment.fromObject(params));
    }
    static isErrorFragment(value) {
        return (value && value._isFragment && value.type === "error");
    }
}
function verifyType(type) {
    // These need to be transformed to their full description
    if (type.match(/^uint($|[^1-9])/)) {
        type = "uint256" + type.substring(4);
    }
    else if (type.match(/^int($|[^1-9])/)) {
        type = "int256" + type.substring(3);
    }
    // @TODO: more verification
    return type;
}
// See: https://github.com/ethereum/solidity/blob/1f8f1a3db93a548d0555e3e14cfc55a10e25b60e/docs/grammar/SolidityLexer.g4#L234
const regexIdentifier = new RegExp("^[a-zA-Z$_][a-zA-Z0-9$_]*$");
function verifyIdentifier(value) {
    if (!value || !value.match(regexIdentifier)) {
        logger$b.throwArgumentError(`invalid identifier "${value}"`, "value", value);
    }
    return value;
}
const regexParen = new RegExp("^([^)(]*)\\((.*)\\)([^)(]*)$");
function splitNesting(value) {
    value = value.trim();
    let result = [];
    let accum = "";
    let depth = 0;
    for (let offset = 0; offset < value.length; offset++) {
        let c = value[offset];
        if (c === "," && depth === 0) {
            result.push(accum);
            accum = "";
        }
        else {
            accum += c;
            if (c === "(") {
                depth++;
            }
            else if (c === ")") {
                depth--;
                if (depth === -1) {
                    logger$b.throwArgumentError("unbalanced parenthesis", "value", value);
                }
            }
        }
    }
    if (accum) {
        result.push(accum);
    }
    return result;
}

const logger$a = new Logger(version$7);
function checkResultErrors(result) {
    // Find the first error (if any)
    const errors = [];
    const checkErrors = function (path, object) {
        if (!Array.isArray(object)) {
            return;
        }
        for (let key in object) {
            const childPath = path.slice();
            childPath.push(key);
            try {
                checkErrors(childPath, object[key]);
            }
            catch (error) {
                errors.push({ path: childPath, error: error });
            }
        }
    };
    checkErrors([], result);
    return errors;
}
class Coder {
    constructor(name, type, localName, dynamic) {
        // @TODO: defineReadOnly these
        this.name = name;
        this.type = type;
        this.localName = localName;
        this.dynamic = dynamic;
    }
    _throwError(message, value) {
        logger$a.throwArgumentError(message, this.localName, value);
    }
}
class Writer {
    constructor(wordSize) {
        defineReadOnly(this, "wordSize", wordSize || 32);
        this._data = [];
        this._dataLength = 0;
        this._padding = new Uint8Array(wordSize);
    }
    get data() {
        return hexConcat(this._data);
    }
    get length() { return this._dataLength; }
    _writeData(data) {
        this._data.push(data);
        this._dataLength += data.length;
        return data.length;
    }
    appendWriter(writer) {
        return this._writeData(concat(writer._data));
    }
    // Arrayish items; padded on the right to wordSize
    writeBytes(value) {
        let bytes = arrayify(value);
        const paddingOffset = bytes.length % this.wordSize;
        if (paddingOffset) {
            bytes = concat([bytes, this._padding.slice(paddingOffset)]);
        }
        return this._writeData(bytes);
    }
    _getValue(value) {
        let bytes = arrayify(BigNumber.from(value));
        if (bytes.length > this.wordSize) {
            logger$a.throwError("value out-of-bounds", Logger.errors.BUFFER_OVERRUN, {
                length: this.wordSize,
                offset: bytes.length
            });
        }
        if (bytes.length % this.wordSize) {
            bytes = concat([this._padding.slice(bytes.length % this.wordSize), bytes]);
        }
        return bytes;
    }
    // BigNumberish items; padded on the left to wordSize
    writeValue(value) {
        return this._writeData(this._getValue(value));
    }
    writeUpdatableValue() {
        const offset = this._data.length;
        this._data.push(this._padding);
        this._dataLength += this.wordSize;
        return (value) => {
            this._data[offset] = this._getValue(value);
        };
    }
}
class Reader {
    constructor(data, wordSize, coerceFunc, allowLoose) {
        defineReadOnly(this, "_data", arrayify(data));
        defineReadOnly(this, "wordSize", wordSize || 32);
        defineReadOnly(this, "_coerceFunc", coerceFunc);
        defineReadOnly(this, "allowLoose", allowLoose);
        this._offset = 0;
    }
    get data() { return hexlify(this._data); }
    get consumed() { return this._offset; }
    // The default Coerce function
    static coerce(name, value) {
        let match = name.match("^u?int([0-9]+)$");
        if (match && parseInt(match[1]) <= 48) {
            value = value.toNumber();
        }
        return value;
    }
    coerce(name, value) {
        if (this._coerceFunc) {
            return this._coerceFunc(name, value);
        }
        return Reader.coerce(name, value);
    }
    _peekBytes(offset, length, loose) {
        let alignedLength = Math.ceil(length / this.wordSize) * this.wordSize;
        if (this._offset + alignedLength > this._data.length) {
            if (this.allowLoose && loose && this._offset + length <= this._data.length) {
                alignedLength = length;
            }
            else {
                logger$a.throwError("data out-of-bounds", Logger.errors.BUFFER_OVERRUN, {
                    length: this._data.length,
                    offset: this._offset + alignedLength
                });
            }
        }
        return this._data.slice(this._offset, this._offset + alignedLength);
    }
    subReader(offset) {
        return new Reader(this._data.slice(this._offset + offset), this.wordSize, this._coerceFunc, this.allowLoose);
    }
    readBytes(length, loose) {
        let bytes = this._peekBytes(0, length, !!loose);
        this._offset += bytes.length;
        // @TODO: Make sure the length..end bytes are all 0?
        return bytes.slice(0, length);
    }
    readValue() {
        return BigNumber.from(this.readBytes(this.wordSize));
    }
}

var sha3$1 = {exports: {}};

/**
 * [js-sha3]{@link https://github.com/emn178/js-sha3}
 *
 * @version 0.8.0
 * @author Chen, Yi-Cyuan [emn178@gmail.com]
 * @copyright Chen, Yi-Cyuan 2015-2018
 * @license MIT
 */

(function (module) {
	/*jslint bitwise: true */
	(function () {

	  var INPUT_ERROR = 'input is invalid type';
	  var FINALIZE_ERROR = 'finalize already called';
	  var WINDOW = typeof window === 'object';
	  var root = WINDOW ? window : {};
	  if (root.JS_SHA3_NO_WINDOW) {
	    WINDOW = false;
	  }
	  var WEB_WORKER = !WINDOW && typeof self === 'object';
	  var NODE_JS = !root.JS_SHA3_NO_NODE_JS && typeof process === 'object' && process.versions && process.versions.node;
	  if (NODE_JS) {
	    root = commonjsGlobal;
	  } else if (WEB_WORKER) {
	    root = self;
	  }
	  var COMMON_JS = !root.JS_SHA3_NO_COMMON_JS && 'object' === 'object' && module.exports;
	  var ARRAY_BUFFER = !root.JS_SHA3_NO_ARRAY_BUFFER && typeof ArrayBuffer !== 'undefined';
	  var HEX_CHARS = '0123456789abcdef'.split('');
	  var SHAKE_PADDING = [31, 7936, 2031616, 520093696];
	  var CSHAKE_PADDING = [4, 1024, 262144, 67108864];
	  var KECCAK_PADDING = [1, 256, 65536, 16777216];
	  var PADDING = [6, 1536, 393216, 100663296];
	  var SHIFT = [0, 8, 16, 24];
	  var RC = [1, 0, 32898, 0, 32906, 2147483648, 2147516416, 2147483648, 32907, 0, 2147483649,
	    0, 2147516545, 2147483648, 32777, 2147483648, 138, 0, 136, 0, 2147516425, 0,
	    2147483658, 0, 2147516555, 0, 139, 2147483648, 32905, 2147483648, 32771,
	    2147483648, 32770, 2147483648, 128, 2147483648, 32778, 0, 2147483658, 2147483648,
	    2147516545, 2147483648, 32896, 2147483648, 2147483649, 0, 2147516424, 2147483648];
	  var BITS = [224, 256, 384, 512];
	  var SHAKE_BITS = [128, 256];
	  var OUTPUT_TYPES = ['hex', 'buffer', 'arrayBuffer', 'array', 'digest'];
	  var CSHAKE_BYTEPAD = {
	    '128': 168,
	    '256': 136
	  };

	  if (root.JS_SHA3_NO_NODE_JS || !Array.isArray) {
	    Array.isArray = function (obj) {
	      return Object.prototype.toString.call(obj) === '[object Array]';
	    };
	  }

	  if (ARRAY_BUFFER && (root.JS_SHA3_NO_ARRAY_BUFFER_IS_VIEW || !ArrayBuffer.isView)) {
	    ArrayBuffer.isView = function (obj) {
	      return typeof obj === 'object' && obj.buffer && obj.buffer.constructor === ArrayBuffer;
	    };
	  }

	  var createOutputMethod = function (bits, padding, outputType) {
	    return function (message) {
	      return new Keccak(bits, padding, bits).update(message)[outputType]();
	    };
	  };

	  var createShakeOutputMethod = function (bits, padding, outputType) {
	    return function (message, outputBits) {
	      return new Keccak(bits, padding, outputBits).update(message)[outputType]();
	    };
	  };

	  var createCshakeOutputMethod = function (bits, padding, outputType) {
	    return function (message, outputBits, n, s) {
	      return methods['cshake' + bits].update(message, outputBits, n, s)[outputType]();
	    };
	  };

	  var createKmacOutputMethod = function (bits, padding, outputType) {
	    return function (key, message, outputBits, s) {
	      return methods['kmac' + bits].update(key, message, outputBits, s)[outputType]();
	    };
	  };

	  var createOutputMethods = function (method, createMethod, bits, padding) {
	    for (var i = 0; i < OUTPUT_TYPES.length; ++i) {
	      var type = OUTPUT_TYPES[i];
	      method[type] = createMethod(bits, padding, type);
	    }
	    return method;
	  };

	  var createMethod = function (bits, padding) {
	    var method = createOutputMethod(bits, padding, 'hex');
	    method.create = function () {
	      return new Keccak(bits, padding, bits);
	    };
	    method.update = function (message) {
	      return method.create().update(message);
	    };
	    return createOutputMethods(method, createOutputMethod, bits, padding);
	  };

	  var createShakeMethod = function (bits, padding) {
	    var method = createShakeOutputMethod(bits, padding, 'hex');
	    method.create = function (outputBits) {
	      return new Keccak(bits, padding, outputBits);
	    };
	    method.update = function (message, outputBits) {
	      return method.create(outputBits).update(message);
	    };
	    return createOutputMethods(method, createShakeOutputMethod, bits, padding);
	  };

	  var createCshakeMethod = function (bits, padding) {
	    var w = CSHAKE_BYTEPAD[bits];
	    var method = createCshakeOutputMethod(bits, padding, 'hex');
	    method.create = function (outputBits, n, s) {
	      if (!n && !s) {
	        return methods['shake' + bits].create(outputBits);
	      } else {
	        return new Keccak(bits, padding, outputBits).bytepad([n, s], w);
	      }
	    };
	    method.update = function (message, outputBits, n, s) {
	      return method.create(outputBits, n, s).update(message);
	    };
	    return createOutputMethods(method, createCshakeOutputMethod, bits, padding);
	  };

	  var createKmacMethod = function (bits, padding) {
	    var w = CSHAKE_BYTEPAD[bits];
	    var method = createKmacOutputMethod(bits, padding, 'hex');
	    method.create = function (key, outputBits, s) {
	      return new Kmac(bits, padding, outputBits).bytepad(['KMAC', s], w).bytepad([key], w);
	    };
	    method.update = function (key, message, outputBits, s) {
	      return method.create(key, outputBits, s).update(message);
	    };
	    return createOutputMethods(method, createKmacOutputMethod, bits, padding);
	  };

	  var algorithms = [
	    { name: 'keccak', padding: KECCAK_PADDING, bits: BITS, createMethod: createMethod },
	    { name: 'sha3', padding: PADDING, bits: BITS, createMethod: createMethod },
	    { name: 'shake', padding: SHAKE_PADDING, bits: SHAKE_BITS, createMethod: createShakeMethod },
	    { name: 'cshake', padding: CSHAKE_PADDING, bits: SHAKE_BITS, createMethod: createCshakeMethod },
	    { name: 'kmac', padding: CSHAKE_PADDING, bits: SHAKE_BITS, createMethod: createKmacMethod }
	  ];

	  var methods = {}, methodNames = [];

	  for (var i = 0; i < algorithms.length; ++i) {
	    var algorithm = algorithms[i];
	    var bits = algorithm.bits;
	    for (var j = 0; j < bits.length; ++j) {
	      var methodName = algorithm.name + '_' + bits[j];
	      methodNames.push(methodName);
	      methods[methodName] = algorithm.createMethod(bits[j], algorithm.padding);
	      if (algorithm.name !== 'sha3') {
	        var newMethodName = algorithm.name + bits[j];
	        methodNames.push(newMethodName);
	        methods[newMethodName] = methods[methodName];
	      }
	    }
	  }

	  function Keccak(bits, padding, outputBits) {
	    this.blocks = [];
	    this.s = [];
	    this.padding = padding;
	    this.outputBits = outputBits;
	    this.reset = true;
	    this.finalized = false;
	    this.block = 0;
	    this.start = 0;
	    this.blockCount = (1600 - (bits << 1)) >> 5;
	    this.byteCount = this.blockCount << 2;
	    this.outputBlocks = outputBits >> 5;
	    this.extraBytes = (outputBits & 31) >> 3;

	    for (var i = 0; i < 50; ++i) {
	      this.s[i] = 0;
	    }
	  }

	  Keccak.prototype.update = function (message) {
	    if (this.finalized) {
	      throw new Error(FINALIZE_ERROR);
	    }
	    var notString, type = typeof message;
	    if (type !== 'string') {
	      if (type === 'object') {
	        if (message === null) {
	          throw new Error(INPUT_ERROR);
	        } else if (ARRAY_BUFFER && message.constructor === ArrayBuffer) {
	          message = new Uint8Array(message);
	        } else if (!Array.isArray(message)) {
	          if (!ARRAY_BUFFER || !ArrayBuffer.isView(message)) {
	            throw new Error(INPUT_ERROR);
	          }
	        }
	      } else {
	        throw new Error(INPUT_ERROR);
	      }
	      notString = true;
	    }
	    var blocks = this.blocks, byteCount = this.byteCount, length = message.length,
	      blockCount = this.blockCount, index = 0, s = this.s, i, code;

	    while (index < length) {
	      if (this.reset) {
	        this.reset = false;
	        blocks[0] = this.block;
	        for (i = 1; i < blockCount + 1; ++i) {
	          blocks[i] = 0;
	        }
	      }
	      if (notString) {
	        for (i = this.start; index < length && i < byteCount; ++index) {
	          blocks[i >> 2] |= message[index] << SHIFT[i++ & 3];
	        }
	      } else {
	        for (i = this.start; index < length && i < byteCount; ++index) {
	          code = message.charCodeAt(index);
	          if (code < 0x80) {
	            blocks[i >> 2] |= code << SHIFT[i++ & 3];
	          } else if (code < 0x800) {
	            blocks[i >> 2] |= (0xc0 | (code >> 6)) << SHIFT[i++ & 3];
	            blocks[i >> 2] |= (0x80 | (code & 0x3f)) << SHIFT[i++ & 3];
	          } else if (code < 0xd800 || code >= 0xe000) {
	            blocks[i >> 2] |= (0xe0 | (code >> 12)) << SHIFT[i++ & 3];
	            blocks[i >> 2] |= (0x80 | ((code >> 6) & 0x3f)) << SHIFT[i++ & 3];
	            blocks[i >> 2] |= (0x80 | (code & 0x3f)) << SHIFT[i++ & 3];
	          } else {
	            code = 0x10000 + (((code & 0x3ff) << 10) | (message.charCodeAt(++index) & 0x3ff));
	            blocks[i >> 2] |= (0xf0 | (code >> 18)) << SHIFT[i++ & 3];
	            blocks[i >> 2] |= (0x80 | ((code >> 12) & 0x3f)) << SHIFT[i++ & 3];
	            blocks[i >> 2] |= (0x80 | ((code >> 6) & 0x3f)) << SHIFT[i++ & 3];
	            blocks[i >> 2] |= (0x80 | (code & 0x3f)) << SHIFT[i++ & 3];
	          }
	        }
	      }
	      this.lastByteIndex = i;
	      if (i >= byteCount) {
	        this.start = i - byteCount;
	        this.block = blocks[blockCount];
	        for (i = 0; i < blockCount; ++i) {
	          s[i] ^= blocks[i];
	        }
	        f(s);
	        this.reset = true;
	      } else {
	        this.start = i;
	      }
	    }
	    return this;
	  };

	  Keccak.prototype.encode = function (x, right) {
	    var o = x & 255, n = 1;
	    var bytes = [o];
	    x = x >> 8;
	    o = x & 255;
	    while (o > 0) {
	      bytes.unshift(o);
	      x = x >> 8;
	      o = x & 255;
	      ++n;
	    }
	    if (right) {
	      bytes.push(n);
	    } else {
	      bytes.unshift(n);
	    }
	    this.update(bytes);
	    return bytes.length;
	  };

	  Keccak.prototype.encodeString = function (str) {
	    var notString, type = typeof str;
	    if (type !== 'string') {
	      if (type === 'object') {
	        if (str === null) {
	          throw new Error(INPUT_ERROR);
	        } else if (ARRAY_BUFFER && str.constructor === ArrayBuffer) {
	          str = new Uint8Array(str);
	        } else if (!Array.isArray(str)) {
	          if (!ARRAY_BUFFER || !ArrayBuffer.isView(str)) {
	            throw new Error(INPUT_ERROR);
	          }
	        }
	      } else {
	        throw new Error(INPUT_ERROR);
	      }
	      notString = true;
	    }
	    var bytes = 0, length = str.length;
	    if (notString) {
	      bytes = length;
	    } else {
	      for (var i = 0; i < str.length; ++i) {
	        var code = str.charCodeAt(i);
	        if (code < 0x80) {
	          bytes += 1;
	        } else if (code < 0x800) {
	          bytes += 2;
	        } else if (code < 0xd800 || code >= 0xe000) {
	          bytes += 3;
	        } else {
	          code = 0x10000 + (((code & 0x3ff) << 10) | (str.charCodeAt(++i) & 0x3ff));
	          bytes += 4;
	        }
	      }
	    }
	    bytes += this.encode(bytes * 8);
	    this.update(str);
	    return bytes;
	  };

	  Keccak.prototype.bytepad = function (strs, w) {
	    var bytes = this.encode(w);
	    for (var i = 0; i < strs.length; ++i) {
	      bytes += this.encodeString(strs[i]);
	    }
	    var paddingBytes = w - bytes % w;
	    var zeros = [];
	    zeros.length = paddingBytes;
	    this.update(zeros);
	    return this;
	  };

	  Keccak.prototype.finalize = function () {
	    if (this.finalized) {
	      return;
	    }
	    this.finalized = true;
	    var blocks = this.blocks, i = this.lastByteIndex, blockCount = this.blockCount, s = this.s;
	    blocks[i >> 2] |= this.padding[i & 3];
	    if (this.lastByteIndex === this.byteCount) {
	      blocks[0] = blocks[blockCount];
	      for (i = 1; i < blockCount + 1; ++i) {
	        blocks[i] = 0;
	      }
	    }
	    blocks[blockCount - 1] |= 0x80000000;
	    for (i = 0; i < blockCount; ++i) {
	      s[i] ^= blocks[i];
	    }
	    f(s);
	  };

	  Keccak.prototype.toString = Keccak.prototype.hex = function () {
	    this.finalize();

	    var blockCount = this.blockCount, s = this.s, outputBlocks = this.outputBlocks,
	      extraBytes = this.extraBytes, i = 0, j = 0;
	    var hex = '', block;
	    while (j < outputBlocks) {
	      for (i = 0; i < blockCount && j < outputBlocks; ++i, ++j) {
	        block = s[i];
	        hex += HEX_CHARS[(block >> 4) & 0x0F] + HEX_CHARS[block & 0x0F] +
	          HEX_CHARS[(block >> 12) & 0x0F] + HEX_CHARS[(block >> 8) & 0x0F] +
	          HEX_CHARS[(block >> 20) & 0x0F] + HEX_CHARS[(block >> 16) & 0x0F] +
	          HEX_CHARS[(block >> 28) & 0x0F] + HEX_CHARS[(block >> 24) & 0x0F];
	      }
	      if (j % blockCount === 0) {
	        f(s);
	        i = 0;
	      }
	    }
	    if (extraBytes) {
	      block = s[i];
	      hex += HEX_CHARS[(block >> 4) & 0x0F] + HEX_CHARS[block & 0x0F];
	      if (extraBytes > 1) {
	        hex += HEX_CHARS[(block >> 12) & 0x0F] + HEX_CHARS[(block >> 8) & 0x0F];
	      }
	      if (extraBytes > 2) {
	        hex += HEX_CHARS[(block >> 20) & 0x0F] + HEX_CHARS[(block >> 16) & 0x0F];
	      }
	    }
	    return hex;
	  };

	  Keccak.prototype.arrayBuffer = function () {
	    this.finalize();

	    var blockCount = this.blockCount, s = this.s, outputBlocks = this.outputBlocks,
	      extraBytes = this.extraBytes, i = 0, j = 0;
	    var bytes = this.outputBits >> 3;
	    var buffer;
	    if (extraBytes) {
	      buffer = new ArrayBuffer((outputBlocks + 1) << 2);
	    } else {
	      buffer = new ArrayBuffer(bytes);
	    }
	    var array = new Uint32Array(buffer);
	    while (j < outputBlocks) {
	      for (i = 0; i < blockCount && j < outputBlocks; ++i, ++j) {
	        array[j] = s[i];
	      }
	      if (j % blockCount === 0) {
	        f(s);
	      }
	    }
	    if (extraBytes) {
	      array[i] = s[i];
	      buffer = buffer.slice(0, bytes);
	    }
	    return buffer;
	  };

	  Keccak.prototype.buffer = Keccak.prototype.arrayBuffer;

	  Keccak.prototype.digest = Keccak.prototype.array = function () {
	    this.finalize();

	    var blockCount = this.blockCount, s = this.s, outputBlocks = this.outputBlocks,
	      extraBytes = this.extraBytes, i = 0, j = 0;
	    var array = [], offset, block;
	    while (j < outputBlocks) {
	      for (i = 0; i < blockCount && j < outputBlocks; ++i, ++j) {
	        offset = j << 2;
	        block = s[i];
	        array[offset] = block & 0xFF;
	        array[offset + 1] = (block >> 8) & 0xFF;
	        array[offset + 2] = (block >> 16) & 0xFF;
	        array[offset + 3] = (block >> 24) & 0xFF;
	      }
	      if (j % blockCount === 0) {
	        f(s);
	      }
	    }
	    if (extraBytes) {
	      offset = j << 2;
	      block = s[i];
	      array[offset] = block & 0xFF;
	      if (extraBytes > 1) {
	        array[offset + 1] = (block >> 8) & 0xFF;
	      }
	      if (extraBytes > 2) {
	        array[offset + 2] = (block >> 16) & 0xFF;
	      }
	    }
	    return array;
	  };

	  function Kmac(bits, padding, outputBits) {
	    Keccak.call(this, bits, padding, outputBits);
	  }

	  Kmac.prototype = new Keccak();

	  Kmac.prototype.finalize = function () {
	    this.encode(this.outputBits, true);
	    return Keccak.prototype.finalize.call(this);
	  };

	  var f = function (s) {
	    var h, l, n, c0, c1, c2, c3, c4, c5, c6, c7, c8, c9,
	      b0, b1, b2, b3, b4, b5, b6, b7, b8, b9, b10, b11, b12, b13, b14, b15, b16, b17,
	      b18, b19, b20, b21, b22, b23, b24, b25, b26, b27, b28, b29, b30, b31, b32, b33,
	      b34, b35, b36, b37, b38, b39, b40, b41, b42, b43, b44, b45, b46, b47, b48, b49;
	    for (n = 0; n < 48; n += 2) {
	      c0 = s[0] ^ s[10] ^ s[20] ^ s[30] ^ s[40];
	      c1 = s[1] ^ s[11] ^ s[21] ^ s[31] ^ s[41];
	      c2 = s[2] ^ s[12] ^ s[22] ^ s[32] ^ s[42];
	      c3 = s[3] ^ s[13] ^ s[23] ^ s[33] ^ s[43];
	      c4 = s[4] ^ s[14] ^ s[24] ^ s[34] ^ s[44];
	      c5 = s[5] ^ s[15] ^ s[25] ^ s[35] ^ s[45];
	      c6 = s[6] ^ s[16] ^ s[26] ^ s[36] ^ s[46];
	      c7 = s[7] ^ s[17] ^ s[27] ^ s[37] ^ s[47];
	      c8 = s[8] ^ s[18] ^ s[28] ^ s[38] ^ s[48];
	      c9 = s[9] ^ s[19] ^ s[29] ^ s[39] ^ s[49];

	      h = c8 ^ ((c2 << 1) | (c3 >>> 31));
	      l = c9 ^ ((c3 << 1) | (c2 >>> 31));
	      s[0] ^= h;
	      s[1] ^= l;
	      s[10] ^= h;
	      s[11] ^= l;
	      s[20] ^= h;
	      s[21] ^= l;
	      s[30] ^= h;
	      s[31] ^= l;
	      s[40] ^= h;
	      s[41] ^= l;
	      h = c0 ^ ((c4 << 1) | (c5 >>> 31));
	      l = c1 ^ ((c5 << 1) | (c4 >>> 31));
	      s[2] ^= h;
	      s[3] ^= l;
	      s[12] ^= h;
	      s[13] ^= l;
	      s[22] ^= h;
	      s[23] ^= l;
	      s[32] ^= h;
	      s[33] ^= l;
	      s[42] ^= h;
	      s[43] ^= l;
	      h = c2 ^ ((c6 << 1) | (c7 >>> 31));
	      l = c3 ^ ((c7 << 1) | (c6 >>> 31));
	      s[4] ^= h;
	      s[5] ^= l;
	      s[14] ^= h;
	      s[15] ^= l;
	      s[24] ^= h;
	      s[25] ^= l;
	      s[34] ^= h;
	      s[35] ^= l;
	      s[44] ^= h;
	      s[45] ^= l;
	      h = c4 ^ ((c8 << 1) | (c9 >>> 31));
	      l = c5 ^ ((c9 << 1) | (c8 >>> 31));
	      s[6] ^= h;
	      s[7] ^= l;
	      s[16] ^= h;
	      s[17] ^= l;
	      s[26] ^= h;
	      s[27] ^= l;
	      s[36] ^= h;
	      s[37] ^= l;
	      s[46] ^= h;
	      s[47] ^= l;
	      h = c6 ^ ((c0 << 1) | (c1 >>> 31));
	      l = c7 ^ ((c1 << 1) | (c0 >>> 31));
	      s[8] ^= h;
	      s[9] ^= l;
	      s[18] ^= h;
	      s[19] ^= l;
	      s[28] ^= h;
	      s[29] ^= l;
	      s[38] ^= h;
	      s[39] ^= l;
	      s[48] ^= h;
	      s[49] ^= l;

	      b0 = s[0];
	      b1 = s[1];
	      b32 = (s[11] << 4) | (s[10] >>> 28);
	      b33 = (s[10] << 4) | (s[11] >>> 28);
	      b14 = (s[20] << 3) | (s[21] >>> 29);
	      b15 = (s[21] << 3) | (s[20] >>> 29);
	      b46 = (s[31] << 9) | (s[30] >>> 23);
	      b47 = (s[30] << 9) | (s[31] >>> 23);
	      b28 = (s[40] << 18) | (s[41] >>> 14);
	      b29 = (s[41] << 18) | (s[40] >>> 14);
	      b20 = (s[2] << 1) | (s[3] >>> 31);
	      b21 = (s[3] << 1) | (s[2] >>> 31);
	      b2 = (s[13] << 12) | (s[12] >>> 20);
	      b3 = (s[12] << 12) | (s[13] >>> 20);
	      b34 = (s[22] << 10) | (s[23] >>> 22);
	      b35 = (s[23] << 10) | (s[22] >>> 22);
	      b16 = (s[33] << 13) | (s[32] >>> 19);
	      b17 = (s[32] << 13) | (s[33] >>> 19);
	      b48 = (s[42] << 2) | (s[43] >>> 30);
	      b49 = (s[43] << 2) | (s[42] >>> 30);
	      b40 = (s[5] << 30) | (s[4] >>> 2);
	      b41 = (s[4] << 30) | (s[5] >>> 2);
	      b22 = (s[14] << 6) | (s[15] >>> 26);
	      b23 = (s[15] << 6) | (s[14] >>> 26);
	      b4 = (s[25] << 11) | (s[24] >>> 21);
	      b5 = (s[24] << 11) | (s[25] >>> 21);
	      b36 = (s[34] << 15) | (s[35] >>> 17);
	      b37 = (s[35] << 15) | (s[34] >>> 17);
	      b18 = (s[45] << 29) | (s[44] >>> 3);
	      b19 = (s[44] << 29) | (s[45] >>> 3);
	      b10 = (s[6] << 28) | (s[7] >>> 4);
	      b11 = (s[7] << 28) | (s[6] >>> 4);
	      b42 = (s[17] << 23) | (s[16] >>> 9);
	      b43 = (s[16] << 23) | (s[17] >>> 9);
	      b24 = (s[26] << 25) | (s[27] >>> 7);
	      b25 = (s[27] << 25) | (s[26] >>> 7);
	      b6 = (s[36] << 21) | (s[37] >>> 11);
	      b7 = (s[37] << 21) | (s[36] >>> 11);
	      b38 = (s[47] << 24) | (s[46] >>> 8);
	      b39 = (s[46] << 24) | (s[47] >>> 8);
	      b30 = (s[8] << 27) | (s[9] >>> 5);
	      b31 = (s[9] << 27) | (s[8] >>> 5);
	      b12 = (s[18] << 20) | (s[19] >>> 12);
	      b13 = (s[19] << 20) | (s[18] >>> 12);
	      b44 = (s[29] << 7) | (s[28] >>> 25);
	      b45 = (s[28] << 7) | (s[29] >>> 25);
	      b26 = (s[38] << 8) | (s[39] >>> 24);
	      b27 = (s[39] << 8) | (s[38] >>> 24);
	      b8 = (s[48] << 14) | (s[49] >>> 18);
	      b9 = (s[49] << 14) | (s[48] >>> 18);

	      s[0] = b0 ^ (~b2 & b4);
	      s[1] = b1 ^ (~b3 & b5);
	      s[10] = b10 ^ (~b12 & b14);
	      s[11] = b11 ^ (~b13 & b15);
	      s[20] = b20 ^ (~b22 & b24);
	      s[21] = b21 ^ (~b23 & b25);
	      s[30] = b30 ^ (~b32 & b34);
	      s[31] = b31 ^ (~b33 & b35);
	      s[40] = b40 ^ (~b42 & b44);
	      s[41] = b41 ^ (~b43 & b45);
	      s[2] = b2 ^ (~b4 & b6);
	      s[3] = b3 ^ (~b5 & b7);
	      s[12] = b12 ^ (~b14 & b16);
	      s[13] = b13 ^ (~b15 & b17);
	      s[22] = b22 ^ (~b24 & b26);
	      s[23] = b23 ^ (~b25 & b27);
	      s[32] = b32 ^ (~b34 & b36);
	      s[33] = b33 ^ (~b35 & b37);
	      s[42] = b42 ^ (~b44 & b46);
	      s[43] = b43 ^ (~b45 & b47);
	      s[4] = b4 ^ (~b6 & b8);
	      s[5] = b5 ^ (~b7 & b9);
	      s[14] = b14 ^ (~b16 & b18);
	      s[15] = b15 ^ (~b17 & b19);
	      s[24] = b24 ^ (~b26 & b28);
	      s[25] = b25 ^ (~b27 & b29);
	      s[34] = b34 ^ (~b36 & b38);
	      s[35] = b35 ^ (~b37 & b39);
	      s[44] = b44 ^ (~b46 & b48);
	      s[45] = b45 ^ (~b47 & b49);
	      s[6] = b6 ^ (~b8 & b0);
	      s[7] = b7 ^ (~b9 & b1);
	      s[16] = b16 ^ (~b18 & b10);
	      s[17] = b17 ^ (~b19 & b11);
	      s[26] = b26 ^ (~b28 & b20);
	      s[27] = b27 ^ (~b29 & b21);
	      s[36] = b36 ^ (~b38 & b30);
	      s[37] = b37 ^ (~b39 & b31);
	      s[46] = b46 ^ (~b48 & b40);
	      s[47] = b47 ^ (~b49 & b41);
	      s[8] = b8 ^ (~b0 & b2);
	      s[9] = b9 ^ (~b1 & b3);
	      s[18] = b18 ^ (~b10 & b12);
	      s[19] = b19 ^ (~b11 & b13);
	      s[28] = b28 ^ (~b20 & b22);
	      s[29] = b29 ^ (~b21 & b23);
	      s[38] = b38 ^ (~b30 & b32);
	      s[39] = b39 ^ (~b31 & b33);
	      s[48] = b48 ^ (~b40 & b42);
	      s[49] = b49 ^ (~b41 & b43);

	      s[0] ^= RC[n];
	      s[1] ^= RC[n + 1];
	    }
	  };

	  if (COMMON_JS) {
	    module.exports = methods;
	  } else {
	    for (i = 0; i < methodNames.length; ++i) {
	      root[methodNames[i]] = methods[methodNames[i]];
	    }
	  }
	})(); 
} (sha3$1));

var sha3Exports = sha3$1.exports;
var sha3 = /*@__PURE__*/getDefaultExportFromCjs(sha3Exports);

function keccak256(data) {
    return '0x' + sha3.keccak_256(arrayify(data));
}

const version$6 = "rlp/5.7.0";

const logger$9 = new Logger(version$6);
function arrayifyInteger(value) {
    const result = [];
    while (value) {
        result.unshift(value & 0xff);
        value >>= 8;
    }
    return result;
}
function unarrayifyInteger(data, offset, length) {
    let result = 0;
    for (let i = 0; i < length; i++) {
        result = (result * 256) + data[offset + i];
    }
    return result;
}
function _encode(object) {
    if (Array.isArray(object)) {
        let payload = [];
        object.forEach(function (child) {
            payload = payload.concat(_encode(child));
        });
        if (payload.length <= 55) {
            payload.unshift(0xc0 + payload.length);
            return payload;
        }
        const length = arrayifyInteger(payload.length);
        length.unshift(0xf7 + length.length);
        return length.concat(payload);
    }
    if (!isBytesLike(object)) {
        logger$9.throwArgumentError("RLP object must be BytesLike", "object", object);
    }
    const data = Array.prototype.slice.call(arrayify(object));
    if (data.length === 1 && data[0] <= 0x7f) {
        return data;
    }
    else if (data.length <= 55) {
        data.unshift(0x80 + data.length);
        return data;
    }
    const length = arrayifyInteger(data.length);
    length.unshift(0xb7 + length.length);
    return length.concat(data);
}
function encode(object) {
    return hexlify(_encode(object));
}
function _decodeChildren(data, offset, childOffset, length) {
    const result = [];
    while (childOffset < offset + 1 + length) {
        const decoded = _decode(data, childOffset);
        result.push(decoded.result);
        childOffset += decoded.consumed;
        if (childOffset > offset + 1 + length) {
            logger$9.throwError("child data too short", Logger.errors.BUFFER_OVERRUN, {});
        }
    }
    return { consumed: (1 + length), result: result };
}
// returns { consumed: number, result: Object }
function _decode(data, offset) {
    if (data.length === 0) {
        logger$9.throwError("data too short", Logger.errors.BUFFER_OVERRUN, {});
    }
    // Array with extra length prefix
    if (data[offset] >= 0xf8) {
        const lengthLength = data[offset] - 0xf7;
        if (offset + 1 + lengthLength > data.length) {
            logger$9.throwError("data short segment too short", Logger.errors.BUFFER_OVERRUN, {});
        }
        const length = unarrayifyInteger(data, offset + 1, lengthLength);
        if (offset + 1 + lengthLength + length > data.length) {
            logger$9.throwError("data long segment too short", Logger.errors.BUFFER_OVERRUN, {});
        }
        return _decodeChildren(data, offset, offset + 1 + lengthLength, lengthLength + length);
    }
    else if (data[offset] >= 0xc0) {
        const length = data[offset] - 0xc0;
        if (offset + 1 + length > data.length) {
            logger$9.throwError("data array too short", Logger.errors.BUFFER_OVERRUN, {});
        }
        return _decodeChildren(data, offset, offset + 1, length);
    }
    else if (data[offset] >= 0xb8) {
        const lengthLength = data[offset] - 0xb7;
        if (offset + 1 + lengthLength > data.length) {
            logger$9.throwError("data array too short", Logger.errors.BUFFER_OVERRUN, {});
        }
        const length = unarrayifyInteger(data, offset + 1, lengthLength);
        if (offset + 1 + lengthLength + length > data.length) {
            logger$9.throwError("data array too short", Logger.errors.BUFFER_OVERRUN, {});
        }
        const result = hexlify(data.slice(offset + 1 + lengthLength, offset + 1 + lengthLength + length));
        return { consumed: (1 + lengthLength + length), result: result };
    }
    else if (data[offset] >= 0x80) {
        const length = data[offset] - 0x80;
        if (offset + 1 + length > data.length) {
            logger$9.throwError("data too short", Logger.errors.BUFFER_OVERRUN, {});
        }
        const result = hexlify(data.slice(offset + 1, offset + 1 + length));
        return { consumed: (1 + length), result: result };
    }
    return { consumed: 1, result: hexlify(data[offset]) };
}
function decode(data) {
    const bytes = arrayify(data);
    const decoded = _decode(bytes, 0);
    if (decoded.consumed !== bytes.length) {
        logger$9.throwArgumentError("invalid rlp data", "data", data);
    }
    return decoded.result;
}

const version$5 = "address/5.7.0";

const logger$8 = new Logger(version$5);
function getChecksumAddress(address) {
    if (!isHexString(address, 20)) {
        logger$8.throwArgumentError("invalid address", "address", address);
    }
    address = address.toLowerCase();
    const chars = address.substring(2).split("");
    const expanded = new Uint8Array(40);
    for (let i = 0; i < 40; i++) {
        expanded[i] = chars[i].charCodeAt(0);
    }
    const hashed = arrayify(keccak256(expanded));
    for (let i = 0; i < 40; i += 2) {
        if ((hashed[i >> 1] >> 4) >= 8) {
            chars[i] = chars[i].toUpperCase();
        }
        if ((hashed[i >> 1] & 0x0f) >= 8) {
            chars[i + 1] = chars[i + 1].toUpperCase();
        }
    }
    return "0x" + chars.join("");
}
// Shims for environments that are missing some required constants and functions
const MAX_SAFE_INTEGER = 0x1fffffffffffff;
function log10(x) {
    if (Math.log10) {
        return Math.log10(x);
    }
    return Math.log(x) / Math.LN10;
}
// See: https://en.wikipedia.org/wiki/International_Bank_Account_Number
// Create lookup table
const ibanLookup = {};
for (let i = 0; i < 10; i++) {
    ibanLookup[String(i)] = String(i);
}
for (let i = 0; i < 26; i++) {
    ibanLookup[String.fromCharCode(65 + i)] = String(10 + i);
}
// How many decimal digits can we process? (for 64-bit float, this is 15)
const safeDigits = Math.floor(log10(MAX_SAFE_INTEGER));
function ibanChecksum(address) {
    address = address.toUpperCase();
    address = address.substring(4) + address.substring(0, 2) + "00";
    let expanded = address.split("").map((c) => { return ibanLookup[c]; }).join("");
    // Javascript can handle integers safely up to 15 (decimal) digits
    while (expanded.length >= safeDigits) {
        let block = expanded.substring(0, safeDigits);
        expanded = parseInt(block, 10) % 97 + expanded.substring(block.length);
    }
    let checksum = String(98 - (parseInt(expanded, 10) % 97));
    while (checksum.length < 2) {
        checksum = "0" + checksum;
    }
    return checksum;
}
function getAddress(address) {
    let result = null;
    if (typeof (address) !== "string") {
        logger$8.throwArgumentError("invalid address", "address", address);
    }
    if (address.match(/^(0x)?[0-9a-fA-F]{40}$/)) {
        // Missing the 0x prefix
        if (address.substring(0, 2) !== "0x") {
            address = "0x" + address;
        }
        result = getChecksumAddress(address);
        // It is a checksummed address with a bad checksum
        if (address.match(/([A-F].*[a-f])|([a-f].*[A-F])/) && result !== address) {
            logger$8.throwArgumentError("bad address checksum", "address", address);
        }
        // Maybe ICAP? (we only support direct mode)
    }
    else if (address.match(/^XE[0-9]{2}[0-9A-Za-z]{30,31}$/)) {
        // It is an ICAP address with a bad checksum
        if (address.substring(2, 4) !== ibanChecksum(address)) {
            logger$8.throwArgumentError("bad icap checksum", "address", address);
        }
        result = _base36To16(address.substring(4));
        while (result.length < 40) {
            result = "0" + result;
        }
        result = getChecksumAddress("0x" + result);
    }
    else {
        logger$8.throwArgumentError("invalid address", "address", address);
    }
    return result;
}
function isAddress(address) {
    try {
        getAddress(address);
        return true;
    }
    catch (error) { }
    return false;
}
// http://ethereum.stackexchange.com/questions/760/how-is-the-address-of-an-ethereum-contract-computed
function getContractAddress(transaction) {
    let from = null;
    try {
        from = getAddress(transaction.from);
    }
    catch (error) {
        logger$8.throwArgumentError("missing from address", "transaction", transaction);
    }
    const nonce = stripZeros(arrayify(BigNumber.from(transaction.nonce).toHexString()));
    return getAddress(hexDataSlice(keccak256(encode([from, nonce])), 12));
}

class AddressCoder extends Coder {
    constructor(localName) {
        super("address", "address", localName, false);
    }
    defaultValue() {
        return "0x0000000000000000000000000000000000000000";
    }
    encode(writer, value) {
        try {
            value = getAddress(value);
        }
        catch (error) {
            this._throwError(error.message, value);
        }
        return writer.writeValue(value);
    }
    decode(reader) {
        return getAddress(hexZeroPad(reader.readValue().toHexString(), 20));
    }
}

// Clones the functionality of an existing Coder, but without a localName
class AnonymousCoder extends Coder {
    constructor(coder) {
        super(coder.name, coder.type, undefined, coder.dynamic);
        this.coder = coder;
    }
    defaultValue() {
        return this.coder.defaultValue();
    }
    encode(writer, value) {
        return this.coder.encode(writer, value);
    }
    decode(reader) {
        return this.coder.decode(reader);
    }
}

const logger$7 = new Logger(version$7);
function pack(writer, coders, values) {
    let arrayValues = null;
    if (Array.isArray(values)) {
        arrayValues = values;
    }
    else if (values && typeof (values) === "object") {
        let unique = {};
        arrayValues = coders.map((coder) => {
            const name = coder.localName;
            if (!name) {
                logger$7.throwError("cannot encode object for signature with missing names", Logger.errors.INVALID_ARGUMENT, {
                    argument: "values",
                    coder: coder,
                    value: values
                });
            }
            if (unique[name]) {
                logger$7.throwError("cannot encode object for signature with duplicate names", Logger.errors.INVALID_ARGUMENT, {
                    argument: "values",
                    coder: coder,
                    value: values
                });
            }
            unique[name] = true;
            return values[name];
        });
    }
    else {
        logger$7.throwArgumentError("invalid tuple value", "tuple", values);
    }
    if (coders.length !== arrayValues.length) {
        logger$7.throwArgumentError("types/value length mismatch", "tuple", values);
    }
    let staticWriter = new Writer(writer.wordSize);
    let dynamicWriter = new Writer(writer.wordSize);
    let updateFuncs = [];
    coders.forEach((coder, index) => {
        let value = arrayValues[index];
        if (coder.dynamic) {
            // Get current dynamic offset (for the future pointer)
            let dynamicOffset = dynamicWriter.length;
            // Encode the dynamic value into the dynamicWriter
            coder.encode(dynamicWriter, value);
            // Prepare to populate the correct offset once we are done
            let updateFunc = staticWriter.writeUpdatableValue();
            updateFuncs.push((baseOffset) => {
                updateFunc(baseOffset + dynamicOffset);
            });
        }
        else {
            coder.encode(staticWriter, value);
        }
    });
    // Backfill all the dynamic offsets, now that we know the static length
    updateFuncs.forEach((func) => { func(staticWriter.length); });
    let length = writer.appendWriter(staticWriter);
    length += writer.appendWriter(dynamicWriter);
    return length;
}
function unpack(reader, coders) {
    let values = [];
    // A reader anchored to this base
    let baseReader = reader.subReader(0);
    coders.forEach((coder) => {
        let value = null;
        if (coder.dynamic) {
            let offset = reader.readValue();
            let offsetReader = baseReader.subReader(offset.toNumber());
            try {
                value = coder.decode(offsetReader);
            }
            catch (error) {
                // Cannot recover from this
                if (error.code === Logger.errors.BUFFER_OVERRUN) {
                    throw error;
                }
                value = error;
                value.baseType = coder.name;
                value.name = coder.localName;
                value.type = coder.type;
            }
        }
        else {
            try {
                value = coder.decode(reader);
            }
            catch (error) {
                // Cannot recover from this
                if (error.code === Logger.errors.BUFFER_OVERRUN) {
                    throw error;
                }
                value = error;
                value.baseType = coder.name;
                value.name = coder.localName;
                value.type = coder.type;
            }
        }
        if (value != undefined) {
            values.push(value);
        }
    });
    // We only output named properties for uniquely named coders
    const uniqueNames = coders.reduce((accum, coder) => {
        const name = coder.localName;
        if (name) {
            if (!accum[name]) {
                accum[name] = 0;
            }
            accum[name]++;
        }
        return accum;
    }, {});
    // Add any named parameters (i.e. tuples)
    coders.forEach((coder, index) => {
        let name = coder.localName;
        if (!name || uniqueNames[name] !== 1) {
            return;
        }
        if (name === "length") {
            name = "_length";
        }
        if (values[name] != null) {
            return;
        }
        const value = values[index];
        if (value instanceof Error) {
            Object.defineProperty(values, name, {
                enumerable: true,
                get: () => { throw value; }
            });
        }
        else {
            values[name] = value;
        }
    });
    for (let i = 0; i < values.length; i++) {
        const value = values[i];
        if (value instanceof Error) {
            Object.defineProperty(values, i, {
                enumerable: true,
                get: () => { throw value; }
            });
        }
    }
    return Object.freeze(values);
}
class ArrayCoder extends Coder {
    constructor(coder, length, localName) {
        const type = (coder.type + "[" + (length >= 0 ? length : "") + "]");
        const dynamic = (length === -1 || coder.dynamic);
        super("array", type, localName, dynamic);
        this.coder = coder;
        this.length = length;
    }
    defaultValue() {
        // Verifies the child coder is valid (even if the array is dynamic or 0-length)
        const defaultChild = this.coder.defaultValue();
        const result = [];
        for (let i = 0; i < this.length; i++) {
            result.push(defaultChild);
        }
        return result;
    }
    encode(writer, value) {
        if (!Array.isArray(value)) {
            this._throwError("expected array value", value);
        }
        let count = this.length;
        if (count === -1) {
            count = value.length;
            writer.writeValue(value.length);
        }
        logger$7.checkArgumentCount(value.length, count, "coder array" + (this.localName ? (" " + this.localName) : ""));
        let coders = [];
        for (let i = 0; i < value.length; i++) {
            coders.push(this.coder);
        }
        return pack(writer, coders, value);
    }
    decode(reader) {
        let count = this.length;
        if (count === -1) {
            count = reader.readValue().toNumber();
            // Check that there is *roughly* enough data to ensure
            // stray random data is not being read as a length. Each
            // slot requires at least 32 bytes for their value (or 32
            // bytes as a link to the data). This could use a much
            // tighter bound, but we are erroring on the side of safety.
            if (count * 32 > reader._data.length) {
                logger$7.throwError("insufficient data length", Logger.errors.BUFFER_OVERRUN, {
                    length: reader._data.length,
                    count: count
                });
            }
        }
        let coders = [];
        for (let i = 0; i < count; i++) {
            coders.push(new AnonymousCoder(this.coder));
        }
        return reader.coerce(this.name, unpack(reader, coders));
    }
}

class BooleanCoder extends Coder {
    constructor(localName) {
        super("bool", "bool", localName, false);
    }
    defaultValue() {
        return false;
    }
    encode(writer, value) {
        return writer.writeValue(value ? 1 : 0);
    }
    decode(reader) {
        return reader.coerce(this.type, !reader.readValue().isZero());
    }
}

class DynamicBytesCoder extends Coder {
    constructor(type, localName) {
        super(type, type, localName, true);
    }
    defaultValue() {
        return "0x";
    }
    encode(writer, value) {
        value = arrayify(value);
        let length = writer.writeValue(value.length);
        length += writer.writeBytes(value);
        return length;
    }
    decode(reader) {
        return reader.readBytes(reader.readValue().toNumber(), true);
    }
}
class BytesCoder extends DynamicBytesCoder {
    constructor(localName) {
        super("bytes", localName);
    }
    decode(reader) {
        return reader.coerce(this.name, hexlify(super.decode(reader)));
    }
}

// @TODO: Merge this with bytes
class FixedBytesCoder extends Coder {
    constructor(size, localName) {
        let name = "bytes" + String(size);
        super(name, name, localName, false);
        this.size = size;
    }
    defaultValue() {
        return ("0x0000000000000000000000000000000000000000000000000000000000000000").substring(0, 2 + this.size * 2);
    }
    encode(writer, value) {
        let data = arrayify(value);
        if (data.length !== this.size) {
            this._throwError("incorrect data length", value);
        }
        return writer.writeBytes(data);
    }
    decode(reader) {
        return reader.coerce(this.name, hexlify(reader.readBytes(this.size)));
    }
}

class NullCoder extends Coder {
    constructor(localName) {
        super("null", "", localName, false);
    }
    defaultValue() {
        return null;
    }
    encode(writer, value) {
        if (value != null) {
            this._throwError("not null", value);
        }
        return writer.writeBytes([]);
    }
    decode(reader) {
        reader.readBytes(0);
        return reader.coerce(this.name, null);
    }
}

const NegativeOne = ( /*#__PURE__*/BigNumber.from(-1));
const Zero = ( /*#__PURE__*/BigNumber.from(0));
const One = ( /*#__PURE__*/BigNumber.from(1));
const MaxUint256 = ( /*#__PURE__*/BigNumber.from("0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff"));

class NumberCoder extends Coder {
    constructor(size, signed, localName) {
        const name = ((signed ? "int" : "uint") + (size * 8));
        super(name, name, localName, false);
        this.size = size;
        this.signed = signed;
    }
    defaultValue() {
        return 0;
    }
    encode(writer, value) {
        let v = BigNumber.from(value);
        // Check bounds are safe for encoding
        let maxUintValue = MaxUint256.mask(writer.wordSize * 8);
        if (this.signed) {
            let bounds = maxUintValue.mask(this.size * 8 - 1);
            if (v.gt(bounds) || v.lt(bounds.add(One).mul(NegativeOne))) {
                this._throwError("value out-of-bounds", value);
            }
        }
        else if (v.lt(Zero) || v.gt(maxUintValue.mask(this.size * 8))) {
            this._throwError("value out-of-bounds", value);
        }
        v = v.toTwos(this.size * 8).mask(this.size * 8);
        if (this.signed) {
            v = v.fromTwos(this.size * 8).toTwos(8 * writer.wordSize);
        }
        return writer.writeValue(v);
    }
    decode(reader) {
        let value = reader.readValue().mask(this.size * 8);
        if (this.signed) {
            value = value.fromTwos(this.size * 8);
        }
        return reader.coerce(this.name, value);
    }
}

const version$4 = "strings/5.7.0";

const logger$6 = new Logger(version$4);
///////////////////////////////
var UnicodeNormalizationForm;
(function (UnicodeNormalizationForm) {
    UnicodeNormalizationForm["current"] = "";
    UnicodeNormalizationForm["NFC"] = "NFC";
    UnicodeNormalizationForm["NFD"] = "NFD";
    UnicodeNormalizationForm["NFKC"] = "NFKC";
    UnicodeNormalizationForm["NFKD"] = "NFKD";
})(UnicodeNormalizationForm || (UnicodeNormalizationForm = {}));
var Utf8ErrorReason;
(function (Utf8ErrorReason) {
    // A continuation byte was present where there was nothing to continue
    // - offset = the index the codepoint began in
    Utf8ErrorReason["UNEXPECTED_CONTINUE"] = "unexpected continuation byte";
    // An invalid (non-continuation) byte to start a UTF-8 codepoint was found
    // - offset = the index the codepoint began in
    Utf8ErrorReason["BAD_PREFIX"] = "bad codepoint prefix";
    // The string is too short to process the expected codepoint
    // - offset = the index the codepoint began in
    Utf8ErrorReason["OVERRUN"] = "string overrun";
    // A missing continuation byte was expected but not found
    // - offset = the index the continuation byte was expected at
    Utf8ErrorReason["MISSING_CONTINUE"] = "missing continuation byte";
    // The computed code point is outside the range for UTF-8
    // - offset       = start of this codepoint
    // - badCodepoint = the computed codepoint; outside the UTF-8 range
    Utf8ErrorReason["OUT_OF_RANGE"] = "out of UTF-8 range";
    // UTF-8 strings may not contain UTF-16 surrogate pairs
    // - offset       = start of this codepoint
    // - badCodepoint = the computed codepoint; inside the UTF-16 surrogate range
    Utf8ErrorReason["UTF16_SURROGATE"] = "UTF-16 surrogate";
    // The string is an overlong representation
    // - offset       = start of this codepoint
    // - badCodepoint = the computed codepoint; already bounds checked
    Utf8ErrorReason["OVERLONG"] = "overlong representation";
})(Utf8ErrorReason || (Utf8ErrorReason = {}));
function errorFunc(reason, offset, bytes, output, badCodepoint) {
    return logger$6.throwArgumentError(`invalid codepoint at offset ${offset}; ${reason}`, "bytes", bytes);
}
function ignoreFunc(reason, offset, bytes, output, badCodepoint) {
    // If there is an invalid prefix (including stray continuation), skip any additional continuation bytes
    if (reason === Utf8ErrorReason.BAD_PREFIX || reason === Utf8ErrorReason.UNEXPECTED_CONTINUE) {
        let i = 0;
        for (let o = offset + 1; o < bytes.length; o++) {
            if (bytes[o] >> 6 !== 0x02) {
                break;
            }
            i++;
        }
        return i;
    }
    // This byte runs us past the end of the string, so just jump to the end
    // (but the first byte was read already read and therefore skipped)
    if (reason === Utf8ErrorReason.OVERRUN) {
        return bytes.length - offset - 1;
    }
    // Nothing to skip
    return 0;
}
function replaceFunc(reason, offset, bytes, output, badCodepoint) {
    // Overlong representations are otherwise "valid" code points; just non-deistingtished
    if (reason === Utf8ErrorReason.OVERLONG) {
        output.push(badCodepoint);
        return 0;
    }
    // Put the replacement character into the output
    output.push(0xfffd);
    // Otherwise, process as if ignoring errors
    return ignoreFunc(reason, offset, bytes);
}
// Common error handing strategies
const Utf8ErrorFuncs = Object.freeze({
    error: errorFunc,
    ignore: ignoreFunc,
    replace: replaceFunc
});
// http://stackoverflow.com/questions/13356493/decode-utf-8-with-javascript#13691499
function getUtf8CodePoints(bytes, onError) {
    if (onError == null) {
        onError = Utf8ErrorFuncs.error;
    }
    bytes = arrayify(bytes);
    const result = [];
    let i = 0;
    // Invalid bytes are ignored
    while (i < bytes.length) {
        const c = bytes[i++];
        // 0xxx xxxx
        if (c >> 7 === 0) {
            result.push(c);
            continue;
        }
        // Multibyte; how many bytes left for this character?
        let extraLength = null;
        let overlongMask = null;
        // 110x xxxx 10xx xxxx
        if ((c & 0xe0) === 0xc0) {
            extraLength = 1;
            overlongMask = 0x7f;
            // 1110 xxxx 10xx xxxx 10xx xxxx
        }
        else if ((c & 0xf0) === 0xe0) {
            extraLength = 2;
            overlongMask = 0x7ff;
            // 1111 0xxx 10xx xxxx 10xx xxxx 10xx xxxx
        }
        else if ((c & 0xf8) === 0xf0) {
            extraLength = 3;
            overlongMask = 0xffff;
        }
        else {
            if ((c & 0xc0) === 0x80) {
                i += onError(Utf8ErrorReason.UNEXPECTED_CONTINUE, i - 1, bytes, result);
            }
            else {
                i += onError(Utf8ErrorReason.BAD_PREFIX, i - 1, bytes, result);
            }
            continue;
        }
        // Do we have enough bytes in our data?
        if (i - 1 + extraLength >= bytes.length) {
            i += onError(Utf8ErrorReason.OVERRUN, i - 1, bytes, result);
            continue;
        }
        // Remove the length prefix from the char
        let res = c & ((1 << (8 - extraLength - 1)) - 1);
        for (let j = 0; j < extraLength; j++) {
            let nextChar = bytes[i];
            // Invalid continuation byte
            if ((nextChar & 0xc0) != 0x80) {
                i += onError(Utf8ErrorReason.MISSING_CONTINUE, i, bytes, result);
                res = null;
                break;
            }
            res = (res << 6) | (nextChar & 0x3f);
            i++;
        }
        // See above loop for invalid continuation byte
        if (res === null) {
            continue;
        }
        // Maximum code point
        if (res > 0x10ffff) {
            i += onError(Utf8ErrorReason.OUT_OF_RANGE, i - 1 - extraLength, bytes, result, res);
            continue;
        }
        // Reserved for UTF-16 surrogate halves
        if (res >= 0xd800 && res <= 0xdfff) {
            i += onError(Utf8ErrorReason.UTF16_SURROGATE, i - 1 - extraLength, bytes, result, res);
            continue;
        }
        // Check for overlong sequences (more bytes than needed)
        if (res <= overlongMask) {
            i += onError(Utf8ErrorReason.OVERLONG, i - 1 - extraLength, bytes, result, res);
            continue;
        }
        result.push(res);
    }
    return result;
}
// http://stackoverflow.com/questions/18729405/how-to-convert-utf8-string-to-byte-array
function toUtf8Bytes(str, form = UnicodeNormalizationForm.current) {
    if (form != UnicodeNormalizationForm.current) {
        logger$6.checkNormalize();
        str = str.normalize(form);
    }
    let result = [];
    for (let i = 0; i < str.length; i++) {
        const c = str.charCodeAt(i);
        if (c < 0x80) {
            result.push(c);
        }
        else if (c < 0x800) {
            result.push((c >> 6) | 0xc0);
            result.push((c & 0x3f) | 0x80);
        }
        else if ((c & 0xfc00) == 0xd800) {
            i++;
            const c2 = str.charCodeAt(i);
            if (i >= str.length || (c2 & 0xfc00) !== 0xdc00) {
                throw new Error("invalid utf-8 string");
            }
            // Surrogate Pair
            const pair = 0x10000 + ((c & 0x03ff) << 10) + (c2 & 0x03ff);
            result.push((pair >> 18) | 0xf0);
            result.push(((pair >> 12) & 0x3f) | 0x80);
            result.push(((pair >> 6) & 0x3f) | 0x80);
            result.push((pair & 0x3f) | 0x80);
        }
        else {
            result.push((c >> 12) | 0xe0);
            result.push(((c >> 6) & 0x3f) | 0x80);
            result.push((c & 0x3f) | 0x80);
        }
    }
    return arrayify(result);
}
function _toUtf8String(codePoints) {
    return codePoints.map((codePoint) => {
        if (codePoint <= 0xffff) {
            return String.fromCharCode(codePoint);
        }
        codePoint -= 0x10000;
        return String.fromCharCode((((codePoint >> 10) & 0x3ff) + 0xd800), ((codePoint & 0x3ff) + 0xdc00));
    }).join("");
}
function toUtf8String(bytes, onError) {
    return _toUtf8String(getUtf8CodePoints(bytes, onError));
}

class StringCoder extends DynamicBytesCoder {
    constructor(localName) {
        super("string", localName);
    }
    defaultValue() {
        return "";
    }
    encode(writer, value) {
        return super.encode(writer, toUtf8Bytes(value));
    }
    decode(reader) {
        return toUtf8String(super.decode(reader));
    }
}

class TupleCoder extends Coder {
    constructor(coders, localName) {
        let dynamic = false;
        const types = [];
        coders.forEach((coder) => {
            if (coder.dynamic) {
                dynamic = true;
            }
            types.push(coder.type);
        });
        const type = ("tuple(" + types.join(",") + ")");
        super("tuple", type, localName, dynamic);
        this.coders = coders;
    }
    defaultValue() {
        const values = [];
        this.coders.forEach((coder) => {
            values.push(coder.defaultValue());
        });
        // We only output named properties for uniquely named coders
        const uniqueNames = this.coders.reduce((accum, coder) => {
            const name = coder.localName;
            if (name) {
                if (!accum[name]) {
                    accum[name] = 0;
                }
                accum[name]++;
            }
            return accum;
        }, {});
        // Add named values
        this.coders.forEach((coder, index) => {
            let name = coder.localName;
            if (!name || uniqueNames[name] !== 1) {
                return;
            }
            if (name === "length") {
                name = "_length";
            }
            if (values[name] != null) {
                return;
            }
            values[name] = values[index];
        });
        return Object.freeze(values);
    }
    encode(writer, value) {
        return pack(writer, this.coders, value);
    }
    decode(reader) {
        return reader.coerce(this.name, unpack(reader, this.coders));
    }
}

const logger$5 = new Logger(version$7);
const paramTypeBytes = new RegExp(/^bytes([0-9]*)$/);
const paramTypeNumber = new RegExp(/^(u?int)([0-9]*)$/);
class AbiCoder {
    constructor(coerceFunc) {
        defineReadOnly(this, "coerceFunc", coerceFunc || null);
    }
    _getCoder(param) {
        switch (param.baseType) {
            case "address":
                return new AddressCoder(param.name);
            case "bool":
                return new BooleanCoder(param.name);
            case "string":
                return new StringCoder(param.name);
            case "bytes":
                return new BytesCoder(param.name);
            case "array":
                return new ArrayCoder(this._getCoder(param.arrayChildren), param.arrayLength, param.name);
            case "tuple":
                return new TupleCoder((param.components || []).map((component) => {
                    return this._getCoder(component);
                }), param.name);
            case "":
                return new NullCoder(param.name);
        }
        // u?int[0-9]*
        let match = param.type.match(paramTypeNumber);
        if (match) {
            let size = parseInt(match[2] || "256");
            if (size === 0 || size > 256 || (size % 8) !== 0) {
                logger$5.throwArgumentError("invalid " + match[1] + " bit length", "param", param);
            }
            return new NumberCoder(size / 8, (match[1] === "int"), param.name);
        }
        // bytes[0-9]+
        match = param.type.match(paramTypeBytes);
        if (match) {
            let size = parseInt(match[1]);
            if (size === 0 || size > 32) {
                logger$5.throwArgumentError("invalid bytes length", "param", param);
            }
            return new FixedBytesCoder(size, param.name);
        }
        return logger$5.throwArgumentError("invalid type", "type", param.type);
    }
    _getWordSize() { return 32; }
    _getReader(data, allowLoose) {
        return new Reader(data, this._getWordSize(), this.coerceFunc, allowLoose);
    }
    _getWriter() {
        return new Writer(this._getWordSize());
    }
    getDefaultValue(types) {
        const coders = types.map((type) => this._getCoder(ParamType.from(type)));
        const coder = new TupleCoder(coders, "_");
        return coder.defaultValue();
    }
    encode(types, values) {
        if (types.length !== values.length) {
            logger$5.throwError("types/values length mismatch", Logger.errors.INVALID_ARGUMENT, {
                count: { types: types.length, values: values.length },
                value: { types: types, values: values }
            });
        }
        const coders = types.map((type) => this._getCoder(ParamType.from(type)));
        const coder = (new TupleCoder(coders, "_"));
        const writer = this._getWriter();
        coder.encode(writer, values);
        return writer.data;
    }
    decode(types, data, loose) {
        const coders = types.map((type) => this._getCoder(ParamType.from(type)));
        const coder = new TupleCoder(coders, "_");
        return coder.decode(this._getReader(arrayify(data), loose));
    }
}
const defaultAbiCoder = new AbiCoder();

function id(text) {
    return keccak256(toUtf8Bytes(text));
}

const logger$4 = new Logger(version$7);
class LogDescription extends Description {
}
class TransactionDescription extends Description {
}
class ErrorDescription extends Description {
}
class Indexed extends Description {
    static isIndexed(value) {
        return !!(value && value._isIndexed);
    }
}
const BuiltinErrors = {
    "0x08c379a0": { signature: "Error(string)", name: "Error", inputs: ["string"], reason: true },
    "0x4e487b71": { signature: "Panic(uint256)", name: "Panic", inputs: ["uint256"] }
};
function wrapAccessError(property, error) {
    const wrap = new Error(`deferred error during ABI decoding triggered accessing ${property}`);
    wrap.error = error;
    return wrap;
}
/*
function checkNames(fragment: Fragment, type: "input" | "output", params: Array<ParamType>): void {
    params.reduce((accum, param) => {
        if (param.name) {
            if (accum[param.name]) {
                logger.throwArgumentError(`duplicate ${ type } parameter ${ JSON.stringify(param.name) } in ${ fragment.format("full") }`, "fragment", fragment);
            }
            accum[param.name] = true;
        }
        return accum;
    }, <{ [ name: string ]: boolean }>{ });
}
*/
class Interface {
    constructor(fragments) {
        let abi = [];
        if (typeof (fragments) === "string") {
            abi = JSON.parse(fragments);
        }
        else {
            abi = fragments;
        }
        defineReadOnly(this, "fragments", abi.map((fragment) => {
            return Fragment.from(fragment);
        }).filter((fragment) => (fragment != null)));
        defineReadOnly(this, "_abiCoder", getStatic(new.target, "getAbiCoder")());
        defineReadOnly(this, "functions", {});
        defineReadOnly(this, "errors", {});
        defineReadOnly(this, "events", {});
        defineReadOnly(this, "structs", {});
        // Add all fragments by their signature
        this.fragments.forEach((fragment) => {
            let bucket = null;
            switch (fragment.type) {
                case "constructor":
                    if (this.deploy) {
                        logger$4.warn("duplicate definition - constructor");
                        return;
                    }
                    //checkNames(fragment, "input", fragment.inputs);
                    defineReadOnly(this, "deploy", fragment);
                    return;
                case "function":
                    //checkNames(fragment, "input", fragment.inputs);
                    //checkNames(fragment, "output", (<FunctionFragment>fragment).outputs);
                    bucket = this.functions;
                    break;
                case "event":
                    //checkNames(fragment, "input", fragment.inputs);
                    bucket = this.events;
                    break;
                case "error":
                    bucket = this.errors;
                    break;
                default:
                    return;
            }
            let signature = fragment.format();
            if (bucket[signature]) {
                logger$4.warn("duplicate definition - " + signature);
                return;
            }
            bucket[signature] = fragment;
        });
        // If we do not have a constructor add a default
        if (!this.deploy) {
            defineReadOnly(this, "deploy", ConstructorFragment.from({
                payable: false,
                type: "constructor"
            }));
        }
        defineReadOnly(this, "_isInterface", true);
    }
    format(format) {
        if (!format) {
            format = FormatTypes.full;
        }
        if (format === FormatTypes.sighash) {
            logger$4.throwArgumentError("interface does not support formatting sighash", "format", format);
        }
        const abi = this.fragments.map((fragment) => fragment.format(format));
        // We need to re-bundle the JSON fragments a bit
        if (format === FormatTypes.json) {
            return JSON.stringify(abi.map((j) => JSON.parse(j)));
        }
        return abi;
    }
    // Sub-classes can override these to handle other blockchains
    static getAbiCoder() {
        return defaultAbiCoder;
    }
    static getAddress(address) {
        return getAddress(address);
    }
    static getSighash(fragment) {
        return hexDataSlice(id(fragment.format()), 0, 4);
    }
    static getEventTopic(eventFragment) {
        return id(eventFragment.format());
    }
    // Find a function definition by any means necessary (unless it is ambiguous)
    getFunction(nameOrSignatureOrSighash) {
        if (isHexString(nameOrSignatureOrSighash)) {
            for (const name in this.functions) {
                if (nameOrSignatureOrSighash === this.getSighash(name)) {
                    return this.functions[name];
                }
            }
            logger$4.throwArgumentError("no matching function", "sighash", nameOrSignatureOrSighash);
        }
        // It is a bare name, look up the function (will return null if ambiguous)
        if (nameOrSignatureOrSighash.indexOf("(") === -1) {
            const name = nameOrSignatureOrSighash.trim();
            const matching = Object.keys(this.functions).filter((f) => (f.split("(" /* fix:) */)[0] === name));
            if (matching.length === 0) {
                logger$4.throwArgumentError("no matching function", "name", name);
            }
            else if (matching.length > 1) {
                logger$4.throwArgumentError("multiple matching functions", "name", name);
            }
            return this.functions[matching[0]];
        }
        // Normalize the signature and lookup the function
        const result = this.functions[FunctionFragment.fromString(nameOrSignatureOrSighash).format()];
        if (!result) {
            logger$4.throwArgumentError("no matching function", "signature", nameOrSignatureOrSighash);
        }
        return result;
    }
    // Find an event definition by any means necessary (unless it is ambiguous)
    getEvent(nameOrSignatureOrTopic) {
        if (isHexString(nameOrSignatureOrTopic)) {
            const topichash = nameOrSignatureOrTopic.toLowerCase();
            for (const name in this.events) {
                if (topichash === this.getEventTopic(name)) {
                    return this.events[name];
                }
            }
            logger$4.throwArgumentError("no matching event", "topichash", topichash);
        }
        // It is a bare name, look up the function (will return null if ambiguous)
        if (nameOrSignatureOrTopic.indexOf("(") === -1) {
            const name = nameOrSignatureOrTopic.trim();
            const matching = Object.keys(this.events).filter((f) => (f.split("(" /* fix:) */)[0] === name));
            if (matching.length === 0) {
                logger$4.throwArgumentError("no matching event", "name", name);
            }
            else if (matching.length > 1) {
                logger$4.throwArgumentError("multiple matching events", "name", name);
            }
            return this.events[matching[0]];
        }
        // Normalize the signature and lookup the function
        const result = this.events[EventFragment.fromString(nameOrSignatureOrTopic).format()];
        if (!result) {
            logger$4.throwArgumentError("no matching event", "signature", nameOrSignatureOrTopic);
        }
        return result;
    }
    // Find a function definition by any means necessary (unless it is ambiguous)
    getError(nameOrSignatureOrSighash) {
        if (isHexString(nameOrSignatureOrSighash)) {
            const getSighash = getStatic(this.constructor, "getSighash");
            for (const name in this.errors) {
                const error = this.errors[name];
                if (nameOrSignatureOrSighash === getSighash(error)) {
                    return this.errors[name];
                }
            }
            logger$4.throwArgumentError("no matching error", "sighash", nameOrSignatureOrSighash);
        }
        // It is a bare name, look up the function (will return null if ambiguous)
        if (nameOrSignatureOrSighash.indexOf("(") === -1) {
            const name = nameOrSignatureOrSighash.trim();
            const matching = Object.keys(this.errors).filter((f) => (f.split("(" /* fix:) */)[0] === name));
            if (matching.length === 0) {
                logger$4.throwArgumentError("no matching error", "name", name);
            }
            else if (matching.length > 1) {
                logger$4.throwArgumentError("multiple matching errors", "name", name);
            }
            return this.errors[matching[0]];
        }
        // Normalize the signature and lookup the function
        const result = this.errors[FunctionFragment.fromString(nameOrSignatureOrSighash).format()];
        if (!result) {
            logger$4.throwArgumentError("no matching error", "signature", nameOrSignatureOrSighash);
        }
        return result;
    }
    // Get the sighash (the bytes4 selector) used by Solidity to identify a function
    getSighash(fragment) {
        if (typeof (fragment) === "string") {
            try {
                fragment = this.getFunction(fragment);
            }
            catch (error) {
                try {
                    fragment = this.getError(fragment);
                }
                catch (_) {
                    throw error;
                }
            }
        }
        return getStatic(this.constructor, "getSighash")(fragment);
    }
    // Get the topic (the bytes32 hash) used by Solidity to identify an event
    getEventTopic(eventFragment) {
        if (typeof (eventFragment) === "string") {
            eventFragment = this.getEvent(eventFragment);
        }
        return getStatic(this.constructor, "getEventTopic")(eventFragment);
    }
    _decodeParams(params, data) {
        return this._abiCoder.decode(params, data);
    }
    _encodeParams(params, values) {
        return this._abiCoder.encode(params, values);
    }
    encodeDeploy(values) {
        return this._encodeParams(this.deploy.inputs, values || []);
    }
    decodeErrorResult(fragment, data) {
        if (typeof (fragment) === "string") {
            fragment = this.getError(fragment);
        }
        const bytes = arrayify(data);
        if (hexlify(bytes.slice(0, 4)) !== this.getSighash(fragment)) {
            logger$4.throwArgumentError(`data signature does not match error ${fragment.name}.`, "data", hexlify(bytes));
        }
        return this._decodeParams(fragment.inputs, bytes.slice(4));
    }
    encodeErrorResult(fragment, values) {
        if (typeof (fragment) === "string") {
            fragment = this.getError(fragment);
        }
        return hexlify(concat([
            this.getSighash(fragment),
            this._encodeParams(fragment.inputs, values || [])
        ]));
    }
    // Decode the data for a function call (e.g. tx.data)
    decodeFunctionData(functionFragment, data) {
        if (typeof (functionFragment) === "string") {
            functionFragment = this.getFunction(functionFragment);
        }
        const bytes = arrayify(data);
        if (hexlify(bytes.slice(0, 4)) !== this.getSighash(functionFragment)) {
            logger$4.throwArgumentError(`data signature does not match function ${functionFragment.name}.`, "data", hexlify(bytes));
        }
        return this._decodeParams(functionFragment.inputs, bytes.slice(4));
    }
    // Encode the data for a function call (e.g. tx.data)
    encodeFunctionData(functionFragment, values) {
        if (typeof (functionFragment) === "string") {
            functionFragment = this.getFunction(functionFragment);
        }
        return hexlify(concat([
            this.getSighash(functionFragment),
            this._encodeParams(functionFragment.inputs, values || [])
        ]));
    }
    // Decode the result from a function call (e.g. from eth_call)
    decodeFunctionResult(functionFragment, data) {
        if (typeof (functionFragment) === "string") {
            functionFragment = this.getFunction(functionFragment);
        }
        let bytes = arrayify(data);
        let reason = null;
        let message = "";
        let errorArgs = null;
        let errorName = null;
        let errorSignature = null;
        switch (bytes.length % this._abiCoder._getWordSize()) {
            case 0:
                try {
                    return this._abiCoder.decode(functionFragment.outputs, bytes);
                }
                catch (error) { }
                break;
            case 4: {
                const selector = hexlify(bytes.slice(0, 4));
                const builtin = BuiltinErrors[selector];
                if (builtin) {
                    errorArgs = this._abiCoder.decode(builtin.inputs, bytes.slice(4));
                    errorName = builtin.name;
                    errorSignature = builtin.signature;
                    if (builtin.reason) {
                        reason = errorArgs[0];
                    }
                    if (errorName === "Error") {
                        message = `; VM Exception while processing transaction: reverted with reason string ${JSON.stringify(errorArgs[0])}`;
                    }
                    else if (errorName === "Panic") {
                        message = `; VM Exception while processing transaction: reverted with panic code ${errorArgs[0]}`;
                    }
                }
                else {
                    try {
                        const error = this.getError(selector);
                        errorArgs = this._abiCoder.decode(error.inputs, bytes.slice(4));
                        errorName = error.name;
                        errorSignature = error.format();
                    }
                    catch (error) { }
                }
                break;
            }
        }
        return logger$4.throwError("call revert exception" + message, Logger.errors.CALL_EXCEPTION, {
            method: functionFragment.format(),
            data: hexlify(data), errorArgs, errorName, errorSignature, reason
        });
    }
    // Encode the result for a function call (e.g. for eth_call)
    encodeFunctionResult(functionFragment, values) {
        if (typeof (functionFragment) === "string") {
            functionFragment = this.getFunction(functionFragment);
        }
        return hexlify(this._abiCoder.encode(functionFragment.outputs, values || []));
    }
    // Create the filter for the event with search criteria (e.g. for eth_filterLog)
    encodeFilterTopics(eventFragment, values) {
        if (typeof (eventFragment) === "string") {
            eventFragment = this.getEvent(eventFragment);
        }
        if (values.length > eventFragment.inputs.length) {
            logger$4.throwError("too many arguments for " + eventFragment.format(), Logger.errors.UNEXPECTED_ARGUMENT, {
                argument: "values",
                value: values
            });
        }
        let topics = [];
        if (!eventFragment.anonymous) {
            topics.push(this.getEventTopic(eventFragment));
        }
        const encodeTopic = (param, value) => {
            if (param.type === "string") {
                return id(value);
            }
            else if (param.type === "bytes") {
                return keccak256(hexlify(value));
            }
            if (param.type === "bool" && typeof (value) === "boolean") {
                value = (value ? "0x01" : "0x00");
            }
            if (param.type.match(/^u?int/)) {
                value = BigNumber.from(value).toHexString();
            }
            // Check addresses are valid
            if (param.type === "address") {
                this._abiCoder.encode(["address"], [value]);
            }
            return hexZeroPad(hexlify(value), 32);
        };
        values.forEach((value, index) => {
            let param = eventFragment.inputs[index];
            if (!param.indexed) {
                if (value != null) {
                    logger$4.throwArgumentError("cannot filter non-indexed parameters; must be null", ("contract." + param.name), value);
                }
                return;
            }
            if (value == null) {
                topics.push(null);
            }
            else if (param.baseType === "array" || param.baseType === "tuple") {
                logger$4.throwArgumentError("filtering with tuples or arrays not supported", ("contract." + param.name), value);
            }
            else if (Array.isArray(value)) {
                topics.push(value.map((value) => encodeTopic(param, value)));
            }
            else {
                topics.push(encodeTopic(param, value));
            }
        });
        // Trim off trailing nulls
        while (topics.length && topics[topics.length - 1] === null) {
            topics.pop();
        }
        return topics;
    }
    encodeEventLog(eventFragment, values) {
        if (typeof (eventFragment) === "string") {
            eventFragment = this.getEvent(eventFragment);
        }
        const topics = [];
        const dataTypes = [];
        const dataValues = [];
        if (!eventFragment.anonymous) {
            topics.push(this.getEventTopic(eventFragment));
        }
        if (values.length !== eventFragment.inputs.length) {
            logger$4.throwArgumentError("event arguments/values mismatch", "values", values);
        }
        eventFragment.inputs.forEach((param, index) => {
            const value = values[index];
            if (param.indexed) {
                if (param.type === "string") {
                    topics.push(id(value));
                }
                else if (param.type === "bytes") {
                    topics.push(keccak256(value));
                }
                else if (param.baseType === "tuple" || param.baseType === "array") {
                    // @TODO
                    throw new Error("not implemented");
                }
                else {
                    topics.push(this._abiCoder.encode([param.type], [value]));
                }
            }
            else {
                dataTypes.push(param);
                dataValues.push(value);
            }
        });
        return {
            data: this._abiCoder.encode(dataTypes, dataValues),
            topics: topics
        };
    }
    // Decode a filter for the event and the search criteria
    decodeEventLog(eventFragment, data, topics) {
        if (typeof (eventFragment) === "string") {
            eventFragment = this.getEvent(eventFragment);
        }
        if (topics != null && !eventFragment.anonymous) {
            let topicHash = this.getEventTopic(eventFragment);
            if (!isHexString(topics[0], 32) || topics[0].toLowerCase() !== topicHash) {
                logger$4.throwError("fragment/topic mismatch", Logger.errors.INVALID_ARGUMENT, { argument: "topics[0]", expected: topicHash, value: topics[0] });
            }
            topics = topics.slice(1);
        }
        let indexed = [];
        let nonIndexed = [];
        let dynamic = [];
        eventFragment.inputs.forEach((param, index) => {
            if (param.indexed) {
                if (param.type === "string" || param.type === "bytes" || param.baseType === "tuple" || param.baseType === "array") {
                    indexed.push(ParamType.fromObject({ type: "bytes32", name: param.name }));
                    dynamic.push(true);
                }
                else {
                    indexed.push(param);
                    dynamic.push(false);
                }
            }
            else {
                nonIndexed.push(param);
                dynamic.push(false);
            }
        });
        let resultIndexed = (topics != null) ? this._abiCoder.decode(indexed, concat(topics)) : null;
        let resultNonIndexed = this._abiCoder.decode(nonIndexed, data, true);
        let result = [];
        let nonIndexedIndex = 0, indexedIndex = 0;
        eventFragment.inputs.forEach((param, index) => {
            if (param.indexed) {
                if (resultIndexed == null) {
                    result[index] = new Indexed({ _isIndexed: true, hash: null });
                }
                else if (dynamic[index]) {
                    result[index] = new Indexed({ _isIndexed: true, hash: resultIndexed[indexedIndex++] });
                }
                else {
                    try {
                        result[index] = resultIndexed[indexedIndex++];
                    }
                    catch (error) {
                        result[index] = error;
                    }
                }
            }
            else {
                try {
                    result[index] = resultNonIndexed[nonIndexedIndex++];
                }
                catch (error) {
                    result[index] = error;
                }
            }
            // Add the keyword argument if named and safe
            if (param.name && result[param.name] == null) {
                const value = result[index];
                // Make error named values throw on access
                if (value instanceof Error) {
                    Object.defineProperty(result, param.name, {
                        enumerable: true,
                        get: () => { throw wrapAccessError(`property ${JSON.stringify(param.name)}`, value); }
                    });
                }
                else {
                    result[param.name] = value;
                }
            }
        });
        // Make all error indexed values throw on access
        for (let i = 0; i < result.length; i++) {
            const value = result[i];
            if (value instanceof Error) {
                Object.defineProperty(result, i, {
                    enumerable: true,
                    get: () => { throw wrapAccessError(`index ${i}`, value); }
                });
            }
        }
        return Object.freeze(result);
    }
    // Given a transaction, find the matching function fragment (if any) and
    // determine all its properties and call parameters
    parseTransaction(tx) {
        let fragment = this.getFunction(tx.data.substring(0, 10).toLowerCase());
        if (!fragment) {
            return null;
        }
        return new TransactionDescription({
            args: this._abiCoder.decode(fragment.inputs, "0x" + tx.data.substring(10)),
            functionFragment: fragment,
            name: fragment.name,
            signature: fragment.format(),
            sighash: this.getSighash(fragment),
            value: BigNumber.from(tx.value || "0"),
        });
    }
    // @TODO
    //parseCallResult(data: BytesLike): ??
    // Given an event log, find the matching event fragment (if any) and
    // determine all its properties and values
    parseLog(log) {
        let fragment = this.getEvent(log.topics[0]);
        if (!fragment || fragment.anonymous) {
            return null;
        }
        // @TODO: If anonymous, and the only method, and the input count matches, should we parse?
        //        Probably not, because just because it is the only event in the ABI does
        //        not mean we have the full ABI; maybe just a fragment?
        return new LogDescription({
            eventFragment: fragment,
            name: fragment.name,
            signature: fragment.format(),
            topic: this.getEventTopic(fragment),
            args: this.decodeEventLog(fragment, log.data, log.topics)
        });
    }
    parseError(data) {
        const hexData = hexlify(data);
        let fragment = this.getError(hexData.substring(0, 10).toLowerCase());
        if (!fragment) {
            return null;
        }
        return new ErrorDescription({
            args: this._abiCoder.decode(fragment.inputs, "0x" + hexData.substring(10)),
            errorFragment: fragment,
            name: fragment.name,
            signature: fragment.format(),
            sighash: this.getSighash(fragment),
        });
    }
    /*
    static from(value: Array<Fragment | string | JsonAbi> | string | Interface) {
        if (Interface.isInterface(value)) {
            return value;
        }
        if (typeof(value) === "string") {
            return new Interface(JSON.parse(value));
        }
        return new Interface(value);
    }
    */
    static isInterface(value) {
        return !!(value && value._isInterface);
    }
}

const version$3 = "abstract-provider/5.7.0";

var __awaiter$2 = function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
const logger$3 = new Logger(version$3);
///////////////////////////////
// Exported Abstracts
class Provider {
    constructor() {
        logger$3.checkAbstract(new.target, Provider);
        defineReadOnly(this, "_isProvider", true);
    }
    getFeeData() {
        return __awaiter$2(this, void 0, void 0, function* () {
            const { block, gasPrice } = yield resolveProperties({
                block: this.getBlock("latest"),
                gasPrice: this.getGasPrice().catch((error) => {
                    // @TODO: Why is this now failing on Calaveras?
                    //console.log(error);
                    return null;
                })
            });
            let lastBaseFeePerGas = null, maxFeePerGas = null, maxPriorityFeePerGas = null;
            if (block && block.baseFeePerGas) {
                // We may want to compute this more accurately in the future,
                // using the formula "check if the base fee is correct".
                // See: https://eips.ethereum.org/EIPS/eip-1559
                lastBaseFeePerGas = block.baseFeePerGas;
                maxPriorityFeePerGas = BigNumber.from("1500000000");
                maxFeePerGas = block.baseFeePerGas.mul(2).add(maxPriorityFeePerGas);
            }
            return { lastBaseFeePerGas, maxFeePerGas, maxPriorityFeePerGas, gasPrice };
        });
    }
    // Alias for "on"
    addListener(eventName, listener) {
        return this.on(eventName, listener);
    }
    // Alias for "off"
    removeListener(eventName, listener) {
        return this.off(eventName, listener);
    }
    static isProvider(value) {
        return !!(value && value._isProvider);
    }
}

const version$2 = "abstract-signer/5.7.0";

var __awaiter$1 = function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
const logger$2 = new Logger(version$2);
const allowedTransactionKeys = [
    "accessList", "ccipReadEnabled", "chainId", "customData", "data", "from", "gasLimit", "gasPrice", "maxFeePerGas", "maxPriorityFeePerGas", "nonce", "to", "type", "value"
];
const forwardErrors = [
    Logger.errors.INSUFFICIENT_FUNDS,
    Logger.errors.NONCE_EXPIRED,
    Logger.errors.REPLACEMENT_UNDERPRICED,
];
class Signer {
    ///////////////////
    // Sub-classes MUST call super
    constructor() {
        logger$2.checkAbstract(new.target, Signer);
        defineReadOnly(this, "_isSigner", true);
    }
    ///////////////////
    // Sub-classes MAY override these
    getBalance(blockTag) {
        return __awaiter$1(this, void 0, void 0, function* () {
            this._checkProvider("getBalance");
            return yield this.provider.getBalance(this.getAddress(), blockTag);
        });
    }
    getTransactionCount(blockTag) {
        return __awaiter$1(this, void 0, void 0, function* () {
            this._checkProvider("getTransactionCount");
            return yield this.provider.getTransactionCount(this.getAddress(), blockTag);
        });
    }
    // Populates "from" if unspecified, and estimates the gas for the transaction
    estimateGas(transaction) {
        return __awaiter$1(this, void 0, void 0, function* () {
            this._checkProvider("estimateGas");
            const tx = yield resolveProperties(this.checkTransaction(transaction));
            return yield this.provider.estimateGas(tx);
        });
    }
    // Populates "from" if unspecified, and calls with the transaction
    call(transaction, blockTag) {
        return __awaiter$1(this, void 0, void 0, function* () {
            this._checkProvider("call");
            const tx = yield resolveProperties(this.checkTransaction(transaction));
            return yield this.provider.call(tx, blockTag);
        });
    }
    // Populates all fields in a transaction, signs it and sends it to the network
    sendTransaction(transaction) {
        return __awaiter$1(this, void 0, void 0, function* () {
            this._checkProvider("sendTransaction");
            const tx = yield this.populateTransaction(transaction);
            const signedTx = yield this.signTransaction(tx);
            return yield this.provider.sendTransaction(signedTx);
        });
    }
    getChainId() {
        return __awaiter$1(this, void 0, void 0, function* () {
            this._checkProvider("getChainId");
            const network = yield this.provider.getNetwork();
            return network.chainId;
        });
    }
    getGasPrice() {
        return __awaiter$1(this, void 0, void 0, function* () {
            this._checkProvider("getGasPrice");
            return yield this.provider.getGasPrice();
        });
    }
    getFeeData() {
        return __awaiter$1(this, void 0, void 0, function* () {
            this._checkProvider("getFeeData");
            return yield this.provider.getFeeData();
        });
    }
    resolveName(name) {
        return __awaiter$1(this, void 0, void 0, function* () {
            this._checkProvider("resolveName");
            return yield this.provider.resolveName(name);
        });
    }
    // Checks a transaction does not contain invalid keys and if
    // no "from" is provided, populates it.
    // - does NOT require a provider
    // - adds "from" is not present
    // - returns a COPY (safe to mutate the result)
    // By default called from: (overriding these prevents it)
    //   - call
    //   - estimateGas
    //   - populateTransaction (and therefor sendTransaction)
    checkTransaction(transaction) {
        for (const key in transaction) {
            if (allowedTransactionKeys.indexOf(key) === -1) {
                logger$2.throwArgumentError("invalid transaction key: " + key, "transaction", transaction);
            }
        }
        const tx = shallowCopy(transaction);
        if (tx.from == null) {
            tx.from = this.getAddress();
        }
        else {
            // Make sure any provided address matches this signer
            tx.from = Promise.all([
                Promise.resolve(tx.from),
                this.getAddress()
            ]).then((result) => {
                if (result[0].toLowerCase() !== result[1].toLowerCase()) {
                    logger$2.throwArgumentError("from address mismatch", "transaction", transaction);
                }
                return result[0];
            });
        }
        return tx;
    }
    // Populates ALL keys for a transaction and checks that "from" matches
    // this Signer. Should be used by sendTransaction but NOT by signTransaction.
    // By default called from: (overriding these prevents it)
    //   - sendTransaction
    //
    // Notes:
    //  - We allow gasPrice for EIP-1559 as long as it matches maxFeePerGas
    populateTransaction(transaction) {
        return __awaiter$1(this, void 0, void 0, function* () {
            const tx = yield resolveProperties(this.checkTransaction(transaction));
            if (tx.to != null) {
                tx.to = Promise.resolve(tx.to).then((to) => __awaiter$1(this, void 0, void 0, function* () {
                    if (to == null) {
                        return null;
                    }
                    const address = yield this.resolveName(to);
                    if (address == null) {
                        logger$2.throwArgumentError("provided ENS name resolves to null", "tx.to", to);
                    }
                    return address;
                }));
                // Prevent this error from causing an UnhandledPromiseException
                tx.to.catch((error) => { });
            }
            // Do not allow mixing pre-eip-1559 and eip-1559 properties
            const hasEip1559 = (tx.maxFeePerGas != null || tx.maxPriorityFeePerGas != null);
            if (tx.gasPrice != null && (tx.type === 2 || hasEip1559)) {
                logger$2.throwArgumentError("eip-1559 transaction do not support gasPrice", "transaction", transaction);
            }
            else if ((tx.type === 0 || tx.type === 1) && hasEip1559) {
                logger$2.throwArgumentError("pre-eip-1559 transaction do not support maxFeePerGas/maxPriorityFeePerGas", "transaction", transaction);
            }
            if ((tx.type === 2 || tx.type == null) && (tx.maxFeePerGas != null && tx.maxPriorityFeePerGas != null)) {
                // Fully-formed EIP-1559 transaction (skip getFeeData)
                tx.type = 2;
            }
            else if (tx.type === 0 || tx.type === 1) {
                // Explicit Legacy or EIP-2930 transaction
                // Populate missing gasPrice
                if (tx.gasPrice == null) {
                    tx.gasPrice = this.getGasPrice();
                }
            }
            else {
                // We need to get fee data to determine things
                const feeData = yield this.getFeeData();
                if (tx.type == null) {
                    // We need to auto-detect the intended type of this transaction...
                    if (feeData.maxFeePerGas != null && feeData.maxPriorityFeePerGas != null) {
                        // The network supports EIP-1559!
                        // Upgrade transaction from null to eip-1559
                        tx.type = 2;
                        if (tx.gasPrice != null) {
                            // Using legacy gasPrice property on an eip-1559 network,
                            // so use gasPrice as both fee properties
                            const gasPrice = tx.gasPrice;
                            delete tx.gasPrice;
                            tx.maxFeePerGas = gasPrice;
                            tx.maxPriorityFeePerGas = gasPrice;
                        }
                        else {
                            // Populate missing fee data
                            if (tx.maxFeePerGas == null) {
                                tx.maxFeePerGas = feeData.maxFeePerGas;
                            }
                            if (tx.maxPriorityFeePerGas == null) {
                                tx.maxPriorityFeePerGas = feeData.maxPriorityFeePerGas;
                            }
                        }
                    }
                    else if (feeData.gasPrice != null) {
                        // Network doesn't support EIP-1559...
                        // ...but they are trying to use EIP-1559 properties
                        if (hasEip1559) {
                            logger$2.throwError("network does not support EIP-1559", Logger.errors.UNSUPPORTED_OPERATION, {
                                operation: "populateTransaction"
                            });
                        }
                        // Populate missing fee data
                        if (tx.gasPrice == null) {
                            tx.gasPrice = feeData.gasPrice;
                        }
                        // Explicitly set untyped transaction to legacy
                        tx.type = 0;
                    }
                    else {
                        // getFeeData has failed us.
                        logger$2.throwError("failed to get consistent fee data", Logger.errors.UNSUPPORTED_OPERATION, {
                            operation: "signer.getFeeData"
                        });
                    }
                }
                else if (tx.type === 2) {
                    // Explicitly using EIP-1559
                    // Populate missing fee data
                    if (tx.maxFeePerGas == null) {
                        tx.maxFeePerGas = feeData.maxFeePerGas;
                    }
                    if (tx.maxPriorityFeePerGas == null) {
                        tx.maxPriorityFeePerGas = feeData.maxPriorityFeePerGas;
                    }
                }
            }
            if (tx.nonce == null) {
                tx.nonce = this.getTransactionCount("pending");
            }
            if (tx.gasLimit == null) {
                tx.gasLimit = this.estimateGas(tx).catch((error) => {
                    if (forwardErrors.indexOf(error.code) >= 0) {
                        throw error;
                    }
                    return logger$2.throwError("cannot estimate gas; transaction may fail or may require manual gas limit", Logger.errors.UNPREDICTABLE_GAS_LIMIT, {
                        error: error,
                        tx: tx
                    });
                });
            }
            if (tx.chainId == null) {
                tx.chainId = this.getChainId();
            }
            else {
                tx.chainId = Promise.all([
                    Promise.resolve(tx.chainId),
                    this.getChainId()
                ]).then((results) => {
                    if (results[1] !== 0 && results[0] !== results[1]) {
                        logger$2.throwArgumentError("chainId address mismatch", "transaction", transaction);
                    }
                    return results[0];
                });
            }
            return yield resolveProperties(tx);
        });
    }
    ///////////////////
    // Sub-classes SHOULD leave these alone
    _checkProvider(operation) {
        if (!this.provider) {
            logger$2.throwError("missing provider", Logger.errors.UNSUPPORTED_OPERATION, {
                operation: (operation || "_checkProvider")
            });
        }
    }
    static isSigner(value) {
        return !!(value && value._isSigner);
    }
}
class VoidSigner extends Signer {
    constructor(address, provider) {
        super();
        defineReadOnly(this, "address", address);
        defineReadOnly(this, "provider", provider || null);
    }
    getAddress() {
        return Promise.resolve(this.address);
    }
    _fail(message, operation) {
        return Promise.resolve().then(() => {
            logger$2.throwError(message, Logger.errors.UNSUPPORTED_OPERATION, { operation: operation });
        });
    }
    signMessage(message) {
        return this._fail("VoidSigner cannot sign messages", "signMessage");
    }
    signTransaction(transaction) {
        return this._fail("VoidSigner cannot sign transactions", "signTransaction");
    }
    _signTypedData(domain, types, value) {
        return this._fail("VoidSigner cannot sign typed data", "signTypedData");
    }
    connect(provider) {
        return new VoidSigner(this.address, provider);
    }
}

const version$1 = "transactions/5.7.0";

const logger$1 = new Logger(version$1);
var TransactionTypes;
(function (TransactionTypes) {
    TransactionTypes[TransactionTypes["legacy"] = 0] = "legacy";
    TransactionTypes[TransactionTypes["eip2930"] = 1] = "eip2930";
    TransactionTypes[TransactionTypes["eip1559"] = 2] = "eip1559";
})(TransactionTypes || (TransactionTypes = {}));
function accessSetify(addr, storageKeys) {
    return {
        address: getAddress(addr),
        storageKeys: (storageKeys || []).map((storageKey, index) => {
            if (hexDataLength(storageKey) !== 32) {
                logger$1.throwArgumentError("invalid access list storageKey", `accessList[${addr}:${index}]`, storageKey);
            }
            return storageKey.toLowerCase();
        })
    };
}
function accessListify(value) {
    if (Array.isArray(value)) {
        return value.map((set, index) => {
            if (Array.isArray(set)) {
                if (set.length > 2) {
                    logger$1.throwArgumentError("access list expected to be [ address, storageKeys[] ]", `value[${index}]`, set);
                }
                return accessSetify(set[0], set[1]);
            }
            return accessSetify(set.address, set.storageKeys);
        });
    }
    const result = Object.keys(value).map((addr) => {
        const storageKeys = value[addr].reduce((accum, storageKey) => {
            accum[storageKey] = true;
            return accum;
        }, {});
        return accessSetify(addr, Object.keys(storageKeys).sort());
    });
    result.sort((a, b) => (a.address.localeCompare(b.address)));
    return result;
}

const version = "contracts/5.7.0";

var __awaiter = function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
const logger = new Logger(version);
function resolveName(resolver, nameOrPromise) {
    return __awaiter(this, void 0, void 0, function* () {
        const name = yield nameOrPromise;
        if (typeof (name) !== "string") {
            logger.throwArgumentError("invalid address or ENS name", "name", name);
        }
        // If it is already an address, just use it (after adding checksum)
        try {
            return getAddress(name);
        }
        catch (error) { }
        if (!resolver) {
            logger.throwError("a provider or signer is needed to resolve ENS names", Logger.errors.UNSUPPORTED_OPERATION, {
                operation: "resolveName"
            });
        }
        const address = yield resolver.resolveName(name);
        if (address == null) {
            logger.throwArgumentError("resolver or addr is not configured for ENS name", "name", name);
        }
        return address;
    });
}
// Recursively replaces ENS names with promises to resolve the name and resolves all properties
function resolveAddresses(resolver, value, paramType) {
    return __awaiter(this, void 0, void 0, function* () {
        if (Array.isArray(paramType)) {
            return yield Promise.all(paramType.map((paramType, index) => {
                return resolveAddresses(resolver, ((Array.isArray(value)) ? value[index] : value[paramType.name]), paramType);
            }));
        }
        if (paramType.type === "address") {
            return yield resolveName(resolver, value);
        }
        if (paramType.type === "tuple") {
            return yield resolveAddresses(resolver, value, paramType.components);
        }
        if (paramType.baseType === "array") {
            if (!Array.isArray(value)) {
                return Promise.reject(logger.makeError("invalid value for array", Logger.errors.INVALID_ARGUMENT, {
                    argument: "value",
                    value
                }));
            }
            return yield Promise.all(value.map((v) => resolveAddresses(resolver, v, paramType.arrayChildren)));
        }
        return value;
    });
}
function populateTransaction(contract, fragment, args) {
    return __awaiter(this, void 0, void 0, function* () {
        // If an extra argument is given, it is overrides
        let overrides = {};
        if (args.length === fragment.inputs.length + 1 && typeof (args[args.length - 1]) === "object") {
            overrides = shallowCopy(args.pop());
        }
        // Make sure the parameter count matches
        logger.checkArgumentCount(args.length, fragment.inputs.length, "passed to contract");
        // Populate "from" override (allow promises)
        if (contract.signer) {
            if (overrides.from) {
                // Contracts with a Signer are from the Signer's frame-of-reference;
                // but we allow overriding "from" if it matches the signer
                overrides.from = resolveProperties({
                    override: resolveName(contract.signer, overrides.from),
                    signer: contract.signer.getAddress()
                }).then((check) => __awaiter(this, void 0, void 0, function* () {
                    if (getAddress(check.signer) !== check.override) {
                        logger.throwError("Contract with a Signer cannot override from", Logger.errors.UNSUPPORTED_OPERATION, {
                            operation: "overrides.from"
                        });
                    }
                    return check.override;
                }));
            }
            else {
                overrides.from = contract.signer.getAddress();
            }
        }
        else if (overrides.from) {
            overrides.from = resolveName(contract.provider, overrides.from);
            //} else {
            // Contracts without a signer can override "from", and if
            // unspecified the zero address is used
            //overrides.from = AddressZero;
        }
        // Wait for all dependencies to be resolved (prefer the signer over the provider)
        const resolved = yield resolveProperties({
            args: resolveAddresses(contract.signer || contract.provider, args, fragment.inputs),
            address: contract.resolvedAddress,
            overrides: (resolveProperties(overrides) || {})
        });
        // The ABI coded transaction
        const data = contract.interface.encodeFunctionData(fragment, resolved.args);
        const tx = {
            data: data,
            to: resolved.address
        };
        // Resolved Overrides
        const ro = resolved.overrides;
        // Populate simple overrides
        if (ro.nonce != null) {
            tx.nonce = BigNumber.from(ro.nonce).toNumber();
        }
        if (ro.gasLimit != null) {
            tx.gasLimit = BigNumber.from(ro.gasLimit);
        }
        if (ro.gasPrice != null) {
            tx.gasPrice = BigNumber.from(ro.gasPrice);
        }
        if (ro.maxFeePerGas != null) {
            tx.maxFeePerGas = BigNumber.from(ro.maxFeePerGas);
        }
        if (ro.maxPriorityFeePerGas != null) {
            tx.maxPriorityFeePerGas = BigNumber.from(ro.maxPriorityFeePerGas);
        }
        if (ro.from != null) {
            tx.from = ro.from;
        }
        if (ro.type != null) {
            tx.type = ro.type;
        }
        if (ro.accessList != null) {
            tx.accessList = accessListify(ro.accessList);
        }
        // If there was no "gasLimit" override, but the ABI specifies a default, use it
        if (tx.gasLimit == null && fragment.gas != null) {
            // Compute the intrinsic gas cost for this transaction
            // @TODO: This is based on the yellow paper as of Petersburg; this is something
            // we may wish to parameterize in v6 as part of the Network object. Since this
            // is always a non-nil to address, we can ignore G_create, but may wish to add
            // similar logic to the ContractFactory.
            let intrinsic = 21000;
            const bytes = arrayify(data);
            for (let i = 0; i < bytes.length; i++) {
                intrinsic += 4;
                if (bytes[i]) {
                    intrinsic += 64;
                }
            }
            tx.gasLimit = BigNumber.from(fragment.gas).add(intrinsic);
        }
        // Populate "value" override
        if (ro.value) {
            const roValue = BigNumber.from(ro.value);
            if (!roValue.isZero() && !fragment.payable) {
                logger.throwError("non-payable method cannot override value", Logger.errors.UNSUPPORTED_OPERATION, {
                    operation: "overrides.value",
                    value: overrides.value
                });
            }
            tx.value = roValue;
        }
        if (ro.customData) {
            tx.customData = shallowCopy(ro.customData);
        }
        if (ro.ccipReadEnabled) {
            tx.ccipReadEnabled = !!ro.ccipReadEnabled;
        }
        // Remove the overrides
        delete overrides.nonce;
        delete overrides.gasLimit;
        delete overrides.gasPrice;
        delete overrides.from;
        delete overrides.value;
        delete overrides.type;
        delete overrides.accessList;
        delete overrides.maxFeePerGas;
        delete overrides.maxPriorityFeePerGas;
        delete overrides.customData;
        delete overrides.ccipReadEnabled;
        // Make sure there are no stray overrides, which may indicate a
        // typo or using an unsupported key.
        const leftovers = Object.keys(overrides).filter((key) => (overrides[key] != null));
        if (leftovers.length) {
            logger.throwError(`cannot override ${leftovers.map((l) => JSON.stringify(l)).join(",")}`, Logger.errors.UNSUPPORTED_OPERATION, {
                operation: "overrides",
                overrides: leftovers
            });
        }
        return tx;
    });
}
function buildPopulate(contract, fragment) {
    return function (...args) {
        return populateTransaction(contract, fragment, args);
    };
}
function buildEstimate(contract, fragment) {
    const signerOrProvider = (contract.signer || contract.provider);
    return function (...args) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!signerOrProvider) {
                logger.throwError("estimate require a provider or signer", Logger.errors.UNSUPPORTED_OPERATION, {
                    operation: "estimateGas"
                });
            }
            const tx = yield populateTransaction(contract, fragment, args);
            return yield signerOrProvider.estimateGas(tx);
        });
    };
}
function addContractWait(contract, tx) {
    const wait = tx.wait.bind(tx);
    tx.wait = (confirmations) => {
        return wait(confirmations).then((receipt) => {
            receipt.events = receipt.logs.map((log) => {
                let event = deepCopy(log);
                let parsed = null;
                try {
                    parsed = contract.interface.parseLog(log);
                }
                catch (e) { }
                // Successfully parsed the event log; include it
                if (parsed) {
                    event.args = parsed.args;
                    event.decode = (data, topics) => {
                        return contract.interface.decodeEventLog(parsed.eventFragment, data, topics);
                    };
                    event.event = parsed.name;
                    event.eventSignature = parsed.signature;
                }
                // Useful operations
                event.removeListener = () => { return contract.provider; };
                event.getBlock = () => {
                    return contract.provider.getBlock(receipt.blockHash);
                };
                event.getTransaction = () => {
                    return contract.provider.getTransaction(receipt.transactionHash);
                };
                event.getTransactionReceipt = () => {
                    return Promise.resolve(receipt);
                };
                return event;
            });
            return receipt;
        });
    };
}
function buildCall(contract, fragment, collapseSimple) {
    const signerOrProvider = (contract.signer || contract.provider);
    return function (...args) {
        return __awaiter(this, void 0, void 0, function* () {
            // Extract the "blockTag" override if present
            let blockTag = undefined;
            if (args.length === fragment.inputs.length + 1 && typeof (args[args.length - 1]) === "object") {
                const overrides = shallowCopy(args.pop());
                if (overrides.blockTag != null) {
                    blockTag = yield overrides.blockTag;
                }
                delete overrides.blockTag;
                args.push(overrides);
            }
            // If the contract was just deployed, wait until it is mined
            if (contract.deployTransaction != null) {
                yield contract._deployed(blockTag);
            }
            // Call a node and get the result
            const tx = yield populateTransaction(contract, fragment, args);
            const result = yield signerOrProvider.call(tx, blockTag);
            try {
                let value = contract.interface.decodeFunctionResult(fragment, result);
                if (collapseSimple && fragment.outputs.length === 1) {
                    value = value[0];
                }
                return value;
            }
            catch (error) {
                if (error.code === Logger.errors.CALL_EXCEPTION) {
                    error.address = contract.address;
                    error.args = args;
                    error.transaction = tx;
                }
                throw error;
            }
        });
    };
}
function buildSend(contract, fragment) {
    return function (...args) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!contract.signer) {
                logger.throwError("sending a transaction requires a signer", Logger.errors.UNSUPPORTED_OPERATION, {
                    operation: "sendTransaction"
                });
            }
            // If the contract was just deployed, wait until it is mined
            if (contract.deployTransaction != null) {
                yield contract._deployed();
            }
            const txRequest = yield populateTransaction(contract, fragment, args);
            const tx = yield contract.signer.sendTransaction(txRequest);
            // Tweak the tx.wait so the receipt has extra properties
            addContractWait(contract, tx);
            return tx;
        });
    };
}
function buildDefault(contract, fragment, collapseSimple) {
    if (fragment.constant) {
        return buildCall(contract, fragment, collapseSimple);
    }
    return buildSend(contract, fragment);
}
function getEventTag(filter) {
    if (filter.address && (filter.topics == null || filter.topics.length === 0)) {
        return "*";
    }
    return (filter.address || "*") + "@" + (filter.topics ? filter.topics.map((topic) => {
        if (Array.isArray(topic)) {
            return topic.join("|");
        }
        return topic;
    }).join(":") : "");
}
class RunningEvent {
    constructor(tag, filter) {
        defineReadOnly(this, "tag", tag);
        defineReadOnly(this, "filter", filter);
        this._listeners = [];
    }
    addListener(listener, once) {
        this._listeners.push({ listener: listener, once: once });
    }
    removeListener(listener) {
        let done = false;
        this._listeners = this._listeners.filter((item) => {
            if (done || item.listener !== listener) {
                return true;
            }
            done = true;
            return false;
        });
    }
    removeAllListeners() {
        this._listeners = [];
    }
    listeners() {
        return this._listeners.map((i) => i.listener);
    }
    listenerCount() {
        return this._listeners.length;
    }
    run(args) {
        const listenerCount = this.listenerCount();
        this._listeners = this._listeners.filter((item) => {
            const argsCopy = args.slice();
            // Call the callback in the next event loop
            setTimeout(() => {
                item.listener.apply(this, argsCopy);
            }, 0);
            // Reschedule it if it not "once"
            return !(item.once);
        });
        return listenerCount;
    }
    prepareEvent(event) {
    }
    // Returns the array that will be applied to an emit
    getEmit(event) {
        return [event];
    }
}
class ErrorRunningEvent extends RunningEvent {
    constructor() {
        super("error", null);
    }
}
// @TODO Fragment should inherit Wildcard? and just override getEmit?
//       or have a common abstract super class, with enough constructor
//       options to configure both.
// A Fragment Event will populate all the properties that Wildcard
// will, and additionally dereference the arguments when emitting
class FragmentRunningEvent extends RunningEvent {
    constructor(address, contractInterface, fragment, topics) {
        const filter = {
            address: address
        };
        let topic = contractInterface.getEventTopic(fragment);
        if (topics) {
            if (topic !== topics[0]) {
                logger.throwArgumentError("topic mismatch", "topics", topics);
            }
            filter.topics = topics.slice();
        }
        else {
            filter.topics = [topic];
        }
        super(getEventTag(filter), filter);
        defineReadOnly(this, "address", address);
        defineReadOnly(this, "interface", contractInterface);
        defineReadOnly(this, "fragment", fragment);
    }
    prepareEvent(event) {
        super.prepareEvent(event);
        event.event = this.fragment.name;
        event.eventSignature = this.fragment.format();
        event.decode = (data, topics) => {
            return this.interface.decodeEventLog(this.fragment, data, topics);
        };
        try {
            event.args = this.interface.decodeEventLog(this.fragment, event.data, event.topics);
        }
        catch (error) {
            event.args = null;
            event.decodeError = error;
        }
    }
    getEmit(event) {
        const errors = checkResultErrors(event.args);
        if (errors.length) {
            throw errors[0].error;
        }
        const args = (event.args || []).slice();
        args.push(event);
        return args;
    }
}
// A Wildcard Event will attempt to populate:
//  - event            The name of the event name
//  - eventSignature   The full signature of the event
//  - decode           A function to decode data and topics
//  - args             The decoded data and topics
class WildcardRunningEvent extends RunningEvent {
    constructor(address, contractInterface) {
        super("*", { address: address });
        defineReadOnly(this, "address", address);
        defineReadOnly(this, "interface", contractInterface);
    }
    prepareEvent(event) {
        super.prepareEvent(event);
        try {
            const parsed = this.interface.parseLog(event);
            event.event = parsed.name;
            event.eventSignature = parsed.signature;
            event.decode = (data, topics) => {
                return this.interface.decodeEventLog(parsed.eventFragment, data, topics);
            };
            event.args = parsed.args;
        }
        catch (error) {
            // No matching event
        }
    }
}
class BaseContract {
    constructor(addressOrName, contractInterface, signerOrProvider) {
        // @TODO: Maybe still check the addressOrName looks like a valid address or name?
        //address = getAddress(address);
        defineReadOnly(this, "interface", getStatic(new.target, "getInterface")(contractInterface));
        if (signerOrProvider == null) {
            defineReadOnly(this, "provider", null);
            defineReadOnly(this, "signer", null);
        }
        else if (Signer.isSigner(signerOrProvider)) {
            defineReadOnly(this, "provider", signerOrProvider.provider || null);
            defineReadOnly(this, "signer", signerOrProvider);
        }
        else if (Provider.isProvider(signerOrProvider)) {
            defineReadOnly(this, "provider", signerOrProvider);
            defineReadOnly(this, "signer", null);
        }
        else {
            logger.throwArgumentError("invalid signer or provider", "signerOrProvider", signerOrProvider);
        }
        defineReadOnly(this, "callStatic", {});
        defineReadOnly(this, "estimateGas", {});
        defineReadOnly(this, "functions", {});
        defineReadOnly(this, "populateTransaction", {});
        defineReadOnly(this, "filters", {});
        {
            const uniqueFilters = {};
            Object.keys(this.interface.events).forEach((eventSignature) => {
                const event = this.interface.events[eventSignature];
                defineReadOnly(this.filters, eventSignature, (...args) => {
                    return {
                        address: this.address,
                        topics: this.interface.encodeFilterTopics(event, args)
                    };
                });
                if (!uniqueFilters[event.name]) {
                    uniqueFilters[event.name] = [];
                }
                uniqueFilters[event.name].push(eventSignature);
            });
            Object.keys(uniqueFilters).forEach((name) => {
                const filters = uniqueFilters[name];
                if (filters.length === 1) {
                    defineReadOnly(this.filters, name, this.filters[filters[0]]);
                }
                else {
                    logger.warn(`Duplicate definition of ${name} (${filters.join(", ")})`);
                }
            });
        }
        defineReadOnly(this, "_runningEvents", {});
        defineReadOnly(this, "_wrappedEmits", {});
        if (addressOrName == null) {
            logger.throwArgumentError("invalid contract address or ENS name", "addressOrName", addressOrName);
        }
        defineReadOnly(this, "address", addressOrName);
        if (this.provider) {
            defineReadOnly(this, "resolvedAddress", resolveName(this.provider, addressOrName));
        }
        else {
            try {
                defineReadOnly(this, "resolvedAddress", Promise.resolve(getAddress(addressOrName)));
            }
            catch (error) {
                // Without a provider, we cannot use ENS names
                logger.throwError("provider is required to use ENS name as contract address", Logger.errors.UNSUPPORTED_OPERATION, {
                    operation: "new Contract"
                });
            }
        }
        // Swallow bad ENS names to prevent Unhandled Exceptions
        this.resolvedAddress.catch((e) => { });
        const uniqueNames = {};
        const uniqueSignatures = {};
        Object.keys(this.interface.functions).forEach((signature) => {
            const fragment = this.interface.functions[signature];
            // Check that the signature is unique; if not the ABI generation has
            // not been cleaned or may be incorrectly generated
            if (uniqueSignatures[signature]) {
                logger.warn(`Duplicate ABI entry for ${JSON.stringify(signature)}`);
                return;
            }
            uniqueSignatures[signature] = true;
            // Track unique names; we only expose bare named functions if they
            // are ambiguous
            {
                const name = fragment.name;
                if (!uniqueNames[`%${name}`]) {
                    uniqueNames[`%${name}`] = [];
                }
                uniqueNames[`%${name}`].push(signature);
            }
            if (this[signature] == null) {
                defineReadOnly(this, signature, buildDefault(this, fragment, true));
            }
            // We do not collapse simple calls on this bucket, which allows
            // frameworks to safely use this without introspection as well as
            // allows decoding error recovery.
            if (this.functions[signature] == null) {
                defineReadOnly(this.functions, signature, buildDefault(this, fragment, false));
            }
            if (this.callStatic[signature] == null) {
                defineReadOnly(this.callStatic, signature, buildCall(this, fragment, true));
            }
            if (this.populateTransaction[signature] == null) {
                defineReadOnly(this.populateTransaction, signature, buildPopulate(this, fragment));
            }
            if (this.estimateGas[signature] == null) {
                defineReadOnly(this.estimateGas, signature, buildEstimate(this, fragment));
            }
        });
        Object.keys(uniqueNames).forEach((name) => {
            // Ambiguous names to not get attached as bare names
            const signatures = uniqueNames[name];
            if (signatures.length > 1) {
                return;
            }
            // Strip off the leading "%" used for prototype protection
            name = name.substring(1);
            const signature = signatures[0];
            // If overwriting a member property that is null, swallow the error
            try {
                if (this[name] == null) {
                    defineReadOnly(this, name, this[signature]);
                }
            }
            catch (e) { }
            if (this.functions[name] == null) {
                defineReadOnly(this.functions, name, this.functions[signature]);
            }
            if (this.callStatic[name] == null) {
                defineReadOnly(this.callStatic, name, this.callStatic[signature]);
            }
            if (this.populateTransaction[name] == null) {
                defineReadOnly(this.populateTransaction, name, this.populateTransaction[signature]);
            }
            if (this.estimateGas[name] == null) {
                defineReadOnly(this.estimateGas, name, this.estimateGas[signature]);
            }
        });
    }
    static getContractAddress(transaction) {
        return getContractAddress(transaction);
    }
    static getInterface(contractInterface) {
        if (Interface.isInterface(contractInterface)) {
            return contractInterface;
        }
        return new Interface(contractInterface);
    }
    // @TODO: Allow timeout?
    deployed() {
        return this._deployed();
    }
    _deployed(blockTag) {
        if (!this._deployedPromise) {
            // If we were just deployed, we know the transaction we should occur in
            if (this.deployTransaction) {
                this._deployedPromise = this.deployTransaction.wait().then(() => {
                    return this;
                });
            }
            else {
                // @TODO: Once we allow a timeout to be passed in, we will wait
                // up to that many blocks for getCode
                // Otherwise, poll for our code to be deployed
                this._deployedPromise = this.provider.getCode(this.address, blockTag).then((code) => {
                    if (code === "0x") {
                        logger.throwError("contract not deployed", Logger.errors.UNSUPPORTED_OPERATION, {
                            contractAddress: this.address,
                            operation: "getDeployed"
                        });
                    }
                    return this;
                });
            }
        }
        return this._deployedPromise;
    }
    // @TODO:
    // estimateFallback(overrides?: TransactionRequest): Promise<BigNumber>
    // @TODO:
    // estimateDeploy(bytecode: string, ...args): Promise<BigNumber>
    fallback(overrides) {
        if (!this.signer) {
            logger.throwError("sending a transactions require a signer", Logger.errors.UNSUPPORTED_OPERATION, { operation: "sendTransaction(fallback)" });
        }
        const tx = shallowCopy(overrides || {});
        ["from", "to"].forEach(function (key) {
            if (tx[key] == null) {
                return;
            }
            logger.throwError("cannot override " + key, Logger.errors.UNSUPPORTED_OPERATION, { operation: key });
        });
        tx.to = this.resolvedAddress;
        return this.deployed().then(() => {
            return this.signer.sendTransaction(tx);
        });
    }
    // Reconnect to a different signer or provider
    connect(signerOrProvider) {
        if (typeof (signerOrProvider) === "string") {
            signerOrProvider = new VoidSigner(signerOrProvider, this.provider);
        }
        const contract = new (this.constructor)(this.address, this.interface, signerOrProvider);
        if (this.deployTransaction) {
            defineReadOnly(contract, "deployTransaction", this.deployTransaction);
        }
        return contract;
    }
    // Re-attach to a different on-chain instance of this contract
    attach(addressOrName) {
        return new (this.constructor)(addressOrName, this.interface, this.signer || this.provider);
    }
    static isIndexed(value) {
        return Indexed.isIndexed(value);
    }
    _normalizeRunningEvent(runningEvent) {
        // Already have an instance of this event running; we can re-use it
        if (this._runningEvents[runningEvent.tag]) {
            return this._runningEvents[runningEvent.tag];
        }
        return runningEvent;
    }
    _getRunningEvent(eventName) {
        if (typeof (eventName) === "string") {
            // Listen for "error" events (if your contract has an error event, include
            // the full signature to bypass this special event keyword)
            if (eventName === "error") {
                return this._normalizeRunningEvent(new ErrorRunningEvent());
            }
            // Listen for any event that is registered
            if (eventName === "event") {
                return this._normalizeRunningEvent(new RunningEvent("event", null));
            }
            // Listen for any event
            if (eventName === "*") {
                return this._normalizeRunningEvent(new WildcardRunningEvent(this.address, this.interface));
            }
            // Get the event Fragment (throws if ambiguous/unknown event)
            const fragment = this.interface.getEvent(eventName);
            return this._normalizeRunningEvent(new FragmentRunningEvent(this.address, this.interface, fragment));
        }
        // We have topics to filter by...
        if (eventName.topics && eventName.topics.length > 0) {
            // Is it a known topichash? (throws if no matching topichash)
            try {
                const topic = eventName.topics[0];
                if (typeof (topic) !== "string") {
                    throw new Error("invalid topic"); // @TODO: May happen for anonymous events
                }
                const fragment = this.interface.getEvent(topic);
                return this._normalizeRunningEvent(new FragmentRunningEvent(this.address, this.interface, fragment, eventName.topics));
            }
            catch (error) { }
            // Filter by the unknown topichash
            const filter = {
                address: this.address,
                topics: eventName.topics
            };
            return this._normalizeRunningEvent(new RunningEvent(getEventTag(filter), filter));
        }
        return this._normalizeRunningEvent(new WildcardRunningEvent(this.address, this.interface));
    }
    _checkRunningEvents(runningEvent) {
        if (runningEvent.listenerCount() === 0) {
            delete this._runningEvents[runningEvent.tag];
            // If we have a poller for this, remove it
            const emit = this._wrappedEmits[runningEvent.tag];
            if (emit && runningEvent.filter) {
                this.provider.off(runningEvent.filter, emit);
                delete this._wrappedEmits[runningEvent.tag];
            }
        }
    }
    // Subclasses can override this to gracefully recover
    // from parse errors if they wish
    _wrapEvent(runningEvent, log, listener) {
        const event = deepCopy(log);
        event.removeListener = () => {
            if (!listener) {
                return;
            }
            runningEvent.removeListener(listener);
            this._checkRunningEvents(runningEvent);
        };
        event.getBlock = () => { return this.provider.getBlock(log.blockHash); };
        event.getTransaction = () => { return this.provider.getTransaction(log.transactionHash); };
        event.getTransactionReceipt = () => { return this.provider.getTransactionReceipt(log.transactionHash); };
        // This may throw if the topics and data mismatch the signature
        runningEvent.prepareEvent(event);
        return event;
    }
    _addEventListener(runningEvent, listener, once) {
        if (!this.provider) {
            logger.throwError("events require a provider or a signer with a provider", Logger.errors.UNSUPPORTED_OPERATION, { operation: "once" });
        }
        runningEvent.addListener(listener, once);
        // Track this running event and its listeners (may already be there; but no hard in updating)
        this._runningEvents[runningEvent.tag] = runningEvent;
        // If we are not polling the provider, start polling
        if (!this._wrappedEmits[runningEvent.tag]) {
            const wrappedEmit = (log) => {
                let event = this._wrapEvent(runningEvent, log, listener);
                // Try to emit the result for the parameterized event...
                if (event.decodeError == null) {
                    try {
                        const args = runningEvent.getEmit(event);
                        this.emit(runningEvent.filter, ...args);
                    }
                    catch (error) {
                        event.decodeError = error.error;
                    }
                }
                // Always emit "event" for fragment-base events
                if (runningEvent.filter != null) {
                    this.emit("event", event);
                }
                // Emit "error" if there was an error
                if (event.decodeError != null) {
                    this.emit("error", event.decodeError, event);
                }
            };
            this._wrappedEmits[runningEvent.tag] = wrappedEmit;
            // Special events, like "error" do not have a filter
            if (runningEvent.filter != null) {
                this.provider.on(runningEvent.filter, wrappedEmit);
            }
        }
    }
    queryFilter(event, fromBlockOrBlockhash, toBlock) {
        const runningEvent = this._getRunningEvent(event);
        const filter = shallowCopy(runningEvent.filter);
        if (typeof (fromBlockOrBlockhash) === "string" && isHexString(fromBlockOrBlockhash, 32)) {
            if (toBlock != null) {
                logger.throwArgumentError("cannot specify toBlock with blockhash", "toBlock", toBlock);
            }
            filter.blockHash = fromBlockOrBlockhash;
        }
        else {
            filter.fromBlock = ((fromBlockOrBlockhash != null) ? fromBlockOrBlockhash : 0);
            filter.toBlock = ((toBlock != null) ? toBlock : "latest");
        }
        return this.provider.getLogs(filter).then((logs) => {
            return logs.map((log) => this._wrapEvent(runningEvent, log, null));
        });
    }
    on(event, listener) {
        this._addEventListener(this._getRunningEvent(event), listener, false);
        return this;
    }
    once(event, listener) {
        this._addEventListener(this._getRunningEvent(event), listener, true);
        return this;
    }
    emit(eventName, ...args) {
        if (!this.provider) {
            return false;
        }
        const runningEvent = this._getRunningEvent(eventName);
        const result = (runningEvent.run(args) > 0);
        // May have drained all the "once" events; check for living events
        this._checkRunningEvents(runningEvent);
        return result;
    }
    listenerCount(eventName) {
        if (!this.provider) {
            return 0;
        }
        if (eventName == null) {
            return Object.keys(this._runningEvents).reduce((accum, key) => {
                return accum + this._runningEvents[key].listenerCount();
            }, 0);
        }
        return this._getRunningEvent(eventName).listenerCount();
    }
    listeners(eventName) {
        if (!this.provider) {
            return [];
        }
        if (eventName == null) {
            const result = [];
            for (let tag in this._runningEvents) {
                this._runningEvents[tag].listeners().forEach((listener) => {
                    result.push(listener);
                });
            }
            return result;
        }
        return this._getRunningEvent(eventName).listeners();
    }
    removeAllListeners(eventName) {
        if (!this.provider) {
            return this;
        }
        if (eventName == null) {
            for (const tag in this._runningEvents) {
                const runningEvent = this._runningEvents[tag];
                runningEvent.removeAllListeners();
                this._checkRunningEvents(runningEvent);
            }
            return this;
        }
        // Delete any listeners
        const runningEvent = this._getRunningEvent(eventName);
        runningEvent.removeAllListeners();
        this._checkRunningEvents(runningEvent);
        return this;
    }
    off(eventName, listener) {
        if (!this.provider) {
            return this;
        }
        const runningEvent = this._getRunningEvent(eventName);
        runningEvent.removeListener(listener);
        this._checkRunningEvents(runningEvent);
        return this;
    }
    removeListener(eventName, listener) {
        return this.off(eventName, listener);
    }
}
class Contract extends BaseContract {
}

/**
 * @typedef {Object} CompletionStatus
 * @property {string} SUCCESS - The transaction has been successfully synced.
 * @property {string} PENDING - The transaction is still pending.
 * @property {string} FAILED - The transaction has failed.
 */
var CompletionStatus;
(function (CompletionStatus) {
    CompletionStatus["SUCCESS"] = "SUCCESS";
    CompletionStatus["PENDING"] = "PENDING";
    CompletionStatus["FAILED"] = "FAILED";
})(CompletionStatus || (CompletionStatus = {}));

const ROOT_ERC20_PREDICATE = [
    {
        anonymous: false,
        inputs: [
            {
                indexed: true,
                internalType: 'address',
                name: 'rootToken',
                type: 'address',
            },
            {
                indexed: true,
                internalType: 'address',
                name: 'childToken',
                type: 'address',
            },
            {
                indexed: false,
                internalType: 'address',
                name: 'depositor',
                type: 'address',
            },
            {
                indexed: true,
                internalType: 'address',
                name: 'receiver',
                type: 'address',
            },
            {
                indexed: false,
                internalType: 'uint256',
                name: 'amount',
                type: 'uint256',
            },
        ],
        name: 'ERC20Deposit',
        type: 'event',
    },
    {
        anonymous: false,
        inputs: [
            {
                indexed: true,
                internalType: 'address',
                name: 'rootToken',
                type: 'address',
            },
            {
                indexed: true,
                internalType: 'address',
                name: 'childToken',
                type: 'address',
            },
            {
                indexed: false,
                internalType: 'address',
                name: 'withdrawer',
                type: 'address',
            },
            {
                indexed: true,
                internalType: 'address',
                name: 'receiver',
                type: 'address',
            },
            {
                indexed: false,
                internalType: 'uint256',
                name: 'amount',
                type: 'uint256',
            },
        ],
        name: 'ERC20Withdraw',
        type: 'event',
    },
    {
        anonymous: false,
        inputs: [
            {
                indexed: false,
                internalType: 'uint8',
                name: 'version',
                type: 'uint8',
            },
        ],
        name: 'Initialized',
        type: 'event',
    },
    {
        anonymous: false,
        inputs: [
            {
                indexed: true,
                internalType: 'address',
                name: 'rootToken',
                type: 'address',
            },
            {
                indexed: true,
                internalType: 'address',
                name: 'childToken',
                type: 'address',
            },
        ],
        name: 'TokenMapped',
        type: 'event',
    },
    {
        inputs: [],
        name: 'DEPOSIT_SIG',
        outputs: [
            {
                internalType: 'bytes32',
                name: '',
                type: 'bytes32',
            },
        ],
        stateMutability: 'view',
        type: 'function',
    },
    {
        inputs: [],
        name: 'MAP_TOKEN_SIG',
        outputs: [
            {
                internalType: 'bytes32',
                name: '',
                type: 'bytes32',
            },
        ],
        stateMutability: 'view',
        type: 'function',
    },
    {
        inputs: [],
        name: 'NATIVE_TOKEN',
        outputs: [
            {
                internalType: 'address',
                name: '',
                type: 'address',
            },
        ],
        stateMutability: 'view',
        type: 'function',
    },
    {
        inputs: [],
        name: 'WITHDRAW_SIG',
        outputs: [
            {
                internalType: 'bytes32',
                name: '',
                type: 'bytes32',
            },
        ],
        stateMutability: 'view',
        type: 'function',
    },
    {
        inputs: [],
        name: 'childERC20Predicate',
        outputs: [
            {
                internalType: 'address',
                name: '',
                type: 'address',
            },
        ],
        stateMutability: 'view',
        type: 'function',
    },
    {
        inputs: [],
        name: 'childTokenTemplate',
        outputs: [
            {
                internalType: 'address',
                name: '',
                type: 'address',
            },
        ],
        stateMutability: 'view',
        type: 'function',
    },
    {
        inputs: [
            {
                internalType: 'contract IERC20Metadata',
                name: 'rootToken',
                type: 'address',
            },
            {
                internalType: 'uint256',
                name: 'amount',
                type: 'uint256',
            },
        ],
        name: 'deposit',
        outputs: [],
        stateMutability: 'nonpayable',
        type: 'function',
    },
    {
        inputs: [
            {
                internalType: 'address',
                name: 'receiver',
                type: 'address',
            },
        ],
        name: 'depositNativeTo',
        outputs: [],
        stateMutability: 'payable',
        type: 'function',
    },
    {
        inputs: [
            {
                internalType: 'contract IERC20Metadata',
                name: 'rootToken',
                type: 'address',
            },
            {
                internalType: 'address',
                name: 'receiver',
                type: 'address',
            },
            {
                internalType: 'uint256',
                name: 'amount',
                type: 'uint256',
            },
        ],
        name: 'depositTo',
        outputs: [],
        stateMutability: 'nonpayable',
        type: 'function',
    },
    {
        inputs: [],
        name: 'exitHelper',
        outputs: [
            {
                internalType: 'address',
                name: '',
                type: 'address',
            },
        ],
        stateMutability: 'view',
        type: 'function',
    },
    {
        inputs: [
            {
                internalType: 'address',
                name: 'newStateSender',
                type: 'address',
            },
            {
                internalType: 'address',
                name: 'newExitHelper',
                type: 'address',
            },
            {
                internalType: 'address',
                name: 'newChildERC20Predicate',
                type: 'address',
            },
            {
                internalType: 'address',
                name: 'newChildTokenTemplate',
                type: 'address',
            },
            {
                internalType: 'address',
                name: 'nativeTokenRootAddress',
                type: 'address',
            },
        ],
        name: 'initialize',
        outputs: [],
        stateMutability: 'nonpayable',
        type: 'function',
    },
    {
        inputs: [
            {
                internalType: 'contract IERC20Metadata',
                name: 'rootToken',
                type: 'address',
            },
        ],
        name: 'mapToken',
        outputs: [
            {
                internalType: 'address',
                name: '',
                type: 'address',
            },
        ],
        stateMutability: 'nonpayable',
        type: 'function',
    },
    {
        inputs: [
            {
                internalType: 'uint256',
                name: '',
                type: 'uint256',
            },
            {
                internalType: 'address',
                name: 'sender',
                type: 'address',
            },
            {
                internalType: 'bytes',
                name: 'data',
                type: 'bytes',
            },
        ],
        name: 'onL2StateReceive',
        outputs: [],
        stateMutability: 'nonpayable',
        type: 'function',
    },
    {
        inputs: [
            {
                internalType: 'address',
                name: '',
                type: 'address',
            },
        ],
        name: 'rootTokenToChildToken',
        outputs: [
            {
                internalType: 'address',
                name: '',
                type: 'address',
            },
        ],
        stateMutability: 'view',
        type: 'function',
    },
    {
        inputs: [],
        name: 'stateSender',
        outputs: [
            {
                internalType: 'contract IStateSender',
                name: '',
                type: 'address',
            },
        ],
        stateMutability: 'view',
        type: 'function',
    },
];

const ERC20 = [
    {
        constant: true,
        inputs: [],
        name: 'name',
        outputs: [
            {
                name: '',
                type: 'string',
            },
        ],
        payable: false,
        stateMutability: 'view',
        type: 'function',
    },
    {
        constant: false,
        inputs: [
            {
                name: '_spender',
                type: 'address',
            },
            {
                name: '_value',
                type: 'uint256',
            },
        ],
        name: 'approve',
        outputs: [
            {
                name: '',
                type: 'bool',
            },
        ],
        payable: false,
        stateMutability: 'nonpayable',
        type: 'function',
    },
    {
        constant: true,
        inputs: [],
        name: 'totalSupply',
        outputs: [
            {
                name: '',
                type: 'uint256',
            },
        ],
        payable: false,
        stateMutability: 'view',
        type: 'function',
    },
    {
        constant: false,
        inputs: [
            {
                name: '_from',
                type: 'address',
            },
            {
                name: '_to',
                type: 'address',
            },
            {
                name: '_value',
                type: 'uint256',
            },
        ],
        name: 'transferFrom',
        outputs: [
            {
                name: '',
                type: 'bool',
            },
        ],
        payable: false,
        stateMutability: 'nonpayable',
        type: 'function',
    },
    {
        constant: true,
        inputs: [],
        name: 'decimals',
        outputs: [
            {
                name: '',
                type: 'uint8',
            },
        ],
        payable: false,
        stateMutability: 'view',
        type: 'function',
    },
    {
        constant: true,
        inputs: [
            {
                name: '_owner',
                type: 'address',
            },
        ],
        name: 'balanceOf',
        outputs: [
            {
                name: 'balance',
                type: 'uint256',
            },
        ],
        payable: false,
        stateMutability: 'view',
        type: 'function',
    },
    {
        constant: true,
        inputs: [],
        name: 'symbol',
        outputs: [
            {
                name: '',
                type: 'string',
            },
        ],
        payable: false,
        stateMutability: 'view',
        type: 'function',
    },
    {
        constant: false,
        inputs: [
            {
                name: '_to',
                type: 'address',
            },
            {
                name: '_value',
                type: 'uint256',
            },
        ],
        name: 'transfer',
        outputs: [
            {
                name: '',
                type: 'bool',
            },
        ],
        payable: false,
        stateMutability: 'nonpayable',
        type: 'function',
    },
    {
        constant: true,
        inputs: [
            {
                name: '_owner',
                type: 'address',
            },
            {
                name: '_spender',
                type: 'address',
            },
        ],
        name: 'allowance',
        outputs: [
            {
                name: '',
                type: 'uint256',
            },
        ],
        payable: false,
        stateMutability: 'view',
        type: 'function',
    },
    {
        payable: true,
        stateMutability: 'payable',
        type: 'fallback',
    },
    {
        anonymous: false,
        inputs: [
            {
                indexed: true,
                name: 'owner',
                type: 'address',
            },
            {
                indexed: true,
                name: 'spender',
                type: 'address',
            },
            {
                indexed: false,
                name: 'value',
                type: 'uint256',
            },
        ],
        name: 'Approval',
        type: 'event',
    },
    {
        anonymous: false,
        inputs: [
            {
                indexed: true,
                name: 'from',
                type: 'address',
            },
            {
                indexed: true,
                name: 'to',
                type: 'address',
            },
            {
                indexed: false,
                name: 'value',
                type: 'uint256',
            },
        ],
        name: 'Transfer',
        type: 'event',
    },
];

/**
 * @enum {string} BridgeErrorType - Enumeration of different types of bridge errors.
 */
var BridgeErrorType;
(function (BridgeErrorType) {
    BridgeErrorType["UNSUPPORTED_ERROR"] = "UNSUPPORTED_ERROR";
    BridgeErrorType["INVALID_ADDRESS"] = "INVALID_ADDRESS";
    BridgeErrorType["INVALID_AMOUNT"] = "INVALID_AMOUNT";
    BridgeErrorType["INTERNAL_ERROR"] = "INTERNAL_ERROR";
    BridgeErrorType["PROVIDER_ERROR"] = "PROVIDER_ERROR";
    BridgeErrorType["TRANSACTION_REVERTED"] = "TRANSACTION_REVERTED";
    BridgeErrorType["INVALID_TOKEN"] = "INVALID_TOKEN";
    BridgeErrorType["INVALID_TRANSACTION"] = "INVALID_TRANSACTION";
})(BridgeErrorType || (BridgeErrorType = {}));
/**
 * Represents a custom error for bridge operations.
 * @extends Error
 */
class BridgeError extends Error {
    /**
     * @property {BridgeErrorType} type - The type of the bridge error.
     */
    type;
    /**
     * Constructs a BridgeError instance.
     *
     * @param {string} message - The error message.
     * @param {BridgeErrorType} type - The type of the bridge error.
     */
    constructor(message, type) {
        super(message);
        this.type = type;
    }
}
/**
 * A helper function that wraps a Promise function with error handling for bridge operations.
 *
 * @template T - The type of the value that the Promise resolves to.
 * @param {() => Promise<T>} fn - The function to wrap with error handling.
 * @param {BridgeErrorType} customErrorType - The custom error type to use for the error.
 * @param {string} [details] - Additional details to add to the error message.
 * @returns {Promise<T>} The result of the wrapped function or a rejected promise with a BridgeError.
 */
const withBridgeError = async (fn, customErrorType, details) => {
    try {
        return await fn();
    }
    catch (error) {
        let errorMessage = `${customErrorType}: ${error.message}` || 'UnknownError';
        if (details) {
            errorMessage = `${details}: ${errorMessage}`;
        }
        throw new BridgeError(errorMessage, customErrorType);
    }
};

const ROOT_STATE_SENDER = [
    {
        anonymous: false,
        inputs: [
            {
                indexed: true,
                internalType: 'uint256',
                name: 'id',
                type: 'uint256',
            },
            {
                indexed: true,
                internalType: 'address',
                name: 'sender',
                type: 'address',
            },
            {
                indexed: true,
                internalType: 'address',
                name: 'receiver',
                type: 'address',
            },
            {
                indexed: false,
                internalType: 'bytes',
                name: 'data',
                type: 'bytes',
            },
        ],
        name: 'StateSynced',
        type: 'event',
    },
    {
        inputs: [],
        name: 'MAX_LENGTH',
        outputs: [
            {
                internalType: 'uint256',
                name: '',
                type: 'uint256',
            },
        ],
        stateMutability: 'view',
        type: 'function',
    },
    {
        inputs: [],
        name: 'counter',
        outputs: [
            {
                internalType: 'uint256',
                name: '',
                type: 'uint256',
            },
        ],
        stateMutability: 'view',
        type: 'function',
    },
    {
        inputs: [
            {
                internalType: 'address',
                name: 'receiver',
                type: 'address',
            },
            {
                internalType: 'bytes',
                name: 'data',
                type: 'bytes',
            },
        ],
        name: 'syncState',
        outputs: [],
        stateMutability: 'nonpayable',
        type: 'function',
    },
];

const CHILD_STATE_RECEIVER = [
    {
        inputs: [
            {
                internalType: 'string',
                name: 'only',
                type: 'string',
            },
        ],
        name: 'Unauthorized',
        type: 'error',
    },
    {
        anonymous: false,
        inputs: [
            {
                indexed: true,
                internalType: 'uint256',
                name: 'startId',
                type: 'uint256',
            },
            {
                indexed: true,
                internalType: 'uint256',
                name: 'endId',
                type: 'uint256',
            },
            {
                indexed: false,
                internalType: 'bytes32',
                name: 'root',
                type: 'bytes32',
            },
        ],
        name: 'NewCommitment',
        type: 'event',
    },
    {
        anonymous: false,
        inputs: [
            {
                indexed: true,
                internalType: 'uint256',
                name: 'counter',
                type: 'uint256',
            },
            {
                indexed: true,
                internalType: 'bool',
                name: 'status',
                type: 'bool',
            },
            {
                indexed: false,
                internalType: 'bytes',
                name: 'message',
                type: 'bytes',
            },
        ],
        name: 'StateSyncResult',
        type: 'event',
    },
    {
        inputs: [],
        name: 'NATIVE_TOKEN_CONTRACT',
        outputs: [
            {
                internalType: 'address',
                name: '',
                type: 'address',
            },
        ],
        stateMutability: 'view',
        type: 'function',
    },
    {
        inputs: [],
        name: 'NATIVE_TRANSFER_PRECOMPILE',
        outputs: [
            {
                internalType: 'address',
                name: '',
                type: 'address',
            },
        ],
        stateMutability: 'view',
        type: 'function',
    },
    {
        inputs: [],
        name: 'NATIVE_TRANSFER_PRECOMPILE_GAS',
        outputs: [
            {
                internalType: 'uint256',
                name: '',
                type: 'uint256',
            },
        ],
        stateMutability: 'view',
        type: 'function',
    },
    {
        inputs: [],
        name: 'SYSTEM',
        outputs: [
            {
                internalType: 'address',
                name: '',
                type: 'address',
            },
        ],
        stateMutability: 'view',
        type: 'function',
    },
    {
        inputs: [],
        name: 'VALIDATOR_PKCHECK_PRECOMPILE',
        outputs: [
            {
                internalType: 'address',
                name: '',
                type: 'address',
            },
        ],
        stateMutability: 'view',
        type: 'function',
    },
    {
        inputs: [],
        name: 'VALIDATOR_PKCHECK_PRECOMPILE_GAS',
        outputs: [
            {
                internalType: 'uint256',
                name: '',
                type: 'uint256',
            },
        ],
        stateMutability: 'view',
        type: 'function',
    },
    {
        inputs: [
            {
                internalType: 'bytes32[][]',
                name: 'proofs',
                type: 'bytes32[][]',
            },
            {
                components: [
                    {
                        internalType: 'uint256',
                        name: 'id',
                        type: 'uint256',
                    },
                    {
                        internalType: 'address',
                        name: 'sender',
                        type: 'address',
                    },
                    {
                        internalType: 'address',
                        name: 'receiver',
                        type: 'address',
                    },
                    {
                        internalType: 'bytes',
                        name: 'data',
                        type: 'bytes',
                    },
                ],
                internalType: 'struct StateReceiver.StateSync[]',
                name: 'objs',
                type: 'tuple[]',
            },
        ],
        name: 'batchExecute',
        outputs: [],
        stateMutability: 'nonpayable',
        type: 'function',
    },
    {
        inputs: [
            {
                components: [
                    {
                        internalType: 'uint256',
                        name: 'startId',
                        type: 'uint256',
                    },
                    {
                        internalType: 'uint256',
                        name: 'endId',
                        type: 'uint256',
                    },
                    {
                        internalType: 'bytes32',
                        name: 'root',
                        type: 'bytes32',
                    },
                ],
                internalType: 'struct StateReceiver.StateSyncCommitment',
                name: 'commitment',
                type: 'tuple',
            },
            {
                internalType: 'bytes',
                name: 'signature',
                type: 'bytes',
            },
            {
                internalType: 'bytes',
                name: 'bitmap',
                type: 'bytes',
            },
        ],
        name: 'commit',
        outputs: [],
        stateMutability: 'nonpayable',
        type: 'function',
    },
    {
        inputs: [],
        name: 'commitmentCounter',
        outputs: [
            {
                internalType: 'uint256',
                name: '',
                type: 'uint256',
            },
        ],
        stateMutability: 'view',
        type: 'function',
    },
    {
        inputs: [
            {
                internalType: 'uint256',
                name: '',
                type: 'uint256',
            },
        ],
        name: 'commitmentIds',
        outputs: [
            {
                internalType: 'uint256',
                name: '',
                type: 'uint256',
            },
        ],
        stateMutability: 'view',
        type: 'function',
    },
    {
        inputs: [
            {
                internalType: 'uint256',
                name: '',
                type: 'uint256',
            },
        ],
        name: 'commitments',
        outputs: [
            {
                internalType: 'uint256',
                name: 'startId',
                type: 'uint256',
            },
            {
                internalType: 'uint256',
                name: 'endId',
                type: 'uint256',
            },
            {
                internalType: 'bytes32',
                name: 'root',
                type: 'bytes32',
            },
        ],
        stateMutability: 'view',
        type: 'function',
    },
    {
        inputs: [
            {
                internalType: 'bytes32[]',
                name: 'proof',
                type: 'bytes32[]',
            },
            {
                components: [
                    {
                        internalType: 'uint256',
                        name: 'id',
                        type: 'uint256',
                    },
                    {
                        internalType: 'address',
                        name: 'sender',
                        type: 'address',
                    },
                    {
                        internalType: 'address',
                        name: 'receiver',
                        type: 'address',
                    },
                    {
                        internalType: 'bytes',
                        name: 'data',
                        type: 'bytes',
                    },
                ],
                internalType: 'struct StateReceiver.StateSync',
                name: 'obj',
                type: 'tuple',
            },
        ],
        name: 'execute',
        outputs: [],
        stateMutability: 'nonpayable',
        type: 'function',
    },
    {
        inputs: [
            {
                internalType: 'uint256',
                name: 'id',
                type: 'uint256',
            },
        ],
        name: 'getCommitmentByStateSyncId',
        outputs: [
            {
                components: [
                    {
                        internalType: 'uint256',
                        name: 'startId',
                        type: 'uint256',
                    },
                    {
                        internalType: 'uint256',
                        name: 'endId',
                        type: 'uint256',
                    },
                    {
                        internalType: 'bytes32',
                        name: 'root',
                        type: 'bytes32',
                    },
                ],
                internalType: 'struct StateReceiver.StateSyncCommitment',
                name: '',
                type: 'tuple',
            },
        ],
        stateMutability: 'view',
        type: 'function',
    },
    {
        inputs: [
            {
                internalType: 'uint256',
                name: 'id',
                type: 'uint256',
            },
        ],
        name: 'getRootByStateSyncId',
        outputs: [
            {
                internalType: 'bytes32',
                name: '',
                type: 'bytes32',
            },
        ],
        stateMutability: 'view',
        type: 'function',
    },
    {
        inputs: [],
        name: 'lastCommittedId',
        outputs: [
            {
                internalType: 'uint256',
                name: '',
                type: 'uint256',
            },
        ],
        stateMutability: 'view',
        type: 'function',
    },
    {
        inputs: [
            {
                internalType: 'uint256',
                name: '',
                type: 'uint256',
            },
        ],
        name: 'processedStateSyncs',
        outputs: [
            {
                internalType: 'bool',
                name: '',
                type: 'bool',
            },
        ],
        stateMutability: 'view',
        type: 'function',
    },
];

async function getBlockNumberClosestToTimestamp(provider, targetTimestamp, blockTime, clockInaccuracy) {
    let lowerBlockNumber = 0;
    let upperBlockNumber = await provider.getBlockNumber();
    while (upperBlockNumber !== lowerBlockNumber + 1) {
        const midBlockNumber = Math.floor((lowerBlockNumber + upperBlockNumber) / 2);
        // This is a valid use case to disable as results depend on previous results
        // eslint-disable-next-line no-await-in-loop
        const midBlock = await provider.getBlock(midBlockNumber);
        const timeDifference = targetTimestamp - midBlock.timestamp;
        if (timeDifference > clockInaccuracy && timeDifference < (blockTime + clockInaccuracy)) {
            return midBlockNumber;
        }
        if (midBlock.timestamp < targetTimestamp) {
            lowerBlockNumber = midBlockNumber;
        }
        else {
            upperBlockNumber = midBlockNumber;
        }
    }
    return lowerBlockNumber;
}

const CHILD_ERC20_PREDICATE = [
    {
        inputs: [
            {
                internalType: 'string',
                name: 'only',
                type: 'string',
            },
        ],
        name: 'Unauthorized',
        type: 'error',
    },
    {
        anonymous: false,
        inputs: [
            {
                indexed: false,
                internalType: 'uint8',
                name: 'version',
                type: 'uint8',
            },
        ],
        name: 'Initialized',
        type: 'event',
    },
    {
        anonymous: false,
        inputs: [
            {
                indexed: true,
                internalType: 'address',
                name: 'rootToken',
                type: 'address',
            },
            {
                indexed: true,
                internalType: 'address',
                name: 'childToken',
                type: 'address',
            },
            {
                indexed: false,
                internalType: 'address',
                name: 'sender',
                type: 'address',
            },
            {
                indexed: true,
                internalType: 'address',
                name: 'receiver',
                type: 'address',
            },
            {
                indexed: false,
                internalType: 'uint256',
                name: 'amount',
                type: 'uint256',
            },
        ],
        name: 'L2ERC20Deposit',
        type: 'event',
    },
    {
        anonymous: false,
        inputs: [
            {
                indexed: true,
                internalType: 'address',
                name: 'rootToken',
                type: 'address',
            },
            {
                indexed: true,
                internalType: 'address',
                name: 'childToken',
                type: 'address',
            },
            {
                indexed: false,
                internalType: 'address',
                name: 'sender',
                type: 'address',
            },
            {
                indexed: true,
                internalType: 'address',
                name: 'receiver',
                type: 'address',
            },
            {
                indexed: false,
                internalType: 'uint256',
                name: 'amount',
                type: 'uint256',
            },
        ],
        name: 'L2ERC20Withdraw',
        type: 'event',
    },
    {
        anonymous: false,
        inputs: [
            {
                indexed: true,
                internalType: 'address',
                name: 'rootToken',
                type: 'address',
            },
            {
                indexed: true,
                internalType: 'address',
                name: 'childToken',
                type: 'address',
            },
        ],
        name: 'L2TokenMapped',
        type: 'event',
    },
    {
        inputs: [],
        name: 'DEPOSIT_SIG',
        outputs: [
            {
                internalType: 'bytes32',
                name: '',
                type: 'bytes32',
            },
        ],
        stateMutability: 'view',
        type: 'function',
    },
    {
        inputs: [],
        name: 'MAP_TOKEN_SIG',
        outputs: [
            {
                internalType: 'bytes32',
                name: '',
                type: 'bytes32',
            },
        ],
        stateMutability: 'view',
        type: 'function',
    },
    {
        inputs: [],
        name: 'NATIVE_TOKEN_CONTRACT',
        outputs: [
            {
                internalType: 'address',
                name: '',
                type: 'address',
            },
        ],
        stateMutability: 'view',
        type: 'function',
    },
    {
        inputs: [],
        name: 'NATIVE_TRANSFER_PRECOMPILE',
        outputs: [
            {
                internalType: 'address',
                name: '',
                type: 'address',
            },
        ],
        stateMutability: 'view',
        type: 'function',
    },
    {
        inputs: [],
        name: 'NATIVE_TRANSFER_PRECOMPILE_GAS',
        outputs: [
            {
                internalType: 'uint256',
                name: '',
                type: 'uint256',
            },
        ],
        stateMutability: 'view',
        type: 'function',
    },
    {
        inputs: [],
        name: 'SYSTEM',
        outputs: [
            {
                internalType: 'address',
                name: '',
                type: 'address',
            },
        ],
        stateMutability: 'view',
        type: 'function',
    },
    {
        inputs: [],
        name: 'VALIDATOR_PKCHECK_PRECOMPILE',
        outputs: [
            {
                internalType: 'address',
                name: '',
                type: 'address',
            },
        ],
        stateMutability: 'view',
        type: 'function',
    },
    {
        inputs: [],
        name: 'VALIDATOR_PKCHECK_PRECOMPILE_GAS',
        outputs: [
            {
                internalType: 'uint256',
                name: '',
                type: 'uint256',
            },
        ],
        stateMutability: 'view',
        type: 'function',
    },
    {
        inputs: [],
        name: 'WITHDRAW_SIG',
        outputs: [
            {
                internalType: 'bytes32',
                name: '',
                type: 'bytes32',
            },
        ],
        stateMutability: 'view',
        type: 'function',
    },
    {
        inputs: [],
        name: 'childTokenTemplate',
        outputs: [
            {
                internalType: 'address',
                name: '',
                type: 'address',
            },
        ],
        stateMutability: 'view',
        type: 'function',
    },
    {
        inputs: [
            {
                internalType: 'address',
                name: 'newL2StateSender',
                type: 'address',
            },
            {
                internalType: 'address',
                name: 'newStateReceiver',
                type: 'address',
            },
            {
                internalType: 'address',
                name: 'newRootERC20Predicate',
                type: 'address',
            },
            {
                internalType: 'address',
                name: 'newChildTokenTemplate',
                type: 'address',
            },
            {
                internalType: 'address',
                name: 'newNativeTokenRootAddress',
                type: 'address',
            },
        ],
        name: 'initialize',
        outputs: [],
        stateMutability: 'nonpayable',
        type: 'function',
    },
    {
        inputs: [],
        name: 'l2StateSender',
        outputs: [
            {
                internalType: 'contract IStateSender',
                name: '',
                type: 'address',
            },
        ],
        stateMutability: 'view',
        type: 'function',
    },
    {
        inputs: [
            {
                internalType: 'uint256',
                name: '',
                type: 'uint256',
            },
            {
                internalType: 'address',
                name: 'sender',
                type: 'address',
            },
            {
                internalType: 'bytes',
                name: 'data',
                type: 'bytes',
            },
        ],
        name: 'onStateReceive',
        outputs: [],
        stateMutability: 'nonpayable',
        type: 'function',
    },
    {
        inputs: [],
        name: 'rootERC20Predicate',
        outputs: [
            {
                internalType: 'address',
                name: '',
                type: 'address',
            },
        ],
        stateMutability: 'view',
        type: 'function',
    },
    {
        inputs: [
            {
                internalType: 'address',
                name: '',
                type: 'address',
            },
        ],
        name: 'rootTokenToChildToken',
        outputs: [
            {
                internalType: 'address',
                name: '',
                type: 'address',
            },
        ],
        stateMutability: 'view',
        type: 'function',
    },
    {
        inputs: [],
        name: 'stateReceiver',
        outputs: [
            {
                internalType: 'address',
                name: '',
                type: 'address',
            },
        ],
        stateMutability: 'view',
        type: 'function',
    },
    {
        inputs: [
            {
                internalType: 'contract IChildERC20',
                name: 'childToken',
                type: 'address',
            },
            {
                internalType: 'uint256',
                name: 'amount',
                type: 'uint256',
            },
        ],
        name: 'withdraw',
        outputs: [],
        stateMutability: 'nonpayable',
        type: 'function',
    },
    {
        inputs: [
            {
                internalType: 'contract IChildERC20',
                name: 'childToken',
                type: 'address',
            },
            {
                internalType: 'address',
                name: 'receiver',
                type: 'address',
            },
            {
                internalType: 'uint256',
                name: 'amount',
                type: 'uint256',
            },
        ],
        name: 'withdrawTo',
        outputs: [],
        stateMutability: 'nonpayable',
        type: 'function',
    },
];

const CHECKPOINT_MANAGER = [
    {
        anonymous: false,
        inputs: [
            {
                indexed: false,
                internalType: 'uint8',
                name: 'version',
                type: 'uint8',
            },
        ],
        name: 'Initialized',
        type: 'event',
    },
    {
        inputs: [],
        name: 'DOMAIN',
        outputs: [
            {
                internalType: 'bytes32',
                name: '',
                type: 'bytes32',
            },
        ],
        stateMutability: 'view',
        type: 'function',
    },
    {
        inputs: [],
        name: 'bls',
        outputs: [
            {
                internalType: 'contract IBLS',
                name: '',
                type: 'address',
            },
        ],
        stateMutability: 'view',
        type: 'function',
    },
    {
        inputs: [],
        name: 'bn256G2',
        outputs: [
            {
                internalType: 'contract IBN256G2',
                name: '',
                type: 'address',
            },
        ],
        stateMutability: 'view',
        type: 'function',
    },
    {
        inputs: [],
        name: 'chainId',
        outputs: [
            {
                internalType: 'uint256',
                name: '',
                type: 'uint256',
            },
        ],
        stateMutability: 'view',
        type: 'function',
    },
    {
        inputs: [
            {
                internalType: 'uint256',
                name: '',
                type: 'uint256',
            },
        ],
        name: 'checkpointBlockNumbers',
        outputs: [
            {
                internalType: 'uint256',
                name: '',
                type: 'uint256',
            },
        ],
        stateMutability: 'view',
        type: 'function',
    },
    {
        inputs: [
            {
                internalType: 'uint256',
                name: '',
                type: 'uint256',
            },
        ],
        name: 'checkpoints',
        outputs: [
            {
                internalType: 'uint256',
                name: 'epoch',
                type: 'uint256',
            },
            {
                internalType: 'uint256',
                name: 'blockNumber',
                type: 'uint256',
            },
            {
                internalType: 'bytes32',
                name: 'eventRoot',
                type: 'bytes32',
            },
        ],
        stateMutability: 'view',
        type: 'function',
    },
    {
        inputs: [],
        name: 'currentCheckpointBlockNumber',
        outputs: [
            {
                internalType: 'uint256',
                name: '',
                type: 'uint256',
            },
        ],
        stateMutability: 'view',
        type: 'function',
    },
    {
        inputs: [],
        name: 'currentEpoch',
        outputs: [
            {
                internalType: 'uint256',
                name: '',
                type: 'uint256',
            },
        ],
        stateMutability: 'view',
        type: 'function',
    },
    {
        inputs: [
            {
                internalType: 'uint256',
                name: '',
                type: 'uint256',
            },
        ],
        name: 'currentValidatorSet',
        outputs: [
            {
                internalType: 'address',
                name: '_address',
                type: 'address',
            },
            {
                internalType: 'uint256',
                name: 'votingPower',
                type: 'uint256',
            },
        ],
        stateMutability: 'view',
        type: 'function',
    },
    {
        inputs: [],
        name: 'currentValidatorSetHash',
        outputs: [
            {
                internalType: 'bytes32',
                name: '',
                type: 'bytes32',
            },
        ],
        stateMutability: 'view',
        type: 'function',
    },
    {
        inputs: [],
        name: 'currentValidatorSetLength',
        outputs: [
            {
                internalType: 'uint256',
                name: '',
                type: 'uint256',
            },
        ],
        stateMutability: 'view',
        type: 'function',
    },
    {
        inputs: [
            {
                internalType: 'uint256',
                name: 'blockNumber',
                type: 'uint256',
            },
        ],
        name: 'getCheckpointBlock',
        outputs: [
            {
                internalType: 'bool',
                name: '',
                type: 'bool',
            },
            {
                internalType: 'uint256',
                name: '',
                type: 'uint256',
            },
        ],
        stateMutability: 'view',
        type: 'function',
    },
    {
        inputs: [
            {
                internalType: 'uint256',
                name: 'blockNumber',
                type: 'uint256',
            },
            {
                internalType: 'bytes32',
                name: 'leaf',
                type: 'bytes32',
            },
            {
                internalType: 'uint256',
                name: 'leafIndex',
                type: 'uint256',
            },
            {
                internalType: 'bytes32[]',
                name: 'proof',
                type: 'bytes32[]',
            },
        ],
        name: 'getEventMembershipByBlockNumber',
        outputs: [
            {
                internalType: 'bool',
                name: '',
                type: 'bool',
            },
        ],
        stateMutability: 'view',
        type: 'function',
    },
    {
        inputs: [
            {
                internalType: 'uint256',
                name: 'epoch',
                type: 'uint256',
            },
            {
                internalType: 'bytes32',
                name: 'leaf',
                type: 'bytes32',
            },
            {
                internalType: 'uint256',
                name: 'leafIndex',
                type: 'uint256',
            },
            {
                internalType: 'bytes32[]',
                name: 'proof',
                type: 'bytes32[]',
            },
        ],
        name: 'getEventMembershipByEpoch',
        outputs: [
            {
                internalType: 'bool',
                name: '',
                type: 'bool',
            },
        ],
        stateMutability: 'view',
        type: 'function',
    },
    {
        inputs: [
            {
                internalType: 'uint256',
                name: 'blockNumber',
                type: 'uint256',
            },
        ],
        name: 'getEventRootByBlock',
        outputs: [
            {
                internalType: 'bytes32',
                name: '',
                type: 'bytes32',
            },
        ],
        stateMutability: 'view',
        type: 'function',
    },
    {
        inputs: [
            {
                internalType: 'contract IBLS',
                name: 'newBls',
                type: 'address',
            },
            {
                internalType: 'contract IBN256G2',
                name: 'newBn256G2',
                type: 'address',
            },
            {
                internalType: 'uint256',
                name: 'chainId_',
                type: 'uint256',
            },
            {
                components: [
                    {
                        internalType: 'address',
                        name: '_address',
                        type: 'address',
                    },
                    {
                        internalType: 'uint256[4]',
                        name: 'blsKey',
                        type: 'uint256[4]',
                    },
                    {
                        internalType: 'uint256',
                        name: 'votingPower',
                        type: 'uint256',
                    },
                ],
                internalType: 'struct ICheckpointManager.Validator[]',
                name: 'newValidatorSet',
                type: 'tuple[]',
            },
        ],
        name: 'initialize',
        outputs: [],
        stateMutability: 'nonpayable',
        type: 'function',
    },
    {
        inputs: [
            {
                components: [
                    {
                        internalType: 'bytes32',
                        name: 'blockHash',
                        type: 'bytes32',
                    },
                    {
                        internalType: 'uint256',
                        name: 'blockRound',
                        type: 'uint256',
                    },
                    {
                        internalType: 'bytes32',
                        name: 'currentValidatorSetHash',
                        type: 'bytes32',
                    },
                ],
                internalType: 'struct ICheckpointManager.CheckpointMetadata',
                name: 'checkpointMetadata',
                type: 'tuple',
            },
            {
                components: [
                    {
                        internalType: 'uint256',
                        name: 'epoch',
                        type: 'uint256',
                    },
                    {
                        internalType: 'uint256',
                        name: 'blockNumber',
                        type: 'uint256',
                    },
                    {
                        internalType: 'bytes32',
                        name: 'eventRoot',
                        type: 'bytes32',
                    },
                ],
                internalType: 'struct ICheckpointManager.Checkpoint',
                name: 'checkpoint',
                type: 'tuple',
            },
            {
                internalType: 'uint256[2]',
                name: 'signature',
                type: 'uint256[2]',
            },
            {
                components: [
                    {
                        internalType: 'address',
                        name: '_address',
                        type: 'address',
                    },
                    {
                        internalType: 'uint256[4]',
                        name: 'blsKey',
                        type: 'uint256[4]',
                    },
                    {
                        internalType: 'uint256',
                        name: 'votingPower',
                        type: 'uint256',
                    },
                ],
                internalType: 'struct ICheckpointManager.Validator[]',
                name: 'newValidatorSet',
                type: 'tuple[]',
            },
            {
                internalType: 'bytes',
                name: 'bitmap',
                type: 'bytes',
            },
        ],
        name: 'submit',
        outputs: [],
        stateMutability: 'nonpayable',
        type: 'function',
    },
    {
        inputs: [],
        name: 'totalVotingPower',
        outputs: [
            {
                internalType: 'uint256',
                name: '',
                type: 'uint256',
            },
        ],
        stateMutability: 'view',
        type: 'function',
    },
];

function decodeExtraData(extraData) {
    const decoded = decode(`0x${extraData.substring(66)}`);
    const blockExtraData = {
        validators: decoded[0],
        parent: decoded[1],
        committed: decoded[2],
        checkpoint: {
            blockRound: decoded[3][0],
            epochNumber: parseInt(decoded[3][1], 16),
            currentValidatorHash: decoded[3][2],
            nextValidatorHash: decoded[3][3],
            eventRoot: decoded[3][4],
        },
    };
    return blockExtraData;
}

const L2_STATE_SENDER = [
    {
        anonymous: false,
        inputs: [
            {
                indexed: true,
                internalType: 'uint256',
                name: 'id',
                type: 'uint256',
            },
            {
                indexed: true,
                internalType: 'address',
                name: 'sender',
                type: 'address',
            },
            {
                indexed: true,
                internalType: 'address',
                name: 'receiver',
                type: 'address',
            },
            {
                indexed: false,
                internalType: 'bytes',
                name: 'data',
                type: 'bytes',
            },
        ],
        name: 'L2StateSynced',
        type: 'event',
    },
    {
        inputs: [],
        name: 'MAX_LENGTH',
        outputs: [
            {
                internalType: 'uint256',
                name: '',
                type: 'uint256',
            },
        ],
        stateMutability: 'view',
        type: 'function',
    },
    {
        inputs: [],
        name: 'counter',
        outputs: [
            {
                internalType: 'uint256',
                name: '',
                type: 'uint256',
            },
        ],
        stateMutability: 'view',
        type: 'function',
    },
    {
        inputs: [
            {
                internalType: 'address',
                name: 'receiver',
                type: 'address',
            },
            {
                internalType: 'bytes',
                name: 'data',
                type: 'bytes',
            },
        ],
        name: 'syncState',
        outputs: [],
        stateMutability: 'nonpayable',
        type: 'function',
    },
];

const EXIT_HELPER = [
    {
        anonymous: false,
        inputs: [
            {
                indexed: true,
                internalType: 'uint256',
                name: 'id',
                type: 'uint256',
            },
            {
                indexed: true,
                internalType: 'bool',
                name: 'success',
                type: 'bool',
            },
            {
                indexed: false,
                internalType: 'bytes',
                name: 'returnData',
                type: 'bytes',
            },
        ],
        name: 'ExitProcessed',
        type: 'event',
    },
    {
        anonymous: false,
        inputs: [
            {
                indexed: false,
                internalType: 'uint8',
                name: 'version',
                type: 'uint8',
            },
        ],
        name: 'Initialized',
        type: 'event',
    },
    {
        inputs: [
            {
                components: [
                    {
                        internalType: 'uint256',
                        name: 'blockNumber',
                        type: 'uint256',
                    },
                    {
                        internalType: 'uint256',
                        name: 'leafIndex',
                        type: 'uint256',
                    },
                    {
                        internalType: 'bytes',
                        name: 'unhashedLeaf',
                        type: 'bytes',
                    },
                    {
                        internalType: 'bytes32[]',
                        name: 'proof',
                        type: 'bytes32[]',
                    },
                ],
                internalType: 'struct IExitHelper.BatchExitInput[]',
                name: 'inputs',
                type: 'tuple[]',
            },
        ],
        name: 'batchExit',
        outputs: [],
        stateMutability: 'nonpayable',
        type: 'function',
    },
    {
        inputs: [],
        name: 'checkpointManager',
        outputs: [
            {
                internalType: 'contract ICheckpointManager',
                name: '',
                type: 'address',
            },
        ],
        stateMutability: 'view',
        type: 'function',
    },
    {
        inputs: [
            {
                internalType: 'uint256',
                name: 'blockNumber',
                type: 'uint256',
            },
            {
                internalType: 'uint256',
                name: 'leafIndex',
                type: 'uint256',
            },
            {
                internalType: 'bytes',
                name: 'unhashedLeaf',
                type: 'bytes',
            },
            {
                internalType: 'bytes32[]',
                name: 'proof',
                type: 'bytes32[]',
            },
        ],
        name: 'exit',
        outputs: [],
        stateMutability: 'nonpayable',
        type: 'function',
    },
    {
        inputs: [
            {
                internalType: 'contract ICheckpointManager',
                name: 'newCheckpointManager',
                type: 'address',
            },
        ],
        name: 'initialize',
        outputs: [],
        stateMutability: 'nonpayable',
        type: 'function',
    },
    {
        inputs: [
            {
                internalType: 'uint256',
                name: '',
                type: 'uint256',
            },
        ],
        name: 'processedExits',
        outputs: [
            {
                internalType: 'bool',
                name: '',
                type: 'bool',
            },
        ],
        stateMutability: 'view',
        type: 'function',
    },
];

const CHILD_ERC20 = [
    {
        anonymous: false,
        inputs: [
            {
                indexed: true,
                internalType: 'address',
                name: 'owner',
                type: 'address',
            },
            {
                indexed: true,
                internalType: 'address',
                name: 'spender',
                type: 'address',
            },
            {
                indexed: false,
                internalType: 'uint256',
                name: 'value',
                type: 'uint256',
            },
        ],
        name: 'Approval',
        type: 'event',
    },
    {
        anonymous: false,
        inputs: [
            {
                indexed: false,
                internalType: 'uint8',
                name: 'version',
                type: 'uint8',
            },
        ],
        name: 'Initialized',
        type: 'event',
    },
    {
        anonymous: false,
        inputs: [
            {
                indexed: false,
                internalType: 'address',
                name: 'userAddress',
                type: 'address',
            },
            {
                indexed: false,
                internalType: 'address',
                name: 'relayerAddress',
                type: 'address',
            },
            {
                indexed: false,
                internalType: 'bytes',
                name: 'functionSignature',
                type: 'bytes',
            },
        ],
        name: 'MetaTransactionExecuted',
        type: 'event',
    },
    {
        anonymous: false,
        inputs: [
            {
                indexed: true,
                internalType: 'address',
                name: 'from',
                type: 'address',
            },
            {
                indexed: true,
                internalType: 'address',
                name: 'to',
                type: 'address',
            },
            {
                indexed: false,
                internalType: 'uint256',
                name: 'value',
                type: 'uint256',
            },
        ],
        name: 'Transfer',
        type: 'event',
    },
    {
        inputs: [
            {
                internalType: 'address',
                name: 'owner',
                type: 'address',
            },
            {
                internalType: 'address',
                name: 'spender',
                type: 'address',
            },
        ],
        name: 'allowance',
        outputs: [
            {
                internalType: 'uint256',
                name: '',
                type: 'uint256',
            },
        ],
        stateMutability: 'view',
        type: 'function',
    },
    {
        inputs: [
            {
                internalType: 'address',
                name: 'spender',
                type: 'address',
            },
            {
                internalType: 'uint256',
                name: 'amount',
                type: 'uint256',
            },
        ],
        name: 'approve',
        outputs: [
            {
                internalType: 'bool',
                name: '',
                type: 'bool',
            },
        ],
        stateMutability: 'nonpayable',
        type: 'function',
    },
    {
        inputs: [
            {
                internalType: 'address',
                name: 'account',
                type: 'address',
            },
        ],
        name: 'balanceOf',
        outputs: [
            {
                internalType: 'uint256',
                name: '',
                type: 'uint256',
            },
        ],
        stateMutability: 'view',
        type: 'function',
    },
    {
        inputs: [
            {
                internalType: 'address',
                name: 'account',
                type: 'address',
            },
            {
                internalType: 'uint256',
                name: 'amount',
                type: 'uint256',
            },
        ],
        name: 'burn',
        outputs: [
            {
                internalType: 'bool',
                name: '',
                type: 'bool',
            },
        ],
        stateMutability: 'nonpayable',
        type: 'function',
    },
    {
        inputs: [],
        name: 'decimals',
        outputs: [
            {
                internalType: 'uint8',
                name: '',
                type: 'uint8',
            },
        ],
        stateMutability: 'view',
        type: 'function',
    },
    {
        inputs: [
            {
                internalType: 'address',
                name: 'spender',
                type: 'address',
            },
            {
                internalType: 'uint256',
                name: 'subtractedValue',
                type: 'uint256',
            },
        ],
        name: 'decreaseAllowance',
        outputs: [
            {
                internalType: 'bool',
                name: '',
                type: 'bool',
            },
        ],
        stateMutability: 'nonpayable',
        type: 'function',
    },
    {
        inputs: [
            {
                internalType: 'address',
                name: 'userAddress',
                type: 'address',
            },
            {
                internalType: 'bytes',
                name: 'functionSignature',
                type: 'bytes',
            },
            {
                internalType: 'bytes32',
                name: 'sigR',
                type: 'bytes32',
            },
            {
                internalType: 'bytes32',
                name: 'sigS',
                type: 'bytes32',
            },
            {
                internalType: 'uint8',
                name: 'sigV',
                type: 'uint8',
            },
        ],
        name: 'executeMetaTransaction',
        outputs: [
            {
                internalType: 'bytes',
                name: '',
                type: 'bytes',
            },
        ],
        stateMutability: 'nonpayable',
        type: 'function',
    },
    {
        inputs: [
            {
                internalType: 'address',
                name: 'user',
                type: 'address',
            },
        ],
        name: 'getNonce',
        outputs: [
            {
                internalType: 'uint256',
                name: 'nonce',
                type: 'uint256',
            },
        ],
        stateMutability: 'view',
        type: 'function',
    },
    {
        inputs: [
            {
                internalType: 'address',
                name: 'spender',
                type: 'address',
            },
            {
                internalType: 'uint256',
                name: 'addedValue',
                type: 'uint256',
            },
        ],
        name: 'increaseAllowance',
        outputs: [
            {
                internalType: 'bool',
                name: '',
                type: 'bool',
            },
        ],
        stateMutability: 'nonpayable',
        type: 'function',
    },
    {
        inputs: [
            {
                internalType: 'address',
                name: 'rootToken_',
                type: 'address',
            },
            {
                internalType: 'string',
                name: 'name_',
                type: 'string',
            },
            {
                internalType: 'string',
                name: 'symbol_',
                type: 'string',
            },
            {
                internalType: 'uint8',
                name: 'decimals_',
                type: 'uint8',
            },
        ],
        name: 'initialize',
        outputs: [],
        stateMutability: 'nonpayable',
        type: 'function',
    },
    {
        inputs: [
            {
                internalType: 'uint256',
                name: 'offset',
                type: 'uint256',
            },
        ],
        name: 'invalidateNext',
        outputs: [],
        stateMutability: 'nonpayable',
        type: 'function',
    },
    {
        inputs: [
            {
                internalType: 'address',
                name: 'account',
                type: 'address',
            },
            {
                internalType: 'uint256',
                name: 'amount',
                type: 'uint256',
            },
        ],
        name: 'mint',
        outputs: [
            {
                internalType: 'bool',
                name: '',
                type: 'bool',
            },
        ],
        stateMutability: 'nonpayable',
        type: 'function',
    },
    {
        inputs: [],
        name: 'name',
        outputs: [
            {
                internalType: 'string',
                name: '',
                type: 'string',
            },
        ],
        stateMutability: 'view',
        type: 'function',
    },
    {
        inputs: [],
        name: 'predicate',
        outputs: [
            {
                internalType: 'address',
                name: '',
                type: 'address',
            },
        ],
        stateMutability: 'view',
        type: 'function',
    },
    {
        inputs: [],
        name: 'rootToken',
        outputs: [
            {
                internalType: 'address',
                name: '',
                type: 'address',
            },
        ],
        stateMutability: 'view',
        type: 'function',
    },
    {
        inputs: [],
        name: 'symbol',
        outputs: [
            {
                internalType: 'string',
                name: '',
                type: 'string',
            },
        ],
        stateMutability: 'view',
        type: 'function',
    },
    {
        inputs: [],
        name: 'totalSupply',
        outputs: [
            {
                internalType: 'uint256',
                name: '',
                type: 'uint256',
            },
        ],
        stateMutability: 'view',
        type: 'function',
    },
    {
        inputs: [
            {
                internalType: 'address',
                name: 'to',
                type: 'address',
            },
            {
                internalType: 'uint256',
                name: 'amount',
                type: 'uint256',
            },
        ],
        name: 'transfer',
        outputs: [
            {
                internalType: 'bool',
                name: '',
                type: 'bool',
            },
        ],
        stateMutability: 'nonpayable',
        type: 'function',
    },
    {
        inputs: [
            {
                internalType: 'address',
                name: 'from',
                type: 'address',
            },
            {
                internalType: 'address',
                name: 'to',
                type: 'address',
            },
            {
                internalType: 'uint256',
                name: 'amount',
                type: 'uint256',
            },
        ],
        name: 'transferFrom',
        outputs: [
            {
                internalType: 'bool',
                name: '',
                type: 'bool',
            },
        ],
        stateMutability: 'nonpayable',
        type: 'function',
    },
];

/**
 * Represents a token bridge, which manages asset transfers between two chains.
 */
class TokenBridge {
    /**
     * @property {BridgeConfiguration} config - The bridge configuration object.
     */
    config;
    /**
     * Constructs a TokenBridge instance.
     *
     * @param {BridgeConfiguration} config - The bridge configuration object.
     */
    constructor(config) {
        this.config = config;
    }
    /**
     * Retrieves the bridge fee for depositing a specific token, used to reimburse the bridge-relayer.
     * It is clipped from the deposit amount.
     *
     * @param {BridgeFeeRequest} req - The fee request object containing the token address for which the fee is required.
     * @returns {Promise<BridgeFeeResponse>} - A promise that resolves to an object containing the bridge fee for the specified
     * token and a flag indicating if the token is bridgeable.
     * @throws {BridgeError} - If an error occurs during the fee retrieval, a BridgeError will be thrown with a specific error type.
     *
     * Possible BridgeError types include:
     * - INVALID_ADDRESS: The token address provided in the request is invalid.
     *
     * @example
     * const feeRequest = {
     *   token: '0x123456...', // token
     * };
     *
     * @example
     * const feeRequest = {
     *   token: 'NATIVE', // token
     * };
     *
     * bridgeSdk.getFee(feeRequest)
     *   .then((feeResponse) => {
     *     console.log('Bridgeable:', feeResponse.bridgeable);
     *     console.log('Fee Amount:', feeResponse.feeAmount.toString());
     *   })
     *   .catch((error) => {
     *     console.error('Error:', error.message);
     *   });
     */
    async getFee(req) {
        this.validateChainConfiguration();
        if (req.token !== 'NATIVE' && !isAddress(req.token)) {
            throw new BridgeError(`token address ${req.token} is not a valid address`, BridgeErrorType.INVALID_ADDRESS);
        }
        return {
            bridgeable: true,
            feeAmount: BigNumber.from(0),
        };
    }
    /**
     * Retrieves the unsigned approval transaction for a deposit to the bridge.
     * Approval is required before depositing tokens to the bridge using
     *
     * @param {ApproveBridgeRequest} req - The approve bridge request object containing the depositor address,
     * token address, and deposit amount.
     * @returns {Promise<ApproveBridgeResponse>} - A promise that resolves to an object containing the unsigned
     * approval transaction and a flag indicating if the approval is required.
     * @throws {BridgeError} - If an error occurs during the transaction creation, a BridgeError will be thrown with a specific error type.
     *
     * Possible BridgeError types include:
     * - UNSUPPORTED_ERROR: The operation is not supported. Currently thrown when attempting to deposit native tokens.
     * - INVALID_ADDRESS: An Ethereum address provided in the request is invalid.
     * - INVALID_AMOUNT: The deposit amount provided in the request is invalid (less than or equal to 0).
     * - INTERNAL_ERROR: An unexpected error occurred during the execution, likely due to the bridge SDK implementation.
     * - PROVIDER_ERROR: An error occurred while interacting with the Ethereum provider. This includes issues calling the ERC20 smart contract
     *
     * @example
     * const approveRequest = {
     *   depositorAddress: '0x123456...', // Depositor's Ethereum address
     *   token: '0xabcdef...', // ERC20 token address
     *   depositAmount: ethers.utils.parseUnits('100', 18), // Deposit amount in token's smallest unit (e.g., wei for Ether)
     * };
     *
     * bridgeSdk.getUnsignedApproveDepositBridgeTx(approveRequest)
     *   .then((approveResponse) => {
     *     if (approveResponse.unsignedTx) {
     *       // Send the unsigned approval transaction to the depositor to sign and send
     *     } else {
     *      // No approval is required
     *     }
     *   })
     *   .catch((error) => {
     *     console.error('Error:', error.message);
     *   });
     */
    async getUnsignedApproveDepositBridgeTx(req) {
        this.validateChainConfiguration();
        TokenBridge.validateDepositArgs(req.depositorAddress, req.depositAmount, req.token);
        // If the token is NATIVE, no approval is required
        if (req.token === 'NATIVE') {
            return {
                unsignedTx: null,
            };
        }
        const erc20Contract = await withBridgeError(async () => new Contract(req.token, ERC20, this.config.rootProvider), BridgeErrorType.PROVIDER_ERROR);
        // Get the current approved allowance of the RootERC20Predicate
        const rootERC20PredicateAllowance = await withBridgeError(() => erc20Contract
            .allowance(req.depositorAddress, this.config.bridgeContracts.rootChainERC20Predicate), BridgeErrorType.PROVIDER_ERROR);
        // If the allowance is greater than or equal to the deposit amount, no approval is required
        if (rootERC20PredicateAllowance.gte(req.depositAmount)) {
            return {
                unsignedTx: null,
            };
        }
        // Calculate the amount of tokens that need to be approved for deposit
        const approvalAmountRequired = req.depositAmount.sub(rootERC20PredicateAllowance);
        // Encode the approve function call data for the ERC20 contract
        const data = await withBridgeError(async () => erc20Contract.interface
            .encodeFunctionData('approve', [
            this.config.bridgeContracts.rootChainERC20Predicate,
            approvalAmountRequired,
        ]), BridgeErrorType.INTERNAL_ERROR);
        // Create the unsigned transaction for the approval
        const unsignedTx = {
            data,
            to: req.token,
            value: 0,
            from: req.depositorAddress,
        };
        return {
            unsignedTx,
        };
    }
    /**
     * Generates an unsigned deposit transaction for a user to sign and submit to the bridge.
     * Must be called after bridgeSdk.getUnsignedApproveDepositBridgeTx to ensure user has approved sufficient tokens for deposit.
     *
     * @param {BridgeDepositRequest} req - The deposit request object containing the required data for depositing tokens.
     * @returns {Promise<BridgeDepositResponse>} - A promise that resolves to an object containing the unsigned transaction data.
     * @throws {BridgeError} - If an error occurs during the generation of the unsigned transaction, a BridgeError
     * will be thrown with a specific error type.
     *
     * Possible BridgeError types include:
     * - UNSUPPORTED_ERROR: The operation is not supported. Currently thrown when attempting to deposit native tokens.
     * - INVALID_ADDRESS: An Ethereum address provided in the request is invalid. This could be the depositor's,
     * recipient's or the token's address.
     * - INVALID_AMOUNT: The deposit amount provided in the request is invalid (less than or equal to 0).
     * - INTERNAL_ERROR: An unexpected error occurred during the execution, likely due to the bridge SDK implementation.
     *
     * @example
     * const depositERC20Request = {
     *   token: '0x123456...', // ERC20 token address
     *   depositorAddress: '0xabcdef...', // User's wallet address
     *   recipientAddress: '0x987654...', // Destination wallet address on the target chain
     *   depositAmount: ethers.utils.parseUnits('100', 18), // Deposit amount in wei
     * };
     *
     * @example
     * const depositEtherTokenRequest = {
     *   token: 'NATIVE',
     *   depositorAddress: '0xabcdef...', // User's wallet address
     *   recipientAddress: '0x987654...', // Destination wallet address on the target chain
     *   depositAmount: ethers.utils.parseUnits('100', 18), // Deposit amount in wei
     * };
     *
     * bridgeSdk.getUnsignedDepositTx(depositRequest)
     *   .then((depositResponse) => {
     *     console.log(depositResponse.unsignedTx);
     *   })
     *   .catch((error) => {
     *     console.error('Error:', error.message);
     *   });
     */
    async getUnsignedDepositTx(req) {
        this.validateChainConfiguration();
        TokenBridge.validateDepositArgs(req.recipientAddress, req.depositAmount, req.token);
        const rootERC20PredicateContract = await withBridgeError(async () => {
            const contract = new Contract(this.config.bridgeContracts.rootChainERC20Predicate, ROOT_ERC20_PREDICATE);
            return contract;
        }, BridgeErrorType.INTERNAL_ERROR);
        // Convert the addresses to correct format addresses (e.g. prepend 0x if not already)
        const receipient = getAddress(req.recipientAddress);
        // Handle return if it is a native token
        if (req.token === 'NATIVE') {
            // Encode the function data into a payload
            const data = await withBridgeError(async () => rootERC20PredicateContract.interface.encodeFunctionData('depositNativeTo', [receipient]), BridgeErrorType.INTERNAL_ERROR);
            return {
                unsignedTx: {
                    data,
                    to: this.config.bridgeContracts.rootChainERC20Predicate,
                    value: req.depositAmount,
                },
            };
        }
        // Handle return for ERC20
        const token = getAddress(req.token);
        // Encode the function data into a payload
        const data = await withBridgeError(async () => rootERC20PredicateContract.interface.encodeFunctionData('depositTo', [token, receipient, req.depositAmount]), BridgeErrorType.INTERNAL_ERROR);
        return {
            unsignedTx: {
                data,
                to: this.config.bridgeContracts.rootChainERC20Predicate,
                value: 0,
            },
        };
    }
    /**
     * Waits for the deposit transaction to be confirmed and synced from the root chain to the child chain.
     *
     * @param {WaitForDepositRequest} req - The wait for request object containing the transaction hash.
     * @returns {Promise<WaitForDepositResponse>} - A promise that resolves to an object containing the status of the deposit transaction.
     * @throws {BridgeError} - If an error occurs during the transaction confirmation or state sync, a BridgeError will be
     * thrown with a specific error type.
     *
     * Possible BridgeError types include:
     * - PROVIDER_ERROR: An error occurred with the Ethereum provider during transaction confirmation or state synchronization.
     * - TRANSACTION_REVERTED: The transaction on the root chain was reverted.
     *
     * @example
     * const waitForRequest = {
     *   transactionHash: '0x123456...', // Deposit transaction hash on the root chain
     * };
     *
     * bridgeSdk.waitForDeposit(waitForRequest)
     *   .then((waitForResponse) => {
     *     console.log('Deposit Transaction Status:', waitForResponse.status);
     *   })
     *   .catch((error) => {
     *     console.error('Error:', error.message);
     *   });
     */
    async waitForDeposit(req) {
        this.validateChainConfiguration();
        const rootTxReceipt = await withBridgeError(async () => this.config.rootProvider.waitForTransaction(req.transactionHash, this.config.rootChainFinalityBlocks), BridgeErrorType.PROVIDER_ERROR);
        // Throw an error if the transaction was reverted
        if (rootTxReceipt.status !== 1) {
            throw new BridgeError(`${rootTxReceipt.transactionHash} on rootchain was reverted`, BridgeErrorType.TRANSACTION_REVERTED);
        }
        // Get the state sync ID from the transaction receipt
        const stateSyncID = await withBridgeError(async () => this.getRootStateSyncID(rootTxReceipt), BridgeErrorType.PROVIDER_ERROR);
        // Get the block for the timestamp
        const rootBlock = await withBridgeError(async () => await this.config.rootProvider.getBlock(rootTxReceipt.blockNumber), BridgeErrorType.PROVIDER_ERROR, `failed to query block ${rootTxReceipt.blockNumber} on rootchain`);
        // Get the minimum block on childchain which corresponds with the timestamp on rootchain
        const minBlockRange = await withBridgeError(async () => getBlockNumberClosestToTimestamp(this.config.childProvider, rootBlock.timestamp, this.config.blockTime, this.config.clockInaccuracy), BridgeErrorType.PROVIDER_ERROR);
        // Get the upper bound for which we expect the StateSync event to occur
        const maxBlockRange = minBlockRange + this.config.maxDepositBlockDelay;
        // Poll till event observed
        const result = await withBridgeError(async () => this.waitForChildStateSync(stateSyncID, this.config.pollInterval, minBlockRange, maxBlockRange), BridgeErrorType.PROVIDER_ERROR);
        return {
            status: result,
        };
    }
    /**
   * Retrieves the corresponding child token address for a given root token address.
   * This function is used to map a root token to its child token in the context of a bridging system between chains.
   * If the token is native, a special key is used to represent it.
   *
   * @param {ChildTokenRequest} req - The request object containing the root token address or the string 'NATIVE'.
   * @returns {Promise<ChildTokenResponse>} - A promise that resolves to an object containing the child token address.
   * @throws {BridgeError} - If an error occurs during the query, a BridgeError will be thrown with a specific error type.
   *
   * Possible BridgeError types include:
   * - INVALID_ADDRESS: If the Ethereum address provided in the request is invalid.
   * - PROVIDER_ERROR: If there's an error in querying the getChildToken mapping.
   * - INTERNAL_ERROR: An unexpected error occurred during the execution.
   *
   * @example
   * const request = {
   *   rootToken: '0x123456...', // Root token address or 'NATIVE'
   * };
   *
   * bridgeSdk.getChildToken(request)
   *   .then((response) => {
   *     console.log(response.childToken); // Child token address
   *   })
   *   .catch((error) => {
   *     console.error('Error:', error.message);
   *   });
   */
    async getChildToken(req) {
        // Validate the chain configuration to ensure proper setup
        this.validateChainConfiguration();
        // If the root token is native, use the native token key; otherwise, use the provided root token address
        const reqTokenAddress = (req.rootToken === 'NATIVE') ? NATIVE_TOKEN_BRIDGE_KEY : req.rootToken;
        // Validate the request token address
        if (!isAddress(reqTokenAddress)) {
            throw new BridgeError(`token address ${reqTokenAddress} is not a valid address`, BridgeErrorType.INVALID_ADDRESS);
        }
        // Create an instance of the root ERC20 predicate contract
        const childTokenAddress = await withBridgeError(async () => {
            const rootERC20Predicate = new Contract(this.config.bridgeContracts.rootChainERC20Predicate, ROOT_ERC20_PREDICATE, this.config.rootProvider);
            return await rootERC20Predicate.rootTokenToChildToken(reqTokenAddress);
        }, BridgeErrorType.PROVIDER_ERROR, 'failed to query rootTokenToChildToken mapping');
        // Return the child token address
        return {
            childToken: childTokenAddress,
        };
    }
    /**
   * Retrieves the corresponding root token address for a given child token address.
   * This function is used to map a child token back to its root token in the context of a bridging system between chains.
   *
   * If the root token address matches the address designated for the native token, the method will return 'NATIVE'.
   *
   * @param {RootTokenRequest} req - The request object containing the child token address.
   * @returns {Promise<RootTokenResponse>} - A promise that resolves to an object containing the root token address.
   * @throws {BridgeError} - If an error occurs during the query, a BridgeError will be thrown with a specific error type.
   *
   * Possible BridgeError types include:
   * - PROVIDER_ERROR: If there's an error in querying the root token from the child token contract.
   * - INVALID_TOKEN: If the token being withdrawed is not a valid bridgeable token
   *
   * @example
   * const request = {
   *   childToken: '0x123456...', // Child token address
   * };
   *
   * bridgeSdk.getRootToken(request)
   *   .then((response) => {
   *     console.log(response.rootToken); // Outputs: 'NATIVE' or Root token address
   *   })
   *   .catch((error) => {
   *     console.error('Error:', error.message);
   *   });
   */
    async getRootToken(req) {
        // Validate the chain configuration to ensure proper setup
        this.validateChainConfiguration();
        // Query the corresponding root token address using the child token contract
        const rootToken = await withBridgeError(async () => {
            // Create an instance of the child token contract using the given child token address
            const childToken = new Contract(req.childToken, CHILD_ERC20, this.config.childProvider);
            return await childToken.rootToken();
        }, BridgeErrorType.PROVIDER_ERROR, 'failed to query the root token from the child token contract');
        // Check if the rootToken address is the designated native token address.
        // If it is, return 'NATIVE'. Else, return the root token address.
        return {
            rootToken: (rootToken === NATIVE_TOKEN_BRIDGE_KEY) ? 'NATIVE' : rootToken,
        };
    }
    /**
     * Generates an unsigned transaction that a user can use to initiate a token withdrawal from the bridge.
     * The user must sign and submit this transaction to execute the withdrawal.
     *
     * @param {BridgeWithdrawRequest} req - The withdrawal request object containing the necessary data for withdrawing tokens.
     * @returns {Promise<BridgeWithdrawResponse>} - A promise that resolves to an object containing the unsigned transaction data.
     *
     * @throws {BridgeError} - If an error occurs during the generation of the unsigned transaction,
     * a BridgeError will be thrown with a specific error type.
     * Possible BridgeError types include:
     * - INVALID_ADDRESS: The Ethereum address provided in the request is invalid. This could be the user's address or the token's address.
     * - INVALID_AMOUNT: The withdrawal amount provided in the request is invalid (less than or equal to 0).
     * - PROVIDER_ERROR: An error occurred when interacting with the Ethereum provider, likely due to a network or connectivity issue.
     * - INTERNAL_ERROR: An unexpected error occurred during the execution, likely due to the bridge SDK implementation.
     *
     * @example
     * const withdrawRequest = {
     *   token: '0x123456...', // ERC20 token address
     *   recipientAddress: '0xabcdef...', // Address to receive the withdrawn tokens
     *   withdrawAmount: ethers.utils.parseUnits('100', 18), // Withdraw amount in wei
     * };
     *
     * bridgeSdk.getUnsignedWithdrawTx(withdrawRequest)
     *   .then((withdrawalResponse) => {
     *     console.log(withdrawalResponse.unsignedTx);
     *   })
     *   .catch((error) => {
     *     console.error('Error:', error.message);
     *   });
     */
    async getUnsignedWithdrawTx(req) {
        // Ensure the configuration of chains is valid.
        this.validateChainConfiguration();
        // Validate the recipient address, withdrawal amount, and token.
        TokenBridge.validateWithdrawArgs(req.recipientAddress, req.withdrawAmount, req.token);
        // Create a contract instance for interacting with the ChildERC20Predicate
        const childERC20PredicateContract = await withBridgeError(async () => {
            const contract = new Contract(this.config.bridgeContracts.childChainERC20Predicate, CHILD_ERC20_PREDICATE);
            return contract;
        }, BridgeErrorType.INTERNAL_ERROR);
        // Encode the withdrawTo function call data for the ERC20 contract
        const data = await withBridgeError(async () => childERC20PredicateContract.interface
            .encodeFunctionData('withdrawTo', [
            req.token,
            req.recipientAddress,
            req.withdrawAmount,
        ]), BridgeErrorType.INTERNAL_ERROR);
        // Construct the unsigned transaction for the withdrawal
        return {
            unsignedTx: {
                data,
                to: this.config.bridgeContracts.childChainERC20Predicate,
                value: 0,
            },
        };
    }
    /**
     * Waits for the withdrawal transaction to be confirmed in the root chain by continuously
     * polling until the transaction is included in a checkpoint.
     * This function is intended to be used after executing a withdrawal transaction.
     *
     * @param {WaitForWithdrawalRequest} req - The request object containing the transaction hash of the withdrawal transaction.
     * @returns {Promise<WaitForWithdrawalResponse>} - A promise that resolves to an empty object once the withdrawal
     * transaction has been confirmed in the root chain.
     *
     * @throws {BridgeError} - If an error occurs during the waiting process, a BridgeError will be thrown with a specific error type.
     * Possible BridgeError types include:
     * - PROVIDER_ERROR: An error occurred when interacting with the Ethereum provider, likely due to a network or connectivity issue.
     *
     * @example
     * const waitForWithdrawalRequest = {
     *   transactionHash: '0x123456...', // Transaction hash of the withdrawal transaction
     * };
     *
     * bridgeSdk.waitForWithdrawal(waitForWithdrawalRequest)
     *   .then(() => {
     *     console.log('Withdrawal transaction has been confirmed in the root chain.');
     *   })
     *   .catch((error) => {
     *     console.error('Error:', error.message);
     *   });
     */
    async waitForWithdrawal(req) {
        // Ensure the configuration of chains is valid.
        this.validateChainConfiguration();
        // Helper function to pause execution for a specified interval
        const pause = () => new Promise((resolve) => {
            setTimeout(resolve, this.config.pollInterval);
        });
        await withBridgeError(async () => {
            // Fetch the receipt of the withdrawal transaction
            const transactionReceipt = await this.config.childProvider.getTransactionReceipt(req.transactionHash);
            // Fetch the block in which the withdrawal transaction was included
            const block = await this.config.childProvider.getBlock(transactionReceipt.blockNumber);
            // Decode the extra data field from the block header
            const decodedExtraData = decodeExtraData(block.extraData);
            // Instantiate the checkpoint manager contract
            const checkpointManager = new Contract(this.config.bridgeContracts.rootChainCheckpointManager, CHECKPOINT_MANAGER, this.config.rootProvider);
            // Recursive function to keep checking for the child deposit event
            const waitForRootEpoch = async () => {
                // Fetch the current checkpoint epoch from the root chain
                const currentEpoch = await checkpointManager.currentEpoch();
                // If the current epoch is greater than or equal to the epoch number of the checkpoint in which
                // the withdrawal transaction was included, the withdrawal has been confirmed in the root chain
                if (currentEpoch >= decodedExtraData.checkpoint.epochNumber) {
                    return null;
                }
                // Pause execution for a specified interval before checking again
                await pause();
                // Recursive call
                return waitForRootEpoch();
            };
            // Start waiting for the withdrawal transaction to be confirmed in the root chain
            await waitForRootEpoch();
        }, BridgeErrorType.PROVIDER_ERROR);
        // Return an empty object once the withdrawal transaction has been confirmed in the root chain
        return {};
    }
    /**
     * Creates an unsigned exit transaction which, when executed, will exit the assets from the child chain to the root chain.
     * This function should be used after a withdraw transaction has been executed on the child chain.
     * It should only be executed after `waitForWithdrawal` has completed successfully.
     *
     * @param {ExitRequest} req - The request object containing the transaction hash of the withdraw transaction.
     * @returns {Promise<ExitResponse>} - A promise that resolves to an object containing the unsigned exit transaction.
     *
     * @throws {BridgeError} - If an error occurs during the exit transaction creation process,
     * a BridgeError will be thrown with a specific error type.
     * Possible BridgeError types include:
     * - PROVIDER_ERROR: An error occurred when interacting with the Ethereum provider, likely due to a network or connectivity issue.
     * - INVALID_TRANSACTION: The deposit transaction is invalid or the L2StateSynced event log does not match the expected format.
     * - INTERNAL_ERROR: An internal error occurred during the function call encoding process.
     *
     * @example
     * const exitRequest = {
     *   transactionHash: '0x123456...', // Transaction hash of the deposit transaction
     * };
     *
     * bridgeSdk.getUnsignedExitTx(exitRequest)
     *   .then((response) => {
     *     console.log('Unsigned exit transaction:', response.unsignedTx);
     *   })
     *   .catch((error) => {
     *     console.error('Error:', error.message);
     *   });
     */
    async getUnsignedExitTx(req) {
        // Ensure the configuration of chains is valid
        this.validateChainConfiguration();
        // Fetch the receipt of the deposit transaction
        const txReceipt = await withBridgeError(async () => await this.config.childProvider.getTransactionReceipt(req.transactionHash), BridgeErrorType.PROVIDER_ERROR);
        // Filter out the StateSynced event log from the transaction receipt
        const stateSenderLogs = txReceipt.logs.filter((log) => log.address.toLowerCase() === L2_STATE_SENDER_ADDRESS);
        if (stateSenderLogs.length !== 1) {
            throw new BridgeError(`expected 1 log in tx ${txReceipt.transactionHash} from address ${L2_STATE_SENDER_ADDRESS}`, BridgeErrorType.INVALID_TRANSACTION);
        }
        // Parse the StateSynced event log
        const l2StateSyncEvent = await withBridgeError(async () => {
            const l2StateSenderInterface = new Interface(L2_STATE_SENDER);
            const event = l2StateSenderInterface.parseLog(stateSenderLogs[0]);
            // Throw an error if the event log doesn't match the expected format
            if (event.signature !== 'L2StateSynced(uint256,address,address,bytes)') {
                throw new Error(`expected L2StateSynced event in tx ${txReceipt.transactionHash}`);
            }
            return event;
        }, BridgeErrorType.INVALID_TRANSACTION);
        // Instantiate the exit helper contract
        const exitHelper = await withBridgeError(async () => new Contract(this.config.bridgeContracts.rootChainExitHelper, EXIT_HELPER, this.config.rootProvider), BridgeErrorType.PROVIDER_ERROR);
        // Generate the exit proof
        const exitProof = await withBridgeError(async () => this.config.childProvider
            .send('bridge_generateExitProof', [l2StateSyncEvent.args.id.toHexString()]), BridgeErrorType.PROVIDER_ERROR);
        // Encode the exit function call data
        const encodedExitTx = await withBridgeError(async () => {
            const exitEventEncoded = defaultAbiCoder.encode(['uint256', 'address', 'address', 'bytes'], l2StateSyncEvent.args);
            return exitHelper.interface.encodeFunctionData('exit', [exitProof.Metadata.CheckpointBlock, exitProof.Metadata.LeafIndex, exitEventEncoded, exitProof.Data]);
        }, BridgeErrorType.INTERNAL_ERROR);
        // Create the unsigned exit transaction
        const unsignedTx = {
            data: encodedExitTx,
            to: this.config.bridgeContracts.rootChainExitHelper,
            value: 0,
        };
        // Return the unsigned exit transaction
        return { unsignedTx };
    }
    async waitForChildStateSync(stateSyncID, interval, minBlockRange, maxBlockRange) {
        // Initialize the child state receiver contract
        const childStateReceiver = new Contract(this.config.bridgeContracts.childChainStateReceiver, CHILD_STATE_RECEIVER, this.config.childProvider);
        // Create an event filter for the StateSyncResult event emitted by the contract
        // This will be used to listen for specific instances of the event where the stateSyncID matches our expected ID
        const eventFilter = childStateReceiver.filters.StateSyncResult(stateSyncID, null, null);
        // Define a helper function that queries the blockchain for the StateSyncResult events that match our filter
        // This function scans the block range from minBlockRange to maxBlockRange
        const getEventsWithStateSyncID = async () => childStateReceiver
            .queryFilter(eventFilter, minBlockRange, maxBlockRange);
        // Define a helper function that pauses execution of our program for a certain interval (in milliseconds)
        // This is used to wait between checks for the StateSyncResult event on the blockchain
        const pause = () => new Promise((resolve) => {
            setTimeout(resolve, interval);
        });
        // Define a recursive function that keeps checking the blockchain for our specific StateSyncResult event
        // It calls the helper function getEventsWithStateSyncID() to get the list of matching events
        // If it finds more than one matching event, it throws an error because we only expect one event with our specific stateSyncID
        // If it finds exactly one matching event, it returns that event
        // If it doesn't find any matching event, it waits for a while (using the pause() function) and then checks again (recursive call)
        const checkForChildDepositEvent = async () => {
            const events = await getEventsWithStateSyncID();
            if (events.length > 1) {
                throw new Error(`expected maximum of 1 events with statesync id ${stateSyncID} but found ${events.length}`);
            }
            if (events.length === 1) {
                return events[0];
            }
            // Pause execution for a specified interval before checking again
            await pause();
            // Recursive call
            return checkForChildDepositEvent();
        };
        // Call our recursive function and wait for it to find the StateSyncResult event
        const childDepositEvent = await checkForChildDepositEvent();
        // Perform some error checking on the event:
        // - If there's no event, throw an error
        // - If the event doesn't have arguments, throw an error
        // - If the event's arguments don't include a status, throw an error
        if (!childDepositEvent)
            throw new Error('failed to find child deposit event');
        if (!childDepositEvent.args)
            throw new Error('child deposit event has no args');
        if (childDepositEvent.args.status == null)
            throw new Error('child deposit event has no status');
        // If the event's status argument is present, we consider that the state sync operation was successful
        if (childDepositEvent.args.status) {
            return CompletionStatus.SUCCESS;
        }
        // If not, we consider that the operation failed
        return CompletionStatus.FAILED;
    }
    async getRootStateSyncID(txReceipt) {
        const stateSenderInterface = new Interface(ROOT_STATE_SENDER);
        // Get the StateSynced event log from the transaction receipt
        const stateSenderLogs = txReceipt
            .logs
            .filter((log) => log.address.toLowerCase() === this.config.bridgeContracts.rootChainStateSender.toLowerCase());
        if (stateSenderLogs.length !== 1) {
            throw new Error(`expected at least 1 log in tx ${txReceipt.transactionHash}`);
        }
        const stateSyncEvent = stateSenderInterface.parseLog(stateSenderLogs[0]);
        // Throw an error if the event log doesn't match the expected format
        if (stateSyncEvent.signature !== 'StateSynced(uint256,address,address,bytes)') {
            throw new Error(`expected state sync event in tx ${txReceipt.transactionHash}`);
        }
        // Return the state sync ID as a number
        return parseInt(stateSyncEvent.args.id, 10);
    }
    static validateDepositArgs(depositorOrRecipientAddress, depositAmount, token) {
        if (!isAddress(depositorOrRecipientAddress)) {
            throw new BridgeError(`address ${depositorOrRecipientAddress} is not a valid address`, BridgeErrorType.INVALID_ADDRESS);
        }
        // The deposit amount cannot be <= 0
        if (depositAmount.isNegative() || depositAmount.isZero()) {
            throw new BridgeError(`deposit amount ${depositAmount.toString()} is invalid`, BridgeErrorType.INVALID_AMOUNT);
        }
        // If the token is not native, it must be a valid address
        if (token !== 'NATIVE' && !isAddress(token)) {
            throw new BridgeError(`token address ${token} is not a valid address`, BridgeErrorType.INVALID_ADDRESS);
        }
    }
    static validateWithdrawArgs(withdrawerOrRecipientAddress, withdrawAmount, token) {
        // Validate the withdrawer address
        if (!isAddress(withdrawerOrRecipientAddress)) {
            throw new BridgeError(`withdrawer address ${withdrawerOrRecipientAddress} is not a valid address`, BridgeErrorType.INVALID_ADDRESS);
        }
        // Validate the withdrawal amount. It cannot be zero or negative.
        if (withdrawAmount.isNegative() || withdrawAmount.isZero()) {
            throw new BridgeError(`withdraw amount ${withdrawAmount.toString()} is invalid`, BridgeErrorType.INVALID_AMOUNT);
        }
        // Check if the ERC20 Token is a valid address
        if (!isAddress(token)) {
            throw new BridgeError(`token address ${token} is not a valid address`, BridgeErrorType.INVALID_ADDRESS);
        }
    }
    // Query the rootchain and childchain providers to ensure the chainID is as expected by the SDK.
    // This is to prevent the SDK from being used on the wrong chain, especially after a chain reset.
    async validateChainConfiguration() {
        const errMessage = 'Please upgrade to the latest version of the Bridge SDK or provide valid configuration';
        const rootNetwork = await withBridgeError(async () => this.config.rootProvider.getNetwork(), BridgeErrorType.PROVIDER_ERROR);
        if (rootNetwork.chainId.toString() !== this.config.bridgeInstance.rootChainID) {
            throw new BridgeError(`Rootchain provider chainID ${rootNetwork.chainId} does not match expected chainID ${this.config.bridgeInstance.rootChainID}. ${errMessage}`, BridgeErrorType.UNSUPPORTED_ERROR);
        }
        const childNetwork = await this.config.childProvider.getNetwork();
        if (childNetwork.chainId.toString() !== this.config.bridgeInstance.childChainID) {
            throw new BridgeError(`Childchain provider chainID ${childNetwork.chainId} does not match expected chainID ${this.config.bridgeInstance.childChainID}. ${errMessage}`, BridgeErrorType.UNSUPPORTED_ERROR);
        }
    }
}

var Environment;
(function (Environment) {
    Environment["PRODUCTION"] = "production";
    Environment["SANDBOX"] = "sandbox";
})(Environment || (Environment = {}));

/**
 * @constant {BridgeInstance[]} SupportedSandboxBridges - An array of supported bridge instances for the sandbox environment.
 */
const SUPPORTED_SANDBOX_BRIDGES = [ETH_SEPOLIA_TO_ZKEVM_DEVNET, ETH_SEPOLIA_TO_ZKEVM_TESTNET];
/**
 * @constant {BridgeInstance[]} SUPPORTED_PRODUCTION_BRIDGES - An array of supported bridge instances for the production environment.
 */
const SUPPORTED_PRODUCTION_BRIDGES = [];
/**
 * @constant {Object} SUPPORTED_BRIDGES_FOR_ENVIRONMENT - An object mapping environment types to their supported bridge instances.
 */
const SUPPORTED_BRIDGES_FOR_ENVIRONMENT = {
    [Environment.SANDBOX]: SUPPORTED_SANDBOX_BRIDGES,
    [Environment.PRODUCTION]: SUPPORTED_PRODUCTION_BRIDGES,
};
/**
 * @constant {Map<BridgeInstance, BridgeContracts>} CONTRACTS_FOR_BRIDGE - A map of bridge instances to their associated contract addresses.
 */
const CONTRACTS_FOR_BRIDGE = new Map()
    .set(ETH_SEPOLIA_TO_ZKEVM_DEVNET, {
    rootChainERC20Predicate: '0x75E468cF088F947B96422996132FbE71160F21F1',
    rootChainStateSender: '0xbdC11416f01b122b7621855e61c99C7ED986F894',
    rootChainCheckpointManager: '0x0721b564a96466b864A998D31846Ba409d21092B',
    rootChainExitHelper: '0x0a2cb3f90aE65429E5c516af500F59d8fed51844',
    childChainERC20Predicate: '0x0000000000000000000000000000000000001004',
    childChainStateReceiver: '0x0000000000000000000000000000000000001001',
})
    .set(ETH_SEPOLIA_TO_ZKEVM_TESTNET, {
    rootChainERC20Predicate: '0x1118Cc83780d07ef99F84fD1C0E10CEd49AF3613',
    rootChainStateSender: '0x41716a0DD85ae257DD011A97cE1470F609871270',
    rootChainCheckpointManager: '0xfD69e3FCd72C6374623eeb156dd2C4159eBa7327',
    rootChainExitHelper: '0x270D2B290c8183De23eCD17C7DaAE59fd084fE70',
    childChainERC20Predicate: '0x0000000000000000000000000000000000001004',
    childChainStateReceiver: '0x0000000000000000000000000000000000001001',
})
    .set(ETH_MAINNET_TO_ZKEVM_MAINNET, {
    rootChainERC20Predicate: '0x',
    rootChainStateSender: '0x',
    rootChainCheckpointManager: '0x',
    rootChainExitHelper: '0x',
    childChainERC20Predicate: '0x',
    childChainStateReceiver: '0x',
});
/**
 * Represents the configuration for a bridge between two chains.
 */
class BridgeConfiguration {
    /**
     * @property {ImmutableConfiguration} baseConfig - The base configuration for the module.
     * @property {BridgeInstance} bridgeInstance - The bridge instance configuration for the root and child chains.
     * @property {BridgeContracts} bridgeContracts - The configuration of the contracts associated with the bridge.
     * @property {ethers.providers.Provider} rootProvider - The Ethereum provider for the root chain.
     * @property {ethers.providers.Provider} childProvider - The Ethereum provider for the child chain.
     * @property {number} blockTime - The approximate block time
     * @property {number} pollInterval - The time to wait between polls to the blockchain
     * @property {number} maxDepositBlockDelay - The maximum number of blocks it should take on child chain for deposit to be observed
     * @property {number} clockInaccuracy - The maximum number of seconds of inaccuracy of blockchain timestamps
     * @property {number} rootChainFinalityBlocks - The number of blocks to wait for on the rootchain before accepting finality
    */
    baseConfig;
    bridgeInstance;
    bridgeContracts;
    rootProvider;
    childProvider;
    blockTime;
    pollInterval;
    maxDepositBlockDelay;
    clockInaccuracy;
    rootChainFinalityBlocks;
    /**
     * Constructs a BridgeConfiguration instance.
     *
     * @param {BridgeModuleConfiguration} options - The configuration options for the bridge module.
     */
    constructor({ bridgeInstance, rootProvider, childProvider, baseConfig, overrides, }) {
        this.baseConfig = baseConfig;
        this.bridgeInstance = bridgeInstance;
        this.rootProvider = rootProvider;
        this.childProvider = childProvider;
        // Does not need to be exact, just approximate
        this.blockTime = 12;
        // How frequently we poll the childchain for StateSync events
        this.pollInterval = 5 * 1000; // 5 seconds
        // The upper bound of the block range we poll for StateSync events
        this.maxDepositBlockDelay = 250;
        // Assume that the clock timestamp is at most 900 seconds inaccurate, see for more ->
        // https://github.com/ethereum/wiki/blob/c02254611f218f43cbb07517ca8e5d00fd6d6d75/Block-Protocol-2.0.md
        this.clockInaccuracy = 900;
        // How many blocks to wait for on the root chain before accepting rootchain finality
        this.rootChainFinalityBlocks = 3;
        if (overrides) {
            this.bridgeContracts = overrides.bridgeContracts;
            return;
        }
        const supported = SUPPORTED_BRIDGES_FOR_ENVIRONMENT[baseConfig.environment].includes(bridgeInstance);
        if (!supported) {
            throw new Error(`Bridge instance with rootchain ${bridgeInstance.rootChainID} and childchain ${bridgeInstance.childChainID} is not supported in environment ${baseConfig.environment}`);
        }
        if (!CONTRACTS_FOR_BRIDGE.has(bridgeInstance)) {
            throw new Error(`Bridge instance with rootchain ${bridgeInstance.rootChainID} and childchain ${bridgeInstance.childChainID} is not supported in environment ${baseConfig.environment}`);
        }
        const bridgeContracts = CONTRACTS_FOR_BRIDGE.get(bridgeInstance);
        if (!bridgeContracts) {
            throw new Error(`Bridge instance with rootchain ${bridgeInstance.rootChainID} and childchain ${bridgeInstance.childChainID} is not supported in environment ${baseConfig.environment}`);
        }
        this.bridgeContracts = bridgeContracts;
    }
}

/**
 * @enum {string} Errors that can be returned by the Exchange.
 */
var ExchangeErrorCode;
(function (ExchangeErrorCode) {
    ExchangeErrorCode["INVALID_CONFIGURATION"] = "INVALID_CONFIGURATION";
    ExchangeErrorCode["INVALID_SLIPPAGE"] = "INVALID_SLIPPAGE";
    ExchangeErrorCode["INVALID_MAX_HOPS"] = "INVALID_MAX_HOPS";
    ExchangeErrorCode["INVALID_ADDRESS"] = "INVALID_ADDRESS";
    ExchangeErrorCode["DUPLICATE_ADDRESSES"] = "DUPLICATE_ADDRESSES";
    ExchangeErrorCode["CHAIN_NOT_SUPPORTED"] = "CHAIN_NOT_SUPPORTED";
    ExchangeErrorCode["NO_ROUTES_AVAILABLE"] = "NO_ROUTES_AVAILABLE";
    ExchangeErrorCode["PROVIDER_CALL_ERROR"] = "PROVIDER_CALL_ERROR";
    ExchangeErrorCode["APPROVE_ERROR"] = "APPROVE_ERROR";
    ExchangeErrorCode["ALREADY_APPROVED_ERROR"] = "ALREADY_APPROVED_ERROR";
})(ExchangeErrorCode || (ExchangeErrorCode = {}));
/**
 * The {@link ExchangeError} error class that extends the {@link Error} class.
 * Contains a message string and a type that corresponds to an {@link ExchangeErrorCode}.
 * It has a constructor that takes in a message string and a type.
 */
class ExchangeError extends Error {
    message;
    code;
    constructor(message, code) {
        super(message);
        this.message = message;
        this.code = code;
    }
}
class InvalidConfigurationError extends ExchangeError {
    constructor(message) {
        super(message || 'Invalid configuration', ExchangeErrorCode.INVALID_CONFIGURATION);
    }
}
class ChainNotSupportedError extends ExchangeError {
    constructor(chain, environment) {
        const message = `Chain with ID ${chain} is not a supported chain in environment ${environment}`;
        super(message, ExchangeErrorCode.CHAIN_NOT_SUPPORTED);
    }
}
class InvalidSlippageError extends ExchangeError {
    constructor(message) {
        super(message, ExchangeErrorCode.INVALID_SLIPPAGE);
    }
}
class InvalidMaxHopsError extends ExchangeError {
    constructor(message) {
        super(message, ExchangeErrorCode.INVALID_MAX_HOPS);
    }
}
class InvalidAddressError extends ExchangeError {
    constructor(message) {
        super(message, ExchangeErrorCode.INVALID_ADDRESS);
    }
}
class DuplicateAddressesError extends ExchangeError {
    constructor() {
        super('token in and token out addresses must be different', ExchangeErrorCode.DUPLICATE_ADDRESSES);
    }
}
class NoRoutesAvailableError extends ExchangeError {
    constructor() {
        super('no routes available', ExchangeErrorCode.NO_ROUTES_AVAILABLE);
    }
}
class ProviderCallError extends ExchangeError {
    constructor(message) {
        super(message, ExchangeErrorCode.PROVIDER_CALL_ERROR);
    }
}
class ApproveError extends ExchangeError {
    constructor(message) {
        super(message, ExchangeErrorCode.APPROVE_ERROR);
    }
}
class AlreadyApprovedError extends ExchangeError {
    tokenAddress;
    spenderAddress;
    constructor(amountApproved, tokenAddress, spenderAddress) {
        super(`already approved ${amountApproved} tokens`, ExchangeErrorCode.ALREADY_APPROVED_ERROR);
        this.tokenAddress = tokenAddress;
        this.spenderAddress = spenderAddress;
    }
}

/* Autogenerated file. Do not edit manually. */
/* tslint:disable */
/* eslint-disable */
const _abi$3 = [
    {
        constant: true,
        inputs: [],
        name: "name",
        outputs: [
            {
                name: "",
                type: "string",
            },
        ],
        payable: false,
        stateMutability: "view",
        type: "function",
    },
    {
        constant: false,
        inputs: [
            {
                name: "_spender",
                type: "address",
            },
            {
                name: "_value",
                type: "uint256",
            },
        ],
        name: "approve",
        outputs: [
            {
                name: "",
                type: "bool",
            },
        ],
        payable: false,
        stateMutability: "nonpayable",
        type: "function",
    },
    {
        constant: true,
        inputs: [],
        name: "totalSupply",
        outputs: [
            {
                name: "",
                type: "uint256",
            },
        ],
        payable: false,
        stateMutability: "view",
        type: "function",
    },
    {
        constant: false,
        inputs: [
            {
                name: "_from",
                type: "address",
            },
            {
                name: "_to",
                type: "address",
            },
            {
                name: "_value",
                type: "uint256",
            },
        ],
        name: "transferFrom",
        outputs: [
            {
                name: "",
                type: "bool",
            },
        ],
        payable: false,
        stateMutability: "nonpayable",
        type: "function",
    },
    {
        constant: true,
        inputs: [],
        name: "decimals",
        outputs: [
            {
                name: "",
                type: "uint8",
            },
        ],
        payable: false,
        stateMutability: "view",
        type: "function",
    },
    {
        constant: true,
        inputs: [
            {
                name: "_owner",
                type: "address",
            },
        ],
        name: "balanceOf",
        outputs: [
            {
                name: "balance",
                type: "uint256",
            },
        ],
        payable: false,
        stateMutability: "view",
        type: "function",
    },
    {
        constant: true,
        inputs: [],
        name: "symbol",
        outputs: [
            {
                name: "",
                type: "string",
            },
        ],
        payable: false,
        stateMutability: "view",
        type: "function",
    },
    {
        constant: false,
        inputs: [
            {
                name: "_to",
                type: "address",
            },
            {
                name: "_value",
                type: "uint256",
            },
        ],
        name: "transfer",
        outputs: [
            {
                name: "",
                type: "bool",
            },
        ],
        payable: false,
        stateMutability: "nonpayable",
        type: "function",
    },
    {
        constant: true,
        inputs: [
            {
                name: "_owner",
                type: "address",
            },
            {
                name: "_spender",
                type: "address",
            },
        ],
        name: "allowance",
        outputs: [
            {
                name: "",
                type: "uint256",
            },
        ],
        payable: false,
        stateMutability: "view",
        type: "function",
    },
    {
        payable: true,
        stateMutability: "payable",
        type: "fallback",
    },
    {
        anonymous: false,
        inputs: [
            {
                indexed: true,
                name: "owner",
                type: "address",
            },
            {
                indexed: true,
                name: "spender",
                type: "address",
            },
            {
                indexed: false,
                name: "value",
                type: "uint256",
            },
        ],
        name: "Approval",
        type: "event",
    },
    {
        anonymous: false,
        inputs: [
            {
                indexed: true,
                name: "from",
                type: "address",
            },
            {
                indexed: true,
                name: "to",
                type: "address",
            },
            {
                indexed: false,
                name: "value",
                type: "uint256",
            },
        ],
        name: "Transfer",
        type: "event",
    },
];
class ERC20__factory {
    static abi = _abi$3;
    static createInterface() {
        return new utils$1.Interface(_abi$3);
    }
    static connect(address, signerOrProvider) {
        return new Contract$1(address, _abi$3, signerOrProvider);
    }
}

/* Autogenerated file. Do not edit manually. */
/* tslint:disable */
/* eslint-disable */
const _abi$2 = [
    {
        inputs: [],
        name: "getCurrentBlockTimestamp",
        outputs: [
            {
                internalType: "uint256",
                name: "timestamp",
                type: "uint256",
            },
        ],
        stateMutability: "view",
        type: "function",
    },
    {
        inputs: [
            {
                internalType: "address",
                name: "addr",
                type: "address",
            },
        ],
        name: "getEthBalance",
        outputs: [
            {
                internalType: "uint256",
                name: "balance",
                type: "uint256",
            },
        ],
        stateMutability: "view",
        type: "function",
    },
    {
        inputs: [
            {
                components: [
                    {
                        internalType: "address",
                        name: "target",
                        type: "address",
                    },
                    {
                        internalType: "uint256",
                        name: "gasLimit",
                        type: "uint256",
                    },
                    {
                        internalType: "bytes",
                        name: "callData",
                        type: "bytes",
                    },
                ],
                internalType: "struct UniswapInterfaceMulticall.Call[]",
                name: "calls",
                type: "tuple[]",
            },
        ],
        name: "multicall",
        outputs: [
            {
                internalType: "uint256",
                name: "blockNumber",
                type: "uint256",
            },
            {
                components: [
                    {
                        internalType: "bool",
                        name: "success",
                        type: "bool",
                    },
                    {
                        internalType: "uint256",
                        name: "gasUsed",
                        type: "uint256",
                    },
                    {
                        internalType: "bytes",
                        name: "returnData",
                        type: "bytes",
                    },
                ],
                internalType: "struct UniswapInterfaceMulticall.Result[]",
                name: "returnData",
                type: "tuple[]",
            },
        ],
        stateMutability: "nonpayable",
        type: "function",
    },
];
const _bytecode$2 = "0x608060405234801561001057600080fd5b50610567806100206000396000f3fe608060405234801561001057600080fd5b50600436106100415760003560e01c80630f28c97d146100465780631749e1e3146100645780634d2301cc14610085575b600080fd5b61004e610098565b60405161005b919061041f565b60405180910390f35b6100776100723660046102a7565b61009c565b60405161005b929190610428565b61004e610093366004610286565b610220565b4290565b8051439060609067ffffffffffffffff811180156100b957600080fd5b506040519080825280602002602001820160405280156100f357816020015b6100e061023a565b8152602001906001900390816100d85790505b50905060005b835181101561021a57600080600086848151811061011357fe5b60200260200101516000015187858151811061012b57fe5b60200260200101516020015188868151811061014357fe5b60200260200101516040015192509250925060005a90506000808573ffffffffffffffffffffffffffffffffffffffff1685856040516101839190610403565b60006040518083038160008787f1925050503d80600081146101c1576040519150601f19603f3d011682016040523d82523d6000602084013e6101c6565b606091505b509150915060005a8403905060405180606001604052808415158152602001828152602001838152508989815181106101fb57fe5b60200260200101819052505050505050505080806001019150506100f9565b50915091565b73ffffffffffffffffffffffffffffffffffffffff163190565b604051806060016040528060001515815260200160008152602001606081525090565b803573ffffffffffffffffffffffffffffffffffffffff8116811461028157600080fd5b919050565b600060208284031215610297578081fd5b6102a08261025d565b9392505050565b600060208083850312156102b9578182fd5b823567ffffffffffffffff808211156102d0578384fd5b818501915085601f8301126102e3578384fd5b8135818111156102ef57fe5b6102fc8485830201610506565b81815284810190848601875b848110156103f457813587017fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0606081838f03011215610346578a8bfd5b60408051606081018181108b8211171561035c57fe5b8252610369848d0161025d565b8152818401358c82015260608401358a811115610384578d8efd5b8085019450508e603f850112610398578c8dfd5b8b8401358a8111156103a657fe5b6103b68d85601f84011601610506565b93508084528f838287010111156103cb578d8efd5b808386018e86013783018c018d9052908101919091528552509287019290870190600101610308565b50909998505050505050505050565b6000825161041581846020870161052a565b9190910192915050565b90815260200190565b600060408083018584526020828186015281865180845260609350838701915083838202880101838901875b838110156104f6578983037fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffa001855281518051151584528681015187850152880151888401889052805188850181905260806104b582828801858c0161052a565b96880196601f919091017fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe01694909401909301925090850190600101610454565b50909a9950505050505050505050565b60405181810167ffffffffffffffff8111828210171561052257fe5b604052919050565b60005b8381101561054557818101518382015260200161052d565b83811115610554576000848401525b5050505056fea164736f6c6343000706000a";
const isSuperArgs$2 = (xs) => xs.length > 1;
class Multicall__factory extends ContractFactory {
    constructor(...args) {
        if (isSuperArgs$2(args)) {
            super(...args);
        }
        else {
            super(_abi$2, _bytecode$2, args[0]);
        }
    }
    deploy(overrides) {
        return super.deploy(overrides || {});
    }
    getDeployTransaction(overrides) {
        return super.getDeployTransaction(overrides || {});
    }
    attach(address) {
        return super.attach(address);
    }
    connect(signer) {
        return super.connect(signer);
    }
    static bytecode = _bytecode$2;
    static abi = _abi$2;
    static createInterface() {
        return new utils$1.Interface(_abi$2);
    }
    static connect(address, signerOrProvider) {
        return new Contract$1(address, _abi$2, signerOrProvider);
    }
}

/* Autogenerated file. Do not edit manually. */
/* tslint:disable */
/* eslint-disable */
const _abi$1 = [
    {
        inputs: [
            {
                internalType: "address",
                name: "_admin",
                type: "address",
            },
            {
                internalType: "address",
                name: "_uniRouter",
                type: "address",
            },
        ],
        stateMutability: "nonpayable",
        type: "constructor",
    },
    {
        anonymous: false,
        inputs: [
            {
                indexed: true,
                internalType: "address",
                name: "feeToken",
                type: "address",
            },
            {
                indexed: true,
                internalType: "address",
                name: "feePayer",
                type: "address",
            },
            {
                indexed: true,
                internalType: "address",
                name: "feeRecipient",
                type: "address",
            },
            {
                indexed: false,
                internalType: "uint256",
                name: "feeAmount",
                type: "uint256",
            },
        ],
        name: "FeeTaken",
        type: "event",
    },
    {
        anonymous: false,
        inputs: [
            {
                indexed: false,
                internalType: "address",
                name: "account",
                type: "address",
            },
        ],
        name: "Paused",
        type: "event",
    },
    {
        anonymous: false,
        inputs: [
            {
                indexed: true,
                internalType: "bytes32",
                name: "role",
                type: "bytes32",
            },
            {
                indexed: true,
                internalType: "bytes32",
                name: "previousAdminRole",
                type: "bytes32",
            },
            {
                indexed: true,
                internalType: "bytes32",
                name: "newAdminRole",
                type: "bytes32",
            },
        ],
        name: "RoleAdminChanged",
        type: "event",
    },
    {
        anonymous: false,
        inputs: [
            {
                indexed: true,
                internalType: "bytes32",
                name: "role",
                type: "bytes32",
            },
            {
                indexed: true,
                internalType: "address",
                name: "account",
                type: "address",
            },
            {
                indexed: true,
                internalType: "address",
                name: "sender",
                type: "address",
            },
        ],
        name: "RoleGranted",
        type: "event",
    },
    {
        anonymous: false,
        inputs: [
            {
                indexed: true,
                internalType: "bytes32",
                name: "role",
                type: "bytes32",
            },
            {
                indexed: true,
                internalType: "address",
                name: "account",
                type: "address",
            },
            {
                indexed: true,
                internalType: "address",
                name: "sender",
                type: "address",
            },
        ],
        name: "RoleRevoked",
        type: "event",
    },
    {
        anonymous: false,
        inputs: [
            {
                indexed: false,
                internalType: "address",
                name: "account",
                type: "address",
            },
        ],
        name: "Unpaused",
        type: "event",
    },
    {
        inputs: [],
        name: "BASIS_POINT_PRECISION",
        outputs: [
            {
                internalType: "uint256",
                name: "",
                type: "uint256",
            },
        ],
        stateMutability: "view",
        type: "function",
    },
    {
        inputs: [],
        name: "DEFAULT_ADMIN_ROLE",
        outputs: [
            {
                internalType: "bytes32",
                name: "",
                type: "bytes32",
            },
        ],
        stateMutability: "view",
        type: "function",
    },
    {
        inputs: [],
        name: "FEE_BASIS_POINTS_MAXIMUM",
        outputs: [
            {
                internalType: "uint16",
                name: "",
                type: "uint16",
            },
        ],
        stateMutability: "view",
        type: "function",
    },
    {
        inputs: [],
        name: "PAUSE",
        outputs: [
            {
                internalType: "bytes32",
                name: "",
                type: "bytes32",
            },
        ],
        stateMutability: "view",
        type: "function",
    },
    {
        inputs: [],
        name: "UNPAUSE",
        outputs: [
            {
                internalType: "bytes32",
                name: "",
                type: "bytes32",
            },
        ],
        stateMutability: "view",
        type: "function",
    },
    {
        inputs: [],
        name: "WITHDRAW",
        outputs: [
            {
                internalType: "bytes32",
                name: "",
                type: "bytes32",
            },
        ],
        stateMutability: "view",
        type: "function",
    },
    {
        inputs: [
            {
                components: [
                    {
                        internalType: "address",
                        name: "recipient",
                        type: "address",
                    },
                    {
                        internalType: "uint256",
                        name: "feeBasisPoints",
                        type: "uint256",
                    },
                ],
                internalType: "struct ISecondaryFee.SecondaryFeeParams[]",
                name: "secondaryFees",
                type: "tuple[]",
            },
            {
                components: [
                    {
                        internalType: "address",
                        name: "tokenIn",
                        type: "address",
                    },
                    {
                        internalType: "address",
                        name: "tokenOut",
                        type: "address",
                    },
                    {
                        internalType: "uint24",
                        name: "fee",
                        type: "uint24",
                    },
                    {
                        internalType: "address",
                        name: "recipient",
                        type: "address",
                    },
                    {
                        internalType: "uint256",
                        name: "amountIn",
                        type: "uint256",
                    },
                    {
                        internalType: "uint256",
                        name: "amountOutMinimum",
                        type: "uint256",
                    },
                    {
                        internalType: "uint160",
                        name: "sqrtPriceLimitX96",
                        type: "uint160",
                    },
                ],
                internalType: "struct IV3SwapRouter.ExactInputSingleParams",
                name: "swapParams",
                type: "tuple",
            },
        ],
        name: "exactInputSingleWithSecondaryFee",
        outputs: [
            {
                internalType: "uint256",
                name: "amountOut",
                type: "uint256",
            },
        ],
        stateMutability: "payable",
        type: "function",
    },
    {
        inputs: [
            {
                components: [
                    {
                        internalType: "address",
                        name: "recipient",
                        type: "address",
                    },
                    {
                        internalType: "uint256",
                        name: "feeBasisPoints",
                        type: "uint256",
                    },
                ],
                internalType: "struct ISecondaryFee.SecondaryFeeParams[]",
                name: "secondaryFees",
                type: "tuple[]",
            },
            {
                components: [
                    {
                        internalType: "bytes",
                        name: "path",
                        type: "bytes",
                    },
                    {
                        internalType: "address",
                        name: "recipient",
                        type: "address",
                    },
                    {
                        internalType: "uint256",
                        name: "amountIn",
                        type: "uint256",
                    },
                    {
                        internalType: "uint256",
                        name: "amountOutMinimum",
                        type: "uint256",
                    },
                ],
                internalType: "struct IV3SwapRouter.ExactInputParams",
                name: "swapParams",
                type: "tuple",
            },
        ],
        name: "exactInputWithSecondaryFee",
        outputs: [
            {
                internalType: "uint256",
                name: "amountOut",
                type: "uint256",
            },
        ],
        stateMutability: "payable",
        type: "function",
    },
    {
        inputs: [
            {
                components: [
                    {
                        internalType: "address",
                        name: "recipient",
                        type: "address",
                    },
                    {
                        internalType: "uint256",
                        name: "feeBasisPoints",
                        type: "uint256",
                    },
                ],
                internalType: "struct ISecondaryFee.SecondaryFeeParams[]",
                name: "secondaryFees",
                type: "tuple[]",
            },
            {
                components: [
                    {
                        internalType: "address",
                        name: "tokenIn",
                        type: "address",
                    },
                    {
                        internalType: "address",
                        name: "tokenOut",
                        type: "address",
                    },
                    {
                        internalType: "uint24",
                        name: "fee",
                        type: "uint24",
                    },
                    {
                        internalType: "address",
                        name: "recipient",
                        type: "address",
                    },
                    {
                        internalType: "uint256",
                        name: "amountOut",
                        type: "uint256",
                    },
                    {
                        internalType: "uint256",
                        name: "amountInMaximum",
                        type: "uint256",
                    },
                    {
                        internalType: "uint160",
                        name: "sqrtPriceLimitX96",
                        type: "uint160",
                    },
                ],
                internalType: "struct IV3SwapRouter.ExactOutputSingleParams",
                name: "swapParams",
                type: "tuple",
            },
        ],
        name: "exactOutputSingleWithSecondaryFee",
        outputs: [
            {
                internalType: "uint256",
                name: "",
                type: "uint256",
            },
        ],
        stateMutability: "payable",
        type: "function",
    },
    {
        inputs: [
            {
                components: [
                    {
                        internalType: "address",
                        name: "recipient",
                        type: "address",
                    },
                    {
                        internalType: "uint256",
                        name: "feeBasisPoints",
                        type: "uint256",
                    },
                ],
                internalType: "struct ISecondaryFee.SecondaryFeeParams[]",
                name: "secondaryFees",
                type: "tuple[]",
            },
            {
                components: [
                    {
                        internalType: "bytes",
                        name: "path",
                        type: "bytes",
                    },
                    {
                        internalType: "address",
                        name: "recipient",
                        type: "address",
                    },
                    {
                        internalType: "uint256",
                        name: "amountOut",
                        type: "uint256",
                    },
                    {
                        internalType: "uint256",
                        name: "amountInMaximum",
                        type: "uint256",
                    },
                ],
                internalType: "struct IV3SwapRouter.ExactOutputParams",
                name: "swapParams",
                type: "tuple",
            },
        ],
        name: "exactOutputWithSecondaryFee",
        outputs: [
            {
                internalType: "uint256",
                name: "",
                type: "uint256",
            },
        ],
        stateMutability: "payable",
        type: "function",
    },
    {
        inputs: [
            {
                internalType: "bytes32",
                name: "role",
                type: "bytes32",
            },
        ],
        name: "getRoleAdmin",
        outputs: [
            {
                internalType: "bytes32",
                name: "",
                type: "bytes32",
            },
        ],
        stateMutability: "view",
        type: "function",
    },
    {
        inputs: [
            {
                internalType: "bytes32",
                name: "role",
                type: "bytes32",
            },
            {
                internalType: "address",
                name: "account",
                type: "address",
            },
        ],
        name: "grantRole",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function",
    },
    {
        inputs: [
            {
                internalType: "bytes32",
                name: "role",
                type: "bytes32",
            },
            {
                internalType: "address",
                name: "account",
                type: "address",
            },
        ],
        name: "hasRole",
        outputs: [
            {
                internalType: "bool",
                name: "",
                type: "bool",
            },
        ],
        stateMutability: "view",
        type: "function",
    },
    {
        inputs: [
            {
                internalType: "uint256",
                name: "deadline",
                type: "uint256",
            },
            {
                internalType: "bytes[]",
                name: "data",
                type: "bytes[]",
            },
        ],
        name: "multicall",
        outputs: [
            {
                internalType: "bytes[]",
                name: "",
                type: "bytes[]",
            },
        ],
        stateMutability: "payable",
        type: "function",
    },
    {
        inputs: [
            {
                internalType: "bytes[]",
                name: "data",
                type: "bytes[]",
            },
        ],
        name: "multicall",
        outputs: [
            {
                internalType: "bytes[]",
                name: "results",
                type: "bytes[]",
            },
        ],
        stateMutability: "nonpayable",
        type: "function",
    },
    {
        inputs: [],
        name: "pause",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function",
    },
    {
        inputs: [],
        name: "paused",
        outputs: [
            {
                internalType: "bool",
                name: "",
                type: "bool",
            },
        ],
        stateMutability: "view",
        type: "function",
    },
    {
        inputs: [
            {
                internalType: "bytes32",
                name: "role",
                type: "bytes32",
            },
            {
                internalType: "address",
                name: "account",
                type: "address",
            },
        ],
        name: "renounceRole",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function",
    },
    {
        inputs: [
            {
                internalType: "bytes32",
                name: "role",
                type: "bytes32",
            },
            {
                internalType: "address",
                name: "account",
                type: "address",
            },
        ],
        name: "revokeRole",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function",
    },
    {
        inputs: [
            {
                internalType: "bytes4",
                name: "interfaceId",
                type: "bytes4",
            },
        ],
        name: "supportsInterface",
        outputs: [
            {
                internalType: "bool",
                name: "",
                type: "bool",
            },
        ],
        stateMutability: "view",
        type: "function",
    },
    {
        inputs: [],
        name: "uniswapRouter",
        outputs: [
            {
                internalType: "contract IV3SwapRouter",
                name: "",
                type: "address",
            },
        ],
        stateMutability: "view",
        type: "function",
    },
    {
        inputs: [],
        name: "unpause",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function",
    },
    {
        inputs: [
            {
                internalType: "address",
                name: "to",
                type: "address",
            },
            {
                internalType: "address",
                name: "erc20",
                type: "address",
            },
        ],
        name: "withdrawFunds",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function",
    },
];
const _bytecode$1 = "0x60806040523480156200001157600080fd5b506040516200278438038062002784833981016040819052620000349162000136565b6001805460ff191690556200004b60008362000078565b600180546001600160a01b0390921661010002610100600160a81b0319909216919091179055506200016e565b6000828152602081815260408083206001600160a01b038516845290915290205460ff1662000115576000828152602081815260408083206001600160a01b03851684529091529020805460ff19166001179055620000d43390565b6001600160a01b0316816001600160a01b0316837f2f8788117e7eff1d82e926ec794901d17c78024a50270940304540a733656f0d60405160405180910390a45b5050565b80516001600160a01b03811681146200013157600080fd5b919050565b600080604083850312156200014a57600080fd5b620001558362000119565b9150620001656020840162000119565b90509250929050565b612606806200017e6000396000f3fe60806040526004361061013f5760003560e01c80635ae401dc116100b657806393751f631161006f57806393751f631461038c578063a217fddf146103b5578063ac9650d8146103ca578063d547741f146103ea578063d9a6f7051461040a578063e65fad971461042057600080fd5b80635ae401dc146102ae5780635c975abb146102ce578063735de9f7146102e65780638456cb59146103235780638f3914661461033857806391d148541461036c57600080fd5b80632f2ff15d116101085780632f2ff15d1461022057806336568abe14610240578063383ebb0b146102605780633f4ba83a146102735780635640f6591461028857806358e81a501461029b57600080fd5b80620fa9fb1461014457806301ffc9a714610166578063116944b21461019b57806316ba7197146101bc578063248a9ca3146101f0575b600080fd5b34801561015057600080fd5b5061016461015f366004611db4565b610454565b005b34801561017257600080fd5b50610186610181366004611ded565b61050d565b60405190151581526020015b60405180910390f35b6101ae6101a9366004611f85565b610544565b604051908152602001610192565b3480156101c857600080fd5b506101ae7f7a8dc26796a1e50e6e190b70259f58f6a4edd5b22280ceecc82b687b8e98286981565b3480156101fc57600080fd5b506101ae61020b366004611fda565b60009081526020819052604090206001015490565b34801561022c57600080fd5b5061016461023b366004611ff3565b610634565b34801561024c57600080fd5b5061016461025b366004611ff3565b610659565b6101ae61026e3660046120db565b6106dc565b34801561027f57600080fd5b5061016461084c565b6101ae6102963660046120db565b610889565b6101ae6102a9366004611f85565b61097f565b6102c16102bc366004612187565b610ad0565b6040516101929190612222565b3480156102da57600080fd5b5060015460ff16610186565b3480156102f257600080fd5b5060015461030b9061010090046001600160a01b031681565b6040516001600160a01b039091168152602001610192565b34801561032f57600080fd5b50610164610b1e565b34801561034457600080fd5b506101ae7fe7276a2a84d8de556657ec9cf93a55a7d66f096e529d0582ed08e9e2208b92b581565b34801561037857600080fd5b50610186610387366004611ff3565b610b59565b34801561039857600080fd5b506103a26103e881565b60405161ffff9091168152602001610192565b3480156103c157600080fd5b506101ae600081565b3480156103d657600080fd5b506102c16103e5366004612284565b610b82565b3480156103f657600080fd5b50610164610405366004611ff3565b610c76565b34801561041657600080fd5b506101ae61271081565b34801561042c57600080fd5b506101ae7ffcb9fcbfa83b897fb2d5cf4b58962164105c1e71489a37ef3ae0db3fdce576f681565b61047e7f7a8dc26796a1e50e6e190b70259f58f6a4edd5b22280ceecc82b687b8e98286933610b59565b61048757600080fd5b6040516370a0823160e01b81523060048201526000906001600160a01b038316906370a0823190602401602060405180830381865afa1580156104ce573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906104f291906122c5565b90506105086001600160a01b0383168483610c9b565b505050565b60006001600160e01b03198216637965db0b60e01b148061053e57506301ffc9a760e01b6001600160e01b03198316145b92915050565b60006105b08260000151836080015184606001518787808060200260200160405190810160405280939291908181526020016000905b828210156105a657610597604083028601368190038101906122de565b8152602001906001019061057a565b5050505050610cfe565b60808301526001546040516304e45aaf60e01b81526101009091046001600160a01b0316906304e45aaf906105e9908590600401612335565b6020604051808303816000875af1158015610608573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061062c91906122c5565b949350505050565b60008281526020819052604090206001015461064f81610dbf565b6105088383610dcc565b6001600160a01b03811633146106ce5760405162461bcd60e51b815260206004820152602f60248201527f416363657373436f6e74726f6c3a2063616e206f6e6c792072656e6f756e636560448201526e103937b632b9903337b91039b2b63360891b60648201526084015b60405180910390fd5b6106d88282610e50565b5050565b6000806106ec8360000151610eb5565b905060008061075783866060015187602001518a8a808060200260200160405190810160405280939291908181526020016000905b8282101561074d5761073e604083028601368190038101906122de565b81526020019060010190610721565b5050505050610ee3565b606087018190526001546040516304dc09a360e11b81529294509092506000916101009091046001600160a01b0316906309b813469061079b9089906004016123db565b6020604051808303816000875af11580156107ba573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906107de91906122c5565b905061083e8482858b8b808060200260200160405190810160405280939291908181526020016000905b8282101561083457610825604083028601368190038101906122de565b81526020019060010190610808565b5050505050610f96565b9450505050505b9392505050565b6108767fe7276a2a84d8de556657ec9cf93a55a7d66f096e529d0582ed08e9e2208b92b533610b59565b61087f57600080fd5b610887610ff7565b565b6000806108998360000151611049565b90506108f781846040015185602001518888808060200260200160405190810160405280939291908181526020016000905b828210156105a6576108e8604083028601368190038101906122de565b815260200190600101906108cb565b604084810191909152600154905163b858183f60e01b81526101009091046001600160a01b03169063b858183f906109339086906004016123db565b6020604051808303816000875af1158015610952573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061097691906122c5565b95945050505050565b60008060006109e484600001518560a0015186606001518989808060200260200160405190810160405280939291908181526020016000905b8282101561074d576109d5604083028601368190038101906122de565b815260200190600101906109b8565b60a08601819052600154604051635023b4df60e01b81529294509092506000916101009091046001600160a01b031690635023b4df90610a28908890600401612335565b6020604051808303816000875af1158015610a47573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610a6b91906122c5565b9050610ac5856000015182858a8a808060200260200160405190810160405280939291908181526020016000905b8282101561083457610ab6604083028601368190038101906122de565b81526020019060010190610a99565b979650505050505050565b606083421115610b145760405162461bcd60e51b815260206004820152600f60248201526e111958591b1a5b99481c185cdcd959608a1b60448201526064016106c5565b61062c8383610b82565b610b487ffcb9fcbfa83b897fb2d5cf4b58962164105c1e71489a37ef3ae0db3fdce576f633610b59565b610b5157600080fd5b610887611055565b6000918252602082815260408084206001600160a01b0393909316845291905290205460ff1690565b6060816001600160401b03811115610b9c57610b9c611e62565b604051908082528060200260200182016040528015610bcf57816020015b6060815260200190600190039081610bba5790505b50905060005b82811015610c6f57610c3f30858584818110610bf357610bf36123ee565b9050602002810190610c059190612404565b8080601f01602080910402602001604051908101604052809392919081815260200183838082843760009201919091525061109092505050565b828281518110610c5157610c516123ee565b60200260200101819052508080610c6790612460565b915050610bd5565b5092915050565b600082815260208190526040902060010154610c9181610dbf565b6105088383610e50565b6040516001600160a01b03831660248201526044810182905261050890849063a9059cbb60e01b906064015b60408051601f198184030181529190526020810180516001600160e01b03166001600160e01b0319909316929092179091526110b5565b60006001600160a01b0383163314610d585760405162461bcd60e51b815260206004820181905260248201527f73776170526563697069656e74206d757374206265206d73672e73656e64657260448201526064016106c5565b60015460ff16610d9757610d6b8261118a565b50600080610d79868561123d565b9092509050610d888287612479565b9550610d948782611366565b50505b610dac6001600160a01b03861633308761146f565b610db685856114ad565b50919392505050565b610dc981336115aa565b50565b610dd68282610b59565b6106d8576000828152602081815260408083206001600160a01b03851684529091529020805460ff19166001179055610e0c3390565b6001600160a01b0316816001600160a01b0316837f2f8788117e7eff1d82e926ec794901d17c78024a50270940304540a733656f0d60405160405180910390a45050565b610e5a8282610b59565b156106d8576000828152602081815260408083206001600160a01b0385168085529252808320805460ff1916905551339285917ff6391f5c32d9c69d2a47ea670b442974b53935d1edc7fd64eb21e047a839171b9190a45050565b60008060148351610ec69190612479565b90506000610ed684836014611603565b905061062c816000611710565b6000806001600160a01b0384163314610f3e5760405162461bcd60e51b815260206004820181905260248201527f73776170526563697069656e74206d757374206265206d73672e73656e64657260448201526064016106c5565b6000610f498461118a565b90506000610f598261271061248c565b9050610f688761271083611775565b9250610f7488846114ad565b610f896001600160a01b03891633308a61146f565b5094969095509350505050565b6000806000610fa5868561123d565b91509150610fb560015460ff1690565b610fc357610fc387826117b5565b610fed3383610fd28989612479565b610fdc9190612479565b6001600160a01b038a169190610c9b565b610ac5828761248c565b610fff6118bc565b6001805460ff191690557f5db9ee0a495bf2e6ff9c91a7834c1ba4fdd244a5e8aa4e537bd38aeae4b073aa335b6040516001600160a01b03909116815260200160405180910390a1565b600061053e8282611710565b61105d611905565b6001805460ff1916811790557f62e78cea01bee320cd4e420270b5ea74000d11b0c9f74754ebdbfc544b05a2583361102c565b606061084583836040518060600160405280602781526020016125aa6027913961194b565b600061110a826040518060400160405280602081526020017f5361666545524332303a206c6f772d6c6576656c2063616c6c206661696c6564815250856001600160a01b03166119c39092919063ffffffff16565b905080516000148061112b57508080602001905181019061112b919061249f565b6105085760405162461bcd60e51b815260206004820152602a60248201527f5361666545524332303a204552433230206f7065726174696f6e20646964206e6044820152691bdd081cdd58d8d9595960b21b60648201526084016106c5565b6000805b82518110156111d4578281815181106111a9576111a96123ee565b602002602001015160200151826111c0919061248c565b9150806111cc81612460565b91505061118e565b506103e88111156112385760405162461bcd60e51b815260206004820152602860248201527f5365636f6e6461727920666565203e204645455f42415349535f504f494e54536044820152675f4d4158494d554d60c01b60648201526084016106c5565b919050565b6000606082516001600160401b0381111561125a5761125a611e62565b60405190808252806020026020018201604052801561129f57816020015b60408051808201909152600080825260208201528152602001906001900390816112785790505b50905060005b835181101561135e5760006112e48583815181106112c5576112c56123ee565b602002602001015160200151612710886119d29092919063ffffffff16565b90506040518060400160405280868481518110611303576113036123ee565b6020026020010151600001516001600160a01b0316815260200182815250838381518110611333576113336123ee565b6020908102919091010152611348818561248c565b935050808061135690612460565b9150506112a5565b509250929050565b60005b8151811015610508576113cc33838381518110611388576113886123ee565b6020026020010151600001518484815181106113a6576113a66123ee565b602002602001015160200151866001600160a01b031661146f909392919063ffffffff16565b8181815181106113de576113de6123ee565b6020026020010151600001516001600160a01b0316336001600160a01b0316846001600160a01b03167f1f9a9fdac86b6ca3c5300bec0b61555cded1f1a234378602dcca6c27085eac8e85858151811061143a5761143a6123ee565b60200260200101516020015160405161145591815260200190565b60405180910390a48061146781612460565b915050611369565b6040516001600160a01b03808516602483015283166044820152606481018290526114a79085906323b872dd60e01b90608401610cc7565b50505050565b600154604051636eb1769f60e11b81523060048201526001600160a01b0361010090920482166024820152829184169063dd62ed3e90604401602060405180830381865afa158015611503573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061152791906122c5565b10156106d85760015460405163095ea7b360e01b81526101009091046001600160a01b039081166004830152600019602483015283169063095ea7b3906044016020604051808303816000875af1158015611586573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610508919061249f565b6115b48282610b59565b6106d8576115c181611a74565b6115cc836020611a86565b6040516020016115dd9291906124c1565b60408051601f198184030181529082905262461bcd60e51b82526106c591600401612536565b60608161161181601f61248c565b10156116505760405162461bcd60e51b815260206004820152600e60248201526d736c6963655f6f766572666c6f7760901b60448201526064016106c5565b61165a828461248c565b8451101561169e5760405162461bcd60e51b8152602060048201526011602482015270736c6963655f6f75744f66426f756e647360781b60448201526064016106c5565b6060821580156116bd5760405191506000825260208201604052611707565b6040519150601f8416801560200281840101858101878315602002848b0101015b818310156116f65780518352602092830192016116de565b5050858452601f01601f1916604052505b50949350505050565b600061171d82601461248c565b835110156117655760405162461bcd60e51b8152602060048201526015602482015274746f416464726573735f6f75744f66426f756e647360581b60448201526064016106c5565b500160200151600160601b900490565b60006117828484846119d2565b90506000828061179457611794612549565b84860911156108455760001981106117ab57600080fd5b6001019392505050565b60005b8151811015610508576118198282815181106117d6576117d66123ee565b6020026020010151600001518383815181106117f4576117f46123ee565b602002602001015160200151856001600160a01b0316610c9b9092919063ffffffff16565b81818151811061182b5761182b6123ee565b6020026020010151600001516001600160a01b0316336001600160a01b0316846001600160a01b03167f1f9a9fdac86b6ca3c5300bec0b61555cded1f1a234378602dcca6c27085eac8e858581518110611887576118876123ee565b6020026020010151602001516040516118a291815260200190565b60405180910390a4806118b481612460565b9150506117b8565b60015460ff166108875760405162461bcd60e51b815260206004820152601460248201527314185d5cd8589b194e881b9bdd081c185d5cd95960621b60448201526064016106c5565b60015460ff16156108875760405162461bcd60e51b815260206004820152601060248201526f14185d5cd8589b194e881c185d5cd95960821b60448201526064016106c5565b6060600080856001600160a01b031685604051611968919061255f565b600060405180830381855af49150503d80600081146119a3576040519150601f19603f3d011682016040523d82523d6000602084013e6119a8565b606091505b50915091506119b986838387611c21565b9695505050505050565b606061062c8484600085611c9a565b600083830281600019858709828110838203039150508084116119f457600080fd5b80600003611a0757508290049050610845565b6000848688096000868103871696879004966002600389028118808a02820302808a02820302808a02820302808a02820302808a02820302808a02909103029181900381900460010186841190950394909402919094039290920491909117919091029150509392505050565b606061053e6001600160a01b03831660145b60606000611a9583600261257b565b611aa090600261248c565b6001600160401b03811115611ab757611ab7611e62565b6040519080825280601f01601f191660200182016040528015611ae1576020820181803683370190505b509050600360fc1b81600081518110611afc57611afc6123ee565b60200101906001600160f81b031916908160001a905350600f60fb1b81600181518110611b2b57611b2b6123ee565b60200101906001600160f81b031916908160001a9053506000611b4f84600261257b565b611b5a90600161248c565b90505b6001811115611bd2576f181899199a1a9b1b9c1cb0b131b232b360811b85600f1660108110611b8e57611b8e6123ee565b1a60f81b828281518110611ba457611ba46123ee565b60200101906001600160f81b031916908160001a90535060049490941c93611bcb81612592565b9050611b5d565b5083156108455760405162461bcd60e51b815260206004820181905260248201527f537472696e67733a20686578206c656e67746820696e73756666696369656e7460448201526064016106c5565b60608315611c90578251600003611c89576001600160a01b0385163b611c895760405162461bcd60e51b815260206004820152601d60248201527f416464726573733a2063616c6c20746f206e6f6e2d636f6e747261637400000060448201526064016106c5565b508161062c565b61062c8383611d6a565b606082471015611cfb5760405162461bcd60e51b815260206004820152602660248201527f416464726573733a20696e73756666696369656e742062616c616e636520666f6044820152651c8818d85b1b60d21b60648201526084016106c5565b600080866001600160a01b03168587604051611d17919061255f565b60006040518083038185875af1925050503d8060008114611d54576040519150601f19603f3d011682016040523d82523d6000602084013e611d59565b606091505b5091509150610ac587838387611c21565b815115611d7a5781518083602001fd5b8060405162461bcd60e51b81526004016106c59190612536565b6001600160a01b0381168114610dc957600080fd5b803561123881611d94565b60008060408385031215611dc757600080fd5b8235611dd281611d94565b91506020830135611de281611d94565b809150509250929050565b600060208284031215611dff57600080fd5b81356001600160e01b03198116811461084557600080fd5b60008083601f840112611e2957600080fd5b5081356001600160401b03811115611e4057600080fd5b6020830191508360208260061b8501011115611e5b57600080fd5b9250929050565b634e487b7160e01b600052604160045260246000fd5b60405160e081016001600160401b0381118282101715611e9a57611e9a611e62565b60405290565b604051608081016001600160401b0381118282101715611e9a57611e9a611e62565b604051601f8201601f191681016001600160401b0381118282101715611eea57611eea611e62565b604052919050565b600060e08284031215611f0457600080fd5b611f0c611e78565b90508135611f1981611d94565b81526020820135611f2981611d94565b6020820152604082013562ffffff81168114611f4457600080fd5b6040820152611f5560608301611da9565b60608201526080820135608082015260a082013560a0820152611f7a60c08301611da9565b60c082015292915050565b60008060006101008486031215611f9b57600080fd5b83356001600160401b03811115611fb157600080fd5b611fbd86828701611e17565b9094509250611fd190508560208601611ef2565b90509250925092565b600060208284031215611fec57600080fd5b5035919050565b6000806040838503121561200657600080fd5b823591506020830135611de281611d94565b60006080828403121561202a57600080fd5b612032611ea0565b905081356001600160401b038082111561204b57600080fd5b818401915084601f83011261205f57600080fd5b813560208282111561207357612073611e62565b612085601f8301601f19168201611ec2565b9250818352868183860101111561209b57600080fd5b818185018285013760008183850101528285526120b9818701611da9565b8186015250505050604082013560408201526060820135606082015292915050565b6000806000604084860312156120f057600080fd5b83356001600160401b038082111561210757600080fd5b61211387838801611e17565b9095509350602086013591508082111561212c57600080fd5b5061213986828701612018565b9150509250925092565b60008083601f84011261215557600080fd5b5081356001600160401b0381111561216c57600080fd5b6020830191508360208260051b8501011115611e5b57600080fd5b60008060006040848603121561219c57600080fd5b8335925060208401356001600160401b038111156121b957600080fd5b6121c586828701612143565b9497909650939450505050565b60005b838110156121ed5781810151838201526020016121d5565b50506000910152565b6000815180845261220e8160208601602086016121d2565b601f01601f19169290920160200192915050565b6000602080830181845280855180835260408601915060408160051b870101925083870160005b8281101561227757603f198886030184526122658583516121f6565b94509285019290850190600101612249565b5092979650505050505050565b6000806020838503121561229757600080fd5b82356001600160401b038111156122ad57600080fd5b6122b985828601612143565b90969095509350505050565b6000602082840312156122d757600080fd5b5051919050565b6000604082840312156122f057600080fd5b604051604081018181106001600160401b038211171561231257612312611e62565b604052823561232081611d94565b81526020928301359281019290925250919050565b60e0810161053e828480516001600160a01b03908116835260208083015182169084015260408083015162ffffff16908401526060808301518216908401526080808301519084015260a0828101519084015260c09182015116910152565b60008151608084526123a960808501826121f6565b6020848101516001600160a01b0316908601526040808501519086015260609384015193909401929092525090919050565b6020815260006108456020830184612394565b634e487b7160e01b600052603260045260246000fd5b6000808335601e1984360301811261241b57600080fd5b8301803591506001600160401b0382111561243557600080fd5b602001915036819003821315611e5b57600080fd5b634e487b7160e01b600052601160045260246000fd5b6000600182016124725761247261244a565b5060010190565b8181038181111561053e5761053e61244a565b8082018082111561053e5761053e61244a565b6000602082840312156124b157600080fd5b8151801515811461084557600080fd5b7f416363657373436f6e74726f6c3a206163636f756e74200000000000000000008152600083516124f98160178501602088016121d2565b7001034b99036b4b9b9b4b733903937b6329607d1b601791840191820152835161252a8160288401602088016121d2565b01602801949350505050565b60208152600061084560208301846121f6565b634e487b7160e01b600052601260045260246000fd5b600082516125718184602087016121d2565b9190910192915050565b808202811582820484141761053e5761053e61244a565b6000816125a1576125a161244a565b50600019019056fe416464726573733a206c6f772d6c6576656c2064656c65676174652063616c6c206661696c6564a2646970667358221220c75a7db1b170ff1ce6888f2940825a25db3ebb624d8b84bd3f2372ebae2de1d464736f6c63430008130033";
const isSuperArgs$1 = (xs) => xs.length > 1;
class SecondaryFee__factory extends ContractFactory {
    constructor(...args) {
        if (isSuperArgs$1(args)) {
            super(...args);
        }
        else {
            super(_abi$1, _bytecode$1, args[0]);
        }
    }
    deploy(_admin, _uniRouter, overrides) {
        return super.deploy(_admin, _uniRouter, overrides || {});
    }
    getDeployTransaction(_admin, _uniRouter, overrides) {
        return super.getDeployTransaction(_admin, _uniRouter, overrides || {});
    }
    attach(address) {
        return super.attach(address);
    }
    connect(signer) {
        return super.connect(signer);
    }
    static bytecode = _bytecode$1;
    static abi = _abi$1;
    static createInterface() {
        return new utils$1.Interface(_abi$1);
    }
    static connect(address, signerOrProvider) {
        return new Contract$1(address, _abi$1, signerOrProvider);
    }
}

/* Autogenerated file. Do not edit manually. */
/* tslint:disable */
/* eslint-disable */
const _abi = [
    {
        inputs: [],
        stateMutability: "nonpayable",
        type: "constructor",
    },
    {
        anonymous: false,
        inputs: [
            {
                indexed: true,
                internalType: "address",
                name: "owner",
                type: "address",
            },
            {
                indexed: true,
                internalType: "int24",
                name: "tickLower",
                type: "int24",
            },
            {
                indexed: true,
                internalType: "int24",
                name: "tickUpper",
                type: "int24",
            },
            {
                indexed: false,
                internalType: "uint128",
                name: "amount",
                type: "uint128",
            },
            {
                indexed: false,
                internalType: "uint256",
                name: "amount0",
                type: "uint256",
            },
            {
                indexed: false,
                internalType: "uint256",
                name: "amount1",
                type: "uint256",
            },
        ],
        name: "Burn",
        type: "event",
    },
    {
        anonymous: false,
        inputs: [
            {
                indexed: true,
                internalType: "address",
                name: "owner",
                type: "address",
            },
            {
                indexed: false,
                internalType: "address",
                name: "recipient",
                type: "address",
            },
            {
                indexed: true,
                internalType: "int24",
                name: "tickLower",
                type: "int24",
            },
            {
                indexed: true,
                internalType: "int24",
                name: "tickUpper",
                type: "int24",
            },
            {
                indexed: false,
                internalType: "uint128",
                name: "amount0",
                type: "uint128",
            },
            {
                indexed: false,
                internalType: "uint128",
                name: "amount1",
                type: "uint128",
            },
        ],
        name: "Collect",
        type: "event",
    },
    {
        anonymous: false,
        inputs: [
            {
                indexed: true,
                internalType: "address",
                name: "sender",
                type: "address",
            },
            {
                indexed: true,
                internalType: "address",
                name: "recipient",
                type: "address",
            },
            {
                indexed: false,
                internalType: "uint128",
                name: "amount0",
                type: "uint128",
            },
            {
                indexed: false,
                internalType: "uint128",
                name: "amount1",
                type: "uint128",
            },
        ],
        name: "CollectProtocol",
        type: "event",
    },
    {
        anonymous: false,
        inputs: [
            {
                indexed: true,
                internalType: "address",
                name: "sender",
                type: "address",
            },
            {
                indexed: true,
                internalType: "address",
                name: "recipient",
                type: "address",
            },
            {
                indexed: false,
                internalType: "uint256",
                name: "amount0",
                type: "uint256",
            },
            {
                indexed: false,
                internalType: "uint256",
                name: "amount1",
                type: "uint256",
            },
            {
                indexed: false,
                internalType: "uint256",
                name: "paid0",
                type: "uint256",
            },
            {
                indexed: false,
                internalType: "uint256",
                name: "paid1",
                type: "uint256",
            },
        ],
        name: "Flash",
        type: "event",
    },
    {
        anonymous: false,
        inputs: [
            {
                indexed: false,
                internalType: "uint16",
                name: "observationCardinalityNextOld",
                type: "uint16",
            },
            {
                indexed: false,
                internalType: "uint16",
                name: "observationCardinalityNextNew",
                type: "uint16",
            },
        ],
        name: "IncreaseObservationCardinalityNext",
        type: "event",
    },
    {
        anonymous: false,
        inputs: [
            {
                indexed: false,
                internalType: "uint160",
                name: "sqrtPriceX96",
                type: "uint160",
            },
            {
                indexed: false,
                internalType: "int24",
                name: "tick",
                type: "int24",
            },
        ],
        name: "Initialize",
        type: "event",
    },
    {
        anonymous: false,
        inputs: [
            {
                indexed: false,
                internalType: "address",
                name: "sender",
                type: "address",
            },
            {
                indexed: true,
                internalType: "address",
                name: "owner",
                type: "address",
            },
            {
                indexed: true,
                internalType: "int24",
                name: "tickLower",
                type: "int24",
            },
            {
                indexed: true,
                internalType: "int24",
                name: "tickUpper",
                type: "int24",
            },
            {
                indexed: false,
                internalType: "uint128",
                name: "amount",
                type: "uint128",
            },
            {
                indexed: false,
                internalType: "uint256",
                name: "amount0",
                type: "uint256",
            },
            {
                indexed: false,
                internalType: "uint256",
                name: "amount1",
                type: "uint256",
            },
        ],
        name: "Mint",
        type: "event",
    },
    {
        anonymous: false,
        inputs: [
            {
                indexed: false,
                internalType: "uint8",
                name: "feeProtocol0Old",
                type: "uint8",
            },
            {
                indexed: false,
                internalType: "uint8",
                name: "feeProtocol1Old",
                type: "uint8",
            },
            {
                indexed: false,
                internalType: "uint8",
                name: "feeProtocol0New",
                type: "uint8",
            },
            {
                indexed: false,
                internalType: "uint8",
                name: "feeProtocol1New",
                type: "uint8",
            },
        ],
        name: "SetFeeProtocol",
        type: "event",
    },
    {
        anonymous: false,
        inputs: [
            {
                indexed: true,
                internalType: "address",
                name: "sender",
                type: "address",
            },
            {
                indexed: true,
                internalType: "address",
                name: "recipient",
                type: "address",
            },
            {
                indexed: false,
                internalType: "int256",
                name: "amount0",
                type: "int256",
            },
            {
                indexed: false,
                internalType: "int256",
                name: "amount1",
                type: "int256",
            },
            {
                indexed: false,
                internalType: "uint160",
                name: "sqrtPriceX96",
                type: "uint160",
            },
            {
                indexed: false,
                internalType: "uint128",
                name: "liquidity",
                type: "uint128",
            },
            {
                indexed: false,
                internalType: "int24",
                name: "tick",
                type: "int24",
            },
        ],
        name: "Swap",
        type: "event",
    },
    {
        inputs: [
            {
                internalType: "int24",
                name: "tickLower",
                type: "int24",
            },
            {
                internalType: "int24",
                name: "tickUpper",
                type: "int24",
            },
            {
                internalType: "uint128",
                name: "amount",
                type: "uint128",
            },
        ],
        name: "burn",
        outputs: [
            {
                internalType: "uint256",
                name: "amount0",
                type: "uint256",
            },
            {
                internalType: "uint256",
                name: "amount1",
                type: "uint256",
            },
        ],
        stateMutability: "nonpayable",
        type: "function",
    },
    {
        inputs: [
            {
                internalType: "address",
                name: "recipient",
                type: "address",
            },
            {
                internalType: "int24",
                name: "tickLower",
                type: "int24",
            },
            {
                internalType: "int24",
                name: "tickUpper",
                type: "int24",
            },
            {
                internalType: "uint128",
                name: "amount0Requested",
                type: "uint128",
            },
            {
                internalType: "uint128",
                name: "amount1Requested",
                type: "uint128",
            },
        ],
        name: "collect",
        outputs: [
            {
                internalType: "uint128",
                name: "amount0",
                type: "uint128",
            },
            {
                internalType: "uint128",
                name: "amount1",
                type: "uint128",
            },
        ],
        stateMutability: "nonpayable",
        type: "function",
    },
    {
        inputs: [
            {
                internalType: "address",
                name: "recipient",
                type: "address",
            },
            {
                internalType: "uint128",
                name: "amount0Requested",
                type: "uint128",
            },
            {
                internalType: "uint128",
                name: "amount1Requested",
                type: "uint128",
            },
        ],
        name: "collectProtocol",
        outputs: [
            {
                internalType: "uint128",
                name: "amount0",
                type: "uint128",
            },
            {
                internalType: "uint128",
                name: "amount1",
                type: "uint128",
            },
        ],
        stateMutability: "nonpayable",
        type: "function",
    },
    {
        inputs: [],
        name: "factory",
        outputs: [
            {
                internalType: "address",
                name: "",
                type: "address",
            },
        ],
        stateMutability: "view",
        type: "function",
    },
    {
        inputs: [],
        name: "fee",
        outputs: [
            {
                internalType: "uint24",
                name: "",
                type: "uint24",
            },
        ],
        stateMutability: "view",
        type: "function",
    },
    {
        inputs: [],
        name: "feeGrowthGlobal0X128",
        outputs: [
            {
                internalType: "uint256",
                name: "",
                type: "uint256",
            },
        ],
        stateMutability: "view",
        type: "function",
    },
    {
        inputs: [],
        name: "feeGrowthGlobal1X128",
        outputs: [
            {
                internalType: "uint256",
                name: "",
                type: "uint256",
            },
        ],
        stateMutability: "view",
        type: "function",
    },
    {
        inputs: [
            {
                internalType: "address",
                name: "recipient",
                type: "address",
            },
            {
                internalType: "uint256",
                name: "amount0",
                type: "uint256",
            },
            {
                internalType: "uint256",
                name: "amount1",
                type: "uint256",
            },
            {
                internalType: "bytes",
                name: "data",
                type: "bytes",
            },
        ],
        name: "flash",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function",
    },
    {
        inputs: [
            {
                internalType: "uint16",
                name: "observationCardinalityNext",
                type: "uint16",
            },
        ],
        name: "increaseObservationCardinalityNext",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function",
    },
    {
        inputs: [
            {
                internalType: "uint160",
                name: "sqrtPriceX96",
                type: "uint160",
            },
        ],
        name: "initialize",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function",
    },
    {
        inputs: [],
        name: "liquidity",
        outputs: [
            {
                internalType: "uint128",
                name: "",
                type: "uint128",
            },
        ],
        stateMutability: "view",
        type: "function",
    },
    {
        inputs: [],
        name: "maxLiquidityPerTick",
        outputs: [
            {
                internalType: "uint128",
                name: "",
                type: "uint128",
            },
        ],
        stateMutability: "view",
        type: "function",
    },
    {
        inputs: [
            {
                internalType: "address",
                name: "recipient",
                type: "address",
            },
            {
                internalType: "int24",
                name: "tickLower",
                type: "int24",
            },
            {
                internalType: "int24",
                name: "tickUpper",
                type: "int24",
            },
            {
                internalType: "uint128",
                name: "amount",
                type: "uint128",
            },
            {
                internalType: "bytes",
                name: "data",
                type: "bytes",
            },
        ],
        name: "mint",
        outputs: [
            {
                internalType: "uint256",
                name: "amount0",
                type: "uint256",
            },
            {
                internalType: "uint256",
                name: "amount1",
                type: "uint256",
            },
        ],
        stateMutability: "nonpayable",
        type: "function",
    },
    {
        inputs: [
            {
                internalType: "uint256",
                name: "",
                type: "uint256",
            },
        ],
        name: "observations",
        outputs: [
            {
                internalType: "uint32",
                name: "blockTimestamp",
                type: "uint32",
            },
            {
                internalType: "int56",
                name: "tickCumulative",
                type: "int56",
            },
            {
                internalType: "uint160",
                name: "secondsPerLiquidityCumulativeX128",
                type: "uint160",
            },
            {
                internalType: "bool",
                name: "initialized",
                type: "bool",
            },
        ],
        stateMutability: "view",
        type: "function",
    },
    {
        inputs: [
            {
                internalType: "uint32[]",
                name: "secondsAgos",
                type: "uint32[]",
            },
        ],
        name: "observe",
        outputs: [
            {
                internalType: "int56[]",
                name: "tickCumulatives",
                type: "int56[]",
            },
            {
                internalType: "uint160[]",
                name: "secondsPerLiquidityCumulativeX128s",
                type: "uint160[]",
            },
        ],
        stateMutability: "view",
        type: "function",
    },
    {
        inputs: [
            {
                internalType: "bytes32",
                name: "",
                type: "bytes32",
            },
        ],
        name: "positions",
        outputs: [
            {
                internalType: "uint128",
                name: "liquidity",
                type: "uint128",
            },
            {
                internalType: "uint256",
                name: "feeGrowthInside0LastX128",
                type: "uint256",
            },
            {
                internalType: "uint256",
                name: "feeGrowthInside1LastX128",
                type: "uint256",
            },
            {
                internalType: "uint128",
                name: "tokensOwed0",
                type: "uint128",
            },
            {
                internalType: "uint128",
                name: "tokensOwed1",
                type: "uint128",
            },
        ],
        stateMutability: "view",
        type: "function",
    },
    {
        inputs: [],
        name: "protocolFees",
        outputs: [
            {
                internalType: "uint128",
                name: "token0",
                type: "uint128",
            },
            {
                internalType: "uint128",
                name: "token1",
                type: "uint128",
            },
        ],
        stateMutability: "view",
        type: "function",
    },
    {
        inputs: [
            {
                internalType: "uint8",
                name: "feeProtocol0",
                type: "uint8",
            },
            {
                internalType: "uint8",
                name: "feeProtocol1",
                type: "uint8",
            },
        ],
        name: "setFeeProtocol",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function",
    },
    {
        inputs: [],
        name: "slot0",
        outputs: [
            {
                internalType: "uint160",
                name: "sqrtPriceX96",
                type: "uint160",
            },
            {
                internalType: "int24",
                name: "tick",
                type: "int24",
            },
            {
                internalType: "uint16",
                name: "observationIndex",
                type: "uint16",
            },
            {
                internalType: "uint16",
                name: "observationCardinality",
                type: "uint16",
            },
            {
                internalType: "uint16",
                name: "observationCardinalityNext",
                type: "uint16",
            },
            {
                internalType: "uint8",
                name: "feeProtocol",
                type: "uint8",
            },
            {
                internalType: "bool",
                name: "unlocked",
                type: "bool",
            },
        ],
        stateMutability: "view",
        type: "function",
    },
    {
        inputs: [
            {
                internalType: "int24",
                name: "tickLower",
                type: "int24",
            },
            {
                internalType: "int24",
                name: "tickUpper",
                type: "int24",
            },
        ],
        name: "snapshotCumulativesInside",
        outputs: [
            {
                internalType: "int56",
                name: "tickCumulativeInside",
                type: "int56",
            },
            {
                internalType: "uint160",
                name: "secondsPerLiquidityInsideX128",
                type: "uint160",
            },
            {
                internalType: "uint32",
                name: "secondsInside",
                type: "uint32",
            },
        ],
        stateMutability: "view",
        type: "function",
    },
    {
        inputs: [
            {
                internalType: "address",
                name: "recipient",
                type: "address",
            },
            {
                internalType: "bool",
                name: "zeroForOne",
                type: "bool",
            },
            {
                internalType: "int256",
                name: "amountSpecified",
                type: "int256",
            },
            {
                internalType: "uint160",
                name: "sqrtPriceLimitX96",
                type: "uint160",
            },
            {
                internalType: "bytes",
                name: "data",
                type: "bytes",
            },
        ],
        name: "swap",
        outputs: [
            {
                internalType: "int256",
                name: "amount0",
                type: "int256",
            },
            {
                internalType: "int256",
                name: "amount1",
                type: "int256",
            },
        ],
        stateMutability: "nonpayable",
        type: "function",
    },
    {
        inputs: [
            {
                internalType: "int16",
                name: "",
                type: "int16",
            },
        ],
        name: "tickBitmap",
        outputs: [
            {
                internalType: "uint256",
                name: "",
                type: "uint256",
            },
        ],
        stateMutability: "view",
        type: "function",
    },
    {
        inputs: [],
        name: "tickSpacing",
        outputs: [
            {
                internalType: "int24",
                name: "",
                type: "int24",
            },
        ],
        stateMutability: "view",
        type: "function",
    },
    {
        inputs: [
            {
                internalType: "int24",
                name: "",
                type: "int24",
            },
        ],
        name: "ticks",
        outputs: [
            {
                internalType: "uint128",
                name: "liquidityGross",
                type: "uint128",
            },
            {
                internalType: "int128",
                name: "liquidityNet",
                type: "int128",
            },
            {
                internalType: "uint256",
                name: "feeGrowthOutside0X128",
                type: "uint256",
            },
            {
                internalType: "uint256",
                name: "feeGrowthOutside1X128",
                type: "uint256",
            },
            {
                internalType: "int56",
                name: "tickCumulativeOutside",
                type: "int56",
            },
            {
                internalType: "uint160",
                name: "secondsPerLiquidityOutsideX128",
                type: "uint160",
            },
            {
                internalType: "uint32",
                name: "secondsOutside",
                type: "uint32",
            },
            {
                internalType: "bool",
                name: "initialized",
                type: "bool",
            },
        ],
        stateMutability: "view",
        type: "function",
    },
    {
        inputs: [],
        name: "token0",
        outputs: [
            {
                internalType: "address",
                name: "",
                type: "address",
            },
        ],
        stateMutability: "view",
        type: "function",
    },
    {
        inputs: [],
        name: "token1",
        outputs: [
            {
                internalType: "address",
                name: "",
                type: "address",
            },
        ],
        stateMutability: "view",
        type: "function",
    },
];
const _bytecode = "0x6101606040523480156200001257600080fd5b503060601b60805260408051630890357360e41b81529051600091339163890357309160048082019260a092909190829003018186803b1580156200005657600080fd5b505afa1580156200006b573d6000803e3d6000fd5b505050506040513d60a08110156200008257600080fd5b508051602080830151604084015160608086015160809096015160e896871b6001600160e81b0319166101005291811b6001600160601b031990811660e05292811b831660c0529390931b1660a052600282810b900b90921b610120529150620000f79082906200010f811b62002b8417901c565b60801b6001600160801b03191661014052506200017d565b60008082600281900b620d89e719816200012557fe5b05029050600083600281900b620d89e8816200013d57fe5b0502905060008460020b83830360020b816200015557fe5b0560010190508062ffffff166001600160801b038016816200017357fe5b0495945050505050565b60805160601c60a05160601c60c05160601c60e05160601c6101005160e81c6101205160e81c6101405160801c61567e6200024a60003980611fee5280614b5f5280614b96525080610c0052806128fd5280614bca5280614bfc525080610cef52806119cb5280611a0252806129455250806111c75280611a855280611ef4528061244452806129215280613e6b5250806108d252806112f55280611a545280611e8e52806123be5280613d2252508061207b528061227d52806128d9525080612bfb525061567e6000f3fe608060405234801561001057600080fd5b50600436106101ae5760003560e01c806370cf754a116100ee578063c45a015511610097578063ddca3f4311610071578063ddca3f4314610800578063f305839914610820578063f30dba9314610828578063f637731d146108aa576101ae565b8063c45a0155146107d1578063d0c93a7c146107d9578063d21220a7146107f8576101ae565b8063883bdbfd116100c8578063883bdbfd14610633578063a34123a71461073c578063a38807f214610776576101ae565b806370cf754a146105c65780638206a4d1146105ce57806385b66729146105f6576101ae565b80633850c7bd1161015b578063490e6cbc11610135578063490e6cbc146104705780634f1eb3d8146104fc578063514ea4bf1461054d5780635339c296146105a6576101ae565b80633850c7bd1461035b5780633c8a7d8d146103b45780634614131914610456576101ae565b80631ad8b03b1161018c5780631ad8b03b146102aa578063252c09d7146102e157806332148f6714610338576101ae565b80630dfe1681146101b3578063128acb08146101d75780631a68650214610286575b600080fd5b6101bb6108d0565b604080516001600160a01b039092168252519081900360200190f35b61026d600480360360a08110156101ed57600080fd5b6001600160a01b0382358116926020810135151592604082013592606083013516919081019060a08101608082013564010000000081111561022e57600080fd5b82018360208201111561024057600080fd5b8035906020019184600183028401116401000000008311171561026257600080fd5b5090925090506108f4565b6040805192835260208301919091528051918290030190f35b61028e6114ad565b604080516001600160801b039092168252519081900360200190f35b6102b26114bc565b60405180836001600160801b03168152602001826001600160801b031681526020019250505060405180910390f35b6102fe600480360360208110156102f757600080fd5b50356114d6565b6040805163ffffffff909516855260069390930b60208501526001600160a01b039091168383015215156060830152519081900360800190f35b6103596004803603602081101561034e57600080fd5b503561ffff1661151c565b005b610363611616565b604080516001600160a01b03909816885260029690960b602088015261ffff9485168787015292841660608701529216608085015260ff90911660a0840152151560c0830152519081900360e00190f35b61026d600480360360a08110156103ca57600080fd5b6001600160a01b03823516916020810135600290810b92604083013590910b916001600160801b036060820135169181019060a08101608082013564010000000081111561041757600080fd5b82018360208201111561042957600080fd5b8035906020019184600183028401116401000000008311171561044b57600080fd5b509092509050611666565b61045e611922565b60408051918252519081900360200190f35b6103596004803603608081101561048657600080fd5b6001600160a01b0382351691602081013591604082013591908101906080810160608201356401000000008111156104bd57600080fd5b8201836020820111156104cf57600080fd5b803590602001918460018302840111640100000000831117156104f157600080fd5b509092509050611928565b6102b2600480360360a081101561051257600080fd5b506001600160a01b03813516906020810135600290810b91604081013590910b906001600160801b0360608201358116916080013516611d83565b61056a6004803603602081101561056357600080fd5b5035611f9d565b604080516001600160801b0396871681526020810195909552848101939093529084166060840152909216608082015290519081900360a00190f35b61045e600480360360208110156105bc57600080fd5b503560010b611fda565b61028e611fec565b610359600480360360408110156105e457600080fd5b5060ff81358116916020013516612010565b6102b26004803603606081101561060c57600080fd5b506001600160a01b03813516906001600160801b036020820135811691604001351661220f565b6106a36004803603602081101561064957600080fd5b81019060208101813564010000000081111561066457600080fd5b82018360208201111561067657600080fd5b8035906020019184602083028401116401000000008311171561069857600080fd5b5090925090506124dc565b604051808060200180602001838103835285818151815260200191508051906020019060200280838360005b838110156106e75781810151838201526020016106cf565b50505050905001838103825284818151815260200191508051906020019060200280838360005b8381101561072657818101518382015260200161070e565b5050505090500194505050505060405180910390f35b61026d6004803603606081101561075257600080fd5b508035600290810b91602081013590910b90604001356001600160801b0316612569565b6107a06004803603604081101561078c57600080fd5b508035600290810b9160200135900b6126e0565b6040805160069490940b84526001600160a01b03909216602084015263ffffffff1682820152519081900360600190f35b6101bb6128d7565b6107e16128fb565b6040805160029290920b8252519081900360200190f35b6101bb61291f565b610808612943565b6040805162ffffff9092168252519081900360200190f35b61045e612967565b6108486004803603602081101561083e57600080fd5b503560020b61296d565b604080516001600160801b039099168952600f9790970b602089015287870195909552606087019390935260069190910b60808601526001600160a01b031660a085015263ffffffff1660c0840152151560e083015251908190036101000190f35b610359600480360360208110156108c057600080fd5b50356001600160a01b03166129db565b7f000000000000000000000000000000000000000000000000000000000000000081565b6000806108ff612bf0565b85610936576040805162461bcd60e51b8152602060048201526002602482015261415360f01b604482015290519081900360640190fd5b6040805160e0810182526000546001600160a01b0381168252600160a01b8104600290810b810b900b602083015261ffff600160b81b8204811693830193909352600160c81b810483166060830152600160d81b8104909216608082015260ff600160e81b8304811660a0830152600160f01b909204909116151560c082018190526109ef576040805162461bcd60e51b81526020600482015260036024820152624c4f4b60e81b604482015290519081900360640190fd5b87610a3a5780600001516001600160a01b0316866001600160a01b0316118015610a35575073fffd8963efd1fc6a506488495d951d5263988d266001600160a01b038716105b610a6c565b80600001516001600160a01b0316866001600160a01b0316108015610a6c57506401000276a36001600160a01b038716115b610aa3576040805162461bcd60e51b815260206004820152600360248201526214d41360ea1b604482015290519081900360640190fd5b6000805460ff60f01b191681556040805160c08101909152808a610ad25760048460a0015160ff16901c610ae5565b60108460a0015160ff1681610ae357fe5b065b60ff1681526004546001600160801b03166020820152604001610b06612c27565b63ffffffff168152602001600060060b815260200160006001600160a01b031681526020016000151581525090506000808913905060006040518060e001604052808b81526020016000815260200185600001516001600160a01b03168152602001856020015160020b81526020018c610b8257600254610b86565b6001545b815260200160006001600160801b0316815260200184602001516001600160801b031681525090505b805115801590610bd55750886001600160a01b031681604001516001600160a01b031614155b15610f9f57610be261560e565b60408201516001600160a01b031681526060820151610c25906006907f00000000000000000000000000000000000000000000000000000000000000008f612c2b565b15156040830152600290810b810b60208301819052620d89e719910b1215610c5657620d89e7196020820152610c75565b6020810151620d89e860029190910b1315610c7557620d89e860208201525b610c828160200151612d6d565b6001600160a01b031660608201526040820151610d13908d610cbc578b6001600160a01b031683606001516001600160a01b031611610cd6565b8b6001600160a01b031683606001516001600160a01b0316105b610ce4578260600151610ce6565b8b5b60c085015185517f000000000000000000000000000000000000000000000000000000000000000061309f565b60c085015260a084015260808301526001600160a01b031660408301528215610d7557610d498160c00151826080015101613291565b825103825260a0810151610d6b90610d6090613291565b6020840151906132a7565b6020830152610db0565b610d828160a00151613291565b825101825260c08101516080820151610daa91610d9f9101613291565b6020840151906132c3565b60208301525b835160ff1615610df6576000846000015160ff168260c0015181610dd057fe5b60c0840180519290910491829003905260a0840180519091016001600160801b03169052505b60c08201516001600160801b031615610e3557610e298160c00151600160801b8460c001516001600160801b03166132d9565b60808301805190910190525b80606001516001600160a01b031682604001516001600160a01b03161415610f5e57806040015115610f35578360a00151610ebf57610e9d846040015160008760200151886040015188602001518a606001516008613389909695949392919063ffffffff16565b6001600160a01b03166080860152600690810b900b6060850152600160a08501525b6000610f0b82602001518e610ed657600154610edc565b84608001515b8f610eeb578560800151610eef565b6002545b608089015160608a015160408b0151600595949392919061351c565b90508c15610f17576000035b610f258360c00151826135ef565b6001600160801b031660c0840152505b8b610f44578060200151610f4d565b60018160200151035b600290810b900b6060830152610f99565b80600001516001600160a01b031682604001516001600160a01b031614610f9957610f8c82604001516136a5565b600290810b900b60608301525b50610baf565b836020015160020b816060015160020b1461107a57600080610fed86604001518660400151886020015188602001518a606001518b6080015160086139d1909695949392919063ffffffff16565b604085015160608601516000805461ffff60c81b1916600160c81b61ffff958616021761ffff60b81b1916600160b81b95909416949094029290921762ffffff60a01b1916600160a01b62ffffff60029490940b93909316929092029190911773ffffffffffffffffffffffffffffffffffffffff19166001600160a01b03909116179055506110ac9050565b60408101516000805473ffffffffffffffffffffffffffffffffffffffff19166001600160a01b039092169190911790555b8060c001516001600160801b031683602001516001600160801b0316146110f25760c0810151600480546001600160801b0319166001600160801b039092169190911790555b8a1561114257608081015160015560a08101516001600160801b03161561113d5760a0810151600380546001600160801b031981166001600160801b03918216909301169190911790555b611188565b608081015160025560a08101516001600160801b0316156111885760a0810151600380546001600160801b03808216600160801b92839004821690940116029190911790555b8115158b1515146111a157602081015181518b036111ae565b80600001518a0381602001515b90965094508a156112e75760008512156111f0576111f07f00000000000000000000000000000000000000000000000000000000000000008d87600003613b86565b60006111fa613cd4565b9050336001600160a01b031663fa461e3388888c8c6040518563ffffffff1660e01b815260040180858152602001848152602001806020018281038252848482818152602001925080828437600081840152601f19601f82011690508083019250505095505050505050600060405180830381600087803b15801561127e57600080fd5b505af1158015611292573d6000803e3d6000fd5b5050505061129e613cd4565b6112a88289613e0d565b11156112e1576040805162461bcd60e51b815260206004820152600360248201526249494160e81b604482015290519081900360640190fd5b50611411565b600086121561131e5761131e7f00000000000000000000000000000000000000000000000000000000000000008d88600003613b86565b6000611328613e1d565b9050336001600160a01b031663fa461e3388888c8c6040518563ffffffff1660e01b815260040180858152602001848152602001806020018281038252848482818152602001925080828437600081840152601f19601f82011690508083019250505095505050505050600060405180830381600087803b1580156113ac57600080fd5b505af11580156113c0573d6000803e3d6000fd5b505050506113cc613e1d565b6113d68288613e0d565b111561140f576040805162461bcd60e51b815260206004820152600360248201526249494160e81b604482015290519081900360640190fd5b505b60408082015160c083015160608085015184518b8152602081018b90526001600160a01b03948516818701526001600160801b039093169183019190915260020b60808201529151908e169133917fc42079f94a6350d7e6235f29174924f928cc2ac818eb64fed8004e115fbcca679181900360a00190a350506000805460ff60f01b1916600160f01b17905550919890975095505050505050565b6004546001600160801b031681565b6003546001600160801b0380821691600160801b90041682565b60088161ffff81106114e757600080fd5b015463ffffffff81169150640100000000810460060b90600160581b81046001600160a01b031690600160f81b900460ff1684565b600054600160f01b900460ff16611560576040805162461bcd60e51b81526020600482015260036024820152624c4f4b60e81b604482015290519081900360640190fd5b6000805460ff60f01b19169055611575612bf0565b60008054600160d81b900461ffff169061159160088385613eb5565b6000805461ffff808416600160d81b810261ffff60d81b19909316929092179092559192508316146115fe576040805161ffff80851682528316602082015281517fac49e518f90a358f652e4400164f05a5d8f7e35e7747279bc3a93dbf584e125a929181900390910190a15b50506000805460ff60f01b1916600160f01b17905550565b6000546001600160a01b03811690600160a01b810460020b9061ffff600160b81b8204811691600160c81b8104821691600160d81b8204169060ff600160e81b8204811691600160f01b90041687565b600080548190600160f01b900460ff166116ad576040805162461bcd60e51b81526020600482015260036024820152624c4f4b60e81b604482015290519081900360640190fd5b6000805460ff60f01b191690556001600160801b0385166116cd57600080fd5b60008061171b60405180608001604052808c6001600160a01b031681526020018b60020b81526020018a60020b81526020016117118a6001600160801b0316613f58565b600f0b9052613f69565b9250925050819350809250600080600086111561173d5761173a613cd4565b91505b841561174e5761174b613e1d565b90505b336001600160a01b031663d348799787878b8b6040518563ffffffff1660e01b815260040180858152602001848152602001806020018281038252848482818152602001925080828437600081840152601f19601f82011690508083019250505095505050505050600060405180830381600087803b1580156117d057600080fd5b505af11580156117e4573d6000803e3d6000fd5b50505050600086111561183b576117f9613cd4565b6118038388613e0d565b111561183b576040805162461bcd60e51b815260206004820152600260248201526104d360f41b604482015290519081900360640190fd5b841561188b57611849613e1d565b6118538287613e0d565b111561188b576040805162461bcd60e51b81526020600482015260026024820152614d3160f01b604482015290519081900360640190fd5b8960020b8b60020b8d6001600160a01b03167f7a53080ba414158be7ec69b987b5fb7d07dee101fe85488f0853ae16239d0bde338d8b8b60405180856001600160a01b03168152602001846001600160801b0316815260200183815260200182815260200194505050505060405180910390a450506000805460ff60f01b1916600160f01b17905550919890975095505050505050565b60025481565b600054600160f01b900460ff1661196c576040805162461bcd60e51b81526020600482015260036024820152624c4f4b60e81b604482015290519081900360640190fd5b6000805460ff60f01b19169055611981612bf0565b6004546001600160801b0316806119c3576040805162461bcd60e51b81526020600482015260016024820152601360fa1b604482015290519081900360640190fd5b60006119f8867f000000000000000000000000000000000000000000000000000000000000000062ffffff16620f42406141a9565b90506000611a2f867f000000000000000000000000000000000000000000000000000000000000000062ffffff16620f42406141a9565b90506000611a3b613cd4565b90506000611a47613e1d565b90508815611a7a57611a7a7f00000000000000000000000000000000000000000000000000000000000000008b8b613b86565b8715611aab57611aab7f00000000000000000000000000000000000000000000000000000000000000008b8a613b86565b336001600160a01b031663e9cbafb085858a8a6040518563ffffffff1660e01b815260040180858152602001848152602001806020018281038252848482818152602001925080828437600081840152601f19601f82011690508083019250505095505050505050600060405180830381600087803b158015611b2d57600080fd5b505af1158015611b41573d6000803e3d6000fd5b505050506000611b4f613cd4565b90506000611b5b613e1d565b905081611b688588613e0d565b1115611ba0576040805162461bcd60e51b8152602060048201526002602482015261046360f41b604482015290519081900360640190fd5b80611bab8487613e0d565b1115611be3576040805162461bcd60e51b8152602060048201526002602482015261463160f01b604482015290519081900360640190fd5b8382038382038115611c725760008054600160e81b9004600f16908115611c16578160ff168481611c1057fe5b04611c19565b60005b90506001600160801b03811615611c4c57600380546001600160801b038082168401166001600160801b03199091161790555b611c66818503600160801b8d6001600160801b03166132d9565b60018054909101905550505b8015611cfd5760008054600160e81b900460041c600f16908115611ca2578160ff168381611c9c57fe5b04611ca5565b60005b90506001600160801b03811615611cd757600380546001600160801b03600160801b8083048216850182160291161790555b611cf1818403600160801b8d6001600160801b03166132d9565b60028054909101905550505b8d6001600160a01b0316336001600160a01b03167fbdbdb71d7860376ba52b25a5028beea23581364a40522f6bcfb86bb1f2dca6338f8f86866040518085815260200184815260200183815260200182815260200194505050505060405180910390a350506000805460ff60f01b1916600160f01b179055505050505050505050505050565b600080548190600160f01b900460ff16611dca576040805162461bcd60e51b81526020600482015260036024820152624c4f4b60e81b604482015290519081900360640190fd5b6000805460ff60f01b19168155611de460073389896141e3565b60038101549091506001600160801b0390811690861611611e055784611e14565b60038101546001600160801b03165b60038201549093506001600160801b03600160801b909104811690851611611e3c5783611e52565b6003810154600160801b90046001600160801b03165b91506001600160801b03831615611eb7576003810180546001600160801b031981166001600160801b03918216869003821617909155611eb7907f0000000000000000000000000000000000000000000000000000000000000000908a908616613b86565b6001600160801b03821615611f1d576003810180546001600160801b03600160801b808304821686900382160291811691909117909155611f1d907f0000000000000000000000000000000000000000000000000000000000000000908a908516613b86565b604080516001600160a01b038a1681526001600160801b0380861660208301528416818301529051600288810b92908a900b9133917f70935338e69775456a85ddef226c395fb668b63fa0115f5f20610b388e6ca9c0919081900360600190a4506000805460ff60f01b1916600160f01b17905590969095509350505050565b60076020526000908152604090208054600182015460028301546003909301546001600160801b0392831693919281811691600160801b90041685565b60066020526000908152604090205481565b7f000000000000000000000000000000000000000000000000000000000000000081565b600054600160f01b900460ff16612054576040805162461bcd60e51b81526020600482015260036024820152624c4f4b60e81b604482015290519081900360640190fd5b6000805460ff60f01b1916905560408051638da5cb5b60e01b815290516001600160a01b037f00000000000000000000000000000000000000000000000000000000000000001691638da5cb5b916004808301926020929190829003018186803b1580156120c157600080fd5b505afa1580156120d5573d6000803e3d6000fd5b505050506040513d60208110156120eb57600080fd5b50516001600160a01b0316331461210157600080fd5b60ff82161580612124575060048260ff16101580156121245750600a8260ff1611155b801561214e575060ff8116158061214e575060048160ff161015801561214e5750600a8160ff1611155b61215757600080fd5b60008054610ff0600484901b16840160ff908116600160e81b9081027fffff00ffffffffffffffffffffffffffffffffffffffffffffffffffffffffff841617909355919004167f973d8d92bb299f4af6ce49b52a8adb85ae46b9f214c4c4fc06ac77401237b1336010826040805160ff9390920683168252600f600486901c16602083015286831682820152918516606082015290519081900360800190a150506000805460ff60f01b1916600160f01b17905550565b600080548190600160f01b900460ff16612256576040805162461bcd60e51b81526020600482015260036024820152624c4f4b60e81b604482015290519081900360640190fd5b6000805460ff60f01b1916905560408051638da5cb5b60e01b815290516001600160a01b037f00000000000000000000000000000000000000000000000000000000000000001691638da5cb5b916004808301926020929190829003018186803b1580156122c357600080fd5b505afa1580156122d7573d6000803e3d6000fd5b505050506040513d60208110156122ed57600080fd5b50516001600160a01b0316331461230357600080fd5b6003546001600160801b039081169085161161231f578361232c565b6003546001600160801b03165b6003549092506001600160801b03600160801b9091048116908416116123525782612366565b600354600160801b90046001600160801b03165b90506001600160801b038216156123e7576003546001600160801b038381169116141561239557600019909101905b600380546001600160801b031981166001600160801b039182168590038216179091556123e7907f00000000000000000000000000000000000000000000000000000000000000009087908516613b86565b6001600160801b0381161561246d576003546001600160801b03828116600160801b90920416141561241857600019015b600380546001600160801b03600160801b80830482168590038216029181169190911790915561246d907f00000000000000000000000000000000000000000000000000000000000000009087908416613b86565b604080516001600160801b0380851682528316602082015281516001600160a01b0388169233927f596b573906218d3411850b26a6b437d6c4522fdb43d2d2386263f86d50b8b151929081900390910190a36000805460ff60f01b1916600160f01b1790559094909350915050565b6060806124e7612bf0565b61255e6124f2612c27565b858580806020026020016040519081016040528093929190818152602001838360200280828437600092018290525054600454600896959450600160a01b820460020b935061ffff600160b81b8304811693506001600160801b0390911691600160c81b900416614247565b915091509250929050565b600080548190600160f01b900460ff166125b0576040805162461bcd60e51b81526020600482015260036024820152624c4f4b60e81b604482015290519081900360640190fd5b6000805460ff60f01b1916815560408051608081018252338152600288810b602083015287900b918101919091528190819061260990606081016125fc6001600160801b038a16613f58565b600003600f0b9052613f69565b925092509250816000039450806000039350600085118061262a5750600084115b15612669576003830180546001600160801b038082168089018216600160801b93849004831689019092169092029091176001600160801b0319161790555b604080516001600160801b0388168152602081018790528082018690529051600289810b92908b900b9133917f0c396cd989a39f4459b5fa1aed6a9a8dcdbc45908acfd67e028cd568da98982c919081900360600190a450506000805460ff60f01b1916600160f01b179055509094909350915050565b60008060006126ed612bf0565b6126f785856143a1565b600285810b810b60009081526005602052604080822087840b90930b825281206003830154600681900b9367010000000000000082046001600160a01b0316928492600160d81b810463ffffffff169284929091600160f81b900460ff168061275f57600080fd5b6003820154600681900b985067010000000000000081046001600160a01b03169650600160d81b810463ffffffff169450600160f81b900460ff16806127a457600080fd5b50506040805160e0810182526000546001600160a01b0381168252600160a01b8104600290810b810b810b6020840181905261ffff600160b81b8404811695850195909552600160c81b830485166060850152600160d81b8304909416608084015260ff600160e81b8304811660a0850152600160f01b909204909116151560c08301529093508e810b91900b1215905061284d575093909403965090039350900390506128d0565b8a60020b816020015160020b12156128c1576000612869612c27565b602083015160408401516004546060860151939450600093849361289f936008938893879392916001600160801b031690613389565b9a9003989098039b5050949096039290920396509091030392506128d0915050565b50949093039650039350900390505b9250925092565b7f000000000000000000000000000000000000000000000000000000000000000081565b7f000000000000000000000000000000000000000000000000000000000000000081565b7f000000000000000000000000000000000000000000000000000000000000000081565b7f000000000000000000000000000000000000000000000000000000000000000081565b60015481565b60056020526000908152604090208054600182015460028301546003909301546001600160801b03831693600160801b909304600f0b9290600681900b9067010000000000000081046001600160a01b031690600160d81b810463ffffffff1690600160f81b900460ff1688565b6000546001600160a01b031615612a1e576040805162461bcd60e51b8152602060048201526002602482015261414960f01b604482015290519081900360640190fd5b6000612a29826136a5565b9050600080612a41612a39612c27565b60089061446a565b6040805160e0810182526001600160a01b038816808252600288810b6020808501829052600085870181905261ffff898116606088018190529089166080880181905260a08801839052600160c0909801979097528154600160f01b73ffffffffffffffffffffffffffffffffffffffff19909116871762ffffff60a01b1916600160a01b62ffffff9787900b9790971696909602959095177fffffffffff00000000ffffffffffffffffffffffffffffffffffffffffffffff16600160c81b9091021761ffff60d81b1916600160d81b909602959095177fff0000ffffffffffffffffffffffffffffffffffffffffffffffffffffffffff1692909217909355835191825281019190915281519395509193507f98636036cb66a9c19a37435efc1e90142190214e8abeb821bdba3f2990dd4c9592918290030190a150505050565b60008082600281900b620d89e71981612b9957fe5b05029050600083600281900b620d89e881612bb057fe5b0502905060008460020b83830360020b81612bc757fe5b0560010190508062ffffff166001600160801b03801681612be457fe5b0493505050505b919050565b306001600160a01b037f00000000000000000000000000000000000000000000000000000000000000001614612c2557600080fd5b565b4290565b60008060008460020b8660020b81612c3f57fe5b05905060008660020b128015612c6657508460020b8660020b81612c5f57fe5b0760020b15155b15612c7057600019015b8315612ce557600080612c82836144b6565b600182810b810b600090815260208d9052604090205460ff83169190911b80016000190190811680151597509294509092509085612cc757888360ff16860302612cda565b88612cd1826144c8565b840360ff168603025b965050505050612d63565b600080612cf4836001016144b6565b91509150600060018260ff166001901b031990506000818b60008660010b60010b8152602001908152602001600020541690508060001415955085612d4657888360ff0360ff16866001010102612d5c565b8883612d5183614568565b0360ff168660010101025b9650505050505b5094509492505050565b60008060008360020b12612d84578260020b612d8c565b8260020b6000035b9050620d89e8811115612dca576040805162461bcd60e51b81526020600482015260016024820152601560fa1b604482015290519081900360640190fd5b600060018216612dde57600160801b612df0565b6ffffcb933bd6fad37aa2d162d1a5940015b70ffffffffffffffffffffffffffffffffff1690506002821615612e24576ffff97272373d413259a46990580e213a0260801c5b6004821615612e43576ffff2e50f5f656932ef12357cf3c7fdcc0260801c5b6008821615612e62576fffe5caca7e10e4e61c3624eaa0941cd00260801c5b6010821615612e81576fffcb9843d60f6159c9db58835c9266440260801c5b6020821615612ea0576fff973b41fa98c081472e6896dfb254c00260801c5b6040821615612ebf576fff2ea16466c96a3843ec78b326b528610260801c5b6080821615612ede576ffe5dee046a99a2a811c461f1969c30530260801c5b610100821615612efe576ffcbe86c7900a88aedcffc83b479aa3a40260801c5b610200821615612f1e576ff987a7253ac413176f2b074cf7815e540260801c5b610400821615612f3e576ff3392b0822b70005940c7a398e4b70f30260801c5b610800821615612f5e576fe7159475a2c29b7443b29c7fa6e889d90260801c5b611000821615612f7e576fd097f3bdfd2022b8845ad8f792aa58250260801c5b612000821615612f9e576fa9f746462d870fdf8a65dc1f90e061e50260801c5b614000821615612fbe576f70d869a156d2a1b890bb3df62baf32f70260801c5b618000821615612fde576f31be135f97d08fd981231505542fcfa60260801c5b62010000821615612fff576f09aa508b5b7a84e1c677de54f3e99bc90260801c5b6202000082161561301f576e5d6af8dedb81196699c329225ee6040260801c5b6204000082161561303e576d2216e584f5fa1ea926041bedfe980260801c5b6208000082161561305b576b048a170391f7dc42444e8fa20260801c5b60008460020b131561307657806000198161307257fe5b0490505b64010000000081061561308a57600161308d565b60005b60ff16602082901c0192505050919050565b60008080806001600160a01b03808916908a1610158187128015906131245760006130d88989620f42400362ffffff16620f42406132d9565b9050826130f1576130ec8c8c8c6001614652565b6130fe565b6130fe8b8d8c60016146cd565b955085811061310f578a965061311e565b61311b8c8b838661478a565b96505b5061316e565b8161313b576131368b8b8b60006146cd565b613148565b6131488a8c8b6000614652565b935083886000031061315c5789955061316e565b61316b8b8a8a600003856147d6565b95505b6001600160a01b038a81169087161482156131d15780801561318d5750815b6131a35761319e878d8c60016146cd565b6131a5565b855b95508080156131b2575081155b6131c8576131c3878d8c6000614652565b6131ca565b845b945061321b565b8080156131db5750815b6131f1576131ec8c888c6001614652565b6131f3565b855b9550808015613200575081155b613216576132118c888c60006146cd565b613218565b845b94505b8115801561322b57508860000385115b15613237578860000394505b81801561325657508a6001600160a01b0316876001600160a01b031614155b15613265578589039350613282565b61327f868962ffffff168a620f42400362ffffff166141a9565b93505b50505095509550955095915050565b6000600160ff1b82106132a357600080fd5b5090565b808203828113156000831215146132bd57600080fd5b92915050565b818101828112156000831215146132bd57600080fd5b600080806000198587098686029250828110908390030390508061330f576000841161330457600080fd5b508290049050613382565b80841161331b57600080fd5b6000848688096000868103871696879004966002600389028118808a02820302808a02820302808a02820302808a02820302808a02820302808a02909103029181900381900460010186841190950394909402919094039290920491909117919091029150505b9392505050565b60008063ffffffff8716613430576000898661ffff1661ffff81106133aa57fe5b60408051608081018252919092015463ffffffff8082168084526401000000008304600690810b810b900b6020850152600160581b83046001600160a01b031694840194909452600160f81b90910460ff16151560608301529092508a161461341c57613419818a8988614822565b90505b806020015181604001519250925050613510565b8688036000806134458c8c858c8c8c8c6148d2565b91509150816000015163ffffffff168363ffffffff161415613477578160200151826040015194509450505050613510565b805163ffffffff8481169116141561349f578060200151816040015194509450505050613510565b8151815160208085015190840151918390039286039163ffffffff80841692908516910360060b816134cd57fe5b05028460200151018263ffffffff168263ffffffff1686604001518660400151036001600160a01b031602816134ff57fe5b048560400151019650965050505050505b97509795505050505050565b600295860b860b60009081526020979097526040909620600181018054909503909455938301805490920390915560038201805463ffffffff600160d81b6001600160a01b036701000000000000008085048216909603169094027fffffffffff0000000000000000000000000000000000000000ffffffffffffff90921691909117600681810b90960390950b66ffffffffffffff1666ffffffffffffff199095169490941782810485169095039093160263ffffffff60d81b1990931692909217905554600160801b9004600f0b90565b60008082600f0b121561365457826001600160801b03168260000384039150816001600160801b03161061364f576040805162461bcd60e51b81526020600482015260026024820152614c5360f01b604482015290519081900360640190fd5b6132bd565b826001600160801b03168284019150816001600160801b031610156132bd576040805162461bcd60e51b81526020600482015260026024820152614c4160f01b604482015290519081900360640190fd5b60006401000276a36001600160a01b038316108015906136e1575073fffd8963efd1fc6a506488495d951d5263988d266001600160a01b038316105b613716576040805162461bcd60e51b81526020600482015260016024820152602960f91b604482015290519081900360640190fd5b77ffffffffffffffffffffffffffffffffffffffff00000000602083901b166001600160801b03811160071b81811c67ffffffffffffffff811160061b90811c63ffffffff811160051b90811c61ffff811160041b90811c60ff8111600390811b91821c600f811160021b90811c918211600190811b92831c979088119617909417909217179091171717608081106137b757607f810383901c91506137c1565b80607f0383901b91505b908002607f81811c60ff83811c9190911c800280831c81831c1c800280841c81841c1c800280851c81851c1c800280861c81861c1c800280871c81871c1c800280881c81881c1c800280891c81891c1c8002808a1c818a1c1c8002808b1c818b1c1c8002808c1c818c1c1c8002808d1c818d1c1c8002808e1c9c81901c9c909c1c80029c8d901c9e9d607f198f0160401b60c09190911c678000000000000000161760c19b909b1c674000000000000000169a909a1760c29990991c672000000000000000169890981760c39790971c671000000000000000169690961760c49590951c670800000000000000169490941760c59390931c670400000000000000169290921760c69190911c670200000000000000161760c79190911c670100000000000000161760c89190911c6680000000000000161760c99190911c6640000000000000161760ca9190911c6620000000000000161760cb9190911c6610000000000000161760cc9190911c6608000000000000161760cd9190911c66040000000000001617693627a301d71055774c8581026f028f6481ab7f045a5af012a19d003aa9198101608090811d906fdb2df09e81959a81455e260799a0632f8301901d600281810b9083900b146139c257886001600160a01b03166139a682612d6d565b6001600160a01b031611156139bb57816139bd565b805b6139c4565b815b9998505050505050505050565b6000806000898961ffff1661ffff81106139e757fe5b60408051608081018252919092015463ffffffff8082168084526401000000008304600690810b810b900b6020850152600160581b83046001600160a01b031694840194909452600160f81b90910460ff161515606083015290925089161415613a575788859250925050613510565b8461ffff168461ffff16118015613a7857506001850361ffff168961ffff16145b15613a8557839150613a89565b8491505b8161ffff168960010161ffff1681613a9d57fe5b069250613aac81898989614822565b8a8461ffff1661ffff8110613abd57fe5b825191018054602084015160408501516060909501511515600160f81b027effffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff6001600160a01b03909616600160581b027fff0000000000000000000000000000000000000000ffffffffffffffffffffff60069390930b66ffffffffffffff16640100000000026affffffffffffff000000001963ffffffff90971663ffffffff199095169490941795909516929092171692909217929092161790555097509795505050505050565b604080516001600160a01b038481166024830152604480830185905283518084039091018152606490920183526020820180516001600160e01b031663a9059cbb60e01b1781529251825160009485949389169392918291908083835b60208310613c025780518252601f199092019160209182019101613be3565b6001836020036101000a0380198251168184511680821785525050505050509050019150506000604051808303816000865af19150503d8060008114613c64576040519150601f19603f3d011682016040523d82523d6000602084013e613c69565b606091505b5091509150818015613c97575080511580613c975750808060200190516020811015613c9457600080fd5b50515b613ccd576040805162461bcd60e51b81526020600482015260026024820152612a2360f11b604482015290519081900360640190fd5b5050505050565b604080513060248083019190915282518083039091018152604490910182526020810180516001600160e01b03166370a0823160e01b17815291518151600093849384936001600160a01b037f00000000000000000000000000000000000000000000000000000000000000001693919290918291908083835b60208310613d6d5780518252601f199092019160209182019101613d4e565b6001836020036101000a038019825116818451168082178552505050505050905001915050600060405180830381855afa9150503d8060008114613dcd576040519150601f19603f3d011682016040523d82523d6000602084013e613dd2565b606091505b5091509150818015613de657506020815110155b613def57600080fd5b808060200190516020811015613e0457600080fd5b50519250505090565b808201828110156132bd57600080fd5b604080513060248083019190915282518083039091018152604490910182526020810180516001600160e01b03166370a0823160e01b17815291518151600093849384936001600160a01b037f000000000000000000000000000000000000000000000000000000000000000016939192909182919080838360208310613d6d5780518252601f199092019160209182019101613d4e565b6000808361ffff1611613ef3576040805162461bcd60e51b81526020600482015260016024820152604960f81b604482015290519081900360640190fd5b8261ffff168261ffff1611613f09575081613382565b825b8261ffff168161ffff161015613f4f576001858261ffff1661ffff8110613f2e57fe5b01805463ffffffff191663ffffffff92909216919091179055600101613f0b565b50909392505050565b80600f81900b8114612beb57600080fd5b6000806000613f76612bf0565b613f88846020015185604001516143a1565b6040805160e0810182526000546001600160a01b0381168252600160a01b8104600290810b810b900b602080840182905261ffff600160b81b8404811685870152600160c81b84048116606080870191909152600160d81b8504909116608086015260ff600160e81b8504811660a0870152600160f01b909404909316151560c08501528851908901519489015192890151939461402c9491939092909190614acf565b93508460600151600f0b6000146141a157846020015160020b816020015160020b12156140815761407a6140638660200151612d6d565b6140708760400151612d6d565b8760600151614c84565b92506141a1565b846040015160020b816020015160020b12156141775760045460408201516001600160801b03909116906140d3906140b7612c27565b60208501516060860151608087015160089493929187916139d1565b6000805461ffff60c81b1916600160c81b61ffff938416021761ffff60b81b1916600160b81b939092169290920217905581516040870151614123919061411990612d6d565b8860600151614c84565b93506141416141358760200151612d6d565b83516060890151614cc8565b92506141518187606001516135ef565b600480546001600160801b0319166001600160801b0392909216919091179055506141a1565b61419e6141878660200151612d6d565b6141948760400151612d6d565b8760600151614cc8565b91505b509193909250565b60006141b68484846132d9565b9050600082806141c257fe5b84860911156133825760001981106141d957600080fd5b6001019392505050565b6040805160609490941b6bffffffffffffffffffffffff1916602080860191909152600293840b60e890811b60348701529290930b90911b60378401528051808403601a018152603a90930181528251928201929092206000908152929052902090565b60608060008361ffff1611614287576040805162461bcd60e51b81526020600482015260016024820152604960f81b604482015290519081900360640190fd5b865167ffffffffffffffff8111801561429f57600080fd5b506040519080825280602002602001820160405280156142c9578160200160208202803683370190505b509150865167ffffffffffffffff811180156142e457600080fd5b5060405190808252806020026020018201604052801561430e578160200160208202803683370190505b50905060005b87518110156143945761433f8a8a8a848151811061432e57fe5b60200260200101518a8a8a8a613389565b84838151811061434b57fe5b6020026020010184848151811061435e57fe5b60200260200101826001600160a01b03166001600160a01b03168152508260060b60060b81525050508080600101915050614314565b5097509795505050505050565b8060020b8260020b126143e1576040805162461bcd60e51b8152602060048201526003602482015262544c5560e81b604482015290519081900360640190fd5b620d89e719600283900b1215614424576040805162461bcd60e51b8152602060048201526003602482015262544c4d60e81b604482015290519081900360640190fd5b620d89e8600282900b1315614466576040805162461bcd60e51b815260206004820152600360248201526254554d60e81b604482015290519081900360640190fd5b5050565b6040805160808101825263ffffffff9283168082526000602083018190529282019290925260016060909101819052835463ffffffff1916909117909116600160f81b17909155908190565b60020b600881901d9161010090910790565b60008082116144d657600080fd5b600160801b82106144e957608091821c91015b68010000000000000000821061450157604091821c91015b640100000000821061451557602091821c91015b62010000821061452757601091821c91015b610100821061453857600891821c91015b6010821061454857600491821c91015b6004821061455857600291821c91015b60028210612beb57600101919050565b600080821161457657600080fd5b5060ff6001600160801b0382161561459157607f1901614599565b608082901c91505b67ffffffffffffffff8216156145b257603f19016145ba565b604082901c91505b63ffffffff8216156145cf57601f19016145d7565b602082901c91505b61ffff8216156145ea57600f19016145f2565b601082901c91505b60ff821615614604576007190161460c565b600882901c91505b600f82161561461e5760031901614626565b600482901c91505b60038216156146385760011901614640565b600282901c91505b6001821615612beb5760001901919050565b6000836001600160a01b0316856001600160a01b03161115614672579293925b8161469f5761469a836001600160801b03168686036001600160a01b0316600160601b6132d9565b6146c2565b6146c2836001600160801b03168686036001600160a01b0316600160601b6141a9565b90505b949350505050565b6000836001600160a01b0316856001600160a01b031611156146ed579293925b7bffffffffffffffffffffffffffffffff000000000000000000000000606084901b166001600160a01b03868603811690871661472957600080fd5b8361475957866001600160a01b031661474c8383896001600160a01b03166132d9565b8161475357fe5b0461477f565b61477f6147708383896001600160a01b03166141a9565b886001600160a01b0316614cf7565b979650505050505050565b600080856001600160a01b0316116147a157600080fd5b6000846001600160801b0316116147b757600080fd5b816147c95761469a8585856001614d02565b6146c28585856001614de3565b600080856001600160a01b0316116147ed57600080fd5b6000846001600160801b03161161480357600080fd5b816148155761469a8585856000614de3565b6146c28585856000614d02565b61482a61564a565b600085600001518503905060405180608001604052808663ffffffff1681526020018263ffffffff168660020b0288602001510160060b81526020016000856001600160801b03161161487e576001614880565b845b6001600160801b031673ffffffff00000000000000000000000000000000608085901b16816148ab57fe5b048860400151016001600160a01b0316815260200160011515815250915050949350505050565b6148da61564a565b6148e261564a565b888561ffff1661ffff81106148f357fe5b60408051608081018252919092015463ffffffff81168083526401000000008204600690810b810b900b6020840152600160581b82046001600160a01b031693830193909352600160f81b900460ff1615156060820152925061495890899089614ed8565b15614990578663ffffffff16826000015163ffffffff16141561497a57613510565b8161498783898988614822565b91509150613510565b888361ffff168660010161ffff16816149a557fe5b0661ffff1661ffff81106149b557fe5b60408051608081018252929091015463ffffffff811683526401000000008104600690810b810b900b60208401526001600160a01b03600160581b8204169183019190915260ff600160f81b90910416151560608201819052909250614a6c57604080516080810182528a5463ffffffff811682526401000000008104600690810b810b900b6020830152600160581b81046001600160a01b031692820192909252600160f81b90910460ff161515606082015291505b614a7b88836000015189614ed8565b614ab2576040805162461bcd60e51b815260206004820152600360248201526213d31160ea1b604482015290519081900360640190fd5b614abf8989898887614f9b565b9150915097509795505050505050565b6000614ade60078787876141e3565b60015460025491925090600080600f87900b15614c24576000614aff612c27565b6000805460045492935090918291614b499160089186918591600160a01b810460020b9161ffff600160b81b83048116926001600160801b0390921691600160c81b900416613389565b9092509050614b8360058d8b8d8b8b87898b60007f000000000000000000000000000000000000000000000000000000000000000061513b565b9450614bba60058c8b8d8b8b87898b60017f000000000000000000000000000000000000000000000000000000000000000061513b565b93508415614bee57614bee60068d7f0000000000000000000000000000000000000000000000000000000000000000615325565b8315614c2057614c2060068c7f0000000000000000000000000000000000000000000000000000000000000000615325565b5050505b600080614c3660058c8c8b8a8a61538b565b9092509050614c47878a8484615437565b600089600f0b1215614c75578315614c6457614c6460058c6155cc565b8215614c7557614c7560058b6155cc565b50505050505095945050505050565b60008082600f0b12614caa57614ca5614ca085858560016146cd565b613291565b6146c5565b614cbd614ca085858560000360006146cd565b600003949350505050565b60008082600f0b12614ce457614ca5614ca08585856001614652565b614cbd614ca08585856000036000614652565b808204910615150190565b60008115614d755760006001600160a01b03841115614d3857614d3384600160601b876001600160801b03166132d9565b614d50565b6001600160801b038516606085901b81614d4e57fe5b045b9050614d6d614d686001600160a01b03881683613e0d565b6155f8565b9150506146c5565b60006001600160a01b03841115614da357614d9e84600160601b876001600160801b03166141a9565b614dba565b614dba606085901b6001600160801b038716614cf7565b905080866001600160a01b031611614dd157600080fd5b6001600160a01b0386160390506146c5565b600082614df15750836146c5565b7bffffffffffffffffffffffffffffffff000000000000000000000000606085901b168215614e91576001600160a01b03861684810290858281614e3157fe5b041415614e6257818101828110614e6057614e5683896001600160a01b0316836141a9565b93505050506146c5565b505b614e8882614e83878a6001600160a01b03168681614e7c57fe5b0490613e0d565b614cf7565b925050506146c5565b6001600160a01b03861684810290858281614ea857fe5b04148015614eb557508082115b614ebe57600080fd5b808203614e56614d68846001600160a01b038b16846141a9565b60008363ffffffff168363ffffffff1611158015614f0257508363ffffffff168263ffffffff1611155b15614f1e578163ffffffff168363ffffffff1611159050613382565b60008463ffffffff168463ffffffff1611614f46578363ffffffff1664010000000001614f4e565b8363ffffffff165b64ffffffffff16905060008563ffffffff168463ffffffff1611614f7f578363ffffffff1664010000000001614f87565b8363ffffffff165b64ffffffffff169091111595945050505050565b614fa361564a565b614fab61564a565b60008361ffff168560010161ffff1681614fc157fe5b0661ffff169050600060018561ffff16830103905060005b506002818301048961ffff87168281614fee57fe5b0661ffff8110614ffa57fe5b60408051608081018252929091015463ffffffff811683526401000000008104600690810b810b900b60208401526001600160a01b03600160581b8204169183019190915260ff600160f81b9091041615156060820181905290955061506557806001019250614fd9565b898661ffff16826001018161507657fe5b0661ffff811061508257fe5b60408051608081018252929091015463ffffffff811683526401000000008104600690810b810b900b60208401526001600160a01b03600160581b8204169183019190915260ff600160f81b909104161515606082015285519094506000906150ed908b908b614ed8565b905080801561510657506151068a8a8760000151614ed8565b15615111575061512e565b8061512157600182039250615128565b8160010193505b50614fd9565b5050509550959350505050565b60028a810b900b600090815260208c90526040812080546001600160801b031682615166828d6135ef565b9050846001600160801b0316816001600160801b031611156151b4576040805162461bcd60e51b81526020600482015260026024820152614c4f60f01b604482015290519081900360640190fd5b6001600160801b03828116159082161581141594501561528a578c60020b8e60020b1361525a57600183018b9055600283018a90556003830180547fffffffffff0000000000000000000000000000000000000000ffffffffffffff166701000000000000006001600160a01b038c16021766ffffffffffffff191666ffffffffffffff60068b900b161763ffffffff60d81b1916600160d81b63ffffffff8a16021790555b6003830180547effffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff16600160f81b1790555b82546001600160801b0319166001600160801b038216178355856152d35782546152ce906152c990600160801b9004600f90810b810b908f900b6132c3565b613f58565b6152f4565b82546152f4906152c990600160801b9004600f90810b810b908f900b6132a7565b8354600f9190910b6001600160801b03908116600160801b0291161790925550909c9b505050505050505050505050565b8060020b8260020b8161533457fe5b0760020b1561534257600080fd5b60008061535d8360020b8560020b8161535757fe5b056144b6565b600191820b820b60009081526020979097526040909620805460ff9097169190911b90951890945550505050565b600285810b80820b60009081526020899052604080822088850b850b83529082209193849391929184918291908a900b126153d1575050600182015460028301546153e4565b8360010154880391508360020154870390505b6000808b60020b8b60020b121561540657505060018301546002840154615419565b84600101548a0391508460020154890390505b92909803979097039b96909503949094039850939650505050505050565b6040805160a08101825285546001600160801b0390811682526001870154602083015260028701549282019290925260038601548083166060830152600160801b900490911660808201526000600f85900b6154d65781516001600160801b03166154ce576040805162461bcd60e51b815260206004820152600260248201526104e560f41b604482015290519081900360640190fd5b5080516154e5565b81516154e290866135ef565b90505b60006155098360200151860384600001516001600160801b0316600160801b6132d9565b9050600061552f8460400151860385600001516001600160801b0316600160801b6132d9565b905086600f0b6000146155565787546001600160801b0319166001600160801b0384161788555b60018801869055600288018590556001600160801b03821615158061558457506000816001600160801b0316115b156155c2576003880180546001600160801b031981166001600160801b039182168501821617808216600160801b9182900483168501909216021790555b5050505050505050565b600290810b810b6000908152602092909252604082208281556001810183905590810182905560030155565b806001600160a01b0381168114612beb57600080fd5b6040805160e081018252600080825260208201819052918101829052606081018290526080810182905260a0810182905260c081019190915290565b6040805160808101825260008082526020820181905291810182905260608101919091529056fea164736f6c6343000706000a";
const isSuperArgs = (xs) => xs.length > 1;
class UniswapV3Pool__factory extends ContractFactory {
    constructor(...args) {
        if (isSuperArgs(args)) {
            super(...args);
        }
        else {
            super(_abi, _bytecode, args[0]);
        }
    }
    deploy(overrides) {
        return super.deploy(overrides || {});
    }
    getDeployTransaction(overrides) {
        return super.getDeployTransaction(overrides || {});
    }
    attach(address) {
        return super.attach(address);
    }
    connect(signer) {
        return super.connect(signer);
    }
    static bytecode = _bytecode;
    static abi = _abi;
    static createInterface() {
        return new utils$1.Interface(_abi);
    }
    static connect(address, signerOrProvider) {
        return new Contract$1(address, _abi, signerOrProvider);
    }
}

const DEFAULT_GAS_QUOTE = 2000000;
// TODO: Better description of function and args
async function multicallSingleCallDataMultipleContracts(multicallContract, functionName, addresses) {
    // Encode args - generate calldata for contract
    const contractIFace = UniswapV3Pool__factory.createInterface();
    // TODO: fix used before defined error
    // eslint-disable-next-line @typescript-eslint/no-use-before-define
    const callData = getCallData(functionName, contractIFace);
    const calls = [];
    if (callData) {
        addresses.forEach((address) => {
            if (address) {
                calls.push({
                    target: address,
                    callData,
                    gasLimit: BigNumber$1.from('1000000'),
                });
            }
        });
    }
    return multicallContract.callStatic.multicall(calls);
}
// TODO: Better description of function and args
async function multicallMultipleCallDataSingContract(multicallContract, calldata, address, options) {
    // Create call objects
    const calls = new Array(calldata.length);
    // TODO: use object.keys of something similar to avoid iterating over
    // entire object prototype
    // eslint-disable-next-line no-restricted-syntax, guard-for-in
    for (const i in calldata) {
        calls[i] = {
            target: address,
            callData: calldata[i],
            gasLimit: options?.gasRequired ?? DEFAULT_GAS_QUOTE,
        };
    }
    return multicallContract.callStatic.multicall(calls);
}
const getCallData = (methodName, contractInterface) => {
    // Create ethers function fragment
    const fragment = contractInterface?.getFunction(methodName);
    return fragment ? contractInterface?.encodeFunctionData(fragment) : undefined;
};

const quoteReturnMapping = {
    // eslint-disable-next-line @typescript-eslint/naming-convention
    '0xcdca1753': ['uint256', 'uint160[]', 'uint32[]', 'uint256'],
    // eslint-disable-next-line @typescript-eslint/naming-convention
    '0xc6a5026a': ['uint256', 'uint160', 'uint32', 'uint256'],
    // eslint-disable-next-line @typescript-eslint/naming-convention
    '0x2f80bb1d': ['uint256', 'uint160[]', 'uint32[]', 'uint256'],
    // eslint-disable-next-line @typescript-eslint/naming-convention
    '0xbd21704a': ['uint256', 'uint160', 'uint32', 'uint256'],
};
/**
 * Returns true if poolA is equivalent to poolB
 * @param poolA one of the two pools
 * @param poolB the other pool
 */
function poolEquals(poolA, poolB) {
    return (poolA === poolB
        || (poolA.token0.equals(poolB.token0)
            && poolA.token1.equals(poolB.token1)
            && poolA.fee === poolB.fee));
}
async function getERC20Decimals(tokenAddress, provider) {
    const decimalsFunctionSig = ethers.utils.id('decimals()').substring(0, 10);
    try {
        const decimalsResult = await provider.call({
            to: tokenAddress,
            data: decimalsFunctionSig,
        });
        return parseInt(decimalsResult, 16);
    }
    catch (e) {
        const message = e instanceof Error ? e.message : 'Unknown Error';
        throw new ProviderCallError(`failed to get ERC20 decimals: ${message}`);
    }
}
/**
 * Based on https://github.com/ethers-io/ethers.js/blob/main/src.ts/address/checks.ts#L51
 */
function isValidNonZeroAddress(address) {
    if (address === ethers.constants.AddressZero) {
        return false;
    }
    try {
        ethers.utils.getAddress(address);
        return true;
    }
    catch (error) {
        return false;
    }
}
const tokenInfoToUniswapToken = (tokenInfo) => new Token(tokenInfo.chainId, tokenInfo.address, tokenInfo.decimals, tokenInfo.symbol, tokenInfo.name);
const toCurrencyAmount = (amount) => {
    const token = tokenInfoToUniswapToken(amount.token);
    return CurrencyAmount.fromRawAmount(token, amount.value.toString());
};
const newAmount = (amount, token) => ({
    value: amount,
    token,
});
const addAmount = (a, b) => {
    if (a.token.address !== b.token.address)
        throw new Error('Token mismatch');
    return { value: a.value.add(b.value), token: a.token };
};
const subtractAmount = (a, b) => {
    if (a.token.address !== b.token.address)
        throw new Error('Token mismatch');
    return { value: a.value.sub(b.value), token: a.token };
};

const amountIndex = 0;
const gasEstimateIndex = 3;
async function getQuotesForRoutes(multicallContract, quoterContractAddress, routes, amountSpecified, tradeType) {
    const callData = routes.map((route) => SwapQuoter.quoteCallParameters(route, toCurrencyAmount(amountSpecified), tradeType, {
        useQuoterV2: true,
    }).calldata);
    let quoteResults;
    try {
        quoteResults = await multicallMultipleCallDataSingContract(multicallContract, callData, quoterContractAddress);
    }
    catch (e) {
        const message = e instanceof Error ? e.message : 'Unknown Error';
        throw new ProviderCallError(`failed multicall: ${message}`);
    }
    const decodedQuoteResults = [];
    // TODO: for..in loops iterate over the entire prototype chain,
    // Use Object.{keys,values,entries}, and iterate over the resulting array.
    // eslint-disable-next-line no-restricted-syntax, guard-for-in
    for (const i in quoteResults.returnData) {
        const functionSig = callData[i].substring(0, 10);
        const returnTypes = quoteReturnMapping[functionSig];
        if (!returnTypes) {
            throw new Error('No quoting function signature found');
        }
        if (quoteResults.returnData[i].returnData === '0x') {
            // There is no quote result for the swap using this route, so don't include it in results
            // eslint-disable-next-line no-continue
            continue;
        }
        try {
            const decodedQuoteResult = ethers.utils.defaultAbiCoder.decode(returnTypes, quoteResults.returnData[i].returnData);
            if (decodedQuoteResult) {
                // The 0th element in each decoded data is going to be the amountOut or amountIn.
                const quoteAmount = decodedQuoteResult[amountIndex];
                if (!(quoteAmount instanceof BigNumber$1))
                    throw new Error('Expected BigNumber');
                decodedQuoteResults.push({
                    route: routes[i],
                    amountIn: tradeType === TradeType.EXACT_INPUT ? amountSpecified : newAmount(quoteAmount, routes[i].input),
                    amountOut: tradeType === TradeType.EXACT_INPUT ? newAmount(quoteAmount, routes[i].output) : amountSpecified,
                    gasEstimate: ethers.BigNumber.from(decodedQuoteResult[gasEstimateIndex]),
                    tradeType,
                });
            }
        }
        catch {
            // Failed to get the quote for this particular route
            // Other quotes for routes may still succeed, so do nothing
            // and continue processing
        }
    }
    return decodedQuoteResults;
}

// Hard-coded into factory contract
const POOL_INIT_CODE_HASH = '0xe34f199b19b2b4f47f68442619d555527d244f78a3297ea89325f843f87b8b54';
function computePoolAddress({ factoryAddress, erc20Pair, fee, initCodeHashManualOverride, }) {
    // erc20 addresses need to be in alphabetical order to correctly identify a pool
    // eslint-disable-next-line @typescript-eslint/no-use-before-define, no-param-reassign
    erc20Pair = ensureCorrectERC20AddressOrder(erc20Pair);
    return ethers.utils.getCreate2Address(factoryAddress, keccak256$1(['bytes'], [
        ethers.utils.defaultAbiCoder.encode(['address', 'address', 'uint24'], [erc20Pair[0].address, erc20Pair[1].address, fee]),
    ]), initCodeHashManualOverride ?? POOL_INIT_CODE_HASH);
}
const ensureCorrectERC20AddressOrder = (erc20Pair) => {
    if (erc20Pair[0].address.toLowerCase() > erc20Pair[1].address.toLowerCase()) {
        const temp = erc20Pair[0];
        // eslint-disable-next-line prefer-destructuring, no-param-reassign
        erc20Pair[0] = erc20Pair[1];
        // eslint-disable-next-line no-param-reassign
        erc20Pair[1] = temp;
    }
    return erc20Pair;
};

// GenerateERC20Pairs will generate all possible ERC20 pair combinations, excluding duplicates
const generateERC20Pairs = (erc20Pair, commonRoutingERC20s) => {
    const contractAddressMap = new Map();
    const contractAddresses = [];
    [...erc20Pair, ...commonRoutingERC20s].forEach((erc20) => {
        contractAddressMap.set(erc20.address, erc20);
        contractAddresses.push(erc20.address);
    });
    const uniqueERC20Addresses = new Set([...contractAddresses]);
    const erc20Addresses = [...uniqueERC20Addresses];
    const erc20Pairs = [];
    for (let i = 0; i < erc20Addresses.length; i++) {
        for (let j = i + 1; j < erc20Addresses.length; j++) {
            const firstToken = contractAddressMap.get(erc20Addresses[i]);
            const secondToken = contractAddressMap.get(erc20Addresses[j]);
            if (firstToken && secondToken) {
                erc20Pairs.push([firstToken, secondToken]);
            }
        }
    }
    return erc20Pairs;
};

const poolFees = [
    FeeAmount.LOWEST,
    FeeAmount.LOW,
    FeeAmount.MEDIUM,
    FeeAmount.HIGH,
];
// generatePossiblePoolsFromERC20Pair will compute all possible pool combinations
// from the erc20Pair, commonRoutingERC20s and PoolFees
const generatePossiblePoolsFromERC20Pair = (erc20Pair, commonRoutingERC20s, factoryAddress) => {
    const erc20Pairs = generateERC20Pairs(erc20Pair, commonRoutingERC20s);
    const poolIDs = [];
    for (let i = 0; i < erc20Pairs.length; i++) {
        for (let j = 0; j < poolFees.length; j++) {
            // Compute the address of the pool using its unique identifier (tokenA, tokenB, fee)
            // Computing an address does not mean the pool is guaranteed to exist
            const poolAddress = computePoolAddress({
                factoryAddress,
                erc20Pair: erc20Pairs[i],
                fee: poolFees[j],
            });
            poolIDs.push({
                erc20Pair: erc20Pairs[i],
                fee: poolFees[j],
                poolAddress,
            });
        }
    }
    return poolIDs;
};

const liquidityFuncString = 'liquidity';
const slot0FuncString = 'slot0';
const noDataResult = '0x';
// TODO: Split into fetchPools and filterPools methods
// in order to allow for better error handling/separation of concerns
const fetchValidPools = async (multicallContract, erc20Pair, commonRoutingERC20s, factoryAddress) => {
    const poolIDs = generatePossiblePoolsFromERC20Pair(erc20Pair, commonRoutingERC20s, factoryAddress);
    const poolAddresses = poolIDs.map((pool) => pool.poolAddress);
    // The multicall contract returns data in the same order as the given pool addresses
    // Indexes of pool addresses will map to the indexes of the results
    let slot0Results;
    let liquidityResults;
    try {
        [slot0Results, liquidityResults] = await Promise.all([
            multicallSingleCallDataMultipleContracts(multicallContract, slot0FuncString, poolAddresses),
            multicallSingleCallDataMultipleContracts(multicallContract, liquidityFuncString, poolAddresses),
        ]);
    }
    catch (e) {
        const message = e instanceof Error ? e.message : 'Unknown Error';
        throw new ProviderCallError(`failed multicall: ${message}`);
    }
    const slot0s = slot0Results.returnData;
    const liquidities = liquidityResults.returnData;
    const uniswapV3Pool = UniswapV3Pool__factory.createInterface();
    const validPools = [];
    poolIDs.forEach((poolID, index) => {
        const noPriceResult = slot0Results.returnData[index].returnData === noDataResult;
        const noLiquidityResult = liquidityResults.returnData[index].returnData === noDataResult;
        // This indicates that the pool doesn't exist
        if (noPriceResult || noLiquidityResult) {
            return;
        }
        const poolSlot0 = uniswapV3Pool.decodeFunctionResult(slot0FuncString, slot0s[index].returnData);
        const poolLiquidity = uniswapV3Pool.decodeFunctionResult(liquidityFuncString, liquidities[index].returnData);
        const zeroPrice = poolSlot0.sqrtPriceX96.isZero();
        const zeroLiquidity = poolLiquidity[0].isZero();
        // If there is no price or no liquidity in the pool then we do not want to consider
        // it for swapping
        if (zeroPrice || zeroLiquidity) {
            return;
        }
        const validPool = new Pool(tokenInfoToUniswapToken(poolID.erc20Pair[0]), tokenInfoToUniswapToken(poolID.erc20Pair[1]), poolID.fee, poolSlot0.sqrtPriceX96.toString(), poolLiquidity.toString(), poolSlot0.tick);
        validPools.push(validPool);
    });
    return validPools;
};

class Router {
    provider;
    routingTokens;
    routingContracts;
    constructor(provider, routingTokens, routingContracts) {
        this.provider = provider;
        this.routingTokens = routingTokens;
        this.routingContracts = routingContracts;
    }
    async findOptimalRoute(amountSpecified, otherToken, tradeType, maxHops = 2) {
        const [tokenIn, tokenOut] = this.determineERC20InAndERC20Out(tradeType, amountSpecified, otherToken);
        const multicallContract = Multicall__factory.connect(this.routingContracts.multicallAddress, this.provider);
        const erc20Pair = [tokenIn, tokenOut];
        // Get all pools and use these to get all possible routes.
        const pools = await fetchValidPools(multicallContract, erc20Pair, this.routingTokens, this.routingContracts.factoryAddress);
        const noValidPools = pools.length === 0;
        if (noValidPools) {
            throw new NoRoutesAvailableError();
        }
        // Get all the possible routes from the given pools
        // TODO: Fix used before defined error
        // eslint-disable-next-line @typescript-eslint/no-use-before-define
        const routes = generateAllAcyclicPaths(tokenIn, tokenOut, pools, maxHops, [], [], tokenIn);
        const noValidRoute = routes.length === 0;
        if (noValidRoute) {
            throw new NoRoutesAvailableError();
        }
        // Get the best quote from all of the given routes
        return await this.getBestQuoteFromRoutes(multicallContract, routes, amountSpecified, tradeType);
    }
    async getBestQuoteFromRoutes(multicallContract, routes, amountSpecified, tradeType) {
        const quotes = await getQuotesForRoutes(multicallContract, this.routingContracts.quoterAddress, routes, amountSpecified, tradeType);
        if (quotes.length === 0) {
            throw new NoRoutesAvailableError();
        }
        // We want to maximise the amountOut for the EXACT_INPUT type
        if (tradeType === TradeType.EXACT_INPUT) {
            return this.bestQuoteForAmountIn(quotes);
        }
        // We want to minimise the amountIn for the EXACT_OUTPUT type
        if (tradeType === TradeType.EXACT_OUTPUT) {
            return this.bestQuoteForAmountOut(quotes);
        }
        throw new Error('Invalid trade type');
    }
    // eslint-disable-next-line class-methods-use-this
    bestQuoteForAmountIn(quotes) {
        let bestQuote = quotes[0];
        for (let i = 1; i < quotes.length; i++) {
            if (quotes[i].amountOut.value.gt(bestQuote.amountOut.value)) {
                bestQuote = quotes[i];
            }
        }
        return bestQuote;
    }
    // eslint-disable-next-line class-methods-use-this
    bestQuoteForAmountOut(quotes) {
        let bestQuote = quotes[0];
        for (let i = 1; i < quotes.length; i++) {
            if (quotes[i].amountIn.value.lt(bestQuote.amountIn.value)) {
                bestQuote = quotes[i];
            }
        }
        return bestQuote;
    }
    // eslint-disable-next-line class-methods-use-this
    determineERC20InAndERC20Out(tradeType, amountSpecified, otherToken) {
        // If the trade type is EXACT INPUT then we have specified the amount for the tokenIn
        return tradeType === TradeType.EXACT_INPUT
            ? [amountSpecified.token, otherToken]
            : [otherToken, amountSpecified.token];
    }
}
const generateAllAcyclicPaths = (tokenIn, // the currency we start with
tokenOut, // the currency we want to end up with
pools, // list of all available pools
maxHops, // the maximum number of pools that can be traversed
currentRoute = [], // list of pools already traversed
routes = [], // list of all routes found so far
startTokenIn = tokenIn) => {
    const currencyIn = tokenInfoToUniswapToken(tokenIn);
    const currencyOut = tokenInfoToUniswapToken(tokenOut);
    const startCurrencyIn = tokenInfoToUniswapToken(startTokenIn);
    for (const pool of pools) {
        // if the pool doesn't have the tokenIn or if it has already been traversed,
        // skip to the next pool
        const poolHasTokenIn = pool.involvesToken(currencyIn);
        const poolHasCycle = currentRoute.find((pathPool) => poolEquals(pool, pathPool));
        // eslint-disable-next-line no-continue
        if (!poolHasTokenIn || poolHasCycle)
            continue;
        // get the output token of the pool
        const outputToken = pool.token0.equals(currencyIn) ? pool.token1 : pool.token0;
        // if we have found a route to the target currency, add it to the list of routes
        const routeFound = outputToken.equals(currencyOut);
        if (routeFound) {
            routes.push(new Route([...currentRoute, pool], startCurrencyIn, currencyOut));
        }
        else if (maxHops > 1) {
            // otherwise, if we haven't exceeded the maximum number of pools that can be traversed,
            // recursively call this function with the output token as the new starting currency
            generateAllAcyclicPaths(outputToken, tokenOut, pools, maxHops - 1, [...currentRoute, pool], routes, startTokenIn);
        }
    }
    return routes;
};

/**
 * Determines whether or not the chain supports EIP-1559 by checking for the existence
 * of {@link FeeData.maxFeePerGas} and {@link FeeData.maxPriorityFeePerGas}
 *
 * @param {FeeData} fee - The fee data for the chain
 */
const doesChainSupportEIP1559 = (fee) => {
    const supportsEIP1559 = !!fee.maxFeePerGas && !!fee.maxPriorityFeePerGas;
    return supportsEIP1559;
};
/**
 * Fetch the current gas price estimate. Supports both EIP-1559 and non-EIP1559 chains
 * @param {JsonRpcProvider} provider - The JSON RPC provider used to fetch fee data
 * @returns {Amount | null} - The gas price in the smallest denomination of the chain's currency,
 * or null if no gas price is available
 */
const fetchGasPrice = async (provider, nativeToken) => {
    const feeData = await provider.getFeeData().catch(() => null);
    if (!feeData)
        return null;
    if (doesChainSupportEIP1559(feeData)) {
        return newAmount(feeData.maxFeePerGas.add(feeData.maxPriorityFeePerGas), nativeToken);
    }
    return feeData.gasPrice ? newAmount(feeData.gasPrice, nativeToken) : null;
};
/**
 * Calculate the gas fee from the gas price and gas units used for the transaction
 *
 * @param {Amount} gasPriceInWei - The price of gas
 * @param {BigNumber} gasUsed - The total gas units that will be used for the transaction
 * @returns - The cost of the transaction in the gas token's smallest denomination (e.g. WEI)
 */
const calculateGasFee = (gasPrice, gasEstimate) => 
// eslint-disable-next-line implicit-arrow-linebreak
newAmount(gasEstimate.mul(gasPrice.value), gasPrice.token);

/**
 * Get the amount of an ERC20 token that needs to be approved by
 * checking the existing allowance for the spender
 *
 * @param provider - The provider to use for the call
 * @param ownerAddress - The address of the owner of the token
 * @param tokenAmount  - The amount of the token to approve
 * @param spenderAddress - The address of the spender
 * @returns - The amount of the token that needs to be approved
 */
const getERC20AmountToApprove = async (provider, ownerAddress, tokenAmount, spenderAddress) => {
    // create an instance of the ERC20 token contract
    const erc20Contract = ERC20__factory.connect(tokenAmount.token.address, provider);
    // get the allowance for the token spender
    // minimum is 0 - no allowance
    let allowance;
    try {
        allowance = await erc20Contract.allowance(ownerAddress, spenderAddress);
    }
    catch (e) {
        const message = e instanceof Error ? e.message : 'Unknown Error';
        throw new ApproveError(`failed to get allowance: ${message}`);
    }
    // get the amount that needs to be approved
    const requiredAmount = tokenAmount.value.sub(allowance);
    if (requiredAmount.isNegative() || requiredAmount.isZero()) {
        throw new AlreadyApprovedError(tokenAmount.toString(), tokenAmount.token.address, spenderAddress);
    }
    return newAmount(requiredAmount, tokenAmount.token);
};
/**
 * Get an unsigned ERC20 approve transaction
 *
 * @param ownerAddress - The address of the owner of the token
 * @param tokenAmount - The amount of the token to approve
 * @param spenderAddress - The address of the spender
 * @returns - The unsigned ERC20 approve transaction
 */
const getUnsignedERC20ApproveTransaction = (ownerAddress, tokenAmount, spenderAddress) => {
    if (ownerAddress === spenderAddress) {
        throw new ApproveError('owner and spender addresses are the same');
    }
    const erc20Contract = ERC20__factory.createInterface();
    const callData = erc20Contract.encodeFunctionData('approve', [spenderAddress, tokenAmount.value]);
    return {
        data: callData,
        to: tokenAmount.token.address,
        value: 0,
        from: ownerAddress,
    };
};
const prepareApproval = (tradeType, amountSpecified, amountWithSlippage, routingContracts, secondaryFees) => {
    const amountOfTokenIn = tradeType === TradeType.EXACT_INPUT ? amountSpecified : amountWithSlippage;
    const spender = secondaryFees.length === 0
        ? routingContracts.peripheryRouterAddress
        : routingContracts.secondaryFeeAddress;
    return { spender, amount: amountOfTokenIn };
};
/**
 * Get an unsigned approval transaction if needed
 *
 * @param provider The provider to use for the call
 * @param ownerAddress The address of the owner of the token
 * @param tokenAddress The address of the token to approve
 * @param tokenAmount The amount of the token to approve
 * @param spenderAddress The address of the spender
 * @returns The unsigned ERC20 approve transaction, or null if no approval is needed
 */
const getApproveTransaction = async (provider, ownerAddress, tokenAmount, spenderAddress) => {
    let amountToApprove;
    try {
        amountToApprove = await getERC20AmountToApprove(provider, ownerAddress, tokenAmount, spenderAddress);
    }
    catch (e) {
        if (e instanceof AlreadyApprovedError) {
            // already approved for the required amount, nothing to do
            return null;
        }
        throw e;
    }
    return getUnsignedERC20ApproveTransaction(ownerAddress, amountToApprove, spenderAddress);
};
async function getApproveGasEstimate(provider, ownerAddress, spenderAddress, tokenAddress) {
    const erc20Contract = ERC20__factory.connect(tokenAddress, provider);
    return await erc20Contract.estimateGas.approve(spenderAddress, ethers.constants.MaxUint256, {
        from: ownerAddress,
    });
}
const getApproval = async (provider, ownerAddress, preparedApproval, gasPrice) => {
    const approveTransaction = await getApproveTransaction(provider, ownerAddress, preparedApproval.amount, preparedApproval.spender);
    if (!approveTransaction) {
        return null;
    }
    const gasEstimate = await getApproveGasEstimate(provider, ownerAddress, preparedApproval.spender, preparedApproval.amount.token.address);
    const gasFeeEstimate = gasPrice ? calculateGasFee(gasPrice, gasEstimate) : null;
    return {
        transaction: approveTransaction,
        gasFeeEstimate,
    };
};

// slippageToPercent takes the slippage as a percentage (e.g. 0.1) and
// converts it to the Uniswap equivalent type
const slippageToFraction = (slippage) => {
    // If we receive a whole number, we can return slippage/100
    const noDecimals = slippage.toString().split('.').length === 1;
    if (noDecimals) {
        return new Percent(slippage, 100);
    }
    // Divide the slippage number by 100 to get the decimal
    const slippageDecimal = slippage / 100;
    // Split into two parts by the decimal place
    const parts = slippageDecimal.toString().split('.');
    // Get the numerator by adding the two parts together
    const numerator = parts[0] + parts[1];
    // Get the denominator by multiplying decimals^10
    const denominator = 10 ** parts[1].length;
    return new Percent(numerator, denominator);
};

function getQuoteAmountFromTradeType(tradeInfo) {
    if (tradeInfo.tradeType === TradeType.EXACT_INPUT) {
        return tradeInfo.amountOut;
    }
    return tradeInfo.amountIn;
}
function applySlippage(tradeType, amount, slippage) {
    const slippageTolerance = slippageToFraction(slippage);
    const slippagePlusOne = slippageTolerance.add(1);
    const maybeInverted = tradeType === TradeType.EXACT_INPUT ? slippagePlusOne.invert() : slippagePlusOne;
    const amountWithSlippage = maybeInverted.multiply(amount.toString()).quotient;
    return ethers.BigNumber.from(amountWithSlippage.toString());
}
function prepareUserQuote(otherToken, tradeInfo, slippage, fees) {
    const quote = getQuoteAmountFromTradeType(tradeInfo);
    const amountWithSlippage = applySlippage(tradeInfo.tradeType, quote.value, slippage);
    return {
        amount: quote,
        amountWithMaxSlippage: {
            token: otherToken,
            value: amountWithSlippage,
        },
        slippage,
        fees: fees.withAmounts(),
    };
}
function getOurQuoteReqAmount(amount, fees, tradeType) {
    if (tradeType === TradeType.EXACT_OUTPUT) {
        // For an exact output swap, we do not need to subtract fees from the given amount
        return amount;
    }
    fees.addAmount(amount);
    return fees.amountLessFees();
}

// 0.1% default slippage
const DEFAULT_SLIPPAGE = 0.1;
// 15 minutes from the current Unix time
const DEFAULT_DEADLINE = Math.floor(Date.now() / 1000) + 60 * 15;
// most swaps will be able to resolve with 2 hops
const DEFAULT_MAX_HOPS = 2;
// after 10 hops, it is very unlikely a route will be available
const MAX_MAX_HOPS = 10;
// a max hop of 1 will require a direct swap with no intermediary pools
const MIN_MAX_HOPS = 1;
// precision used to calculate percentage from basis points
const BASIS_POINT_PRECISION = 10000;
// 10% maximum secondary fee
const MAX_SECONDARY_FEE_BASIS_POINTS = 10000;

class Fees {
    secondaryFees;
    amount;
    constructor(secondaryFees, token) {
        this.secondaryFees = secondaryFees;
        this.amount = newAmount(BigNumber$1.from(0), token);
    }
    addAmount(amount) {
        this.amount = addAmount(this.amount, amount);
    }
    amountWithFeesApplied() {
        return addAmount(this.amount, this.total());
    }
    amountLessFees() {
        return subtractAmount(this.amount, this.total());
    }
    withAmounts() {
        return this.secondaryFees.map((fee) => {
            const feeAmount = this.amount.value
                .mul(fee.basisPoints)
                .div(BASIS_POINT_PRECISION);
            return {
                ...fee,
                amount: newAmount(feeAmount, this.amount.token),
            };
        });
    }
    total() {
        let totalFees = newAmount(BigNumber$1.from(0), this.amount.token);
        for (const fee of this.secondaryFees) {
            const feeAmount = this.amount.value
                .mul(fee.basisPoints)
                .div(BASIS_POINT_PRECISION);
            totalFees = addAmount(totalFees, newAmount(feeAmount, this.amount.token));
        }
        return totalFees;
    }
}

const IMMUTABLE_TESTNET_RPC_URL = 'https://rpc.testnet.immutable.com';
const IMMUTABLE_TESTNET_CHAIN_ID = 13472;

const TIMX_IMMUTABLE_TESTNET = {
    chainId: IMMUTABLE_TESTNET_CHAIN_ID,
    address: '0x0000000000000000000000000000000000001010',
    decimals: 18,
    symbol: 'tIMX',
    name: 'Immutable Testnet Token',
};
const IMMUTABLE_TESTNET_COMMON_ROUTING_TOKENS = [
    TIMX_IMMUTABLE_TESTNET,
];

const zeroNativeCurrencyValue = '0x00';
const multicallWithDeadlineFunctionSignature = 'multicall(uint256,bytes[])';
function buildSwapParametersForSinglePoolSwap(fromAddress, trade, route, amountIn, amountOut, secondaryFees, secondaryFeeContract) {
    const secondaryFeeValues = secondaryFees.map((fee) => ({
        feeBasisPoints: fee.basisPoints,
        recipient: fee.recipient,
    }));
    if (trade.tradeType === TradeType.EXACT_INPUT) {
        return secondaryFeeContract.encodeFunctionData('exactInputSingleWithSecondaryFee', [secondaryFeeValues, {
                tokenIn: route.tokenPath[0].address,
                tokenOut: route.tokenPath[1].address,
                fee: route.pools[0].fee,
                recipient: fromAddress,
                amountIn,
                amountOutMinimum: amountOut,
                sqrtPriceLimitX96: 0,
            }]);
    }
    return secondaryFeeContract.encodeFunctionData('exactOutputSingleWithSecondaryFee', [secondaryFeeValues, {
            tokenIn: route.tokenPath[0].address,
            tokenOut: route.tokenPath[1].address,
            fee: route.pools[0].fee,
            recipient: fromAddress,
            amountInMaximum: amountIn,
            amountOut,
            sqrtPriceLimitX96: 0,
        }]);
}
function buildSwapParametersForMultiPoolSwap(fromAddress, trade, route, amountIn, amountOut, secondaryFees, secondaryFeeContract) {
    const path = encodeRouteToPath(route, trade.tradeType === TradeType.EXACT_OUTPUT);
    const secondaryFeeValues = secondaryFees.map((fee) => ({
        feeBasisPoints: fee.basisPoints,
        recipient: fee.recipient,
    }));
    if (trade.tradeType === TradeType.EXACT_INPUT) {
        return secondaryFeeContract.encodeFunctionData('exactInputWithSecondaryFee', [secondaryFeeValues, {
                path,
                recipient: fromAddress,
                amountIn,
                amountOutMinimum: amountOut,
            }]);
    }
    return secondaryFeeContract.encodeFunctionData('exactOutputWithSecondaryFee', [secondaryFeeValues, {
            path,
            recipient: fromAddress,
            amountInMaximum: amountIn,
            amountOut,
        }]);
}
/**
 * Builds swap parameters
 * @param fromAddress the msg.sender of the transaction
 * @param secondaryFeeAddress the secondary fee contract address
 * @param trade details of the swap, including the route, input/output tokens and amounts
 * @param options additional swap options
 * @returns calldata for the swap
 */
function buildSwapParameters(fromAddress, trade, options, secondaryFees, secondaryFeeContract) {
    // @dev we don't support multiple swaps in a single transaction
    // there will always be only one swap in the trade regardless of the trade type
    const { route, inputAmount, outputAmount } = trade.swaps[0];
    const amountIn = toHex$1(trade.maximumAmountIn(options.slippageTolerance, inputAmount).quotient);
    const amountOut = toHex$1(trade.minimumAmountOut(options.slippageTolerance, outputAmount).quotient);
    const isSinglePoolSwap = route.pools.length === 1;
    if (isSinglePoolSwap) {
        return buildSwapParametersForSinglePoolSwap(fromAddress, trade, route, amountIn, amountOut, secondaryFees, secondaryFeeContract);
    }
    return buildSwapParametersForMultiPoolSwap(fromAddress, trade, route, amountIn, amountOut, secondaryFees, secondaryFeeContract);
}
function createSwapCallParametersWithFees(trade, fromAddress, swapOptions, secondaryFees) {
    const secondaryFeeContract = SecondaryFee__factory.createInterface();
    const swapWithFeesCalldata = buildSwapParameters(fromAddress, trade, swapOptions, secondaryFees, secondaryFeeContract);
    return secondaryFeeContract.encodeFunctionData(multicallWithDeadlineFunctionSignature, [swapOptions.deadlineOrPreviousBlockhash, [swapWithFeesCalldata]]);
}
function createSwapParameters(adjustedQuote, fromAddress, slippage, deadline, secondaryFees) {
    // Create an unchecked trade to be used in generating swap parameters.
    const uncheckedTrade = Trade.createUncheckedTrade({
        route: adjustedQuote.route,
        inputAmount: toCurrencyAmount(adjustedQuote.amountIn),
        outputAmount: toCurrencyAmount(adjustedQuote.amountOut),
        tradeType: adjustedQuote.tradeType,
    });
    const slippageTolerance = slippageToFraction(slippage);
    const options = {
        slippageTolerance,
        recipient: fromAddress,
        deadlineOrPreviousBlockhash: deadline,
    };
    if (secondaryFees.length === 0) {
        // Generate swap parameters without secondary fee contract details
        return SwapRouter.swapCallParameters([uncheckedTrade], options).calldata;
    }
    return createSwapCallParametersWithFees(uncheckedTrade, fromAddress, options, secondaryFees);
}
function getSwap(adjustedQuote, fromAddress, slippage, deadline, peripheryRouterAddress, secondaryFeesAddress, gasPrice, secondaryFees) {
    const calldata = createSwapParameters(adjustedQuote, fromAddress, slippage, deadline, secondaryFees);
    // TODO: Add additional gas fee estimates for secondary fees
    const gasFeeEstimate = gasPrice ? calculateGasFee(gasPrice, adjustedQuote.gasEstimate) : null;
    return {
        transaction: {
            data: calldata,
            to: secondaryFees.length > 0 ? secondaryFeesAddress : peripheryRouterAddress,
            value: zeroNativeCurrencyValue,
            from: fromAddress,
        },
        gasFeeEstimate,
    };
}
function prepareSwap(ourQuote, amountSpecified, fees) {
    if (ourQuote.tradeType === TradeType.EXACT_OUTPUT) {
        fees.addAmount(ourQuote.amountIn);
        return {
            gasEstimate: ourQuote.gasEstimate,
            route: ourQuote.route,
            amountIn: fees.amountWithFeesApplied(),
            amountOut: amountSpecified,
            tradeType: ourQuote.tradeType,
        };
    }
    return {
        gasEstimate: ourQuote.gasEstimate,
        route: ourQuote.route,
        amountIn: amountSpecified,
        amountOut: ourQuote.amountOut,
        tradeType: ourQuote.tradeType,
    };
}

const CONTRACTS_FOR_CHAIN_ID = {
    [IMMUTABLE_TESTNET_CHAIN_ID]: {
        multicall: '0xD17c98b38bA28c7eA1080317EB9AB2b9663BEd92',
        coreFactory: '0x8AC26EfCbf5D700b37A27aA00E6934e6904e7B8e',
        quoterV2: '0x0Afe6F5f4DC34461A801420634239FFaD50A2e44',
        peripheryRouter: '0x87854A7D4b9BaC3D37f4516A1Ac7F36fB5ad539f',
        secondaryFee: '0x5893A5c7bc615Dfd36D7383366d00FFFca5f7178',
    },
};
const SUPPORTED_SANDBOX_CHAINS = {
    [IMMUTABLE_TESTNET_CHAIN_ID]: {
        chainId: IMMUTABLE_TESTNET_CHAIN_ID,
        rpcUrl: IMMUTABLE_TESTNET_RPC_URL,
        contracts: CONTRACTS_FOR_CHAIN_ID[IMMUTABLE_TESTNET_CHAIN_ID],
        commonRoutingTokens: IMMUTABLE_TESTNET_COMMON_ROUTING_TOKENS,
        nativeToken: TIMX_IMMUTABLE_TESTNET,
    },
};
const SUPPORTED_PRODUCTION_CHAINS = {};
const SUPPORTED_CHAIN_IDS_FOR_ENVIRONMENT = {
    [Environment$1.SANDBOX]: SUPPORTED_SANDBOX_CHAINS,
    [Environment$1.PRODUCTION]: SUPPORTED_PRODUCTION_CHAINS,
};
function validateOverrides(overrides) {
    const keysToCheck = ['rpcURL', 'exchangeContracts', 'commonRoutingTokens', 'nativeToken'];
    for (const key of keysToCheck) {
        if (!overrides[key]) {
            throw new InvalidConfigurationError(`Missing override: ${key}`);
        }
    }
    Object.entries(overrides.exchangeContracts).forEach(([key, contract]) => {
        if (!isValidNonZeroAddress(contract)) {
            throw new InvalidConfigurationError(`Invalid exchange contract address for ${key}`);
        }
    });
}
function validateSecondaryFees(secondaryFees) {
    let totalSecondaryFeeBasisPoints = 0;
    for (const secondaryFee of secondaryFees) {
        if (!isValidNonZeroAddress(secondaryFee.recipient)) {
            throw new InvalidConfigurationError(`Invalid secondary fee recipient address: ${secondaryFee.recipient}`);
        }
        if (secondaryFee.basisPoints <= 0 || secondaryFee.basisPoints > MAX_SECONDARY_FEE_BASIS_POINTS) {
            throw new InvalidConfigurationError(`Invalid secondary fee basis points: ${secondaryFee.basisPoints}`);
        }
        totalSecondaryFeeBasisPoints += secondaryFee.basisPoints;
    }
    if (totalSecondaryFeeBasisPoints > MAX_SECONDARY_FEE_BASIS_POINTS) {
        throw new InvalidConfigurationError(`Invalid total secondary fee basis points: ${totalSecondaryFeeBasisPoints}`);
    }
}
/**
 * {@link ExchangeConfiguration} is used to configure the {@link Exchange} class.
 * @param chainId the ID of the chain to configure. {@link SUPPORTED_CHAIN_IDS_FOR_ENVIRONMENT} contains the supported chains for each environment.
 * @param baseConfig the base {@link ImmutableConfiguration} for the {@link Exchange} class
 * @param secondaryFees an optional array of {@link SecondaryFee}s to apply to all transactions. Total secondary fees must be less than {@link MAX_SECONDARY_FEE_BASIS_POINTS}.
 */
class ExchangeConfiguration {
    baseConfig;
    chain;
    secondaryFees = [];
    constructor({ chainId, baseConfig, secondaryFees, overrides, }) {
        this.baseConfig = baseConfig;
        this.secondaryFees = secondaryFees || [];
        validateSecondaryFees(this.secondaryFees);
        if (overrides) {
            validateOverrides(overrides);
            this.chain = {
                chainId,
                rpcUrl: overrides.rpcURL,
                contracts: overrides.exchangeContracts,
                commonRoutingTokens: overrides.commonRoutingTokens,
                nativeToken: overrides.nativeToken,
            };
            this.secondaryFees = secondaryFees || [];
            return;
        }
        const chain = SUPPORTED_CHAIN_IDS_FOR_ENVIRONMENT[baseConfig.environment][chainId];
        if (!chain) {
            throw new ChainNotSupportedError(chainId, baseConfig.environment);
        }
        this.chain = chain;
    }
}

class Exchange {
    provider;
    router;
    chainId;
    nativeToken;
    secondaryFees;
    constructor(configuration) {
        const config = new ExchangeConfiguration(configuration);
        this.chainId = config.chain.chainId;
        this.nativeToken = config.chain.nativeToken;
        this.secondaryFees = config.secondaryFees;
        this.provider = new ethers.providers.JsonRpcProvider(config.chain.rpcUrl);
        this.router = new Router(this.provider, config.chain.commonRoutingTokens, {
            multicallAddress: config.chain.contracts.multicall,
            factoryAddress: config.chain.contracts.coreFactory,
            quoterAddress: config.chain.contracts.quoterV2,
            peripheryRouterAddress: config.chain.contracts.peripheryRouter,
            secondaryFeeAddress: config.chain.contracts.secondaryFee,
        });
    }
    static validate(tokenInAddress, tokenOutAddress, maxHops, slippagePercent, fromAddress) {
        assert(isValidNonZeroAddress(fromAddress), new InvalidAddressError('invalid from address'));
        assert(isValidNonZeroAddress(tokenInAddress), new InvalidAddressError('invalid token in address'));
        assert(isValidNonZeroAddress(tokenOutAddress), new InvalidAddressError('invalid token out address'));
        assert(tokenInAddress.toLocaleLowerCase() !== tokenOutAddress.toLocaleLowerCase(), new DuplicateAddressesError());
        assert(maxHops <= MAX_MAX_HOPS, new InvalidMaxHopsError('max hops must be less than or equal to 10'));
        assert(maxHops >= MIN_MAX_HOPS, new InvalidMaxHopsError('max hops must be greater than or equal to 1'));
        assert(slippagePercent <= 50, new InvalidSlippageError('slippage percent must be less than or equal to 50'));
        assert(slippagePercent >= 0, new InvalidSlippageError('slippage percent must be greater than or equal to 0'));
    }
    async getSecondaryFees() {
        if (this.secondaryFees.length === 0) {
            return [];
        }
        const secondaryFeeContract = SecondaryFee__factory.connect(this.router.routingContracts.secondaryFeeAddress, this.provider);
        if (await secondaryFeeContract.paused()) {
            // Do not use secondary fees if the contract is paused
            return [];
        }
        return this.secondaryFees;
    }
    async getUnsignedSwapTx(fromAddress, tokenInAddress, tokenOutAddress, amount, slippagePercent, maxHops, deadline, tradeType) {
        Exchange.validate(tokenInAddress, tokenOutAddress, maxHops, slippagePercent, fromAddress);
        // get the decimals of the tokens that will be swapped
        const [tokenInDecimals, tokenOutDecimals, secondaryFees] = await Promise.all([
            getERC20Decimals(tokenInAddress, this.provider),
            getERC20Decimals(tokenOutAddress, this.provider),
            this.getSecondaryFees(),
        ]);
        const tokenIn = {
            address: tokenInAddress,
            chainId: this.chainId,
            decimals: tokenInDecimals,
        };
        const tokenOut = {
            address: tokenOutAddress,
            chainId: this.chainId,
            decimals: tokenOutDecimals,
        };
        // determine which amount was specified for the swap from the TradeType
        const [tokenSpecified, otherToken] = tradeType === TradeType.EXACT_INPUT
            ? [tokenIn, tokenOut] : [tokenOut, tokenIn];
        const amountSpecified = newAmount(amount, tokenSpecified);
        const fees = new Fees(secondaryFees, tokenIn);
        const ourQuoteReqAmount = getOurQuoteReqAmount(amountSpecified, fees, tradeType);
        // get quote and gas details
        const [ourQuote, gasPrice] = await Promise.all([
            this.router.findOptimalRoute(ourQuoteReqAmount, otherToken, tradeType, maxHops),
            fetchGasPrice(this.provider, this.nativeToken),
        ]);
        const adjustedQuote = prepareSwap(ourQuote, amountSpecified, fees);
        const swap = getSwap(adjustedQuote, fromAddress, slippagePercent, deadline, this.router.routingContracts.peripheryRouterAddress, this.router.routingContracts.secondaryFeeAddress, gasPrice, secondaryFees);
        const userQuote = prepareUserQuote(otherToken, adjustedQuote, slippagePercent, fees);
        const preparedApproval = prepareApproval(tradeType, amountSpecified, userQuote.amountWithMaxSlippage, this.router.routingContracts, secondaryFees);
        // preparedApproval always uses the tokenIn address because we are always selling the tokenIn
        const approval = await getApproval(this.provider, fromAddress, preparedApproval, gasPrice);
        return {
            approval,
            swap,
            quote: userQuote,
        };
    }
    /**
     * Get the unsigned swap transaction given the amount to sell.
     * Includes quote details for the swap.
     *
     * @param {string} fromAddress The public address that will sign and submit the transaction.
     * @param {string} tokenInAddress Token address to sell.
     * @param {string} tokenOutAddress Token address to buy.
     * @param {ethers.BigNumberish} amountIn Amount to sell.
     * @param {number} slippagePercent (optional) The percentage of slippage tolerance. Default = 0.1. Max = 50. Min = 0.
     * @param {number} maxHops (optional) Maximum hops allowed in optimal route. Default is 2.
     * @param {number} deadline (optional) Latest time swap can execute. Default is 15 minutes.
     * @return {TransactionResponse} The result containing the unsigned transaction and details of the swap.
     */
    async getUnsignedSwapTxFromAmountIn(fromAddress, tokenInAddress, tokenOutAddress, amountIn, slippagePercent = DEFAULT_SLIPPAGE, maxHops = DEFAULT_MAX_HOPS, deadline = DEFAULT_DEADLINE) {
        return await this.getUnsignedSwapTx(fromAddress, tokenInAddress, tokenOutAddress, ethers.BigNumber.from(amountIn), slippagePercent, maxHops, deadline, TradeType.EXACT_INPUT);
    }
    /**
     * Get the unsigned swap transaction given the amount to buy.
     * Includes quote details for the swap.
     *
     * @param {string} fromAddress The public address that will sign and submit the transaction.
     * @param {string} tokenInAddress Token address to sell.
     * @param {string} tokenOutAddress Token address to buy.
     * @param {ethers.BigNumberish} amountOut Amount to buy.
     * @param {number} slippagePercent (optional) The percentage of slippage tolerance. Default = 0.1. Max = 50. Min = 0.
     * @param {number} maxHops (optional) Maximum hops allowed in optimal route. Default is 2.
     * @param {number} deadline (optional) Latest time swap can execute. Default is 15 minutes.
     * @return {TransactionResponse} The result containing the unsigned transaction and details of the swap.
     */
    async getUnsignedSwapTxFromAmountOut(fromAddress, tokenInAddress, tokenOutAddress, amountOut, slippagePercent = DEFAULT_SLIPPAGE, maxHops = DEFAULT_MAX_HOPS, deadline = DEFAULT_DEADLINE) {
        return await this.getUnsignedSwapTx(fromAddress, tokenInAddress, tokenOutAddress, ethers.BigNumber.from(amountOut), slippagePercent, maxHops, deadline, TradeType.EXACT_OUTPUT);
    }
}

/* eslint-disable class-methods-use-this */ 




var $aa144554f9ef124b$export$226b052ecb8ca80;
(function(BuyStatusType) {
    BuyStatusType["SUCCESS"] = "SUCCESS";
    BuyStatusType["FAILED"] = "FAILED";
})($aa144554f9ef124b$export$226b052ecb8ca80 || ($aa144554f9ef124b$export$226b052ecb8ca80 = {}));


var $1e6b81bbd98b3a91$export$c0189a8c30039654;
(function(CancelStatusType) {
    CancelStatusType["SUCCESS"] = "SUCCESS";
    CancelStatusType["FAILED"] = "FAILED";
})($1e6b81bbd98b3a91$export$c0189a8c30039654 || ($1e6b81bbd98b3a91$export$c0189a8c30039654 = {}));


/**
 * Enum representing different chain IDs.
 * @enum {number}
 * @property {number} IMTBL_ZKEVM_MAINNET - The chain ID for IMTBL ZKEVM Mainnet.
 * @property {number} IMTBL_ZKEVM_TESTNET - The chain ID for IMTBL ZKEVM Testnet.
 * @property {number} IMTBL_ZKEVM_DEVNET - The chain ID for IMTBL ZKEVM Devnet.
 * @property {number} ETHEREUM - The chain ID for Ethereum.
 * @property {number} SEPOLIA - The chain ID for Sepolia.
 */ var $0472f23319457bfb$export$c06e1e7429de6283;
(function(ChainId) {
    ChainId[ChainId["IMTBL_ZKEVM_MAINNET"] = 13371] = "IMTBL_ZKEVM_MAINNET";
    ChainId[ChainId["IMTBL_ZKEVM_TESTNET"] = 13472] = "IMTBL_ZKEVM_TESTNET";
    ChainId[ChainId["IMTBL_ZKEVM_DEVNET"] = 13433] = "IMTBL_ZKEVM_DEVNET";
    ChainId[ChainId["ETHEREUM"] = 1] = "ETHEREUM";
    ChainId[ChainId["SEPOLIA"] = 11155111] = "SEPOLIA";
})($0472f23319457bfb$export$c06e1e7429de6283 || ($0472f23319457bfb$export$c06e1e7429de6283 = {}));
var $0472f23319457bfb$export$b874c6b1dfe85e02;
(function(ChainName) {
    ChainName["ETHEREUM"] = "Ethereum";
    ChainName["SEPOLIA"] = "Sepolia";
    ChainName["IMTBL_ZKEVM_TESTNET"] = "Immutable zkEVM Test";
    ChainName["IMTBL_ZKEVM_DEVNET"] = "Immutable zkEVM Dev";
    ChainName["IMTBL_ZKEVM_MAINNET"] = "Immutable zkEVM";
})($0472f23319457bfb$export$b874c6b1dfe85e02 || ($0472f23319457bfb$export$b874c6b1dfe85e02 = {}));


var $bc2bfebf768286d3$export$8cb0af6b2bed4b64;
(function(OnRampProvider) {
    OnRampProvider["TRANSAK"] = "201811419111";
})($bc2bfebf768286d3$export$8cb0af6b2bed4b64 || ($bc2bfebf768286d3$export$8cb0af6b2bed4b64 = {}));






var $de275b98d2b651c3$export$788b1fd17f3dad84;
(function(GasEstimateType) {
    GasEstimateType["BRIDGE_TO_L2"] = "BRIDGE_TO_L2";
    GasEstimateType["SWAP"] = "SWAP";
})($de275b98d2b651c3$export$788b1fd17f3dad84 || ($de275b98d2b651c3$export$788b1fd17f3dad84 = {}));


var $a47e48dd2c04791b$export$1f05a55fe0680cc7;
(function(NetworkFilterTypes) {
    NetworkFilterTypes["ALL"] = "all";
})($a47e48dd2c04791b$export$1f05a55fe0680cc7 || ($a47e48dd2c04791b$export$1f05a55fe0680cc7 = {}));




var $c2874b006e92b115$export$a9780122aaa0801a;
(function(SellStatusType) {
    SellStatusType["SUCCESS"] = "SUCCESS";
    SellStatusType["FAILED"] = "FAILED";
})($c2874b006e92b115$export$a9780122aaa0801a || ($c2874b006e92b115$export$a9780122aaa0801a = {}));


var $08d5ddc39acd6833$export$fd9b17d87f4121d2;
(function(TokenFilterTypes) {
    TokenFilterTypes["ALL"] = "all";
    TokenFilterTypes["SWAP"] = "swap";
    TokenFilterTypes["BRIDGE"] = "bridge";
    TokenFilterTypes["ONRAMP"] = "onramp";
})($08d5ddc39acd6833$export$fd9b17d87f4121d2 || ($08d5ddc39acd6833$export$fd9b17d87f4121d2 = {}));


/**
 * Represents information about a token.
 * @interface TokenInfo
 * @property {string} name - The name of the token.
 * @property {string} symbol - The symbol of the token.
 * @property {number} decimals - The number of decimal places the token supports.
 * @property {string | undefined} [address] - The address of the token.
 * @property {string | undefined} [icon] - The URL of the token's icon.
 */ 



var $4f91c5f280efe242$export$35b06f0d33f57e26;
(function(WalletAction) {
    WalletAction["CHECK_CONNECTION"] = "eth_accounts";
    WalletAction["CONNECT"] = "eth_requestAccounts";
    WalletAction["ADD_NETWORK"] = "wallet_addEthereumChain";
    WalletAction["SWITCH_NETWORK"] = "wallet_switchEthereumChain";
    WalletAction["GET_CHAINID"] = "eth_chainId";
})($4f91c5f280efe242$export$35b06f0d33f57e26 || ($4f91c5f280efe242$export$35b06f0d33f57e26 = {}));
var $4f91c5f280efe242$export$a75605c67ea83a5a;
(function(WalletFilterTypes) {
    WalletFilterTypes["ALL"] = "all";
})($4f91c5f280efe242$export$a75605c67ea83a5a || ($4f91c5f280efe242$export$a75605c67ea83a5a = {}));


var $e768639828688ca3$export$2d7a51a18d87e21d;
(function(WalletProviderName) {
    WalletProviderName["PASSPORT"] = "passport";
    WalletProviderName["METAMASK"] = "metamask";
})($e768639828688ca3$export$2d7a51a18d87e21d || ($e768639828688ca3$export$2d7a51a18d87e21d = {}));
const $e768639828688ca3$export$44dde05038008549 = {
    allowMistmatchedChainId: false,
    allowUnsupportedProvider: false
};




const $d85ad1457a3f1a83$export$7d3a9eeba384fa59 = "development";
const $d85ad1457a3f1a83$export$b80040cb173ba6e9 = "0x0000000000000000000000000000000000001010";
const $d85ad1457a3f1a83$export$903389470ba9433c = 18;
const $d85ad1457a3f1a83$var$ZKEVM_NATIVE_TOKEN = {
    name: "IMX",
    symbol: "IMX",
    decimals: $d85ad1457a3f1a83$export$903389470ba9433c,
    address: $d85ad1457a3f1a83$export$b80040cb173ba6e9
};
const $d85ad1457a3f1a83$export$161d4a74df65fc08 = {
    [$d85ad1457a3f1a83$export$7d3a9eeba384fa59]: "https://checkout-api.dev.immutable.com",
    [(Environment$1).SANDBOX]: "https://checkout-api.sandbox.immutable.com",
    [(Environment$1).PRODUCTION]: "https://checkout-api.immutable.com"
};
const $d85ad1457a3f1a83$export$72176e2233d7d5d = true;
const $d85ad1457a3f1a83$export$566b5975cc83d6b4 = true;
const $d85ad1457a3f1a83$export$261cde2078dba35b = true;
const $d85ad1457a3f1a83$export$f6043d7fce62d71b = {
    [(Environment$1).SANDBOX]: "https://global-stg.transak.com",
    [(Environment$1).PRODUCTION]: "https://global.transak.com/"
};
const $d85ad1457a3f1a83$export$6f24f3cef7d501c4 = new Map([
    [
        ($0472f23319457bfb$export$c06e1e7429de6283).ETHEREUM,
        {
            chainIdHex: `0x${($0472f23319457bfb$export$c06e1e7429de6283).ETHEREUM.toString(16)}`,
            chainName: ($0472f23319457bfb$export$b874c6b1dfe85e02).ETHEREUM,
            rpcUrls: [
                "https://checkout-api.immutable.com/v1/rpc/eth-mainnet"
            ],
            nativeCurrency: {
                name: ($0472f23319457bfb$export$b874c6b1dfe85e02).ETHEREUM,
                symbol: "ETH",
                decimals: 18
            },
            blockExplorerUrls: [
                "https://etherscan.io/"
            ]
        }
    ],
    [
        ($0472f23319457bfb$export$c06e1e7429de6283).IMTBL_ZKEVM_MAINNET,
        {
            chainIdHex: `0x${($0472f23319457bfb$export$c06e1e7429de6283).IMTBL_ZKEVM_MAINNET.toString(16)}`,
            chainName: ($0472f23319457bfb$export$b874c6b1dfe85e02).IMTBL_ZKEVM_MAINNET,
            rpcUrls: [
                "https://rpc.immutable.com"
            ],
            nativeCurrency: $d85ad1457a3f1a83$var$ZKEVM_NATIVE_TOKEN
        }
    ]
]);
const $d85ad1457a3f1a83$export$3e81fc0987227f10 = new Map([
    [
        ($0472f23319457bfb$export$c06e1e7429de6283).SEPOLIA,
        {
            chainIdHex: `0x${($0472f23319457bfb$export$c06e1e7429de6283).SEPOLIA.toString(16)}`,
            chainName: ($0472f23319457bfb$export$b874c6b1dfe85e02).SEPOLIA,
            rpcUrls: [
                "https://checkout-api.sandbox.immutable.com/v1/rpc/eth-sepolia"
            ],
            nativeCurrency: {
                name: "Sep Eth",
                symbol: "ETH",
                decimals: 18
            },
            blockExplorerUrls: [
                "https://sepolia.etherscan.io/"
            ]
        }
    ],
    [
        ($0472f23319457bfb$export$c06e1e7429de6283).IMTBL_ZKEVM_TESTNET,
        {
            chainIdHex: `0x${($0472f23319457bfb$export$c06e1e7429de6283).IMTBL_ZKEVM_TESTNET.toString(16)}`,
            chainName: ($0472f23319457bfb$export$b874c6b1dfe85e02).IMTBL_ZKEVM_TESTNET,
            rpcUrls: [
                "https://rpc.testnet.immutable.com"
            ],
            nativeCurrency: $d85ad1457a3f1a83$var$ZKEVM_NATIVE_TOKEN
        }
    ]
]);
const $d85ad1457a3f1a83$export$3a9ebede6a150274 = new Map([
    [
        ($0472f23319457bfb$export$c06e1e7429de6283).SEPOLIA,
        {
            chainIdHex: `0x${($0472f23319457bfb$export$c06e1e7429de6283).SEPOLIA.toString(16)}`,
            chainName: ($0472f23319457bfb$export$b874c6b1dfe85e02).SEPOLIA,
            rpcUrls: [
                "https://checkout-api.dev.immutable.com/v1/rpc/eth-sepolia"
            ],
            nativeCurrency: {
                name: "Sep Eth",
                symbol: "ETH",
                decimals: 18
            },
            blockExplorerUrls: [
                "https://sepolia.etherscan.io/"
            ]
        }
    ],
    [
        ($0472f23319457bfb$export$c06e1e7429de6283).IMTBL_ZKEVM_DEVNET,
        {
            chainIdHex: `0x${($0472f23319457bfb$export$c06e1e7429de6283).IMTBL_ZKEVM_DEVNET.toString(16)}`,
            chainName: ($0472f23319457bfb$export$b874c6b1dfe85e02).IMTBL_ZKEVM_DEVNET,
            rpcUrls: [
                "https://rpc.dev.immutable.com"
            ],
            nativeCurrency: $d85ad1457a3f1a83$var$ZKEVM_NATIVE_TOKEN
        }
    ]
]);
const $d85ad1457a3f1a83$export$fc55ed5a42b458ba = {
    [($0472f23319457bfb$export$c06e1e7429de6283).IMTBL_ZKEVM_TESTNET]: {
        url: "https://explorer.testnet.immutable.com",
        nativeToken: $d85ad1457a3f1a83$export$3e81fc0987227f10.get(($0472f23319457bfb$export$c06e1e7429de6283).IMTBL_ZKEVM_TESTNET).nativeCurrency
    },
    [($0472f23319457bfb$export$c06e1e7429de6283).IMTBL_ZKEVM_MAINNET]: {
        url: "https://explorer.mainnet.immutable.com",
        nativeToken: $d85ad1457a3f1a83$export$6f24f3cef7d501c4.get(($0472f23319457bfb$export$c06e1e7429de6283).IMTBL_ZKEVM_MAINNET).nativeCurrency
    }
};
const $d85ad1457a3f1a83$export$db5daa1b5156ccfe = [
    {
        constant: true,
        inputs: [],
        name: "name",
        outputs: [
            {
                name: "",
                type: "string"
            }
        ],
        payable: false,
        type: "function"
    },
    {
        constant: true,
        inputs: [],
        name: "decimals",
        outputs: [
            {
                name: "",
                type: "uint8"
            }
        ],
        payable: false,
        type: "function"
    },
    {
        constant: true,
        inputs: [
            {
                name: "_owner",
                type: "address"
            }
        ],
        name: "balanceOf",
        outputs: [
            {
                name: "balance",
                type: "uint256"
            }
        ],
        payable: false,
        type: "function"
    },
    {
        constant: true,
        inputs: [],
        name: "symbol",
        outputs: [
            {
                name: "",
                type: "string"
            }
        ],
        payable: false,
        type: "function"
    },
    {
        constant: true,
        inputs: [
            {
                name: "_owner",
                type: "address"
            },
            {
                name: "_spender",
                type: "address"
            }
        ],
        name: "allowance",
        outputs: [
            {
                name: "",
                type: "uint256"
            }
        ],
        payable: false,
        stateMutability: "view",
        type: "function"
    },
    {
        constant: false,
        inputs: [
            {
                name: "_spender",
                type: "address"
            },
            {
                name: "_value",
                type: "uint256"
            }
        ],
        name: "approve",
        outputs: [
            {
                name: "",
                type: "bool"
            }
        ],
        payable: false,
        stateMutability: "nonpayable",
        type: "function"
    }
];
const $d85ad1457a3f1a83$export$8b8be7a2a654f23e = [
    {
        constant: false,
        inputs: [
            {
                internalType: "address",
                name: "to",
                type: "address"
            },
            {
                internalType: "uint256",
                name: "tokenId",
                type: "uint256"
            }
        ],
        name: "approve",
        outputs: [],
        payable: false,
        stateMutability: "nonpayable",
        type: "function"
    },
    {
        constant: true,
        inputs: [
            {
                internalType: "address",
                name: "owner",
                type: "address"
            },
            {
                internalType: "address",
                name: "operator",
                type: "address"
            }
        ],
        name: "isApprovedForAll",
        outputs: [
            {
                internalType: "bool",
                name: "",
                type: "bool"
            }
        ],
        payable: false,
        stateMutability: "view",
        type: "function"
    },
    {
        constant: true,
        inputs: [
            {
                internalType: "uint256",
                name: "tokenId",
                type: "uint256"
            }
        ],
        name: "getApproved",
        outputs: [
            {
                internalType: "address",
                name: "",
                type: "address"
            }
        ],
        payable: false,
        stateMutability: "view",
        type: "function"
    },
    {
        inputs: [
            {
                internalType: "uint256",
                name: "tokenId",
                type: "uint256"
            }
        ],
        name: "ownerOf",
        outputs: [
            {
                internalType: "address",
                name: "",
                type: "address"
            }
        ],
        stateMutability: "view",
        type: "function"
    }
];


var $4b58188d47aafe8d$export$1fc8f52ad1810e52;
(function(ItemType) {
    ItemType["NATIVE"] = "NATIVE";
    ItemType["ERC20"] = "ERC20";
    ItemType["ERC721"] = "ERC721";
})($4b58188d47aafe8d$export$1fc8f52ad1810e52 || ($4b58188d47aafe8d$export$1fc8f52ad1810e52 = {}));
var $4b58188d47aafe8d$export$65c64e46348ee3c1;
(function(TransactionOrGasType) {
    TransactionOrGasType["TRANSACTION"] = "TRANSACTION";
    TransactionOrGasType["GAS"] = "GAS";
})($4b58188d47aafe8d$export$65c64e46348ee3c1 || ($4b58188d47aafe8d$export$65c64e46348ee3c1 = {}));
var $4b58188d47aafe8d$export$537fa3efd10ed435;
(function(GasTokenType) {
    GasTokenType["NATIVE"] = "NATIVE";
    GasTokenType["ERC20"] = "ERC20";
})($4b58188d47aafe8d$export$537fa3efd10ed435 || ($4b58188d47aafe8d$export$537fa3efd10ed435 = {}));
var $4b58188d47aafe8d$export$3af78bb3e8650ee6;
(function(FundingRouteType) {
    FundingRouteType["BRIDGE"] = "BRIDGE";
    FundingRouteType["ONRAMP"] = "ONRAMP";
    FundingRouteType["SWAP"] = "SWAP";
})($4b58188d47aafe8d$export$3af78bb3e8650ee6 || ($4b58188d47aafe8d$export$3af78bb3e8650ee6 = {}));


var $e055e79256bbc1dd$export$80f4da0d409a629d;
(function(ExchangeType) {
    ExchangeType["ONRAMP"] = "onramp";
})($e055e79256bbc1dd$export$80f4da0d409a629d || ($e055e79256bbc1dd$export$80f4da0d409a629d = {}));




/**
 * Enum representing different types of errors that can occur during the checkout process.
 */ var $a8bc256d81a5e2c1$export$e3dc0620abde7f5a;
(function(CheckoutErrorType) {
    CheckoutErrorType["WEB3_PROVIDER_ERROR"] = "WEB3_PROVIDER_ERROR";
    CheckoutErrorType["PROVIDER_ERROR"] = "PROVIDER_ERROR";
    CheckoutErrorType["DEFAULT_PROVIDER_ERROR"] = "DEFAULT_PROVIDER_ERROR";
    CheckoutErrorType["CONNECT_PROVIDER_ERROR"] = "CONNECT_PROVIDER_ERROR";
    CheckoutErrorType["GET_BALANCE_ERROR"] = "GET_BALANCE_ERROR";
    CheckoutErrorType["GET_INDEXER_BALANCE_ERROR"] = "GET_INDEXER_BALANCE_ERROR";
    CheckoutErrorType["GET_ERC20_BALANCE_ERROR"] = "GET_ERC20_BALANCE_ERROR";
    CheckoutErrorType["GET_ERC721_BALANCE_ERROR"] = "GET_ERC721_BALANCE_ERROR";
    CheckoutErrorType["GET_NETWORK_INFO_ERROR"] = "GET_NETWORK_INFO_ERROR";
    CheckoutErrorType["METAMASK_PROVIDER_ERROR"] = "METAMASK_PROVIDER_ERROR";
    CheckoutErrorType["CHAIN_NOT_SUPPORTED_ERROR"] = "CHAIN_NOT_SUPPORTED_ERROR";
    CheckoutErrorType["PROVIDER_REQUEST_MISSING_ERROR"] = "PROVIDER_REQUEST_MISSING_ERROR";
    CheckoutErrorType["PROVIDER_REQUEST_FAILED_ERROR"] = "PROVIDER_REQUEST_FAILED_ERROR";
    CheckoutErrorType["USER_REJECTED_REQUEST_ERROR"] = "USER_REJECTED_REQUEST_ERROR";
    CheckoutErrorType["TRANSACTION_FAILED"] = "TRANSACTION_FAILED";
    CheckoutErrorType["INSUFFICIENT_FUNDS"] = "INSUFFICIENT_FUNDS";
    CheckoutErrorType["UNPREDICTABLE_GAS_LIMIT"] = "UNPREDICTABLE_GAS_LIMIT";
    CheckoutErrorType["INVALID_GAS_ESTIMATE_TYPE"] = "INVALID_GAS_ESTIMATE_TYPE";
    CheckoutErrorType["UNSUPPORTED_TOKEN_TYPE_ERROR"] = "UNSUPPORTED_TOKEN_TYPE_ERROR";
    CheckoutErrorType["UNSUPPORTED_BALANCE_REQUIREMENT_ERROR"] = "UNSUPPORTED_BALANCE_REQUIREMENT_ERROR";
    CheckoutErrorType["GET_ORDER_LISTING_ERROR"] = "GET_ORDER_LISTING_ERROR";
    CheckoutErrorType["CANCEL_ORDER_LISTING_ERROR"] = "CANCEL_ORDER_LISTING_ERROR";
    CheckoutErrorType["PREPARE_ORDER_LISTING_ERROR"] = "PREPARE_ORDER_LISTING_ERROR";
    CheckoutErrorType["CREATE_ORDER_LISTING_ERROR"] = "CREATE_ORDER_LISTING_ERROR";
    CheckoutErrorType["FULFILL_ORDER_LISTING_ERROR"] = "FULFILL_ORDER_LISTING_ERROR";
    CheckoutErrorType["SWITCH_NETWORK_UNSUPPORTED"] = "SWITCH_NETWORK_UNSUPPORTED";
    CheckoutErrorType["GET_ERC20_ALLOWANCE_ERROR"] = "GET_ERC20_ALLOWANCE_ERROR";
    CheckoutErrorType["GET_ERC721_ALLOWANCE_ERROR"] = "GET_ERC721_ALLOWANCE_ERROR";
    CheckoutErrorType["EXECUTE_APPROVAL_TRANSACTION_ERROR"] = "EXECUTE_APPROVAL_TRANSACTION_ERROR";
    CheckoutErrorType["EXECUTE_FULFILLMENT_TRANSACTION_ERROR"] = "EXECUTE_FULFILLMENT_TRANSACTION_ERROR";
    CheckoutErrorType["SIGN_MESSAGE_ERROR"] = "SIGN_MESSAGE_ERROR";
    CheckoutErrorType["BRIDGE_GAS_ESTIMATE_ERROR"] = "BRIDGE_GAS_ESTIMATE_ERROR";
    CheckoutErrorType["ORDER_FEE_ERROR"] = "ORDER_FEE_ERROR";
    CheckoutErrorType["ITEM_REQUIREMENTS_ERROR"] = "ITEM_REQUIREMENTS_ERROR";
})($a8bc256d81a5e2c1$export$e3dc0620abde7f5a || ($a8bc256d81a5e2c1$export$e3dc0620abde7f5a = {}));
class $a8bc256d81a5e2c1$export$b722478a3cbfa3bc extends Error {
    message;
    type;
    data;
    constructor(message, type, data){
        super(message);
        this.message = message;
        this.type = type;
        this.data = data;
    }
}
var $a8bc256d81a5e2c1$export$a22d4e0719ee6def;
(function(CheckoutInternalErrorType) {
    CheckoutInternalErrorType["REJECTED_SWITCH_AFTER_ADDING_NETWORK"] = "REJECTED_SWITCH_AFTER_ADDING_NETWORK";
})($a8bc256d81a5e2c1$export$a22d4e0719ee6def || ($a8bc256d81a5e2c1$export$a22d4e0719ee6def = {}));
const $a8bc256d81a5e2c1$export$bacc563de539c6c3 = async (/**
 * Wraps a function that returns a Promise and catches any errors that occur. If an error is caught,
 * it is wrapped in a CheckoutError and rethrown.
 */ fn, customError)=>{
    try {
        return await fn();
    } catch (error) {
        const cause = `${error.message}` || "UnknownError";
        const errorMessage = customError.message ? `[${customError.type}]:${customError.message}. Cause:${cause}` : `[${customError.type}] Cause:${cause}`;
        if (error instanceof $a8bc256d81a5e2c1$export$b722478a3cbfa3bc) throw new $a8bc256d81a5e2c1$export$b722478a3cbfa3bc(errorMessage, customError.type, {
            ...customError.data,
            innerErrorType: error.type,
            ...error.data
        });
        throw new $a8bc256d81a5e2c1$export$b722478a3cbfa3bc(errorMessage, customError.type, {
            ...customError.data
        });
    }
};




/* eslint-disable @typescript-eslint/no-explicit-any */ 


// this function needs to be in a separate file to prevent circular dependencies with ./network


async function $a1555a1d2c8d059b$export$c3ba3e93a9fee972(web3Provider) {
    if (!web3Provider.provider?.request) throw new ($a8bc256d81a5e2c1$export$b722478a3cbfa3bc)("Parsed provider is not a valid Web3Provider", ($a8bc256d81a5e2c1$export$e3dc0620abde7f5a).WEB3_PROVIDER_ERROR);
    const chainId = await web3Provider.provider.request({
        method: ($4f91c5f280efe242$export$35b06f0d33f57e26).GET_CHAINID,
        params: []
    });
    return parseInt(chainId, 16);
}


const $de192de6ef100f9f$var$UNRECOGNISED_CHAIN_ERROR_CODE = 4902; // error code (MetaMask)
// these functions should not be exported. These functions should be used as part of an exported function e.g switchWalletNetwork() above.
// make sure to check if(provider.provider?.request) in the exported function and throw an error
// eslint-disable-next-line consistent-return
async function $de192de6ef100f9f$var$switchNetworkInWallet(networkMap, web3Provider, chainId) {
    if (web3Provider.provider?.request) return await web3Provider.provider.request({
        method: ($4f91c5f280efe242$export$35b06f0d33f57e26).SWITCH_NETWORK,
        params: [
            {
                chainId: networkMap.get(chainId)?.chainIdHex
            }
        ]
    });
}
// TODO: Should these functions always return something?
// eslint-disable-next-line consistent-return
async function $de192de6ef100f9f$var$addNetworkToWallet(networkMap, web3Provider, chainId) {
    if (web3Provider.provider?.request) {
        const networkDetails = networkMap.get(chainId);
        const addNetwork = {
            chainId: networkDetails?.chainIdHex,
            chainName: networkDetails?.chainName,
            rpcUrls: networkDetails?.rpcUrls,
            nativeCurrency: networkDetails?.nativeCurrency,
            blockExplorerUrls: networkDetails?.blockExplorerUrls
        };
        return await web3Provider.provider.request({
            method: ($4f91c5f280efe242$export$35b06f0d33f57e26).ADD_NETWORK,
            params: [
                addNetwork
            ]
        });
    }
}
async function $de192de6ef100f9f$export$3043f6442a9ef563(config, { type: type = ($a47e48dd2c04791b$export$1f05a55fe0680cc7).ALL, exclude: exclude }) {
    const { networkMap: networkMap } = config;
    const allowedNetworkConfig = await config.remote.getConfig("allowedNetworks");
    const list = allowedNetworkConfig.filter((network)=>{
        const allowAllTokens = type === ($a47e48dd2c04791b$export$1f05a55fe0680cc7).ALL;
        const networkNotExcluded = !(exclude || []).map((exc)=>exc.chainId).includes(network.chainId);
        return allowAllTokens && networkNotExcluded;
    });
    const allowedNetworks = [];
    list.forEach((element)=>{
        const newNetwork = networkMap.get(element.chainId);
        if (newNetwork) allowedNetworks.push({
            name: newNetwork.chainName,
            chainId: parseInt(newNetwork.chainIdHex, 16),
            nativeCurrency: newNetwork.nativeCurrency,
            isSupported: true
        });
    });
    return {
        networks: allowedNetworks
    };
}
async function $de192de6ef100f9f$export$79f13b4cfaaf0d09(config, web3Provider) {
    const { networkMap: networkMap } = config;
    return ($a8bc256d81a5e2c1$export$bacc563de539c6c3)(async ()=>{
        try {
            const network = await web3Provider.getNetwork();
            if (Array.from(networkMap.keys()).includes(network.chainId)) {
                const chainIdNetworkInfo = networkMap.get(network.chainId);
                return {
                    name: chainIdNetworkInfo.chainName,
                    chainId: parseInt(chainIdNetworkInfo.chainIdHex, 16),
                    nativeCurrency: chainIdNetworkInfo.nativeCurrency,
                    isSupported: true
                };
            }
            return {
                chainId: network.chainId,
                name: network.name,
                isSupported: false
            };
        } catch (err) {
            const chainId = await ($a1555a1d2c8d059b$export$c3ba3e93a9fee972)(web3Provider);
            const isSupported = Array.from(networkMap.keys()).includes(chainId);
            return {
                chainId: chainId,
                isSupported: isSupported
            };
        }
    }, {
        type: ($a8bc256d81a5e2c1$export$e3dc0620abde7f5a).GET_NETWORK_INFO_ERROR
    });
}
async function $de192de6ef100f9f$export$b827d9418aeb5dbd(config, web3Provider, chainId) {
    const { networkMap: networkMap } = config;
    const allowedNetworks = await $de192de6ef100f9f$export$3043f6442a9ef563(config, {
        type: ($a47e48dd2c04791b$export$1f05a55fe0680cc7).ALL
    });
    if (!allowedNetworks.networks.some((network)=>network.chainId === chainId)) throw new ($a8bc256d81a5e2c1$export$b722478a3cbfa3bc)(`Chain:${chainId} is not a supported chain`, ($a8bc256d81a5e2c1$export$e3dc0620abde7f5a).CHAIN_NOT_SUPPORTED_ERROR);
    if (web3Provider.provider?.isPassport) throw new ($a8bc256d81a5e2c1$export$b722478a3cbfa3bc)("Switching networks with Passport provider is not supported", ($a8bc256d81a5e2c1$export$e3dc0620abde7f5a).SWITCH_NETWORK_UNSUPPORTED);
    // WT-1146 - Refer to the README in this folder for explanation on the switch network flow
    try {
        await $de192de6ef100f9f$var$switchNetworkInWallet(networkMap, web3Provider, chainId);
    } catch (err) {
        if (err.code === $de192de6ef100f9f$var$UNRECOGNISED_CHAIN_ERROR_CODE) try {
            await $de192de6ef100f9f$var$addNetworkToWallet(networkMap, web3Provider, chainId);
        // eslint-disable-next-line @typescript-eslint/no-shadow
        } catch (err) {
            throw new ($a8bc256d81a5e2c1$export$b722478a3cbfa3bc)("User cancelled add network request", ($a8bc256d81a5e2c1$export$e3dc0620abde7f5a).USER_REJECTED_REQUEST_ERROR);
        }
        else throw new ($a8bc256d81a5e2c1$export$b722478a3cbfa3bc)("User cancelled switch network request", ($a8bc256d81a5e2c1$export$e3dc0620abde7f5a).USER_REJECTED_REQUEST_ERROR);
    }
    const newProvider = new (Web3Provider)(web3Provider.provider);
    const newProviderNetwork = await newProvider.getNetwork();
    if (newProviderNetwork.chainId !== chainId) throw new ($a8bc256d81a5e2c1$export$b722478a3cbfa3bc)("User cancelled switch network request", ($a8bc256d81a5e2c1$export$e3dc0620abde7f5a).USER_REJECTED_REQUEST_ERROR);
    const networkInfo = await $de192de6ef100f9f$export$79f13b4cfaaf0d09(config, newProvider);
    return {
        network: networkInfo,
        provider: newProvider
    };
}










class $a492ee374ae7b613$export$d902b56530cd5f87 {
    isDevelopment;
    isProduction;
    configCache;
    tokensCache;
    constructor(params){
        this.isDevelopment = params.isDevelopment;
        this.isProduction = params.isProduction;
    }
    static async makeHttpRequest(url) {
        let response;
        try {
            response = await (0, globalAxios$1).get(url);
        } catch (error) {
            throw new Error(`Error fetching from api: ${error.message}`);
        }
        if (response.status !== 200) throw new Error(`Error fetching from api: ${response.status} ${response.statusText}`);
        return response;
    }
    getEndpoint = ()=>{
        if (this.isDevelopment) return ($d85ad1457a3f1a83$export$161d4a74df65fc08)[$d85ad1457a3f1a83$export$7d3a9eeba384fa59];
        if (this.isProduction) return ($d85ad1457a3f1a83$export$161d4a74df65fc08)[(Environment$1).PRODUCTION];
        return ($d85ad1457a3f1a83$export$161d4a74df65fc08)[(Environment$1).SANDBOX];
    };
    async loadConfig() {
        if (this.configCache) return this.configCache;
        const response = await $a492ee374ae7b613$export$d902b56530cd5f87.makeHttpRequest(`${this.getEndpoint()}/v1/config`);
        this.configCache = response.data;
        return this.configCache;
    }
    async loadConfigTokens() {
        if (this.tokensCache) return this.tokensCache;
        const response = await $a492ee374ae7b613$export$d902b56530cd5f87.makeHttpRequest(`${this.getEndpoint()}/v1/config/tokens`);
        this.tokensCache = response.data;
        return this.tokensCache;
    }
    async getConfig(key) {
        const config = await this.loadConfig();
        if (!config) return undefined;
        if (!key) return config;
        return config[key];
    }
    async getTokensConfig(chainId) {
        const config = await this.loadConfigTokens();
        if (!config || !config[chainId]) return {};
        return config[chainId] ?? [];
    }
}


class $4013c5c91bb535f6$export$6ad73ea7e1b6f37f extends Error {
    message;
    constructor(message){
        super(message);
        this.message = message;
    }
}
const $4013c5c91bb535f6$var$networkMap = (prod, dev)=>{
    if (dev) return $d85ad1457a3f1a83$export$3a9ebede6a150274;
    if (prod) return $d85ad1457a3f1a83$export$6f24f3cef7d501c4;
    return $d85ad1457a3f1a83$export$3e81fc0987227f10;
};
const $4013c5c91bb535f6$export$9b794d067cdd1af6 = (config)=>{
    // DevMode and Sandbox will both use Sepolia.
    if (!config.isProduction) return ($0472f23319457bfb$export$c06e1e7429de6283).SEPOLIA;
    return ($0472f23319457bfb$export$c06e1e7429de6283).ETHEREUM;
};
const $4013c5c91bb535f6$export$c9af4e4b001c6476 = (config)=>{
    if (config.isDevelopment) return ($0472f23319457bfb$export$c06e1e7429de6283).IMTBL_ZKEVM_DEVNET;
    if (config.isProduction) return ($0472f23319457bfb$export$c06e1e7429de6283).IMTBL_ZKEVM_MAINNET;
    return ($0472f23319457bfb$export$c06e1e7429de6283).IMTBL_ZKEVM_TESTNET;
};
class $4013c5c91bb535f6$export$4823433c4a67bbc6 {
    // This is a hidden feature that is only available
    // when building the project from source code.
    // This will be used to get around the lack of
    // Environment.DEVELOPMENT
    isDevelopment = false;
    isProduction;
    isOnRampEnabled;
    isSwapEnabled;
    isBridgeEnabled;
    remote;
    environment;
    networkMap;
    constructor(config){
        if (!Object.values((Environment$1)).includes(config.baseConfig.environment)) throw new $4013c5c91bb535f6$export$6ad73ea7e1b6f37f("Invalid checkout configuration of environment");
        this.environment = config.baseConfig.environment;
        // Developer mode will super set any environment configuration
        this.isProduction = !this.isDevelopment && this.environment === (Environment$1).PRODUCTION;
        this.isOnRampEnabled = config.isOnRampEnabled ?? ($d85ad1457a3f1a83$export$72176e2233d7d5d);
        this.isSwapEnabled = config.isSwapEnabled ?? ($d85ad1457a3f1a83$export$566b5975cc83d6b4);
        this.isBridgeEnabled = config.isBridgeEnabled ?? ($d85ad1457a3f1a83$export$261cde2078dba35b);
        this.networkMap = $4013c5c91bb535f6$var$networkMap(this.isProduction, this.isDevelopment);
        this.remote = new ($a492ee374ae7b613$export$d902b56530cd5f87)({
            isDevelopment: this.isDevelopment,
            isProduction: this.isProduction
        });
    }
}




const $efe60cea83bfc4e8$export$473cec51305fdae8 = async (config, { type: type = ($08d5ddc39acd6833$export$fd9b17d87f4121d2).ALL, chainId: chainId, exclude: exclude })=>{
    let tokens = [];
    let onRampConfig;
    switch(type){
        case ($08d5ddc39acd6833$export$fd9b17d87f4121d2).SWAP:
            // Fetch tokens from dex-tokens config because
            // Dex needs to have a whitelisted list of tokens due to
            // legal reasons.
            tokens = (await config.remote.getConfig("dex")).tokens || [];
            break;
        case ($08d5ddc39acd6833$export$fd9b17d87f4121d2).ONRAMP:
            onRampConfig = await config.remote.getConfig("onramp");
            // Only using Transak as it's the only on-ramp provider at the moment
            if (!onRampConfig) tokens = [];
            tokens = onRampConfig[($bc2bfebf768286d3$export$8cb0af6b2bed4b64).TRANSAK]?.tokens || [];
            break;
        case ($08d5ddc39acd6833$export$fd9b17d87f4121d2).BRIDGE:
        case ($08d5ddc39acd6833$export$fd9b17d87f4121d2).ALL:
        default:
            tokens = (await config.remote.getTokensConfig(chainId || ($4013c5c91bb535f6$export$9b794d067cdd1af6)(config))).allowed;
    }
    if (!exclude || exclude?.length === 0) return {
        tokens: tokens
    };
    return {
        tokens: tokens.filter((token)=>!exclude.map((e)=>e.address).includes(token.address || ""))
    };
};






const $fd8a8472dcc3ec2b$var$CACHE_DATA_TTL = 60; // seconds
class $fd8a8472dcc3ec2b$export$ef140a6b05dfc786 {
    url;
    nativeToken;
    ttl;
    chainId;
    cacheMap;
    static async makeHttpRequest(url) {
        return (globalAxios$1).get(url);
    }
    setCache(key, data) {
        this.cacheMap[key] = {
            data: data,
            ttl: new Date().getTime() + this.ttl * 1000
        };
    }
    getCache(key) {
        const d = this.cacheMap[key];
        if (!d || d.ttl <= new Date().getTime()) return null;
        return d.data;
    }
    /**
   * Blockscout constructor
   * @param chainId target chain
   * @param ttl cache TTL
   */ constructor(params){
        this.chainId = params.chainId;
        this.url = ($d85ad1457a3f1a83$export$fc55ed5a42b458ba)[this.chainId].url;
        const native = ($d85ad1457a3f1a83$export$fc55ed5a42b458ba)[this.chainId].nativeToken;
        this.nativeToken = {
            address: native.address ?? "",
            decimals: native.decimals.toString(),
            name: native.name,
            symbol: native.symbol
        };
        this.cacheMap = {};
        this.ttl = params.ttl !== undefined ? params.ttl : $fd8a8472dcc3ec2b$var$CACHE_DATA_TTL;
    }
    /**
   * isChainSupported verifies if the chain is supported by Blockscout
   * @param chainId
   */ static isChainSupported = (chainId)=>Boolean(($d85ad1457a3f1a83$export$fc55ed5a42b458ba)[chainId]);
    /**
   * isBlockscoutError verifies if the error is a Blockscout client error
   * @param err error to evaluate
   */ static isBlockscoutError = (err)=>"code" in err;
    /**
   * getTokensByWalletAddress fetches the list of tokens (by type) owned by the wallet address.
   * @param walletAddress wallet address
   * @param tokenType token type
   * @param nextPage parameters for the next page, to be provided alongside walletAddress and tokenType
   * @returns list of tokens given the wallet address and the token types
   */ async getTokensByWalletAddress(params) {
        try {
            let url = `${this.url}/api/v2/addresses/${params.walletAddress}/tokens?type=${params.tokenType}`;
            if (params.nextPage) url += `&${new URLSearchParams(params.nextPage)}`;
            // Cache response data to prevent unnecessary requests
            const cached = this.getCache(url);
            if (cached) return Promise.resolve(cached);
            const response = await $fd8a8472dcc3ec2b$export$ef140a6b05dfc786.makeHttpRequest(url);
            if (response.status >= 400) return Promise.reject({
                code: response.status,
                message: response.statusText
            });
            // To get around an issue with native tokens being an ERC-20, there is the need
            // to remove IMX from `resp` and add it back in using getNativeTokenByWalletAddress.
            // This has affected some of the early wallets, and it might not be an issue in mainnet
            // however, let's enforce it.
            const data = {
                items: response.data?.items?.filter((token)=>token.token.address && token.token.address !== this.nativeToken.address),
                // eslint-disable-next-line @typescript-eslint/naming-convention
                next_page_params: response.data?.next_page_params
            };
            this.setCache(url, data);
            return Promise.resolve(data);
        } catch (err) {
            let code = (HttpStatusCode$2).InternalServerError;
            let message = "InternalServerError";
            if ((globalAxios$1).isAxiosError(err)) {
                code = err.response?.status || code;
                message = err.message;
            }
            return Promise.reject({
                code: code,
                message: message
            });
        }
    }
    /**
   * getNativeTokenByWalletAddress fetches the native token owned by the wallet address.
   * @param walletAddress wallet address
   * @returns list of tokens given the wallet address and the token types
   */ async getNativeTokenByWalletAddress(params) {
        try {
            const url = `${this.url}/api/v2/addresses/${params.walletAddress}`;
            // Cache response data to prevent unnecessary requests
            const cached = this.getCache(url);
            if (cached) return Promise.resolve(cached);
            const response = await $fd8a8472dcc3ec2b$export$ef140a6b05dfc786.makeHttpRequest(url);
            if (response.status >= 400) return Promise.reject({
                code: response.status,
                message: response.statusText
            });
            const data = {
                token: this.nativeToken,
                value: response.data.coin_balance
            };
            this.setCache(url, data);
            return Promise.resolve(data);
        } catch (err) {
            let code = (HttpStatusCode$2).InternalServerError;
            let message = "InternalServerError";
            if ((globalAxios$1).isAxiosError(err)) {
                code = err.response?.status || code;
                message = err.message;
            }
            return Promise.reject({
                code: code,
                message: message
            });
        }
    }
}


/* eslint @typescript-eslint/naming-convention: off */ var $887a00f8f72d61f0$export$5bd1ea2b3d18210;
(function(BlockscoutTokenType) {
    BlockscoutTokenType["ERC20"] = "ERC-20";
})($887a00f8f72d61f0$export$5bd1ea2b3d18210 || ($887a00f8f72d61f0$export$5bd1ea2b3d18210 = {}));




const $1564e43dde50bb61$export$df96cd8d56be0ab1 = async (config, web3Provider, walletAddress)=>await ($a8bc256d81a5e2c1$export$bacc563de539c6c3)(async ()=>{
        const networkInfo = await ($de192de6ef100f9f$export$79f13b4cfaaf0d09)(config, web3Provider);
        if (!networkInfo.isSupported) throw new ($a8bc256d81a5e2c1$export$b722478a3cbfa3bc)(`Chain:${networkInfo.chainId} is not a supported chain`, ($a8bc256d81a5e2c1$export$e3dc0620abde7f5a).CHAIN_NOT_SUPPORTED_ERROR, {
            chainName: networkInfo.name
        });
        const balance = await web3Provider.getBalance(walletAddress);
        return {
            balance: balance,
            formattedBalance: (utils$1).formatUnits(balance, networkInfo.nativeCurrency.decimals),
            token: networkInfo.nativeCurrency
        };
    }, {
        type: ($a8bc256d81a5e2c1$export$e3dc0620abde7f5a).GET_BALANCE_ERROR
    });
async function $1564e43dde50bb61$export$60e0fe116a0e6ed0(web3Provider, walletAddress, contractAddress) {
    return await ($a8bc256d81a5e2c1$export$bacc563de539c6c3)(async ()=>{
        const contract = new (Contract$1)(contractAddress, JSON.stringify(($d85ad1457a3f1a83$export$db5daa1b5156ccfe)), web3Provider);
        return Promise.all([
            contract.name(),
            contract.symbol(),
            contract.balanceOf(walletAddress),
            contract.decimals()
        ]).then(([name, symbol, balance, decimals])=>{
            const formattedBalance = (utils$1).formatUnits(balance, decimals);
            return {
                balance: balance,
                formattedBalance: formattedBalance,
                token: {
                    name: name,
                    symbol: symbol,
                    decimals: decimals,
                    address: contractAddress
                }
            };
        });
    }, {
        type: ($a8bc256d81a5e2c1$export$e3dc0620abde7f5a).GET_ERC20_BALANCE_ERROR
    });
}
// Blockscout client singleton
let $1564e43dde50bb61$var$blockscoutClient;
const $1564e43dde50bb61$export$8c978679845804d4 = async (walletAddress, chainId, rename)=>{
    // Shuffle the mapping of the tokens configuration so it is a hashmap
    // for faster access to tokens config objects.
    const mapRename = Object.assign({}, ...rename.map((t)=>({
            [t.address || ""]: t
        })));
    // Ensure singleton is present and match the selected chain
    if (!$1564e43dde50bb61$var$blockscoutClient || $1564e43dde50bb61$var$blockscoutClient.chainId !== chainId) $1564e43dde50bb61$var$blockscoutClient = new ($fd8a8472dcc3ec2b$export$ef140a6b05dfc786)({
        chainId: chainId
    });
    // Hold the items in an array for post-fetching processing
    const items = [];
    const tokenType = ($887a00f8f72d61f0$export$5bd1ea2b3d18210).ERC20;
    // Given that the widgets aren't yet designed to support pagination,
    // fetch all the possible tokens associated to a given wallet address.
    let resp;
    try {
        do {
            // eslint-disable-next-line no-await-in-loop
            resp = await $1564e43dde50bb61$var$blockscoutClient.getTokensByWalletAddress({
                walletAddress: walletAddress,
                tokenType: tokenType,
                nextPage: resp?.next_page_params
            });
            items.push(...resp.items);
        }while (resp.next_page_params);
    } catch (err) {
        // In case of a 404, the wallet is a new wallet that hasn't been indexed by
        // the Blockscout just yet. This happens when a wallet hasn't had any
        // activity on the chain. In this case, simply ignore the error and return
        // no currencies.
        // In case of a malformed wallet address, Blockscout returns a 422, which
        // means we are safe to assume that a 404 is a missing wallet due to inactivity
        // or simply an incorrect wallet address was provided.
        if (err?.code !== (HttpStatusCode$2).NotFound) throw new ($a8bc256d81a5e2c1$export$b722478a3cbfa3bc)(err.message || "InternalServerError | getTokensByWalletAddress", ($a8bc256d81a5e2c1$export$e3dc0620abde7f5a).GET_INDEXER_BALANCE_ERROR, err);
    }
    try {
        const respNative = await $1564e43dde50bb61$var$blockscoutClient.getNativeTokenByWalletAddress({
            walletAddress: walletAddress
        });
        items.push(respNative);
    } catch (err) {
        // In case of a 404, the wallet is a new wallet that hasn't been indexed by
        // the Blockscout just yet. This happens when a wallet hasn't had any
        // activity on the chain. In this case, simply ignore the error and return
        // no currencies.
        // In case of a malformed wallet address, Blockscout returns a 422, which
        // means we are safe to assume that a 404 is a missing wallet due to inactivity
        // or simply an incorrect wallet address was provided.
        if (err?.code !== (HttpStatusCode$2).NotFound) throw new ($a8bc256d81a5e2c1$export$b722478a3cbfa3bc)(err.message || "InternalServerError | getNativeTokenByWalletAddress", ($a8bc256d81a5e2c1$export$e3dc0620abde7f5a).GET_INDEXER_BALANCE_ERROR, err);
    }
    return {
        balances: items.map((item)=>{
            const tokenData = item.token || {};
            const balance = (BigNumber$1).from(item.value);
            const renamed = mapRename[tokenData.address] || {};
            const token = {
                ...tokenData,
                name: renamed.name ?? tokenData.name,
                symbol: renamed.symbol ?? tokenData.symbol,
                decimals: parseInt(tokenData.decimals, 10)
            };
            const formattedBalance = (utils$1).formatUnits(item.value, token.decimals);
            return {
                balance: balance,
                formattedBalance: formattedBalance,
                token: token
            };
        })
    };
};
const $1564e43dde50bb61$export$a3238cee431627c6 = async (config, web3Provider, walletAddress, tokens)=>{
    const allBalancePromises = [];
    tokens.forEach((token)=>{
        // Check for NATIVE token
        if (!token.address || token.address === ($d85ad1457a3f1a83$export$b80040cb173ba6e9)) allBalancePromises.push($1564e43dde50bb61$export$df96cd8d56be0ab1(config, web3Provider, walletAddress));
        else allBalancePromises.push($1564e43dde50bb61$export$60e0fe116a0e6ed0(web3Provider, walletAddress, token.address));
    });
    const balanceResults = await Promise.allSettled(allBalancePromises);
    const balances = balanceResults.filter((result)=>result.status === "fulfilled").map((result)=>result.value);
    return {
        balances: balances
    };
};
const $1564e43dde50bb61$export$fee49741664a4d7e = async (config, web3Provider, walletAddress, chainId)=>{
    const { tokens: tokens } = await ($efe60cea83bfc4e8$export$473cec51305fdae8)(config, {
        type: ($08d5ddc39acd6833$export$fd9b17d87f4121d2).ALL,
        chainId: chainId
    });
    // In order to prevent unnecessary RPC calls
    // let's use the Indexer if available for the
    // given chain.
    let flag = false;
    try {
        flag = (await config.remote.getTokensConfig(chainId)).blockscout || flag;
    } catch (err) {
        // eslint-disable-next-line no-console
        console.error(err);
    }
    if (flag && ($fd8a8472dcc3ec2b$export$ef140a6b05dfc786).isChainSupported(chainId)) return await $1564e43dde50bb61$export$8c978679845804d4(walletAddress, chainId, tokens);
    // This fallback to use ERC20s calls which is a best effort solution
    // Fails in fetching data from the RCP calls might result in some
    // missing data.
    return await $1564e43dde50bb61$export$a3238cee431627c6(config, web3Provider, walletAddress, tokens);
};





/* eslint-disable @typescript-eslint/no-explicit-any */ 

async function $c99672cf2294e839$export$2d040992269b4717(web3Provider) {
    if (!web3Provider?.provider?.request) throw new ($a8bc256d81a5e2c1$export$b722478a3cbfa3bc)("Check wallet connection request failed", ($a8bc256d81a5e2c1$export$e3dc0620abde7f5a).PROVIDER_REQUEST_FAILED_ERROR, {
        rpcMethod: ($4f91c5f280efe242$export$35b06f0d33f57e26).CHECK_CONNECTION
    });
    let accounts = [];
    try {
        accounts = await web3Provider.provider.request({
            method: (0, $4f91c5f280efe242$export$35b06f0d33f57e26).CHECK_CONNECTION,
            params: []
        });
    } catch (err) {
        throw new ($a8bc256d81a5e2c1$export$b722478a3cbfa3bc)("Check wallet connection request failed", ($a8bc256d81a5e2c1$export$e3dc0620abde7f5a).PROVIDER_REQUEST_FAILED_ERROR, {
            rpcMethod: ($4f91c5f280efe242$export$35b06f0d33f57e26).CHECK_CONNECTION
        });
    }
    // accounts[0] will have the active account if connected.
    return {
        isConnected: accounts && accounts.length > 0,
        walletAddress: accounts[0] ?? ""
    };
}
async function $c99672cf2294e839$export$43f7168eb392a88c(web3Provider) {
    if (!web3Provider || !web3Provider.provider?.request) throw new ($a8bc256d81a5e2c1$export$b722478a3cbfa3bc)("Incompatible provider", ($a8bc256d81a5e2c1$export$e3dc0620abde7f5a).PROVIDER_REQUEST_MISSING_ERROR, {
        details: "Attempting to connect with an incompatible provider"
    });
    await ($a8bc256d81a5e2c1$export$bacc563de539c6c3)(async ()=>{
        if (!web3Provider.provider.request) return;
        // this makes the request to the wallet to connect i.e request eth accounts ('eth_requestAccounts')
        await web3Provider.provider.request({
            method: ($4f91c5f280efe242$export$35b06f0d33f57e26).CONNECT,
            params: []
        });
    }, {
        type: ($a8bc256d81a5e2c1$export$e3dc0620abde7f5a).USER_REJECTED_REQUEST_ERROR
    });
    return web3Provider;
}




/* eslint-disable @typescript-eslint/no-explicit-any */ 



async function $5c763be0b0b81038$var$getMetaMaskProvider() {
    const provider = await ($a8bc256d81a5e2c1$export$bacc563de539c6c3)(async ()=>await (detectEthereumProvider)(), {
        type: ($a8bc256d81a5e2c1$export$e3dc0620abde7f5a).METAMASK_PROVIDER_ERROR
    });
    if (!provider || !provider.request) throw new ($a8bc256d81a5e2c1$export$b722478a3cbfa3bc)("No MetaMask provider installed.", ($a8bc256d81a5e2c1$export$e3dc0620abde7f5a).METAMASK_PROVIDER_ERROR);
    return new (Web3Provider)(provider);
}
async function $5c763be0b0b81038$export$500fbc0cd14cdbaa(walletProviderName, passport) {
    let provider = null;
    switch(walletProviderName){
        case ($e768639828688ca3$export$2d7a51a18d87e21d).PASSPORT:
            if (passport) provider = new (Web3Provider)(passport.connectEvm());
            else throw new ($a8bc256d81a5e2c1$export$b722478a3cbfa3bc)("Passport not provided", ($a8bc256d81a5e2c1$export$e3dc0620abde7f5a).DEFAULT_PROVIDER_ERROR);
            break;
        case ($e768639828688ca3$export$2d7a51a18d87e21d).METAMASK:
            provider = await $5c763be0b0b81038$var$getMetaMaskProvider();
            break;
        default:
            throw new ($a8bc256d81a5e2c1$export$b722478a3cbfa3bc)("Provider not supported", ($a8bc256d81a5e2c1$export$e3dc0620abde7f5a).DEFAULT_PROVIDER_ERROR);
    }
    return {
        provider: provider,
        walletProviderName: walletProviderName
    };
}


// this function needs to be in a separate file to prevent circular dependencies with ./network




function $bb88265fe45a0393$export$ebe4804963e71f98(web3Provider) {
    if (web3Provider && web3Provider.provider?.request && typeof web3Provider.provider.request === "function") return true;
    return false;
}
async function $bb88265fe45a0393$export$9e1fd9cc88c637a0(config, web3Provider, validateProviderOptions) {
    return ($a8bc256d81a5e2c1$export$bacc563de539c6c3)(async ()=>{
        if (web3Provider.provider?.isPassport) // if Passport skip the validation checks
        return web3Provider;
        if (!$bb88265fe45a0393$export$ebe4804963e71f98(web3Provider)) throw new ($a8bc256d81a5e2c1$export$b722478a3cbfa3bc)("Parsed provider is not a valid Web3Provider", ($a8bc256d81a5e2c1$export$e3dc0620abde7f5a).WEB3_PROVIDER_ERROR);
        // this sets the default options and overrides them with any parsed options
        const options = {
            ...($e768639828688ca3$export$44dde05038008549),
            ...validateProviderOptions
        };
        const underlyingChainId = await ($a1555a1d2c8d059b$export$c3ba3e93a9fee972)(web3Provider);
        let web3ChainId = web3Provider.network?.chainId;
        try {
            web3ChainId = web3Provider.network?.chainId;
            if (!web3ChainId) web3ChainId = (await web3Provider.getNetwork()).chainId;
        } catch (err) {
            throw new ($a8bc256d81a5e2c1$export$b722478a3cbfa3bc)("Unable to detect the web3Provider network", ($a8bc256d81a5e2c1$export$e3dc0620abde7f5a).WEB3_PROVIDER_ERROR);
        }
        if (web3ChainId !== underlyingChainId && !options.allowMistmatchedChainId) throw new ($a8bc256d81a5e2c1$export$b722478a3cbfa3bc)("Your wallet has changed network, please switch to a supported network", ($a8bc256d81a5e2c1$export$e3dc0620abde7f5a).WEB3_PROVIDER_ERROR);
        const allowedNetworks = await ($de192de6ef100f9f$export$3043f6442a9ef563)(config, {
            type: ($a47e48dd2c04791b$export$1f05a55fe0680cc7).ALL
        });
        const isAllowed = allowedNetworks.networks.some((network)=>network.chainId === underlyingChainId);
        if (!isAllowed && !options.allowUnsupportedProvider) throw new ($a8bc256d81a5e2c1$export$b722478a3cbfa3bc)("Your wallet is connected to an unsupported network, please switch to a supported network", ($a8bc256d81a5e2c1$export$e3dc0620abde7f5a).WEB3_PROVIDER_ERROR);
        return web3Provider;
    }, {
        type: ($a8bc256d81a5e2c1$export$e3dc0620abde7f5a).WEB3_PROVIDER_ERROR
    });
}





async function $5cdde2ffe6360fec$export$a822caa90d7eef09(params) {
    const walletList = [];
    const excludedWalletProvider = params.exclude?.map((wp)=>wp.walletProvider) ?? [];
    let walletProviderNames = Object.values(($e768639828688ca3$export$2d7a51a18d87e21d));
    if (excludedWalletProvider.length !== 0) walletProviderNames = walletProviderNames.filter((wp)=>!excludedWalletProvider.includes(wp));
    for (const value of walletProviderNames)walletList.push({
        walletProvider: value,
        name: value
    });
    return {
        wallets: walletList
    };
}







const $dbe95599a4661140$export$8e0e7ffc78696d30 = async (web3Provider, transaction)=>{
    try {
        const transactionResponse = await web3Provider.getSigner().sendTransaction(transaction);
        return {
            transactionResponse: transactionResponse
        };
    } catch (err) {
        if (err.code === (ethers).errors.INSUFFICIENT_FUNDS) throw new ($a8bc256d81a5e2c1$export$b722478a3cbfa3bc)(err.message, ($a8bc256d81a5e2c1$export$e3dc0620abde7f5a).INSUFFICIENT_FUNDS);
        if (err.code === (ethers).errors.ACTION_REJECTED) throw new ($a8bc256d81a5e2c1$export$b722478a3cbfa3bc)(err.message, ($a8bc256d81a5e2c1$export$e3dc0620abde7f5a).USER_REJECTED_REQUEST_ERROR);
        if (err.code === (ethers).errors.UNPREDICTABLE_GAS_LIMIT) throw new ($a8bc256d81a5e2c1$export$b722478a3cbfa3bc)(err.message, ($a8bc256d81a5e2c1$export$e3dc0620abde7f5a).UNPREDICTABLE_GAS_LIMIT);
        throw new ($a8bc256d81a5e2c1$export$b722478a3cbfa3bc)(err.message, ($a8bc256d81a5e2c1$export$e3dc0620abde7f5a).TRANSACTION_FAILED);
    }
};








const $dff2555fa96dda9a$var$doesChainSupportEIP1559 = (feeData)=>!!feeData.maxFeePerGas && !!feeData.maxPriorityFeePerGas;
const $dff2555fa96dda9a$export$aa28f3111c524ec5 = (feeData)=>{
    if ($dff2555fa96dda9a$var$doesChainSupportEIP1559(feeData)) return (BigNumber$1).from(feeData.maxFeePerGas).add((BigNumber$1).from(feeData.maxPriorityFeePerGas));
    if (feeData.gasPrice) return (BigNumber$1).from(feeData.gasPrice);
    return null;
};


const $570856c68db0bd36$var$GAS_LIMIT = 140000;
const $570856c68db0bd36$var$getGasEstimates = async (provider)=>{
    const txnGasLimitInWei = $570856c68db0bd36$var$GAS_LIMIT; // todo: fetch gasLimit from bridgeSDK when they add new fn
    const feeData = await provider.getFeeData();
    const gasPriceInWei = ($dff2555fa96dda9a$export$aa28f3111c524ec5)(feeData);
    if (!gasPriceInWei) return undefined;
    return gasPriceInWei.mul(txnGasLimitInWei);
};
async function $570856c68db0bd36$export$51010590edbe56a6(provider, withApproval) {
    const estimatedAmount = await $570856c68db0bd36$var$getGasEstimates(provider);
    // Return an undefined value for estimatedAmount
    if (!estimatedAmount) return {
        estimatedAmount: estimatedAmount
    };
    if (!withApproval) return {
        estimatedAmount: estimatedAmount
    };
    return {
        estimatedAmount: estimatedAmount.add(estimatedAmount)
    };
}
async function $570856c68db0bd36$export$9e73e22953cebcfc(tokenBridge, tokenAddress) {
    const bridgeFeeResponse = await tokenBridge.getFee({
        token: tokenAddress
    });
    return {
        bridgeFee: {
            estimatedAmount: bridgeFeeResponse.feeAmount
        },
        bridgeable: bridgeFeeResponse.bridgeable
    };
}








async function $67fc622a2b913d5f$export$989eefe1274a439c(fromChainId, toChainId, readOnlyProviders, config) {
    const rootChainProvider = readOnlyProviders.get(fromChainId);
    const childChainProvider = readOnlyProviders.get(toChainId);
    if (!rootChainProvider) throw new ($a8bc256d81a5e2c1$export$b722478a3cbfa3bc)(`Chain:${fromChainId} is not a supported chain`, ($a8bc256d81a5e2c1$export$e3dc0620abde7f5a).CHAIN_NOT_SUPPORTED_ERROR);
    if (!childChainProvider) throw new ($a8bc256d81a5e2c1$export$b722478a3cbfa3bc)(`Chain:${toChainId} is not a supported chain`, ($a8bc256d81a5e2c1$export$e3dc0620abde7f5a).CHAIN_NOT_SUPPORTED_ERROR);
    let bridgeInstance = (ETH_SEPOLIA_TO_ZKEVM_TESTNET);
    if (config.isDevelopment) bridgeInstance = (ETH_SEPOLIA_TO_ZKEVM_DEVNET);
    if (config.isProduction) bridgeInstance = (ETH_MAINNET_TO_ZKEVM_MAINNET);
    const bridgeConfig = new (BridgeConfiguration)({
        baseConfig: new (ImmutableConfiguration)({
            environment: config.environment
        }),
        bridgeInstance: bridgeInstance,
        rootProvider: rootChainProvider,
        childProvider: childChainProvider
    });
    return new (TokenBridge)(bridgeConfig);
}
async function $67fc622a2b913d5f$export$7cf6178417769841(chainId, config) {
    const dexConfig = await config.remote.getConfig("dex");
    return new (Exchange)({
        chainId: chainId,
        baseConfig: new (ImmutableConfiguration)({
            environment: config.environment
        }),
        overrides: dexConfig?.overrides
    });
}
async function $67fc622a2b913d5f$export$c60ce6c6a92bc2ff(config) {
    return new (Orderbook)({
        baseConfig: {
            environment: config.environment
        }
    });
}
function $67fc622a2b913d5f$export$436dd76f23f463ff(config) {
    return new (BlockchainData)({
        baseConfig: {
            environment: config.environment
        }
    });
}



function $06a6c5c23f7f2479$export$fbbc17f6e6e58544(address, contractInterface, signerOrProvider) {
    return new (Contract$1)(address, contractInterface, signerOrProvider);
}





const $2e7bf45a7c9a9570$var$DUMMY_WALLET_ADDRESS = "0x0000000000000000000000000000000000000001";
const $2e7bf45a7c9a9570$var$DEFAULT_TOKEN_DECIMALS = 18;
async function $2e7bf45a7c9a9570$var$getTokenInfoByAddress(config, tokenAddress, chainId, provider) {
    if (tokenAddress === "NATIVE") return config.networkMap.get(chainId)?.nativeCurrency;
    const contract = new (Contract$1)(tokenAddress, JSON.stringify(($d85ad1457a3f1a83$export$db5daa1b5156ccfe)), provider);
    const name = await contract.name();
    const symbol = await contract.symbol();
    const decimals = await contract.decimals();
    return {
        name: name,
        symbol: symbol,
        decimals: decimals,
        address: tokenAddress
    };
}
async function $2e7bf45a7c9a9570$var$bridgeToL2GasEstimator(readOnlyProviders, config, isSpendingCapApprovalRequired, tokenAddress) {
    const fromChainId = ($4013c5c91bb535f6$export$9b794d067cdd1af6)(config);
    const toChainId = ($4013c5c91bb535f6$export$c9af4e4b001c6476)(config);
    const gasEstimateTokensConfig = await config.remote.getConfig("gasEstimateTokens");
    const { gasTokenAddress: gasTokenAddress, fromAddress: fromAddress } = gasEstimateTokensConfig[fromChainId].bridgeToL2Addresses;
    const provider = readOnlyProviders.get(fromChainId);
    if (!provider) throw new Error(`Missing JsonRpcProvider for chain id: ${fromChainId}`);
    try {
        const gasFee = await (0, $570856c68db0bd36$export$51010590edbe56a6)(provider, isSpendingCapApprovalRequired);
        gasFee.token = await $2e7bf45a7c9a9570$var$getTokenInfoByAddress(config, tokenAddress ?? (gasTokenAddress || "NATIVE"), fromChainId, provider);
        const tokenBridge = await $67fc622a2b913d5f$export$989eefe1274a439c(fromChainId, toChainId, readOnlyProviders, config);
        const { bridgeFee: bridgeFee, bridgeable: bridgeable } = await (0, $570856c68db0bd36$export$9e73e22953cebcfc)(tokenBridge, fromAddress);
        return {
            gasEstimateType: (0, $de275b98d2b651c3$export$788b1fd17f3dad84).BRIDGE_TO_L2,
            gasFee: gasFee,
            bridgeFee: {
                estimatedAmount: bridgeFee?.estimatedAmount,
                token: bridgeFee?.token
            },
            bridgeable: bridgeable
        };
    } catch  {
        // In the case of an error, just return an empty gas & bridge fee estimate
        return {
            gasEstimateType: ($de275b98d2b651c3$export$788b1fd17f3dad84).BRIDGE_TO_L2,
            gasFee: {},
            bridgeFee: {},
            bridgeable: false
        };
    }
}
async function $2e7bf45a7c9a9570$var$swapGasEstimator(config) {
    const chainId = ($4013c5c91bb535f6$export$c9af4e4b001c6476)(config);
    const gasEstimateTokensConfig = await config.remote.getConfig("gasEstimateTokens");
    const { inAddress: inAddress, outAddress: outAddress } = gasEstimateTokensConfig[chainId].swapAddresses;
    try {
        const exchange = await $67fc622a2b913d5f$export$7cf6178417769841(chainId, config);
        // Create a fake transaction to get the gas from the quote
        const { swap: swap } = await exchange.getUnsignedSwapTxFromAmountIn($2e7bf45a7c9a9570$var$DUMMY_WALLET_ADDRESS, inAddress, outAddress, (0, BigNumber$1).from((0, utils$1).parseUnits("1", $2e7bf45a7c9a9570$var$DEFAULT_TOKEN_DECIMALS)));
        if (swap.gasFeeEstimate === null) return {
            gasEstimateType: (0, $de275b98d2b651c3$export$788b1fd17f3dad84).SWAP,
            gasFee: {}
        };
        let estimatedAmount;
        if (swap.gasFeeEstimate.value) estimatedAmount = (0, BigNumber$1).from(swap.gasFeeEstimate.value);
        return {
            gasEstimateType: (0, $de275b98d2b651c3$export$788b1fd17f3dad84).SWAP,
            gasFee: {
                estimatedAmount: estimatedAmount,
                token: {
                    address: swap.gasFeeEstimate?.token.address,
                    symbol: swap.gasFeeEstimate?.token.symbol ?? "",
                    name: swap.gasFeeEstimate?.token.name ?? "",
                    decimals: swap.gasFeeEstimate?.token.decimals ?? $2e7bf45a7c9a9570$var$DEFAULT_TOKEN_DECIMALS
                }
            }
        };
    } catch  {
        // In the case of an error, just return an empty gas fee estimate
        return {
            gasEstimateType: ($de275b98d2b651c3$export$788b1fd17f3dad84).SWAP,
            gasFee: {}
        };
    }
}
async function $2e7bf45a7c9a9570$export$942c8de7174809fc(params, readOnlyProviders, config) {
    switch(params.gasEstimateType){
        case ($de275b98d2b651c3$export$788b1fd17f3dad84).BRIDGE_TO_L2:
            return await $2e7bf45a7c9a9570$var$bridgeToL2GasEstimator(readOnlyProviders, config, params.isSpendingCapApprovalRequired, params.tokenAddress);
        case ($de275b98d2b651c3$export$788b1fd17f3dad84).SWAP:
            return await $2e7bf45a7c9a9570$var$swapGasEstimator(config);
        default:
            throw new ($a8bc256d81a5e2c1$export$b722478a3cbfa3bc)("Invalid type provided for gasEstimateType", ($a8bc256d81a5e2c1$export$e3dc0620abde7f5a).INVALID_GAS_ESTIMATE_TYPE);
    }
}











const $ddc6bcd0896481e5$export$2fbfa41a4de56a89 = (erc20allowances, erc721allowances)=>{
    const aggregatedAllowances = [];
    if (!erc20allowances.sufficient) {
        for (const allowance of erc20allowances.allowances)if (!allowance.sufficient) aggregatedAllowances.push(allowance);
    }
    if (!erc721allowances.sufficient) {
        for (const allowance of erc721allowances.allowances)if (!allowance.sufficient) aggregatedAllowances.push(allowance);
    }
    return aggregatedAllowances;
};




const $074f75878f618031$export$84f303391caa056f = (itemRequirements)=>{
    const aggregatedMap = new Map();
    const aggregatedItemRequirements = [];
    itemRequirements.forEach((itemRequirement)=>{
        const { type: type } = itemRequirement;
        if (type !== ($4b58188d47aafe8d$export$1fc8f52ad1810e52).NATIVE) {
            aggregatedItemRequirements.push(itemRequirement);
            return;
        }
        const { amount: amount } = itemRequirement;
        const aggregateItem = aggregatedMap.get(type);
        if (aggregateItem && aggregateItem.type === ($4b58188d47aafe8d$export$1fc8f52ad1810e52).NATIVE) aggregateItem.amount = (BigNumber$1).from(aggregateItem.amount).add(amount);
        else aggregatedMap.set(type, {
            ...itemRequirement
        });
    });
    return aggregatedItemRequirements.concat(Array.from(aggregatedMap.values()));
};
const $074f75878f618031$export$1ede6278abcdf1cb = (itemRequirements)=>{
    const aggregatedMap = new Map();
    const aggregatedItemRequirements = [];
    itemRequirements.forEach((itemRequirement)=>{
        const { type: type } = itemRequirement;
        if (type !== ($4b58188d47aafe8d$export$1fc8f52ad1810e52).ERC20) {
            aggregatedItemRequirements.push(itemRequirement);
            return;
        }
        const { contractAddress: contractAddress, spenderAddress: spenderAddress, amount: amount } = itemRequirement;
        const key = `${contractAddress}${spenderAddress}`;
        const aggregateItem = aggregatedMap.get(key);
        if (aggregateItem && aggregateItem.type === ($4b58188d47aafe8d$export$1fc8f52ad1810e52).ERC20) aggregateItem.amount = (BigNumber$1).from(aggregateItem.amount).add(amount);
        else aggregatedMap.set(key, {
            ...itemRequirement
        });
    });
    return aggregatedItemRequirements.concat(Array.from(aggregatedMap.values()));
};
const $074f75878f618031$export$fa1f577106a81103 = (itemRequirements)=>{
    const aggregatedMap = new Map();
    const aggregatedItemRequirements = [];
    itemRequirements.forEach((itemRequirement)=>{
        const { type: type } = itemRequirement;
        if (type !== ($4b58188d47aafe8d$export$1fc8f52ad1810e52).ERC721) {
            aggregatedItemRequirements.push(itemRequirement);
            return;
        }
        const { contractAddress: contractAddress, spenderAddress: spenderAddress, id: id } = itemRequirement;
        const key = `${contractAddress}${spenderAddress}${id}`;
        const aggregateItem = aggregatedMap.get(key);
        if (!aggregateItem) aggregatedMap.set(key, {
            ...itemRequirement
        });
    });
    return aggregatedItemRequirements.concat(Array.from(aggregatedMap.values()));
};
const $074f75878f618031$export$c804c9ade5c28607 = (itemRequirements)=>$074f75878f618031$export$fa1f577106a81103($074f75878f618031$export$1ede6278abcdf1cb($074f75878f618031$export$84f303391caa056f(itemRequirements)));







const $fc8b338399d890f3$export$41491ea105c4dc2d = async (provider, ownerAddress, contractAddress, spenderAddress)=>{
    try {
        const contract = new (0, Contract$1)(contractAddress, JSON.stringify((0, $d85ad1457a3f1a83$export$db5daa1b5156ccfe)), provider);
        return await contract.allowance(ownerAddress, spenderAddress);
    } catch (err) {
        throw new ($a8bc256d81a5e2c1$export$b722478a3cbfa3bc)("Failed to get the allowance for ERC20", ($a8bc256d81a5e2c1$export$e3dc0620abde7f5a).GET_ERC20_ALLOWANCE_ERROR, {
            contractAddress: contractAddress
        });
    }
};
const $fc8b338399d890f3$export$5c6bea080a6ee647 = async (provider, ownerAddress, contractAddress, spenderAddress, amount)=>{
    try {
        const contract = new (0, Contract$1)(contractAddress, JSON.stringify((0, $d85ad1457a3f1a83$export$db5daa1b5156ccfe)), provider);
        const approveTransaction = await contract.populateTransaction.approve(spenderAddress, amount);
        if (approveTransaction) approveTransaction.from = ownerAddress;
        return approveTransaction;
    } catch  {
        throw new ($a8bc256d81a5e2c1$export$b722478a3cbfa3bc)("Failed to get the approval transaction for ERC20", ($a8bc256d81a5e2c1$export$e3dc0620abde7f5a).GET_ERC20_ALLOWANCE_ERROR, {
            contractAddress: contractAddress
        });
    }
};
const $fc8b338399d890f3$export$d93c00812189e36 = async (provider, ownerAddress, itemRequirements)=>{
    let sufficient = true;
    const sufficientAllowances = [];
    const erc20s = new Map();
    const allowancePromises = new Map();
    const insufficientERC20s = new Map();
    const transactionPromises = new Map();
    // Populate maps for both the ERC20 data and promises to get the allowance using the same key
    // so the promise and data can be linked together when the promise resolves
    for (const itemRequirement of itemRequirements){
        if (itemRequirement.type !== ($4b58188d47aafe8d$export$1fc8f52ad1810e52).ERC20) continue;
        const { contractAddress: contractAddress, spenderAddress: spenderAddress } = itemRequirement;
        const key = `${contractAddress}${spenderAddress}`;
        erc20s.set(key, itemRequirement);
        allowancePromises.set(key, $fc8b338399d890f3$export$41491ea105c4dc2d(provider, ownerAddress, contractAddress, spenderAddress));
    }
    const allowances = await Promise.all(allowancePromises.values());
    const allowancePromiseIds = Array.from(allowancePromises.keys());
    // Iterate through the allowance promises and get the ERC20 data from the ERC20 map
    // If the allowance returned for that ERC20 is sufficient then just set the item requirements
    // If the allowance is insufficient then set the delta and a promise for the approval transaction
    for(let index = 0; index < allowances.length; index++){
        const itemRequirement = erc20s.get(allowancePromiseIds[index]);
        if (!itemRequirement || itemRequirement.type !== ($4b58188d47aafe8d$export$1fc8f52ad1810e52).ERC20) continue;
        if (allowances[index].gte(itemRequirement.amount)) {
            sufficientAllowances.push({
                sufficient: true,
                itemRequirement: itemRequirement
            });
            continue;
        }
        sufficient = false; // Set sufficient false on the root of the return object when an ERC20 is insufficient
        const { contractAddress: contractAddress, spenderAddress: spenderAddress } = itemRequirement;
        const key = `${contractAddress}${spenderAddress}`;
        const delta = itemRequirement.amount.sub(allowances[index]);
        // Create maps for both the insufficient ERC20 data and the transaction promises using the same key so the results can be merged
        insufficientERC20s.set(key, {
            type: ($4b58188d47aafe8d$export$1fc8f52ad1810e52).ERC20,
            sufficient: false,
            delta: delta,
            itemRequirement: itemRequirement,
            approvalTransaction: undefined
        });
        transactionPromises.set(key, $fc8b338399d890f3$export$5c6bea080a6ee647(provider, ownerAddress, contractAddress, spenderAddress, delta));
    }
    // Resolves the approval transactions and merges them with the insufficient ERC20 data
    const transactions = await Promise.all(transactionPromises.values());
    const transactionPromiseIds = Array.from(transactionPromises.keys());
    transactions.forEach((transaction, index)=>{
        const insufficientERC20 = insufficientERC20s.get(transactionPromiseIds[index]);
        if (!insufficientERC20) return;
        if (insufficientERC20.sufficient) return;
        insufficientERC20.approvalTransaction = transaction;
    });
    // Merge the allowance arrays to get both the sufficient allowances and the insufficient ERC20 allowances
    return {
        sufficient: sufficient,
        allowances: sufficientAllowances.concat(Array.from(insufficientERC20s.values()))
    };
};





const $35c3fc7013888ba5$export$90366d6b714c6f69 = async (provider, ownerAddress, contractAddress, spenderAddress)=>{
    try {
        const contract = new (0, Contract$1)(contractAddress, JSON.stringify((0, $d85ad1457a3f1a83$export$8b8be7a2a654f23e)), provider);
        return await contract.isApprovedForAll(ownerAddress, spenderAddress);
    } catch (err) {
        throw new ($a8bc256d81a5e2c1$export$b722478a3cbfa3bc)("Failed to check approval for all ERC721s of collection", ($a8bc256d81a5e2c1$export$e3dc0620abde7f5a).GET_ERC721_ALLOWANCE_ERROR, {
            ownerAddress: ownerAddress,
            contractAddress: contractAddress,
            spenderAddress: spenderAddress
        });
    }
};
const $35c3fc7013888ba5$export$ebb2a35f2b4cf5f6 = async (provider, ownerAddress, contractAddress, spenderAddress, id)=>{
    try {
        const contract = new (0, Contract$1)(contractAddress, JSON.stringify((0, $d85ad1457a3f1a83$export$8b8be7a2a654f23e)), provider);
        const transaction = await contract.populateTransaction.approve(spenderAddress, id);
        if (transaction) transaction.from = ownerAddress;
        return transaction;
    } catch (err) {
        throw new ($a8bc256d81a5e2c1$export$b722478a3cbfa3bc)("Failed to get the approval transaction for ERC721", ($a8bc256d81a5e2c1$export$e3dc0620abde7f5a).GET_ERC721_ALLOWANCE_ERROR, {
            id: id.toString(),
            contractAddress: contractAddress,
            spenderAddress: spenderAddress,
            ownerAddress: ownerAddress
        });
    }
};
const $35c3fc7013888ba5$export$c4605a8dd415eeea = async (provider, contractAddress, id)=>{
    try {
        const contract = new (0, Contract$1)(contractAddress, JSON.stringify((0, $d85ad1457a3f1a83$export$8b8be7a2a654f23e)), provider);
        return await contract.getApproved(id);
    } catch (err) {
        throw new ($a8bc256d81a5e2c1$export$b722478a3cbfa3bc)("Failed to get approved address for ERC721", ($a8bc256d81a5e2c1$export$e3dc0620abde7f5a).GET_ERC721_ALLOWANCE_ERROR, {
            id: id.toString(),
            contractAddress: contractAddress
        });
    }
};
const $35c3fc7013888ba5$export$280481f16b8b6845 = (id, contractAddress)=>{
    const parsedId = parseInt(id, 10);
    if (Number.isNaN(parsedId)) throw new ($a8bc256d81a5e2c1$export$b722478a3cbfa3bc)("Invalid ERC721 ID", ($a8bc256d81a5e2c1$export$e3dc0620abde7f5a).GET_ERC721_ALLOWANCE_ERROR, {
        id: id,
        contractAddress: contractAddress
    });
    return parsedId;
};
const $35c3fc7013888ba5$export$bc63cf1bab32d6da = async (provider, itemRequirements, owner)=>{
    const approvedCollections = new Map();
    const approvedForAllPromises = new Map();
    for (const itemRequirement of itemRequirements){
        if (itemRequirement.type !== ($4b58188d47aafe8d$export$1fc8f52ad1810e52).ERC721) continue;
        const { contractAddress: contractAddress, spenderAddress: spenderAddress } = itemRequirement;
        const key = `${contractAddress}-${spenderAddress}`;
        approvedCollections.set(key, false);
        if (approvedForAllPromises.has(key)) continue;
        approvedForAllPromises.set(key, $35c3fc7013888ba5$export$90366d6b714c6f69(provider, owner, contractAddress, spenderAddress));
    }
    const approvals = await Promise.all(approvedForAllPromises.values());
    const keys = Array.from(approvedForAllPromises.keys());
    approvals.forEach((approval, index)=>{
        approvedCollections.set(keys[index], approval);
    });
    return approvedCollections;
};
const $35c3fc7013888ba5$export$be546c525d418988 = async (provider, ownerAddress, itemRequirements)=>{
    let sufficient = true;
    const sufficientAllowances = [];
    // Setup maps to be able to link data back to the associated promises
    const erc721s = new Map();
    const approvedAddressPromises = new Map();
    const insufficientERC721s = new Map();
    const transactionPromises = new Map();
    // Check if there are any collections with approvals for all ERC721s for a given spender
    const approvedCollections = await $35c3fc7013888ba5$export$bc63cf1bab32d6da(provider, itemRequirements, ownerAddress);
    // Populate maps for both the ERC721 data and promises to get the approved addresses using the same key
    // so the promise and data can be linked together when the promise is resolved
    for (const itemRequirement of itemRequirements){
        if (itemRequirement.type !== ($4b58188d47aafe8d$export$1fc8f52ad1810e52).ERC721) continue;
        const { contractAddress: contractAddress, id: id, spenderAddress: spenderAddress } = itemRequirement;
        // If the collection is approved for all then just set the item requirements and sufficient true
        const approvedForAllKey = `${contractAddress}-${spenderAddress}`;
        const approvedForAll = approvedCollections.get(approvedForAllKey);
        if (approvedForAll) {
            sufficientAllowances.push({
                sufficient: true,
                itemRequirement: itemRequirement
            });
            continue;
        }
        // If collection not approved for all then check if the given ERC721 is approved for the spender
        const key = `${contractAddress}-${id}`;
        const convertedId = $35c3fc7013888ba5$export$280481f16b8b6845(id, contractAddress);
        erc721s.set(key, itemRequirement);
        approvedAddressPromises.set(key, $35c3fc7013888ba5$export$c4605a8dd415eeea(provider, contractAddress, convertedId));
    }
    const approvedAddresses = await Promise.all(approvedAddressPromises.values());
    const approvedAddressPromiseIds = Array.from(approvedAddressPromises.keys());
    // Iterate through the approved address promises and get the ERC721 data from the ERC721 map
    // If the approved address returned for that ERC721 is for the spender then just set the item requirements and sufficient true
    // If the approved address does not match the spender then return the approval transaction
    for(let index = 0; index < approvedAddresses.length; index++){
        const itemRequirement = erc721s.get(approvedAddressPromiseIds[index]);
        if (!itemRequirement || itemRequirement.type !== ($4b58188d47aafe8d$export$1fc8f52ad1810e52).ERC721) continue;
        if (approvedAddresses[index] === itemRequirement.spenderAddress) {
            sufficientAllowances.push({
                sufficient: true,
                itemRequirement: itemRequirement
            });
            continue;
        }
        sufficient = false; // Set sufficient false on the root of the return object when an ERC721 is insufficient
        const { contractAddress: contractAddress, id: id, spenderAddress: spenderAddress } = itemRequirement;
        const key = `${contractAddress}-${id}`;
        const convertedId = $35c3fc7013888ba5$export$280481f16b8b6845(id, contractAddress);
        // Create maps for both the insufficient ERC721 data and the transaction promises using the same key so the results can be merged
        insufficientERC721s.set(key, {
            type: ($4b58188d47aafe8d$export$1fc8f52ad1810e52).ERC721,
            sufficient: false,
            itemRequirement: itemRequirement,
            approvalTransaction: undefined
        });
        transactionPromises.set(key, $35c3fc7013888ba5$export$ebb2a35f2b4cf5f6(provider, ownerAddress, contractAddress, spenderAddress, convertedId));
    }
    // Resolves the approval transactions and merges them with the insufficient ERC721 data
    const transactions = await Promise.all(transactionPromises.values());
    const transactionPromiseIds = Array.from(transactionPromises.keys());
    transactions.forEach((transaction, index)=>{
        const insufficientERC721 = insufficientERC721s.get(transactionPromiseIds[index]);
        if (!insufficientERC721) return;
        if (insufficientERC721.sufficient) return;
        insufficientERC721.approvalTransaction = transaction;
    });
    // Merge the allowance arrays to get both the sufficient allowances and the insufficient ERC721 allowances
    return {
        sufficient: sufficient,
        allowances: sufficientAllowances.concat(Array.from(insufficientERC721s.values()))
    };
};




/* eslint-disable arrow-body-style */ 





const $aa6caea9a60d18c7$export$f4d35754ad350071 = (itemRequirements)=>{
    const aggregatedMap = new Map();
    const aggregatedItemRequirements = [];
    itemRequirements.forEach((itemRequirement)=>{
        const { type: type } = itemRequirement;
        if (type !== ($4b58188d47aafe8d$export$1fc8f52ad1810e52).NATIVE) {
            aggregatedItemRequirements.push(itemRequirement);
            return;
        }
        const { amount: amount } = itemRequirement;
        const aggregateItem = aggregatedMap.get(type);
        if (aggregateItem && aggregateItem.type === ($4b58188d47aafe8d$export$1fc8f52ad1810e52).NATIVE) aggregateItem.amount = (BigNumber$1).from(aggregateItem.amount).add(amount);
        else aggregatedMap.set(type, {
            ...itemRequirement
        });
    });
    return aggregatedItemRequirements.concat(Array.from(aggregatedMap.values()));
};
const $aa6caea9a60d18c7$export$b8de545554d50911 = (itemRequirements)=>{
    const aggregatedMap = new Map();
    const aggregatedItemRequirements = [];
    itemRequirements.forEach((itemRequirement)=>{
        const { type: type } = itemRequirement;
        if (type !== ($4b58188d47aafe8d$export$1fc8f52ad1810e52).ERC20) {
            aggregatedItemRequirements.push(itemRequirement);
            return;
        }
        const { contractAddress: contractAddress, amount: amount } = itemRequirement;
        const key = `${contractAddress}`;
        const aggregateItem = aggregatedMap.get(key);
        if (aggregateItem && aggregateItem.type === ($4b58188d47aafe8d$export$1fc8f52ad1810e52).ERC20) aggregateItem.amount = (BigNumber$1).from(aggregateItem.amount).add(amount);
        else aggregatedMap.set(key, {
            ...itemRequirement
        });
    });
    return aggregatedItemRequirements.concat(Array.from(aggregatedMap.values()));
};
const $aa6caea9a60d18c7$export$74fbc29ef48b4f31 = (itemRequirements)=>{
    const aggregatedMap = new Map();
    const aggregatedItemRequirements = [];
    itemRequirements.forEach((itemRequirement)=>{
        const { type: type } = itemRequirement;
        if (type !== ($4b58188d47aafe8d$export$1fc8f52ad1810e52).ERC721) {
            aggregatedItemRequirements.push(itemRequirement);
            return;
        }
        const { contractAddress: contractAddress, id: id } = itemRequirement;
        const key = `${contractAddress}${id}`;
        const aggregateItem = aggregatedMap.get(key);
        if (!aggregateItem) aggregatedMap.set(key, {
            ...itemRequirement
        });
    });
    return aggregatedItemRequirements.concat(Array.from(aggregatedMap.values()));
};
const $aa6caea9a60d18c7$export$f96d1c819a615a64 = (itemRequirements)=>$aa6caea9a60d18c7$export$74fbc29ef48b4f31($aa6caea9a60d18c7$export$b8de545554d50911($aa6caea9a60d18c7$export$f4d35754ad350071(itemRequirements)));


/* eslint-disable arrow-body-style */ 

const $73d2282a108cc7e2$export$ed7929b58bab85da = (itemRequirements)=>itemRequirements.map((itemRequirement)=>{
        if (itemRequirement.type === ($4b58188d47aafe8d$export$1fc8f52ad1810e52).NATIVE) return {
            address: ($d85ad1457a3f1a83$export$b80040cb173ba6e9)
        };
        return {
            address: itemRequirement.contractAddress
        };
    });
const $73d2282a108cc7e2$export$9b757e40b19984c3 = (itemRequirement, balances)=>{
    const requiredBalance = (BigNumber$1).from(1);
    // Find the requirements related balance
    const itemBalanceResult = balances.find((balance)=>{
        const balanceERC721Result = balance;
        return balanceERC721Result.contractAddress === itemRequirement.contractAddress && balanceERC721Result.id === itemRequirement.id;
    });
    // Calculate the balance delta
    const sufficient = requiredBalance.isNegative() || requiredBalance.isZero() || (itemBalanceResult?.balance.gte(requiredBalance) ?? false);
    const delta = requiredBalance.sub(itemBalanceResult?.balance ?? (BigNumber$1).from(0));
    let erc721BalanceResult = itemBalanceResult;
    if (!erc721BalanceResult) erc721BalanceResult = {
        type: ($4b58188d47aafe8d$export$1fc8f52ad1810e52).ERC721,
        balance: (BigNumber$1).from(0),
        formattedBalance: "0",
        contractAddress: itemRequirement.contractAddress,
        id: itemRequirement.id
    };
    return {
        sufficient: sufficient,
        type: ($4b58188d47aafe8d$export$1fc8f52ad1810e52).ERC721,
        delta: {
            balance: delta,
            formattedBalance: delta.toString()
        },
        current: erc721BalanceResult,
        required: {
            ...erc721BalanceResult,
            balance: (BigNumber$1).from(1),
            formattedBalance: "1"
        }
    };
};
const $73d2282a108cc7e2$export$6ab9757fda54db7e = (itemRequirement, balances)=>{
    let itemBalanceResult;
    // Get the requirements related balance
    if (itemRequirement.type === ($4b58188d47aafe8d$export$1fc8f52ad1810e52).ERC20) itemBalanceResult = balances.find((balance)=>{
        return balance.token?.address === itemRequirement.contractAddress;
    });
    else if (itemRequirement.type === ($4b58188d47aafe8d$export$1fc8f52ad1810e52).NATIVE) itemBalanceResult = balances.find((balance)=>{
        return balance.token?.address === "" || balance.token?.address === ($d85ad1457a3f1a83$export$b80040cb173ba6e9);
    });
    // Calculate the balance delta
    const requiredBalance = itemRequirement.amount;
    const sufficient = requiredBalance.isNegative() || requiredBalance.isZero() || (itemBalanceResult?.balance.gte(requiredBalance) ?? false);
    const delta = requiredBalance.sub(itemBalanceResult?.balance ?? (BigNumber$1).from(0));
    let name = "";
    let symbol = "";
    let decimals = ($d85ad1457a3f1a83$export$903389470ba9433c);
    if (itemBalanceResult) {
        decimals = itemBalanceResult.token?.decimals ?? ($d85ad1457a3f1a83$export$903389470ba9433c);
        name = itemBalanceResult.token.name;
        symbol = itemBalanceResult.token.symbol;
    }
    let tokenBalanceResult = itemBalanceResult;
    if (itemRequirement.type === ($4b58188d47aafe8d$export$1fc8f52ad1810e52).NATIVE) {
        // No token balance so mark as zero native
        if (!tokenBalanceResult) tokenBalanceResult = {
            type: ($4b58188d47aafe8d$export$1fc8f52ad1810e52).NATIVE,
            balance: (BigNumber$1).from(0),
            formattedBalance: "0",
            token: {
                name: name,
                symbol: symbol,
                decimals: ($d85ad1457a3f1a83$export$903389470ba9433c),
                address: ($d85ad1457a3f1a83$export$b80040cb173ba6e9)
            }
        };
        return {
            sufficient: sufficient,
            type: ($4b58188d47aafe8d$export$1fc8f52ad1810e52).NATIVE,
            delta: {
                balance: delta,
                formattedBalance: (utils$1).formatUnits(delta, decimals)
            },
            current: {
                ...tokenBalanceResult,
                type: ($4b58188d47aafe8d$export$1fc8f52ad1810e52).NATIVE
            },
            required: {
                ...tokenBalanceResult,
                type: ($4b58188d47aafe8d$export$1fc8f52ad1810e52).NATIVE,
                balance: (BigNumber$1).from(itemRequirement.amount),
                formattedBalance: (utils$1).formatUnits(itemRequirement.amount, decimals)
            }
        };
    }
    // No token balance so mark as zero
    if (!tokenBalanceResult) tokenBalanceResult = {
        type: itemRequirement.type,
        balance: (BigNumber$1).from(0),
        formattedBalance: "0",
        token: {
            name: name,
            symbol: symbol,
            address: itemRequirement.contractAddress,
            decimals: decimals
        }
    };
    return {
        sufficient: sufficient,
        type: ($4b58188d47aafe8d$export$1fc8f52ad1810e52).ERC20,
        delta: {
            balance: delta,
            formattedBalance: (utils$1).formatUnits(delta, decimals)
        },
        current: tokenBalanceResult,
        required: {
            ...tokenBalanceResult,
            balance: (BigNumber$1).from(itemRequirement.amount),
            formattedBalance: (utils$1).formatUnits(itemRequirement.amount, decimals)
        }
    };
};


/**
 * Gets the balances for all NATIVE and ERC20 balance requirements.
 */ const $beb896e098e41faf$var$getTokenBalances = async (config, provider, ownerAddress, itemRequirements)=>{
    let tokenBalances = [];
    try {
        const tokenList = (0, $73d2282a108cc7e2$export$ed7929b58bab85da)(itemRequirements);
        const { balances: balances } = await (0, $1564e43dde50bb61$export$a3238cee431627c6)(config, provider, ownerAddress, tokenList);
        tokenBalances = [
            ...balances.map((balance)=>balance)
        ];
    } catch (error) {
        throw new ($a8bc256d81a5e2c1$export$b722478a3cbfa3bc)("Failed to get balances", ($a8bc256d81a5e2c1$export$e3dc0620abde7f5a).GET_BALANCE_ERROR);
    }
    return tokenBalances;
};
/**
 * Gets the balances for all ERC721 balance requirements.
 */ const $beb896e098e41faf$var$getERC721Balances = async (provider, ownerAddress, itemRequirements)=>{
    const erc721Balances = [];
    // Setup maps to be able to link data back to the associated promises
    const erc721s = new Map();
    const erc721OwnershipPromises = new Map();
    itemRequirements.forEach((itemRequirement)=>{
        if (itemRequirement.type !== ($4b58188d47aafe8d$export$1fc8f52ad1810e52).ERC721) return;
        const contract = new (Contract$1)(itemRequirement.contractAddress, JSON.stringify(($d85ad1457a3f1a83$export$8b8be7a2a654f23e)), provider);
        erc721s.set(itemRequirement.contractAddress, itemRequirement);
        erc721OwnershipPromises.set(itemRequirement.contractAddress, contract.ownerOf(itemRequirement.id));
    });
    try {
        // Convert ERC721 ownership into a balance result
        const erc721Owners = await Promise.all(erc721OwnershipPromises.values());
        const erc721OwnersPromiseIds = Array.from(erc721OwnershipPromises.keys());
        erc721Owners.forEach((erc721OwnerAddress, index)=>{
            const itemRequirement = erc721s.get(erc721OwnersPromiseIds[index]);
            let itemCount = 0;
            if (itemRequirement && ownerAddress === erc721OwnerAddress) itemCount = 1;
            erc721Balances.push({
                type: (0, $4b58188d47aafe8d$export$1fc8f52ad1810e52).ERC721,
                balance: (0, BigNumber$1).from(itemCount),
                formattedBalance: itemCount.toString(),
                contractAddress: itemRequirement.contractAddress,
                id: itemRequirement.id
            });
        });
    } catch (error) {
        throw new ($a8bc256d81a5e2c1$export$b722478a3cbfa3bc)("Failed to get ERC721 balances", ($a8bc256d81a5e2c1$export$e3dc0620abde7f5a).GET_ERC721_BALANCE_ERROR);
    }
    return erc721Balances;
};
const $beb896e098e41faf$export$ddfc885f43c3cb6e = async (config, provider, ownerAddress, itemRequirements)=>{
    const aggregatedItems = ($aa6caea9a60d18c7$export$f96d1c819a615a64)(itemRequirements);
    if (aggregatedItems.filter((itemRequirement)=>{
        return itemRequirement.type !== ($4b58188d47aafe8d$export$1fc8f52ad1810e52).ERC721 && itemRequirement.type !== ($4b58188d47aafe8d$export$1fc8f52ad1810e52).ERC20 && itemRequirement.type !== ($4b58188d47aafe8d$export$1fc8f52ad1810e52).NATIVE;
    }).length > 0) throw new ($a8bc256d81a5e2c1$export$b722478a3cbfa3bc)("Unsupported item requirement balance check", ($a8bc256d81a5e2c1$export$e3dc0620abde7f5a).UNSUPPORTED_BALANCE_REQUIREMENT_ERROR);
    // Get all ERC20 and NATIVE balances
    const currentBalances = [];
    const tokenItemRequirements = aggregatedItems.filter((itemRequirement)=>itemRequirement.type === ($4b58188d47aafe8d$export$1fc8f52ad1810e52).ERC20 || itemRequirement.type === ($4b58188d47aafe8d$export$1fc8f52ad1810e52).NATIVE);
    if (tokenItemRequirements.length > 0) currentBalances.push($beb896e098e41faf$var$getTokenBalances(config, provider, ownerAddress, aggregatedItems));
    // Get all ERC721 balances
    const erc721ItemRequirements = aggregatedItems.filter((itemRequirement)=>itemRequirement.type === ($4b58188d47aafe8d$export$1fc8f52ad1810e52).ERC721);
    if (erc721ItemRequirements.length > 0) currentBalances.push($beb896e098e41faf$var$getERC721Balances(provider, ownerAddress, aggregatedItems));
    // Wait for all balances and calculate the requirements
    const balanceRequirements = await Promise.all(currentBalances).then((balances)=>{
        const requirements = [];
        if (balances.length > 1 || tokenItemRequirements.length > 0) {
            const tokenBalances = balances[0];
            tokenItemRequirements.forEach((tokenItemRequirement)=>{
                requirements.push(($73d2282a108cc7e2$export$6ab9757fda54db7e)(tokenItemRequirement, tokenBalances));
            });
            if (erc721ItemRequirements.length > 0) {
                const erc721Balances = balances[1];
                erc721ItemRequirements.forEach((erc721ItemRequirement)=>{
                    requirements.push(($73d2282a108cc7e2$export$9b757e40b19984c3)(erc721ItemRequirement, erc721Balances));
                });
            }
        } else if (erc721ItemRequirements.length > 0) {
            // Only erc721
            const erc721Balances = balances[0];
            erc721ItemRequirements.forEach((erc721ItemRequirement)=>{
                requirements.push(($73d2282a108cc7e2$export$9b757e40b19984c3)(erc721ItemRequirement, erc721Balances));
            });
        }
        return requirements;
    });
    const sufficient = balanceRequirements.reduce((acc, balanceRequirement)=>{
        return acc && balanceRequirement.sufficient;
    }, true);
    return {
        sufficient: sufficient,
        balanceRequirements: balanceRequirements
    };
};









const $7d1bfafb81e64d74$export$e0580ae1f48db848 = async (provider, transaction)=>{
    try {
        return await provider.estimateGas(transaction);
    } catch (err) {
        throw new ($a8bc256d81a5e2c1$export$b722478a3cbfa3bc)("Failed to estimate gas for transaction", ($a8bc256d81a5e2c1$export$e3dc0620abde7f5a).UNPREDICTABLE_GAS_LIMIT);
    }
};
const $7d1bfafb81e64d74$export$c5e1b13f11e2e27f = (gas, transactionOrGas)=>{
    if (transactionOrGas.type === ($4b58188d47aafe8d$export$65c64e46348ee3c1).TRANSACTION || transactionOrGas.gasToken.type === ($4b58188d47aafe8d$export$537fa3efd10ed435).NATIVE) return {
        type: ($4b58188d47aafe8d$export$1fc8f52ad1810e52).NATIVE,
        amount: gas
    };
    return {
        type: ($4b58188d47aafe8d$export$1fc8f52ad1810e52).ERC20,
        amount: gas,
        contractAddress: transactionOrGas.gasToken.contractAddress,
        spenderAddress: ""
    };
};
const $7d1bfafb81e64d74$export$3a4140bd9e983e4e = async (provider, insufficientItems, transactionOrGas)=>{
    const estimateGasPromises = [];
    let totalGas = (BigNumber$1).from(0);
    // Get all the gas estimate promises for the approval transactions
    for (const item of insufficientItems){
        if (item.approvalTransaction === undefined) continue;
        estimateGasPromises.push($7d1bfafb81e64d74$export$e0580ae1f48db848(provider, item.approvalTransaction));
    }
    // If the transaction is a fulfillment transaction get the estimate gas promise
    // Otherwise use the gas amount with the limit to estimate the gas
    if (transactionOrGas.type === ($4b58188d47aafe8d$export$65c64e46348ee3c1).TRANSACTION) estimateGasPromises.push($7d1bfafb81e64d74$export$e0580ae1f48db848(provider, transactionOrGas.transaction));
    else {
        const feeData = await provider.getFeeData();
        const gasPrice = ($dff2555fa96dda9a$export$aa28f3111c524ec5)(feeData);
        if (gasPrice !== null) {
            const gas = gasPrice?.mul(transactionOrGas.gasToken.limit);
            if (gas) totalGas = totalGas.add(gas);
        }
    }
    // Get the gas estimates for all the transactions and calculate the total gas
    const gasEstimatePromises = await Promise.all(estimateGasPromises);
    gasEstimatePromises.forEach((gasEstimate)=>{
        totalGas = totalGas.add(gasEstimate);
    });
    if (totalGas.eq(0)) return null;
    return $7d1bfafb81e64d74$export$c5e1b13f11e2e27f(totalGas, transactionOrGas);
};




const $1fda5c40669a566d$export$1fac8e857d728583 = async ()=>false;
const $1fda5c40669a566d$export$2e83e9eeaf217e20 = async ()=>false;


const $7f2e17f026d4fc8d$var$isPassportProvider = (provider)=>(provider.provider?.isPassport === true) ?? false;
const $7f2e17f026d4fc8d$export$f1ca3744c025ab81 = async (config, provider)=>{
    const availableRoutingOptions = {
        onRamp: config.isOnRampEnabled,
        swap: config.isSwapEnabled,
        bridge: config.isBridgeEnabled
    };
    // Geo-blocking checks
    const geoBlockingChecks = [];
    if (availableRoutingOptions.onRamp) geoBlockingChecks.push({
        id: "onRamp",
        promise: ($1fda5c40669a566d$export$1fac8e857d728583)()
    });
    if (availableRoutingOptions.swap) geoBlockingChecks.push({
        id: "swap",
        promise: ($1fda5c40669a566d$export$2e83e9eeaf217e20)()
    });
    if (geoBlockingChecks.length > 0) {
        const promises = geoBlockingChecks.map((geoBlockingCheck)=>geoBlockingCheck.promise);
        const geoBlockingStatus = await Promise.allSettled(promises);
        geoBlockingStatus.forEach((result, index)=>{
            const statusId = geoBlockingChecks[index].id;
            availableRoutingOptions[statusId] = availableRoutingOptions[statusId] && result.status === "fulfilled" && !result.value;
        });
    }
    // Bridge not available if passport provider
    availableRoutingOptions.bridge = availableRoutingOptions.bridge && !$7f2e17f026d4fc8d$var$isPassportProvider(provider);
    return availableRoutingOptions;
};




var $b23305044c0e096a$export$3057de18ac0c076;
(function(RouteCalculatorType) {
    RouteCalculatorType["ROUTES_FOUND"] = "ROUTES_FOUND";
    RouteCalculatorType["NO_ROUTES"] = "NO_ROUTES";
    RouteCalculatorType["NO_OPTIONS"] = "NO_OPTIONS";
})($b23305044c0e096a$export$3057de18ac0c076 || ($b23305044c0e096a$export$3057de18ac0c076 = {}));





const $33acec7b4a26c053$export$23ddeb2642d2f9d = async (config, readOnlyProviders, ownerAddress, availableRoutingOptions)=>{
    const chainBalances = new Map();
    const chainBalancePromises = new Map();
    if (readOnlyProviders.size === 0) {
        const noProviderResult = {
            success: false,
            error: new ($a8bc256d81a5e2c1$export$b722478a3cbfa3bc)("No L1 or L2 provider available", ($a8bc256d81a5e2c1$export$e3dc0620abde7f5a).PROVIDER_ERROR),
            balances: []
        };
        chainBalances.set(($4013c5c91bb535f6$export$9b794d067cdd1af6)(config), noProviderResult);
        chainBalances.set(($4013c5c91bb535f6$export$c9af4e4b001c6476)(config), noProviderResult);
        return chainBalances;
    }
    // Only get L1 Balances if we can bridge
    if (availableRoutingOptions.bridge) {
        const chainId = ($4013c5c91bb535f6$export$9b794d067cdd1af6)(config);
        if (readOnlyProviders.has(chainId)) chainBalancePromises.set(chainId, ($1564e43dde50bb61$export$fee49741664a4d7e)(config, readOnlyProviders.get(chainId), ownerAddress, chainId));
        else chainBalances.set(($4013c5c91bb535f6$export$9b794d067cdd1af6)(config), {
            success: false,
            error: new ($a8bc256d81a5e2c1$export$b722478a3cbfa3bc)(`No L1 provider available for ${chainId}`, ($a8bc256d81a5e2c1$export$e3dc0620abde7f5a).PROVIDER_ERROR),
            balances: []
        });
    }
    const chainId = ($4013c5c91bb535f6$export$c9af4e4b001c6476)(config);
    if (readOnlyProviders.has(chainId)) chainBalancePromises.set(chainId, ($1564e43dde50bb61$export$fee49741664a4d7e)(config, readOnlyProviders.get(chainId), ownerAddress, chainId));
    else chainBalances.set(($4013c5c91bb535f6$export$c9af4e4b001c6476)(config), {
        success: false,
        error: new ($a8bc256d81a5e2c1$export$b722478a3cbfa3bc)(`No L2 provider available for ${chainId}`, ($a8bc256d81a5e2c1$export$e3dc0620abde7f5a).PROVIDER_ERROR),
        balances: []
    });
    if (chainBalancePromises.size > 0) {
        const chainIds = Array.from(chainBalancePromises.keys());
        const balanceSettledResults = await Promise.allSettled(chainBalancePromises.values());
        balanceSettledResults.forEach((balanceSettledResult, index)=>{
            const balanceChainId = chainIds[index];
            if (balanceSettledResult.status === "fulfilled") chainBalances.set(balanceChainId, {
                success: true,
                balances: balanceSettledResult.value.balances
            });
            else chainBalances.set(balanceChainId, {
                success: false,
                error: new ($a8bc256d81a5e2c1$export$b722478a3cbfa3bc)(`Error getting ${chainId} balances`, ($a8bc256d81a5e2c1$export$e3dc0620abde7f5a).GET_BALANCE_ERROR),
                balances: []
            });
        });
    }
    return chainBalances;
};


/* eslint-disable @typescript-eslint/no-unused-vars */ 



const $f730af3b727f04ac$export$22fea095b15361de = (balances)=>{
    for (const balance of balances.balances){
        if (!balance.token.address || balance.token.address === "") return balance.balance;
    }
    return (BigNumber$1).from(0);
};






const $8a49d1a3783a2640$export$3aff971444a4f244 = async (config, readOnlyProviders)=>{
    try {
        const estimate = await (0, $2e7bf45a7c9a9570$export$942c8de7174809fc)({
            gasEstimateType: (0, $de275b98d2b651c3$export$788b1fd17f3dad84).BRIDGE_TO_L2,
            isSpendingCapApprovalRequired: false
        }, readOnlyProviders, config);
        const gasEstimate = estimate.gasFee.estimatedAmount;
        const bridgeFee = estimate.bridgeFee.estimatedAmount;
        let totalFees = (0, BigNumber$1).from(0);
        if (gasEstimate) totalFees = totalFees.add(gasEstimate);
        if (bridgeFee) totalFees = totalFees.add(bridgeFee);
        return totalFees;
    } catch (err) {
        throw new ($a8bc256d81a5e2c1$export$b722478a3cbfa3bc)("Error estimating gas for bridge", ($a8bc256d81a5e2c1$export$e3dc0620abde7f5a).BRIDGE_GAS_ESTIMATE_ERROR, {
            message: err.message
        });
    }
};



const $823db9fb0ca4bc15$export$c37d8687c27b9660 = "0x0000000000000000000000000000000000000001";
const $823db9fb0ca4bc15$export$1430626eec86fce9 = (chainId)=>{
    if (chainId === ($0472f23319457bfb$export$c06e1e7429de6283).IMTBL_ZKEVM_TESTNET) return "imtbl-zkevm-testnet";
    return "";
};
const $823db9fb0ca4bc15$export$53e663abd9b77fc1 = async (chainId, config)=>{
    const imxMappingConfig = await config.remote.getConfig("imxAddressMapping");
    return imxMappingConfig[chainId] ?? "";
};







const $07ac9c0576988336$export$7847f5f5cce25dfa = async (config, readOnlyProviders, l1provider, depositorAddress, fromChainId, toChainId, token, depositAmount)=>{
    try {
        const tokenBridge = await $67fc622a2b913d5f$export$989eefe1274a439c(fromChainId, toChainId, readOnlyProviders, config);
        const { unsignedTx: unsignedTx } = await tokenBridge.getUnsignedApproveDepositBridgeTx({
            depositorAddress: depositorAddress,
            token: token,
            depositAmount: depositAmount
        });
        if (unsignedTx === null) return (0, BigNumber$1).from(0);
        return await l1provider.estimateGas(unsignedTx);
    } catch (err) {
        throw new ($a8bc256d81a5e2c1$export$b722478a3cbfa3bc)("Error occurred while attempting ot estimate gas for approval transaction", ($a8bc256d81a5e2c1$export$e3dc0620abde7f5a).BRIDGE_GAS_ESTIMATE_ERROR, {
            message: err.message
        });
    }
};
const $07ac9c0576988336$export$a3dd181de896b7c7 = async (config, readOnlyProviders, l1provider, depositorAddress, l1Address, delta)=>{
    if (l1Address === ($823db9fb0ca4bc15$export$c37d8687c27b9660)) return (BigNumber$1).from(0); // Native ETH does not require approval
    const fromChainId = ($4013c5c91bb535f6$export$9b794d067cdd1af6)(config);
    const toChainId = ($4013c5c91bb535f6$export$c9af4e4b001c6476)(config);
    return await $07ac9c0576988336$export$7847f5f5cce25dfa(config, readOnlyProviders, l1provider, depositorAddress, fromChainId, toChainId, l1Address, delta);
};




const $5a5ccedc98d53d25$var$filterTokens = (allowedTokens, balances)=>{
    if (balances && balances.success) return allowedTokens.filter((token)=>{
        if ("address" in token) return balances.balances.find((balance)=>balance.token.address === token.address && balance.balance.gt(0));
        return balances.balances.find((balance)=>!("address" in balance.token) && balance.balance.gt(0));
    });
    return [];
};
const $5a5ccedc98d53d25$export$9ec9fc71f3ce62c4 = async (config, availableRoutingOptions)=>{
    if (availableRoutingOptions.onRamp) {
        const onRampOptions = await config.remote.getConfig("onramp");
        const onRampAllowList = {};
        Object.entries(onRampOptions).forEach(([onRampProvider, onRampProviderConfig])=>{
            // Allowed list per onRamp provider
            onRampAllowList[onRampProvider] = onRampProviderConfig.tokens ?? [];
        });
        return onRampAllowList;
    }
    return {};
};
const $5a5ccedc98d53d25$export$d744af9f1c0712bc = async (config, tokenBalances, availableRoutingOptions)=>{
    if (availableRoutingOptions.bridge) {
        const allowedTokens = (await config.remote.getConfig("bridge"))?.tokens ?? [];
        const balances = tokenBalances.get(($4013c5c91bb535f6$export$9b794d067cdd1af6)(config));
        return $5a5ccedc98d53d25$var$filterTokens(allowedTokens, balances);
    }
    return [];
};
const $5a5ccedc98d53d25$export$87ed7f956d73690 = async (config, tokenBalances, availableRoutingOptions)=>{
    if (availableRoutingOptions.swap) {
        const allowedTokens = (await config.remote.getConfig("dex"))?.tokens ?? [];
        const balances = tokenBalances.get(($4013c5c91bb535f6$export$c9af4e4b001c6476)(config));
        return $5a5ccedc98d53d25$var$filterTokens(allowedTokens, balances);
    }
    return [];
};
const $5a5ccedc98d53d25$export$1ad29657d49c5440 = async (config, tokenBalances, availableRoutingOptions)=>{
    const tokenAllowList = {};
    tokenAllowList.swap = await $5a5ccedc98d53d25$export$87ed7f956d73690(config, tokenBalances, availableRoutingOptions);
    tokenAllowList.bridge = await $5a5ccedc98d53d25$export$d744af9f1c0712bc(config, tokenBalances, availableRoutingOptions);
    tokenAllowList.onRamp = await $5a5ccedc98d53d25$export$9ec9fc71f3ce62c4(config, availableRoutingOptions);
    return tokenAllowList;
};


const $fa9ac5bfdbbf9dfa$export$9994ad18c2f0e665 = (balances, totalFees)=>{
    const balance = ($f730af3b727f04ac$export$22fea095b15361de)(balances);
    return balance.gte(totalFees);
};
const $fa9ac5bfdbbf9dfa$export$97330fab5f794e7f = (balanceRequirement)=>{
    if (balanceRequirement.type === ($4b58188d47aafe8d$export$1fc8f52ad1810e52).NATIVE) return $d85ad1457a3f1a83$export$b80040cb173ba6e9;
    if (balanceRequirement.type === ($4b58188d47aafe8d$export$1fc8f52ad1810e52).ERC20) return balanceRequirement.required.token.address ?? "";
    return "";
};
const $fa9ac5bfdbbf9dfa$export$952cdf461a00a8c6 = async (config, balanceRequirement)=>{
    const l2address = $fa9ac5bfdbbf9dfa$export$97330fab5f794e7f(balanceRequirement);
    if (l2address === "") return "";
    if (l2address === ($d85ad1457a3f1a83$export$b80040cb173ba6e9)) return await ($823db9fb0ca4bc15$export$53e663abd9b77fc1)(($4013c5c91bb535f6$export$9b794d067cdd1af6)(config), config);
    const chainName = ($823db9fb0ca4bc15$export$1430626eec86fce9)(($4013c5c91bb535f6$export$c9af4e4b001c6476)(config));
    if (chainName === "") return ""; // Chain name not a valid indexer chain name
    const blockchainData = ($67fc622a2b913d5f$export$436dd76f23f463ff)(config);
    const tokenData = await blockchainData.getToken({
        chainName: chainName,
        contractAddress: l2address
    });
    const l1address = tokenData.result.root_contract_address;
    if (l1address === null) return ""; // No L1 representation of this token
    return l1address;
};
const $fa9ac5bfdbbf9dfa$export$da05aed50d75046 = async (config, readOnlyProviders, feeEstimates)=>{
    let bridgeFeeEstimate = feeEstimates.get(($4b58188d47aafe8d$export$3af78bb3e8650ee6).BRIDGE);
    if (bridgeFeeEstimate) return bridgeFeeEstimate;
    bridgeFeeEstimate = await ($8a49d1a3783a2640$export$3aff971444a4f244)(config, readOnlyProviders);
    feeEstimates.set(($4b58188d47aafe8d$export$3af78bb3e8650ee6).BRIDGE, bridgeFeeEstimate);
    return bridgeFeeEstimate;
};
const $fa9ac5bfdbbf9dfa$var$constructBridgeFundingRoute = (chainId, balance)=>({
        type: ($4b58188d47aafe8d$export$3af78bb3e8650ee6).BRIDGE,
        chainId: chainId,
        asset: {
            balance: balance.balance,
            formattedBalance: balance.formattedBalance,
            token: {
                name: balance.token.name,
                symbol: balance.token.symbol,
                address: balance.token.address,
                decimals: balance.token.decimals
            }
        }
    });
const $fa9ac5bfdbbf9dfa$export$3139474685e4dedd = (address)=>{
    if (!address || address === "") return true;
    return false;
};
const $fa9ac5bfdbbf9dfa$export$ddc7ba2b57d7c5fa = async (config, readOnlyProviders, depositorAddress, availableRoutingOptions, balanceRequirement, balances, feeEstimates)=>{
    if (!availableRoutingOptions.bridge) return undefined;
    const chainId = ($4013c5c91bb535f6$export$9b794d067cdd1af6)(config);
    const tokenBalanceResult = balances.get(chainId);
    const l1provider = readOnlyProviders.get(chainId);
    if (!l1provider) throw new ($a8bc256d81a5e2c1$export$b722478a3cbfa3bc)("No L1 provider available", ($a8bc256d81a5e2c1$export$e3dc0620abde7f5a).PROVIDER_ERROR, {
        chainId: chainId.toString()
    });
    // If no balances on layer 1 then Bridge cannot be an option
    if (tokenBalanceResult === undefined || tokenBalanceResult.success === false) return undefined;
    const allowedTokenList = await ($5a5ccedc98d53d25$export$d744af9f1c0712bc)(config, balances, availableRoutingOptions);
    if (allowedTokenList.length === 0) return undefined;
    const bridgeFeeEstimate = await $fa9ac5bfdbbf9dfa$export$da05aed50d75046(config, readOnlyProviders, feeEstimates);
    // If the user has no ETH to cover the bridge fees or approval fees then bridge cannot be an option
    if (!$fa9ac5bfdbbf9dfa$export$9994ad18c2f0e665(tokenBalanceResult, bridgeFeeEstimate)) return undefined;
    const l1address = await $fa9ac5bfdbbf9dfa$export$952cdf461a00a8c6(config, balanceRequirement);
    if (l1address === "") return undefined;
    // Ensure l1address is in the allowed token list
    if (l1address === ($823db9fb0ca4bc15$export$c37d8687c27b9660)) {
        if (!allowedTokenList.find((token)=>!("address" in token))) return undefined;
    } else if (!allowedTokenList.find((token)=>token.address === l1address)) return undefined;
    const gasForApproval = await ($07ac9c0576988336$export$a3dd181de896b7c7)(config, readOnlyProviders, l1provider, depositorAddress, l1address, balanceRequirement.delta.balance);
    if (!$fa9ac5bfdbbf9dfa$export$9994ad18c2f0e665(tokenBalanceResult, gasForApproval.add(bridgeFeeEstimate))) return undefined;
    // If the L1 representation of the requirement is ETH then find the ETH balance and check if the balance covers the delta
    if (l1address === ($823db9fb0ca4bc15$export$c37d8687c27b9660)) {
        const nativeETHBalance = tokenBalanceResult.balances.find((balance)=>$fa9ac5bfdbbf9dfa$export$3139474685e4dedd(balance.token.address));
        if (nativeETHBalance && nativeETHBalance.balance.gte(balanceRequirement.delta.balance.add(bridgeFeeEstimate))) return $fa9ac5bfdbbf9dfa$var$constructBridgeFundingRoute(chainId, nativeETHBalance);
        return undefined;
    }
    // Find the balance of the L1 representation of the token and check if the balance covers the delta
    const erc20balance = tokenBalanceResult.balances.find((balance)=>balance.token.address === l1address);
    if (erc20balance && erc20balance.balance.gte(balanceRequirement.delta.balance)) return $fa9ac5bfdbbf9dfa$var$constructBridgeFundingRoute(chainId, erc20balance);
    return undefined;
};






async function $0e0060cb42e136d2$export$339cb2be73677b30(config, existingReadOnlyProviders) {
    if (config.isProduction && existingReadOnlyProviders?.has(($0472f23319457bfb$export$c06e1e7429de6283).ETHEREUM)) return existingReadOnlyProviders;
    if (existingReadOnlyProviders?.has(($0472f23319457bfb$export$c06e1e7429de6283).SEPOLIA)) return existingReadOnlyProviders;
    const readOnlyProviders = new Map();
    const allowedNetworks = await $de192de6ef100f9f$export$3043f6442a9ef563(config, {
        type: ($a47e48dd2c04791b$export$1f05a55fe0680cc7).ALL
    });
    allowedNetworks.networks.forEach((networkInfo)=>{
        const rpcUrl = config.networkMap.get(networkInfo.chainId)?.rpcUrls[0];
        const provider = new (JsonRpcProvider)(rpcUrl);
        readOnlyProviders.set(networkInfo.chainId, provider);
    });
    return readOnlyProviders;
}








const $049bba630af05555$export$6946a1f17c2bbf26 = async (config, chainId, walletAddress, requiredToken, swappableTokens)=>{
    const dexQuotes = new Map();
    try {
        const exchange = await $67fc622a2b913d5f$export$7cf6178417769841(chainId, config);
        const dexTransactionResponsePromises = [];
        // Create a quote for each swappable token
        for (const swappableToken of swappableTokens)dexTransactionResponsePromises.push(exchange.getUnsignedSwapTxFromAmountOut(walletAddress, swappableToken, requiredToken.address, requiredToken.amount));
        // Resolve all the quotes and link them back to the swappable token
        // The swappable token array is in the same position in the array as the quote in the promise array
        const dexTransactionResponse = await Promise.all(dexTransactionResponsePromises);
        dexTransactionResponse.forEach((response, index)=>{
            const swappableToken = swappableTokens[index];
            dexQuotes.set(swappableToken, {
                quote: response.quote,
                approval: response.approval?.gasFeeEstimate,
                swap: response.swap.gasFeeEstimate
            });
        });
        return dexQuotes;
    } catch  {
        return dexQuotes;
    }
};


const $3ee85f12225c19f3$export$fb80fe94a81a3132 = async (config, dexQuoteCache, walletAddress, requiredToken, swappableTokens)=>{
    const dexQuotes = dexQuoteCache.get(requiredToken.address);
    if (dexQuotes) return dexQuotes;
    const quotes = await ($049bba630af05555$export$6946a1f17c2bbf26)(config, ($4013c5c91bb535f6$export$c9af4e4b001c6476)(config), walletAddress, requiredToken, swappableTokens);
    dexQuoteCache.set(requiredToken.address, quotes);
    return quotes;
};


const $91807edfd7057288$export$85e4d8628aabb217 = (balanceRequirement)=>{
    let address = "";
    let amount = (BigNumber$1).from(0);
    switch(balanceRequirement.type){
        case ($4b58188d47aafe8d$export$1fc8f52ad1810e52).ERC20:
            address = balanceRequirement.required.token.address ?? "";
            amount = balanceRequirement.delta.balance;
            break;
        case ($4b58188d47aafe8d$export$1fc8f52ad1810e52).NATIVE:
            address = ($d85ad1457a3f1a83$export$b80040cb173ba6e9);
            amount = balanceRequirement.delta.balance;
            break;
    }
    return {
        address: address,
        amount: amount
    };
};
const $91807edfd7057288$export$7b6318fc1a8067b3 = (l2Balances, approval)=>{
    // Check if approval required
    if (!approval) return {
        sufficient: true,
        approvalGasFee: (BigNumber$1).from(0),
        approvalGasTokenAddress: ""
    };
    const approvalGasFee = approval.value;
    const approvalGasTokenAddress = approval.token.address;
    // No balance on L2 to cover approval fees
    if (l2Balances.length === 0) return {
        sufficient: false,
        approvalGasFee: approvalGasFee,
        approvalGasTokenAddress: approvalGasTokenAddress
    };
    // Find the users balance of the approval token
    const l2BalanceOfApprovalToken = l2Balances.find((balance)=>balance.token.address === approvalGasTokenAddress);
    if (!l2BalanceOfApprovalToken) return {
        sufficient: false,
        approvalGasFee: approvalGasFee,
        approvalGasTokenAddress: approvalGasTokenAddress
    };
    // If the user does not have enough of the token to cover approval fees then return sufficient false
    if (l2BalanceOfApprovalToken.balance.lt(approvalGasFee)) return {
        sufficient: false,
        approvalGasFee: approvalGasFee,
        approvalGasTokenAddress: approvalGasTokenAddress
    };
    // The user has enough to cover approval gas fees
    return {
        sufficient: true,
        approvalGasFee: approvalGasFee,
        approvalGasTokenAddress: approvalGasTokenAddress
    };
};
const $91807edfd7057288$export$38077235fe748d40 = (l2Balances, swapFees, approvalFees, tokenBeingSwapped)=>{
    // Set up a map of token addresses to amounts for each of the swap fees
    const feeMap = new Map();
    // Add the approval fee to list of fees
    if (approvalFees.approvalGasTokenAddress !== "") feeMap.set(approvalFees.approvalGasTokenAddress, approvalFees.approvalGasFee);
    // Add the token being swapped to list of fees to ensure the user can cover the fee + the token swap
    if (tokenBeingSwapped) {
        const fee = feeMap.get(tokenBeingSwapped.address);
        if (fee) feeMap.set(tokenBeingSwapped.address, fee.add(tokenBeingSwapped.amount));
        else feeMap.set(tokenBeingSwapped.address, tokenBeingSwapped.amount);
    }
    // Get all the fees and key them by their token id
    for (const swapFee of swapFees){
        const fee = feeMap.get(swapFee.amount.token.address);
        if (fee) {
            feeMap.set(swapFee.amount.token.address, fee.add(swapFee.amount.value));
            continue;
        }
        feeMap.set(swapFee.amount.token.address, swapFee.amount.value);
    }
    // Go through the map and for each token address check if the user has enough balance to cover the fee
    for (const [tokenAddress, fee] of feeMap.entries()){
        if (fee === (BigNumber$1).from(0)) continue;
        const l2BalanceOfFeeToken = l2Balances.find((balance)=>balance.token.address === tokenAddress);
        if (!l2BalanceOfFeeToken) return false;
        if (l2BalanceOfFeeToken.balance.lt(fee)) return false;
    }
    return true;
};
const $91807edfd7057288$export$8e03ea04d59f2402 = async (config, availableRoutingOptions, dexQuoteCache, walletAddress, balanceRequirement, tokenBalanceResults, swappableTokens)=>{
    const fundingSteps = [];
    if (!availableRoutingOptions.swap) return fundingSteps;
    if (swappableTokens.length === 0) return fundingSteps;
    const requiredToken = $91807edfd7057288$export$85e4d8628aabb217(balanceRequirement);
    if (requiredToken.address === "") return fundingSteps;
    const l2TokenBalanceResult = tokenBalanceResults.get(($4013c5c91bb535f6$export$c9af4e4b001c6476)(config));
    if (!l2TokenBalanceResult) return fundingSteps;
    const l2Balances = l2TokenBalanceResult.balances;
    if (l2Balances.length === 0) return fundingSteps;
    const quotes = await ($3ee85f12225c19f3$export$fb80fe94a81a3132)(config, dexQuoteCache, walletAddress, requiredToken, swappableTokens);
    const quoteTokenAddresses = Array.from(quotes.keys());
    for (const quoteTokenAddress of quoteTokenAddresses){
        const quote = quotes.get(quoteTokenAddress);
        if (!quote) continue;
        // Find the balance the user has for this quoted token
        const userBalanceOfQuotedToken = l2Balances.find((balance)=>balance.token.address === quoteTokenAddress);
        // If no balance found on L2 for this quoted token then continue
        if (!userBalanceOfQuotedToken) continue;
        // Check the amount of quoted token required against the user balance
        const amountOfQuoteTokenRequired = quote.quote.amount;
        // If user does not have enough balance to perform the swap with this token then continue
        if (userBalanceOfQuotedToken.balance.lt(amountOfQuoteTokenRequired.value)) continue;
        const approvalFees = $91807edfd7057288$export$7b6318fc1a8067b3(l2Balances, quote.approval);
        // If user does not have enough to cover approval fees then continue
        if (!approvalFees.sufficient) continue;
        // If user does not have enough to cover swap fees then continue
        if (!$91807edfd7057288$export$38077235fe748d40(l2Balances, quote.quote.fees, approvalFees, {
            amount: amountOfQuoteTokenRequired.value,
            address: quoteTokenAddress
        })) continue;
        // User has sufficient funds to cover any approval and swap fees so use this token for the funding route
        // Currently we are not prioritising any particular token so just taking the first sufficient token
        fundingSteps.push({
            type: ($4b58188d47aafe8d$export$3af78bb3e8650ee6).SWAP,
            chainId: ($4013c5c91bb535f6$export$c9af4e4b001c6476)(config),
            asset: {
                balance: userBalanceOfQuotedToken.balance,
                formattedBalance: userBalanceOfQuotedToken.formattedBalance,
                token: userBalanceOfQuotedToken.token
            }
        });
    }
    return fundingSteps;
};








const $5649bc8af91da370$export$1fb2bd867f4a9be3 = async (config, availableRoutingOptions, balanceRequirement)=>{
    if (balanceRequirement.type !== ($4b58188d47aafe8d$export$1fc8f52ad1810e52).ERC20 && balanceRequirement.type !== ($4b58188d47aafe8d$export$1fc8f52ad1810e52).NATIVE) return undefined;
    const requiredBalance = balanceRequirement.required;
    let hasAllowList = false;
    const onRampProvidersAllowList = await ($5a5ccedc98d53d25$export$9ec9fc71f3ce62c4)(config, availableRoutingOptions);
    Object.values(onRampProvidersAllowList).forEach((onRampAllowList)=>{
        if (onRampAllowList.length > 0 && !hasAllowList) hasAllowList = !!onRampAllowList.find((token)=>token.address === requiredBalance.token?.address);
    });
    if (!hasAllowList) return undefined;
    return {
        type: ($4b58188d47aafe8d$export$3af78bb3e8650ee6).ONRAMP,
        chainId: ($4013c5c91bb535f6$export$c9af4e4b001c6476)(config),
        asset: {
            balance: requiredBalance.balance,
            formattedBalance: requiredBalance.formattedBalance,
            token: {
                ...requiredBalance.token
            }
        }
    };
};




const $c16168a9c28ae4fd$var$hasAvailableRoutingOptions = (availableRoutingOptions)=>availableRoutingOptions.bridge || availableRoutingOptions.swap || availableRoutingOptions.onRamp;
const $c16168a9c28ae4fd$export$31ce7ba1a2956195 = (balanceRequirements)=>{
    let insufficientBalanceCount = 0;
    let insufficientRequirement;
    for (const balanceRequirement of balanceRequirements.balanceRequirements)if (!balanceRequirement.sufficient) {
        insufficientBalanceCount++;
        insufficientRequirement = balanceRequirement;
    }
    if (insufficientBalanceCount === 1) return insufficientRequirement;
    return undefined;
};
const $c16168a9c28ae4fd$export$814624e957fa0f11 = async (config, availableRoutingOptions, insufficientRequirement, dexQuoteCache, ownerAddress, tokenBalances, swapTokenAllowList)=>{
    const fundingSteps = [];
    if (!availableRoutingOptions.swap) return fundingSteps;
    if (insufficientRequirement === undefined) return fundingSteps;
    if (swapTokenAllowList === undefined) return fundingSteps;
    const tokenBalanceResult = tokenBalances.get(($4013c5c91bb535f6$export$c9af4e4b001c6476)(config));
    if (!tokenBalanceResult) return fundingSteps;
    if (tokenBalanceResult.error !== undefined || !tokenBalanceResult.success) return fundingSteps;
    if (swapTokenAllowList.length === 0) return fundingSteps;
    const swappableTokens = swapTokenAllowList.filter((token)=>token.address).map((token)=>token.address);
    if (swappableTokens.length === 0) return fundingSteps;
    return await ($91807edfd7057288$export$8e03ea04d59f2402)(config, availableRoutingOptions, dexQuoteCache, ownerAddress, insufficientRequirement, tokenBalances, swappableTokens);
};
const $c16168a9c28ae4fd$export$e1b6e4d22d0365ee = async (config, availableRoutingOptions, insufficientRequirement)=>{
    if (!availableRoutingOptions.onRamp) return undefined;
    if (insufficientRequirement === undefined) return undefined;
    const onRampFundingStep = await ($5649bc8af91da370$export$1fb2bd867f4a9be3)(config, availableRoutingOptions, insufficientRequirement);
    return onRampFundingStep;
};
const $c16168a9c28ae4fd$export$92606e71d0a264ff = async (config, ownerAddress, balanceRequirements, availableRoutingOptions)=>{
    if (!$c16168a9c28ae4fd$var$hasAvailableRoutingOptions(availableRoutingOptions)) return {
        response: {
            type: ($b23305044c0e096a$export$3057de18ac0c076).NO_OPTIONS,
            message: "No options available"
        },
        fundingRoutes: []
    };
    let readOnlyProviders;
    try {
        readOnlyProviders = await (0, $0e0060cb42e136d2$export$339cb2be73677b30)(config);
    } catch (err) {
        throw new ($a8bc256d81a5e2c1$export$b722478a3cbfa3bc)("Error occurred while creating read only providers", ($a8bc256d81a5e2c1$export$e3dc0620abde7f5a).PROVIDER_ERROR, {
            message: err.message
        });
    }
    const tokenBalances = await ($33acec7b4a26c053$export$23ddeb2642d2f9d)(config, readOnlyProviders, ownerAddress, availableRoutingOptions);
    const allowList = await ($5a5ccedc98d53d25$export$1ad29657d49c5440)(config, tokenBalances, availableRoutingOptions);
    // Bridge and swap fee cache
    const feeEstimates = new Map();
    // Dex quotes cache
    const dexQuoteCache = new Map();
    // Ensures only 1 balance requirement is insufficient otherwise one bridge or one swap route cannot be recommended
    const insufficientRequirement = $c16168a9c28ae4fd$export$31ce7ba1a2956195(balanceRequirements);
    let bridgeFundingStep;
    if (availableRoutingOptions.bridge && insufficientRequirement) bridgeFundingStep = await ($fa9ac5bfdbbf9dfa$export$ddc7ba2b57d7c5fa)(config, readOnlyProviders, ownerAddress, availableRoutingOptions, insufficientRequirement, tokenBalances, feeEstimates);
    const swapFundingSteps = await $c16168a9c28ae4fd$export$814624e957fa0f11(config, availableRoutingOptions, insufficientRequirement, dexQuoteCache, ownerAddress, tokenBalances, allowList.swap);
    const onRampFundingStep = await $c16168a9c28ae4fd$export$e1b6e4d22d0365ee(config, availableRoutingOptions, insufficientRequirement);
    // Check swap routes
    // > Could bridge first
    // > Could on-ramp first
    // > Could double swap
    const response = {
        response: {
            type: ($b23305044c0e096a$export$3057de18ac0c076).NO_ROUTES,
            message: "Routes not found"
        },
        fundingRoutes: []
    };
    let priority = 0;
    if (bridgeFundingStep || swapFundingSteps.length > 0 || onRampFundingStep) {
        response.response.type = ($b23305044c0e096a$export$3057de18ac0c076).ROUTES_FOUND;
        response.response.message = "Routes found";
    }
    if (bridgeFundingStep) {
        priority++;
        response.fundingRoutes.push({
            priority: priority,
            steps: [
                bridgeFundingStep
            ]
        });
    }
    if (swapFundingSteps.length > 0) {
        priority++;
        swapFundingSteps.forEach((swapFundingStep)=>{
            response.fundingRoutes.push({
                priority: priority,
                steps: [
                    swapFundingStep
                ]
            });
        });
    }
    if (onRampFundingStep) {
        priority++;
        response.fundingRoutes.push({
            priority: priority,
            steps: [
                onRampFundingStep
            ]
        });
    }
    return response;
};


const $0e7419077c373b24$export$4a2a19d99fef3b1b = (balanceCheckResult)=>{
    let sufficient = true;
    const transactionRequirements = [];
    for (const balance of balanceCheckResult.balanceRequirements){
        if (!balance.sufficient) sufficient = false;
        transactionRequirements.push({
            type: balance.type,
            sufficient: balance.sufficient,
            required: balance.required,
            current: balance.current,
            delta: balance.delta
        });
    }
    return {
        sufficient: sufficient,
        transactionRequirements: transactionRequirements
    };
};
const $0e7419077c373b24$export$9e073f9ada8c81e6 = async (config, provider, itemRequirements, transactionOrGasAmount)=>{
    const ownerAddress = await provider.getSigner().getAddress();
    let aggregatedItems = ($074f75878f618031$export$c804c9ade5c28607)(itemRequirements);
    const erc20Allowances = await ($fc8b338399d890f3$export$d93c00812189e36)(provider, ownerAddress, aggregatedItems);
    const erc721Allowances = await ($35c3fc7013888ba5$export$be546c525d418988)(provider, ownerAddress, aggregatedItems);
    const aggregatedAllowances = ($ddc6bcd0896481e5$export$2fbfa41a4de56a89)(erc20Allowances, erc721Allowances);
    const gasItem = await ($7d1bfafb81e64d74$export$3a4140bd9e983e4e)(provider, aggregatedAllowances, transactionOrGasAmount);
    if (gasItem !== null) {
        aggregatedItems.push(gasItem);
        aggregatedItems = ($074f75878f618031$export$c804c9ade5c28607)(aggregatedItems);
    }
    const balanceRequirements = await ($beb896e098e41faf$export$ddfc885f43c3cb6e)(config, provider, ownerAddress, aggregatedItems);
    // Determine which services are available
    const availableRoutingOptions = await ($7f2e17f026d4fc8d$export$f1ca3744c025ab81)(config, provider);
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    await ($c16168a9c28ae4fd$export$92606e71d0a264ff)(config, ownerAddress, balanceRequirements, availableRoutingOptions);
    return $0e7419077c373b24$export$4a2a19d99fef3b1b(balanceRequirements);
};





var $d855a5ba32004345$export$f51b97f3aaf2d5a8;
(function(SignTransactionStatusType) {
    SignTransactionStatusType["SUCCESS"] = "SUCCESS";
    SignTransactionStatusType["FAILED"] = "FAILED";
})($d855a5ba32004345$export$f51b97f3aaf2d5a8 || ($d855a5ba32004345$export$f51b97f3aaf2d5a8 = {}));


const $25ac589234c10b67$export$19693ca396db083e = async (provider, approvalTransactions)=>{
    let receipts = [];
    try {
        const response = await Promise.all(approvalTransactions.map((transaction)=>provider.getSigner().sendTransaction(transaction)));
        receipts = await Promise.all(response.map((transaction)=>transaction.wait()));
    } catch (err) {
        throw new ($a8bc256d81a5e2c1$export$b722478a3cbfa3bc)("An error occurred while executing the approval transaction", ($a8bc256d81a5e2c1$export$e3dc0620abde7f5a).EXECUTE_APPROVAL_TRANSACTION_ERROR, {
            message: err.message
        });
    }
    for (const receipt of receipts){
        if (receipt.status === 0) return {
            type: ($d855a5ba32004345$export$f51b97f3aaf2d5a8).FAILED,
            transactionHash: receipt.transactionHash,
            reason: "Approval transaction failed and was reverted"
        };
    }
    return {
        type: ($d855a5ba32004345$export$f51b97f3aaf2d5a8).SUCCESS
    };
};
const $25ac589234c10b67$export$3f05b33bd1f29038 = async (provider, fulfillmentTransactions)=>{
    let receipts = [];
    try {
        const response = await Promise.all(fulfillmentTransactions.map((transaction)=>provider.getSigner().sendTransaction(transaction)));
        receipts = await Promise.all(response.map((transaction)=>transaction.wait()));
    } catch (err) {
        throw new ($a8bc256d81a5e2c1$export$b722478a3cbfa3bc)("An error occurred while executing the fulfillment transaction", ($a8bc256d81a5e2c1$export$e3dc0620abde7f5a).EXECUTE_FULFILLMENT_TRANSACTION_ERROR, {
            message: err.message
        });
    }
    for (const receipt of receipts){
        if (receipt.status === 0) return {
            type: ($d855a5ba32004345$export$f51b97f3aaf2d5a8).FAILED,
            transactionHash: receipt.transactionHash,
            reason: "Fulfillment transaction failed and was reverted"
        };
    }
    return {
        type: ($d855a5ba32004345$export$f51b97f3aaf2d5a8).SUCCESS
    };
};
const $25ac589234c10b67$export$1d9a7a8a40780de = async (provider, unsignedMessage)=>{
    try {
        // eslint-disable-next-line no-underscore-dangle
        const signedMessage = await provider.getSigner()._signTypedData(unsignedMessage.unsignedMessage.domain, unsignedMessage.unsignedMessage.types, unsignedMessage.unsignedMessage.value);
        return {
            orderComponents: unsignedMessage.orderComponents,
            orderHash: unsignedMessage.orderHash,
            signedMessage: signedMessage
        };
    } catch (err) {
        throw new ($a8bc256d81a5e2c1$export$b722478a3cbfa3bc)("An error occurred while signing the message", ($a8bc256d81a5e2c1$export$e3dc0620abde7f5a).SIGN_MESSAGE_ERROR, {
            message: err.message
        });
    }
};



const $a7367d01c6e76b1c$export$c5b3365853cb6159 = async (actions)=>{
    let approvalTransactions = [];
    let fulfillmentTransactions = [];
    const approvalPromises = [];
    const fulfillmentPromises = [];
    for (const action of actions){
        if (action.type !== (ActionType).TRANSACTION) continue;
        if (action.purpose === (TransactionPurpose).APPROVAL) approvalPromises.push(action.buildTransaction());
        if (action.purpose === (TransactionPurpose).FULFILL_ORDER) fulfillmentPromises.push(action.buildTransaction());
    }
    approvalTransactions = await Promise.all(approvalPromises);
    fulfillmentTransactions = await Promise.all(fulfillmentPromises);
    return {
        approvalTransactions: approvalTransactions,
        fulfillmentTransactions: fulfillmentTransactions
    };
};
const $a7367d01c6e76b1c$export$f64a20a30eb98855 = async (actions)=>{
    let approvalTransactions = [];
    const approvalPromises = [];
    for (const action of actions){
        if (action.type !== (ActionType).TRANSACTION) continue;
        if (action.purpose === (TransactionPurpose).APPROVAL) approvalPromises.push(action.buildTransaction());
    }
    approvalTransactions = await Promise.all(approvalPromises);
    return approvalTransactions;
};
const $a7367d01c6e76b1c$export$396bd6ce7d3ab533 = async (actions)=>{
    let fulfillmentTransactions = [];
    const fulfillmentPromises = [];
    for (const action of actions){
        if (action.type !== (ActionType).TRANSACTION) continue;
        if (action.purpose === (TransactionPurpose).FULFILL_ORDER) fulfillmentPromises.push(action.buildTransaction());
    }
    fulfillmentTransactions = await Promise.all(fulfillmentPromises);
    return fulfillmentTransactions;
};
const $a7367d01c6e76b1c$export$d62081fac18000c2 = (orderHash, orderComponents, actions)=>{
    let unsignedMessage;
    for (const action of actions){
        if (action.type !== (ActionType).SIGNABLE) continue;
        if (action.purpose === (SignablePurpose).CREATE_LISTING) unsignedMessage = {
            domain: action.message.domain,
            types: action.message.types,
            value: action.message.value
        };
    }
    if (!unsignedMessage) return undefined;
    return {
        orderHash: orderHash,
        orderComponents: orderComponents,
        unsignedMessage: unsignedMessage
    };
};









const $9051cee080948594$export$9ac1563efd38130 = 1; // 100%
const $9051cee080948594$export$768e717351d4b176 = 6; // will allow 0.000001 (0.0001%) as the minimum value
const $9051cee080948594$var$calculateFeesPercent = (orderFee, amountBn)=>{
    const feePercentage = orderFee.amount;
    // note: multiply in and out of the maximum decimal places to the power of ten to do the math in big number integers
    const feePercentageMultiplier = Math.round(feePercentage.percentageDecimal * 10 ** $9051cee080948594$export$768e717351d4b176);
    const bnFeeAmount = amountBn.mul((BigNumber$1).from(feePercentageMultiplier)).div(10 ** $9051cee080948594$export$768e717351d4b176);
    return bnFeeAmount;
};
const $9051cee080948594$var$calculateFeesToken = (orderFee, decimals)=>{
    const feeToken = orderFee.amount;
    const bnFeeAmount = (parseUnits$1)(feeToken.token, decimals);
    return bnFeeAmount;
};
const $9051cee080948594$export$1e69c9cfc42e28d8 = (orderFees, weiAmount, decimals = 18)=>{
    let totalTokenFees = (BigNumber$1).from(0);
    const amountBn = (BigNumber$1).from(weiAmount);
    // note: multiply in and out of the maximum decimal places to the power of ten to do the math in big number integers
    const totalAllowableFees = amountBn.mul($9051cee080948594$export$9ac1563efd38130 * 10 ** $9051cee080948594$export$768e717351d4b176).div(10 ** $9051cee080948594$export$768e717351d4b176);
    const calculateFeesResult = [];
    for (const orderFee of orderFees){
        let currentFeeBn = (BigNumber$1).from(0);
        if (Object.hasOwn(orderFee.amount, "percentageDecimal")) {
            currentFeeBn = $9051cee080948594$var$calculateFeesPercent(orderFee, amountBn);
            totalTokenFees = totalTokenFees.add(currentFeeBn);
        } else if (Object.hasOwn(orderFee.amount, "token")) {
            currentFeeBn = $9051cee080948594$var$calculateFeesToken(orderFee, decimals);
            totalTokenFees = totalTokenFees.add(currentFeeBn);
        } else throw new ($a8bc256d81a5e2c1$export$b722478a3cbfa3bc)("Unknown fee type parsed, must be percentageDecimal or token", ($a8bc256d81a5e2c1$export$e3dc0620abde7f5a).ORDER_FEE_ERROR);
        if (totalTokenFees.gt(totalAllowableFees)) throw new ($a8bc256d81a5e2c1$export$b722478a3cbfa3bc)(`The combined fees are above the allowed maximum of ${$9051cee080948594$export$9ac1563efd38130 * 100}%`, ($a8bc256d81a5e2c1$export$e3dc0620abde7f5a).ORDER_FEE_ERROR);
        if (currentFeeBn.gt(0)) calculateFeesResult.push({
            amount: currentFeeBn.toString(),
            recipient: orderFee.recipient
        });
    } // for
    return calculateFeesResult;
};


const $64863c39386de592$export$4249179755829904 = (type, contractAddress, amount, spenderAddress)=>{
    switch(type){
        case ($4b58188d47aafe8d$export$1fc8f52ad1810e52).ERC20:
            return {
                type: type,
                amount: amount,
                contractAddress: contractAddress,
                spenderAddress: spenderAddress
            };
        case ($4b58188d47aafe8d$export$1fc8f52ad1810e52).NATIVE:
        default:
            return {
                type: ($4b58188d47aafe8d$export$1fc8f52ad1810e52).NATIVE,
                amount: amount
            };
    }
};
const $64863c39386de592$export$8f2ff92ab8657f0b = (gasLimit, fulfillmentTransactions)=>{
    if (fulfillmentTransactions.length > 0) return {
        type: ($4b58188d47aafe8d$export$65c64e46348ee3c1).TRANSACTION,
        transaction: fulfillmentTransactions[0]
    };
    return {
        type: ($4b58188d47aafe8d$export$65c64e46348ee3c1).GAS,
        gasToken: {
            type: ($4b58188d47aafe8d$export$537fa3efd10ed435).NATIVE,
            limit: (BigNumber$1).from(gasLimit)
        }
    };
};
const $64863c39386de592$export$7f8e2b98eca5a7f0 = async (config, provider, orders)=>{
    let orderbook;
    let order;
    let spenderAddress = "";
    const gasLimit = (constants).estimatedFulfillmentGasGwei;
    if (orders.length === 0) throw new ($a8bc256d81a5e2c1$export$b722478a3cbfa3bc)("No orders were passed in, must pass at least one order", ($a8bc256d81a5e2c1$export$e3dc0620abde7f5a).FULFILL_ORDER_LISTING_ERROR);
    const { id: id, takerFees: takerFees } = orders[0];
    try {
        orderbook = await $67fc622a2b913d5f$export$c60ce6c6a92bc2ff(config);
        order = await orderbook.getListing(id);
        const { seaportContractAddress: seaportContractAddress } = orderbook.config();
        spenderAddress = seaportContractAddress;
    } catch (err) {
        throw new ($a8bc256d81a5e2c1$export$b722478a3cbfa3bc)("An error occurred while getting the order listing", ($a8bc256d81a5e2c1$export$e3dc0620abde7f5a).GET_ORDER_LISTING_ERROR, {
            orderId: id,
            message: err.message
        });
    }
    if (order.result.buy.length === 0) throw new ($a8bc256d81a5e2c1$export$b722478a3cbfa3bc)("An error occurred with the get order listing", ($a8bc256d81a5e2c1$export$e3dc0620abde7f5a).GET_ORDER_LISTING_ERROR, {
        orderId: id,
        message: "No buy side tokens found on order"
    });
    const buyToken = order.result.buy[0];
    let decimals = 18;
    if (order.result.buy[0].type === "ERC20") {
        const tokenContract = $06a6c5c23f7f2479$export$fbbc17f6e6e58544(order.result.buy[0].contractAddress, ($d85ad1457a3f1a83$export$db5daa1b5156ccfe), provider);
        decimals = await tokenContract.decimals();
    }
    let fees = [];
    if (takerFees && takerFees.length > 0) fees = ($9051cee080948594$export$1e69c9cfc42e28d8)(takerFees, buyToken.amount, decimals);
    let unsignedApprovalTransactions = [];
    let unsignedFulfillmentTransactions = [];
    let orderActions = [];
    try {
        const fulfillerAddress = await provider.getSigner().getAddress();
        const { actions: actions } = await orderbook.fulfillOrder(id, fulfillerAddress, fees);
        orderActions = actions;
        unsignedApprovalTransactions = await (0, $a7367d01c6e76b1c$export$f64a20a30eb98855)(actions);
    } catch  {
    // Silently ignore error as this is usually thrown if user does not have enough balance
    // todo: if balance error - can we determine if its the balance error otherwise throw?
    }
    try {
        unsignedFulfillmentTransactions = await (0, $a7367d01c6e76b1c$export$396bd6ce7d3ab533)(orderActions);
    } catch  {
    // if cannot estimate gas then silently continue and use gas limit in smartCheckout
    // but get the fulfillment transactions after they have approved the spending
    }
    let amount = (BigNumber$1).from("0");
    let type = ($4b58188d47aafe8d$export$1fc8f52ad1810e52).NATIVE;
    let contractAddress = "";
    const buyArray = order.result.buy;
    if (buyArray.length > 0) switch(buyArray[0].type){
        case "NATIVE":
            type = ($4b58188d47aafe8d$export$1fc8f52ad1810e52).NATIVE;
            break;
        case "ERC20":
            type = ($4b58188d47aafe8d$export$1fc8f52ad1810e52).ERC20;
            contractAddress = buyArray[0].contractAddress;
            break;
        default:
            throw new ($a8bc256d81a5e2c1$export$b722478a3cbfa3bc)("Purchasing token type is unsupported", ($a8bc256d81a5e2c1$export$e3dc0620abde7f5a).UNSUPPORTED_TOKEN_TYPE_ERROR, {
                orderId: id
            });
    }
    buyArray.forEach((item)=>{
        if (item.type !== ($4b58188d47aafe8d$export$1fc8f52ad1810e52).ERC721) amount = amount.add((BigNumber$1).from(item.amount));
    });
    const feeArray = order.result.fees;
    feeArray.forEach((item)=>{
        amount = amount.add((BigNumber$1).from(item.amount));
    });
    const itemRequirements = [
        $64863c39386de592$export$4249179755829904(type, contractAddress, amount, spenderAddress)
    ];
    const smartCheckoutResult = await ($0e7419077c373b24$export$9e073f9ada8c81e6)(config, provider, itemRequirements, $64863c39386de592$export$8f2ff92ab8657f0b(gasLimit, unsignedFulfillmentTransactions));
    if (smartCheckoutResult.sufficient) {
        const approvalResult = await ($25ac589234c10b67$export$19693ca396db083e)(provider, unsignedApprovalTransactions);
        if (approvalResult.type === ($d855a5ba32004345$export$f51b97f3aaf2d5a8).FAILED) return {
            smartCheckoutResult: smartCheckoutResult,
            orderId: id,
            status: {
                type: ($aa144554f9ef124b$export$226b052ecb8ca80).FAILED,
                transactionHash: approvalResult.transactionHash,
                reason: approvalResult.reason
            }
        };
        try {
            if (unsignedFulfillmentTransactions.length === 0) unsignedFulfillmentTransactions = await (0, $a7367d01c6e76b1c$export$396bd6ce7d3ab533)(orderActions);
        } catch (err) {
            throw new ($a8bc256d81a5e2c1$export$b722478a3cbfa3bc)("Error fetching fulfillment transaction", ($a8bc256d81a5e2c1$export$e3dc0620abde7f5a).FULFILL_ORDER_LISTING_ERROR, {
                message: err.message
            });
        }
        const fulfillmentResult = await ($25ac589234c10b67$export$3f05b33bd1f29038)(provider, unsignedFulfillmentTransactions);
        if (fulfillmentResult.type === ($d855a5ba32004345$export$f51b97f3aaf2d5a8).FAILED) return {
            smartCheckoutResult: smartCheckoutResult,
            orderId: id,
            status: {
                type: ($aa144554f9ef124b$export$226b052ecb8ca80).FAILED,
                transactionHash: fulfillmentResult.transactionHash,
                reason: fulfillmentResult.reason
            }
        };
        return {
            smartCheckoutResult: smartCheckoutResult,
            orderId: id,
            status: {
                type: ($aa144554f9ef124b$export$226b052ecb8ca80).SUCCESS
            }
        };
    }
    return {
        smartCheckoutResult: smartCheckoutResult,
        orderId: id
    };
};









const $9c3db1bb9c8b69d3$export$70b61ad426ddbe54 = async (config, provider, orderIds)=>{
    let unsignedCancelOrderTransaction;
    if (orderIds.length === 0) throw new ($a8bc256d81a5e2c1$export$b722478a3cbfa3bc)("No orderIds were passed in, must pass at least one orderId to cancel", ($a8bc256d81a5e2c1$export$e3dc0620abde7f5a).CANCEL_ORDER_LISTING_ERROR);
    // Update this when bulk cancel is supproted
    const orderId = orderIds[0];
    try {
        const offererAddress = await provider.getSigner().getAddress();
        const orderbook = await $67fc622a2b913d5f$export$c60ce6c6a92bc2ff(config);
        const cancelOrderResponse = await orderbook.cancelOrder(orderId, offererAddress);
        unsignedCancelOrderTransaction = cancelOrderResponse.unsignedCancelOrderTransaction;
    } catch (err) {
        throw new ($a8bc256d81a5e2c1$export$b722478a3cbfa3bc)("An error occurred while cancelling the order listing", ($a8bc256d81a5e2c1$export$e3dc0620abde7f5a).CANCEL_ORDER_LISTING_ERROR, {
            orderId: orderId,
            message: err.message
        });
    }
    const result = await ($25ac589234c10b67$export$3f05b33bd1f29038)(provider, [
        unsignedCancelOrderTransaction
    ]);
    if (result.type === ($d855a5ba32004345$export$f51b97f3aaf2d5a8).FAILED) return {
        orderId: orderId,
        status: {
            type: ($1e6b81bbd98b3a91$export$c0189a8c30039654).FAILED,
            transactionHash: result.transactionHash,
            reason: result.reason
        }
    };
    return {
        orderId: orderId,
        status: {
            type: ($1e6b81bbd98b3a91$export$c0189a8c30039654).SUCCESS
        }
    };
};















const $9085b221b72ac69e$export$af768ccdf17d5c04 = (id, contractAddress, spenderAddress)=>({
        type: ($4b58188d47aafe8d$export$1fc8f52ad1810e52).ERC721,
        id: id,
        contractAddress: contractAddress,
        spenderAddress: spenderAddress
    });
const $9085b221b72ac69e$export$586d02673c66d423 = (buyToken, decimals = 18)=>{
    const bnAmount = (parseUnits$1)(buyToken.amount, decimals);
    if (buyToken.type === ($4b58188d47aafe8d$export$1fc8f52ad1810e52).NATIVE) return {
        type: ($4b58188d47aafe8d$export$1fc8f52ad1810e52).NATIVE,
        amount: bnAmount.toString()
    };
    return {
        type: ($4b58188d47aafe8d$export$1fc8f52ad1810e52).ERC20,
        amount: bnAmount.toString(),
        contractAddress: buyToken.contractAddress
    };
};
const $9085b221b72ac69e$export$e761f9e0703de895 = async (config, provider, orders)=>{
    let orderbook;
    let listing;
    let spenderAddress = "";
    if (orders.length === 0) throw new ($a8bc256d81a5e2c1$export$b722478a3cbfa3bc)("No orders were parsed, must parse at least one order", ($a8bc256d81a5e2c1$export$e3dc0620abde7f5a).PREPARE_ORDER_LISTING_ERROR);
    const { buyToken: buyToken, sellToken: sellToken, makerFees: makerFees } = orders[0];
    let decimals = 18;
    if (buyToken.type === ($4b58188d47aafe8d$export$1fc8f52ad1810e52).ERC20) {
        // get this from the allowed list
        const buyTokenContract = new (Contract$1)(buyToken.contractAddress, JSON.stringify(($d85ad1457a3f1a83$export$db5daa1b5156ccfe)), provider);
        decimals = await buyTokenContract.decimals();
    }
    const buyTokenOrNative = $9085b221b72ac69e$export$586d02673c66d423(buyToken, decimals);
    try {
        const walletAddress = await provider.getSigner().getAddress();
        orderbook = await $67fc622a2b913d5f$export$c60ce6c6a92bc2ff(config);
        const { seaportContractAddress: seaportContractAddress } = orderbook.config();
        spenderAddress = seaportContractAddress;
        listing = await orderbook.prepareListing({
            makerAddress: walletAddress,
            buy: buyTokenOrNative,
            sell: {
                type: (0, $4b58188d47aafe8d$export$1fc8f52ad1810e52).ERC721,
                contractAddress: sellToken.collectionAddress,
                tokenId: sellToken.id
            }
        });
    } catch (err) {
        throw new ($a8bc256d81a5e2c1$export$b722478a3cbfa3bc)("An error occurred while preparing the listing", ($a8bc256d81a5e2c1$export$e3dc0620abde7f5a).PREPARE_ORDER_LISTING_ERROR, {
            message: err.message,
            id: sellToken.id,
            collectionAddress: sellToken.collectionAddress
        });
    }
    const itemRequirements = [
        $9085b221b72ac69e$export$af768ccdf17d5c04(sellToken.id, sellToken.collectionAddress, spenderAddress)
    ];
    const smartCheckoutResult = await ($0e7419077c373b24$export$9e073f9ada8c81e6)(config, provider, itemRequirements, {
        type: ($4b58188d47aafe8d$export$65c64e46348ee3c1).GAS,
        gasToken: {
            type: ($4b58188d47aafe8d$export$537fa3efd10ed435).NATIVE,
            limit: (BigNumber$1).from((constants).estimatedFulfillmentGasGwei)
        }
    });
    if (smartCheckoutResult.sufficient) {
        const unsignedMessage = ($a7367d01c6e76b1c$export$d62081fac18000c2)(listing.orderHash, listing.orderComponents, listing.actions);
        if (!unsignedMessage) // For sell it is expected the orderbook will always return an unsigned message
        // If for some reason it is missing then we cannot proceed with the create listing
        throw new ($a8bc256d81a5e2c1$export$b722478a3cbfa3bc)("The unsigned message is missing after preparing the listing", ($a8bc256d81a5e2c1$export$e3dc0620abde7f5a).SIGN_MESSAGE_ERROR, {
            id: sellToken.id,
            collectionAddress: sellToken.collectionAddress
        });
        const signedMessage = await ($25ac589234c10b67$export$1d9a7a8a40780de)(provider, unsignedMessage);
        const unsignedTransactions = await ($a7367d01c6e76b1c$export$c5b3365853cb6159)(listing.actions);
        const approvalResult = await ($25ac589234c10b67$export$19693ca396db083e)(provider, unsignedTransactions.approvalTransactions);
        if (approvalResult.type === ($d855a5ba32004345$export$f51b97f3aaf2d5a8).FAILED) return {
            id: sellToken.id,
            collectionAddress: sellToken.collectionAddress,
            smartCheckoutResult: smartCheckoutResult,
            status: {
                type: ($c2874b006e92b115$export$a9780122aaa0801a).FAILED,
                transactionHash: approvalResult.transactionHash,
                reason: approvalResult.reason
            }
        };
        let orderId = "";
        const createListingParams = {
            orderComponents: signedMessage.orderComponents,
            orderHash: signedMessage.orderHash,
            orderSignature: signedMessage.signedMessage,
            makerFees: []
        };
        if (makerFees !== undefined) {
            const orderBookFees = ($9051cee080948594$export$1e69c9cfc42e28d8)(makerFees, buyTokenOrNative.amount, decimals);
            if (orderBookFees.length !== makerFees.length) throw new ($a8bc256d81a5e2c1$export$b722478a3cbfa3bc)("One of the fees is too small, must be greater than 0.000001", ($a8bc256d81a5e2c1$export$e3dc0620abde7f5a).CREATE_ORDER_LISTING_ERROR);
            createListingParams.makerFees = orderBookFees;
        }
        try {
            const order = await orderbook.createListing(createListingParams);
            orderId = order.result.id;
        } catch (err) {
            throw new ($a8bc256d81a5e2c1$export$b722478a3cbfa3bc)("An error occurred while creating the listing", ($a8bc256d81a5e2c1$export$e3dc0620abde7f5a).CREATE_ORDER_LISTING_ERROR, {
                message: err.message,
                collectionId: sellToken.id,
                collectionAddress: sellToken.collectionAddress
            });
        }
        return {
            id: sellToken.id,
            collectionAddress: sellToken.collectionAddress,
            smartCheckoutResult: smartCheckoutResult,
            status: {
                type: ($c2874b006e92b115$export$a9780122aaa0801a).SUCCESS,
                orderId: orderId
            }
        };
    }
    return {
        id: sellToken.id,
        collectionAddress: sellToken.collectionAddress,
        smartCheckoutResult: smartCheckoutResult
    };
};









class $a77d203f701a3b72$export$1453e9b801542ef4 {
    config;
    /**
   * Constructs a new instance of the FiatRampService class.
   * @param {CheckoutConfiguration} config - The config required for the FiatRampService.
   */ constructor(config){
        this.config = config;
    }
    async feeEstimate() {
        const config = await this.config.remote.getConfig("onramp");
        return config[($bc2bfebf768286d3$export$8cb0af6b2bed4b64).TRANSAK]?.fees;
    }
    async createWidgetUrl(params) {
        return await this.getTransakWidgetUrl(params);
    }
    async getTransakWidgetUrl(params) {
        let widgetUrl = `${($d85ad1457a3f1a83$export$f6043d7fce62d71b)[this.config.environment]}?`;
        const onRampConfig = await this.config.remote.getConfig("onramp");
        const apiKey = onRampConfig[($bc2bfebf768286d3$export$8cb0af6b2bed4b64).TRANSAK].publishableApiKey;
        const transakPublishableKey = `apiKey=${apiKey}`;
        const zkevmNetwork = "network=immutablezkevm";
        const defaultPaymentMethod = "defaultPaymentMethod=credit_debit_card";
        const disableBankTransfer = "disablePaymentMethods=sepa_bank_transfer,gbp_bank_transfer,pm_cash_app,pm_jwire,pm_paymaya,pm_bpi,pm_ubp,pm_grabpay,pm_shopeepay,pm_gcash,pm_pix,pm_astropay,pm_pse,inr_bank_transfer";
        const productsAvailed = "productsAvailed=buy";
        const exchangeScreenTitle = "exchangeScreenTitle=Buy";
        const themeColor = "themeColor=0D0D0D";
        widgetUrl += `${transakPublishableKey}&` + `${zkevmNetwork}&` + `${defaultPaymentMethod}&` + `${disableBankTransfer}&` + `${productsAvailed}&` + `${exchangeScreenTitle}&` + `${themeColor}`;
        if (params.isPassport && params.email) {
            const encodedEmail = encodeURIComponent(params.email);
            widgetUrl += `&email=${encodedEmail}&isAutoFillUserData=true&disableWalletAddressForm=true`;
        }
        if (params.tokenAmount && params.tokenSymbol) widgetUrl += `&defaultCryptoAmount=${params.tokenAmount}&cryptoCurrencyCode=${params.tokenSymbol}`;
        else widgetUrl += "&defaultCryptoCurrency=IMX";
        if (params.walletAddress) widgetUrl += `&walletAddress=${params.walletAddress}`;
        return widgetUrl;
    }
}







async function $d35036efee31c5d1$export$dc8635800ef20f4b(provider, requirements) {
    // Get all decimal values by calling contracts for each ERC20
    const decimalPromises = [];
    requirements.forEach((itemRequirementParam)=>{
        if (itemRequirementParam.type === ($4b58188d47aafe8d$export$1fc8f52ad1810e52).ERC20) {
            const { contractAddress: contractAddress } = itemRequirementParam;
            decimalPromises.push(($06a6c5c23f7f2479$export$fbbc17f6e6e58544)(contractAddress, ($d85ad1457a3f1a83$export$db5daa1b5156ccfe), provider).decimals());
        }
    });
    const decimals = await Promise.all(decimalPromises);
    // Map ItemRequirementsParam objects to ItemRequirement by parsing amounts from formatted string to BigNumebrs
    const itemRequirements = requirements.map((itemRequirementParam, index)=>{
        if (itemRequirementParam.type === ($4b58188d47aafe8d$export$1fc8f52ad1810e52).NATIVE) return {
            ...itemRequirementParam,
            amount: (parseUnits$1)(itemRequirementParam.amount, 18)
        };
        if (itemRequirementParam.type === ($4b58188d47aafe8d$export$1fc8f52ad1810e52).ERC20) return {
            ...itemRequirementParam,
            amount: (parseUnits$1)(itemRequirementParam.amount, decimals[index])
        };
        return itemRequirementParam;
    });
    return itemRequirements;
}





const $a8cb37a3fc8eb863$var$SANDBOX_CONFIGURATION = {
    baseConfig: {
        environment: (Environment$1).SANDBOX
    }
};
class $a8cb37a3fc8eb863$export$1f60ba4ec72508a0 {
    config;
    fiatRampService;
    readOnlyProviders;
    /**
   * Constructs a new instance of the CheckoutModule class.
   * @param {CheckoutModuleConfiguration} [config=SANDBOX_CONFIGURATION] - The configuration object for the CheckoutModule.
   */ constructor(config = $a8cb37a3fc8eb863$var$SANDBOX_CONFIGURATION){
        this.config = new ($4013c5c91bb535f6$export$4823433c4a67bbc6)(config);
        this.fiatRampService = new ($a77d203f701a3b72$export$1453e9b801542ef4)(this.config);
        this.readOnlyProviders = new Map();
    }
    /**
   * Creates a provider using the given parameters.
   * @param {CreateProviderParams} params - The parameters for creating the provider.
   * @returns {Promise<CreateProviderResult>} A promise that resolves to the created provider.
   */ async createProvider(params) {
        return await $5c763be0b0b81038$export$500fbc0cd14cdbaa(params.walletProvider, params.passport);
    }
    /**
   * Checks if a wallet is connected to the specified provider.
   * @param {CheckConnectionParams} params - The parameters for checking the wallet connection.
   * @returns {Promise<CheckConnectionResult>} - A promise that resolves to the result of the check.
   */ async checkIsWalletConnected(params) {
        const web3Provider = await $bb88265fe45a0393$export$9e1fd9cc88c637a0(this.config, params.provider, {
            allowUnsupportedProvider: true
        });
        return $c99672cf2294e839$export$2d040992269b4717(web3Provider);
    }
    /**
   * Connects to a blockchain network using the specified provider.
   * @param {ConnectParams} params - The parameters for connecting to the network.
   * @returns {Promise<ConnectResult>} A promise that resolves to an object containing the provider and network information.
   * @throws {Error} If the provider is not valid or if there is an error connecting to the network.
   */ async connect(params) {
        const web3Provider = await $bb88265fe45a0393$export$9e1fd9cc88c637a0(this.config, params.provider, {
            allowUnsupportedProvider: true
        });
        await $c99672cf2294e839$export$43f7168eb392a88c(web3Provider);
        const networkInfo = await $de192de6ef100f9f$export$79f13b4cfaaf0d09(this.config, web3Provider);
        return {
            provider: web3Provider,
            network: networkInfo
        };
    }
    /**
   * Switches the network for the current wallet provider.
   * @param {SwitchNetworkParams} params - The parameters for switching the network.
   * @returns {Promise<SwitchNetworkResult>} - A promise that resolves to the result of switching the network.
   */ async switchNetwork(params) {
        const web3Provider = await $bb88265fe45a0393$export$9e1fd9cc88c637a0(this.config, params.provider, {
            allowUnsupportedProvider: true,
            allowMistmatchedChainId: true
        });
        const switchNetworkRes = await $de192de6ef100f9f$export$b827d9418aeb5dbd(this.config, web3Provider, params.chainId);
        return switchNetworkRes;
    }
    /**
   * Retrieves the balance of a wallet address.
   * @param {GetBalanceParams} params - The parameters for retrieving the balance.
   * @returns {Promise<GetBalanceResult>} - A promise that resolves to the balance result.
   */ async getBalance(params) {
        const web3Provider = await $bb88265fe45a0393$export$9e1fd9cc88c637a0(this.config, params.provider);
        if (!params.contractAddress || params.contractAddress === "") return await $1564e43dde50bb61$export$df96cd8d56be0ab1(this.config, web3Provider, params.walletAddress);
        return await $1564e43dde50bb61$export$60e0fe116a0e6ed0(web3Provider, params.walletAddress, params.contractAddress);
    }
    /**
   * Retrieves the balances of all tokens for a given wallet address on a specific chain.
   * @param {GetAllBalancesParams} params - The parameters for retrieving the balances.
   * @returns {Promise<GetAllBalancesResult>} - A promise that resolves to the result of retrieving the balances.
   */ async getAllBalances(params) {
        const web3Provider = await $bb88265fe45a0393$export$9e1fd9cc88c637a0(this.config, params.provider);
        return $1564e43dde50bb61$export$fee49741664a4d7e(this.config, web3Provider, params.walletAddress, params.chainId);
    }
    /**
   * Retrieves the supported networks based on the provided parameters.
   * @param {GetNetworkAllowListParams} params - The parameters for retrieving the network allow list.
   * @returns {Promise<GetNetworkAllowListResult>} - A promise that resolves to the network allow list result.
   */ async getNetworkAllowList(params) {
        return await $de192de6ef100f9f$export$3043f6442a9ef563(this.config, params);
    }
    /**
   * Retrieves the supported tokens based on the provided parameters.
   * @param {GetTokenAllowListParams} params - The parameters for retrieving the token allow list.
   * @returns {Promise<GetTokenAllowListResult>} - A promise that resolves to the token allow list result.
   */ async getTokenAllowList(params) {
        return await $efe60cea83bfc4e8$export$473cec51305fdae8(this.config, params);
    }
    /**
   * Retrieves the default supported wallets based on the provided parameters.
   * @param {GetWalletAllowListParams} params - The parameters for retrieving the wallet allow list.
   * @returns {Promise<GetWalletAllowListResult>} - A promise that resolves to the wallet allow list result.
   */ async getWalletAllowList(params) {
        return await $5cdde2ffe6360fec$export$a822caa90d7eef09(params);
    }
    /**
   * Sends a transaction using the specified provider and transaction parameters.
   * @param {SendTransactionParams} params - The parameters for sending the transaction.
   * @returns {Promise<SendTransactionResult>} A promise that resolves to the result of the transaction.
   */ async sendTransaction(params) {
        const web3Provider = await $bb88265fe45a0393$export$9e1fd9cc88c637a0(this.config, params.provider);
        return await $dbe95599a4661140$export$8e0e7ffc78696d30(web3Provider, params.transaction);
    }
    /**
   * Retrieves network information using the specified provider.
   * @param {GetNetworkParams} params - The parameters for retrieving network information.
   * @returns {Promise<NetworkInfo>} A promise that resolves to the network information.
   */ async getNetworkInfo(params) {
        const web3Provider = await $bb88265fe45a0393$export$9e1fd9cc88c637a0(this.config, params.provider, {
            allowUnsupportedProvider: true,
            allowMistmatchedChainId: true
        });
        return await $de192de6ef100f9f$export$79f13b4cfaaf0d09(this.config, web3Provider);
    }
    /**
   * Determines the requirements for performing a buy.
   * @param {BuyParams} params - The parameters for the buy.
  */ async buy(params) {
        if (this.config.isProduction) throw new Error("This endpoint is not currently available.");
        // eslint-disable-next-line no-console
        console.warn("This endpoint is currently under construction.");
        if (params.orders.length > 1) // eslint-disable-next-line no-console
        console.warn("This endpoint currently only actions the first order in the array.");
        const web3Provider = await $bb88265fe45a0393$export$9e1fd9cc88c637a0(this.config, params.provider);
        await $64863c39386de592$export$7f8e2b98eca5a7f0(this.config, web3Provider, params.orders);
    }
    /**
   * Determines the requirements for performing a sell.
   * @param {SellParams} params - The parameters for the sell.
   * Only currently actions the first order in the array until we support batch processing.
   * Only currently actions the first fee in the fees array of each order until we support multiple fees.
  */ async sell(params) {
        if (this.config.isProduction) throw new Error("This endpoint is not currently available.");
        // eslint-disable-next-line no-console
        console.warn("This endpoint is currently under construction.");
        if (params.orders.length > 1) // eslint-disable-next-line no-console
        console.warn("This endpoint currently only actions the first order in the array.");
        const web3Provider = await $bb88265fe45a0393$export$9e1fd9cc88c637a0(this.config, params.provider);
        await $9085b221b72ac69e$export$e761f9e0703de895(this.config, web3Provider, params.orders);
    }
    /**
   * Cancels a sell.
   * @param {CancelParams} params - The parameters for the cancel.
   */ async cancel(params) {
        if (this.config.isProduction) throw new Error("This endpoint is not currently available.");
        // eslint-disable-next-line no-console
        console.warn("This endpoint is currently under construction.");
        // eslint-disable-next-line no-console
        console.warn("This endpoint currently only actions the first order in the array.");
        const web3Provider = await $bb88265fe45a0393$export$9e1fd9cc88c637a0(this.config, params.provider);
        await $9c3db1bb9c8b69d3$export$70b61ad426ddbe54(this.config, web3Provider, params.orderIds);
    }
    /**
   * Determines the transaction requirements to complete a purchase.
   * @params {SmartCheckoutParams} params - The parameters for smart checkout.
   */ async smartCheckout(params) {
        if (this.config.isProduction) throw new Error("This endpoint is not currently available.");
        // eslint-disable-next-line no-console
        console.warn("This endpoint is currently under construction.");
        const web3Provider = await $bb88265fe45a0393$export$9e1fd9cc88c637a0(this.config, params.provider);
        let itemRequirements = [];
        try {
            itemRequirements = await (0, $d35036efee31c5d1$export$dc8635800ef20f4b)(web3Provider, params.itemRequirements);
        } catch  {
            throw new ($a8bc256d81a5e2c1$export$b722478a3cbfa3bc)("Failed to map item requirements", ($a8bc256d81a5e2c1$export$e3dc0620abde7f5a).ITEM_REQUIREMENTS_ERROR);
        }
        await $0e7419077c373b24$export$9e073f9ada8c81e6(this.config, web3Provider, itemRequirements, params.transactionOrGasAmount);
    }
    /**
   * Checks if the given object is a Web3 provider.
   * @param {Web3Provider} web3Provider - The object to check.
   * @returns {boolean} - True if the object is a Web3 provider, false otherwise.
   */ static isWeb3Provider(web3Provider) {
        return $bb88265fe45a0393$export$ebe4804963e71f98(web3Provider);
    }
    /**
   * Estimates the gas required for a swap or bridge transaction.
   * @param {GasEstimateParams} params - The parameters for the gas estimation.
   * @returns {Promise<GasEstimateSwapResult | GasEstimateBridgeToL2Result>} - A promise that resolves to the gas estimation result.
   */ async gasEstimate(params) {
        this.readOnlyProviders = await ($0e0060cb42e136d2$export$339cb2be73677b30)(this.config, this.readOnlyProviders);
        return await $2e7bf45a7c9a9570$export$942c8de7174809fc(params, this.readOnlyProviders, this.config);
    }
    /**
   * Creates and returns a URL for the fiat ramp widget.
   * @param {FiatRampParams} params - The parameters for creating the url.
   * @returns {Promise<string>} - A promise that resolves to a string url.
   */ async createFiatRampUrl(params) {
        let tokenAmount;
        let tokenSymbol = "IMX";
        let email;
        const walletAddress = await params.web3Provider.getSigner().getAddress();
        const isPassport = params.web3Provider.provider?.isPassport || false;
        if (isPassport && params.passport) {
            const userInfo = await params.passport.getUserInfo();
            email = userInfo?.email;
        }
        const tokenList = await $efe60cea83bfc4e8$export$473cec51305fdae8(this.config, {
            type: ($08d5ddc39acd6833$export$fd9b17d87f4121d2).ONRAMP
        });
        const token = tokenList.tokens.find((t)=>t.address?.toLowerCase() === params.tokenAddress?.toLowerCase());
        if (token) {
            tokenAmount = params.tokenAmount;
            tokenSymbol = token.symbol;
        }
        return await this.fiatRampService.createWidgetUrl({
            exchangeType: params.exchangeType,
            isPassport: isPassport,
            walletAddress: walletAddress,
            tokenAmount: tokenAmount,
            tokenSymbol: tokenSymbol,
            email: email
        });
    }
    /**
   * Fetches fiat ramp fee estimations.
   * @returns {Promise<OnRampProviderFees>} - A promise that resolves to OnRampProviderFees.
   */ async getExchangeFeeEstimate() {
        return await this.fiatRampService.feeEstimate();
    }
}

var checkout_sdk = /*#__PURE__*/Object.freeze({
    __proto__: null,
    CHECKOUT_API_BASE_URL: $d85ad1457a3f1a83$export$161d4a74df65fc08,
    get ChainId () { return $0472f23319457bfb$export$c06e1e7429de6283; },
    get ChainName () { return $0472f23319457bfb$export$b874c6b1dfe85e02; },
    Checkout: $a8cb37a3fc8eb863$export$1f60ba4ec72508a0,
    get CheckoutErrorType () { return $a8bc256d81a5e2c1$export$e3dc0620abde7f5a; },
    get ExchangeType () { return $e055e79256bbc1dd$export$80f4da0d409a629d; },
    get GasEstimateType () { return $de275b98d2b651c3$export$788b1fd17f3dad84; },
    get GasTokenType () { return $4b58188d47aafe8d$export$537fa3efd10ed435; },
    get ItemType () { return $4b58188d47aafe8d$export$1fc8f52ad1810e52; },
    get NetworkFilterTypes () { return $a47e48dd2c04791b$export$1f05a55fe0680cc7; },
    get TokenFilterTypes () { return $08d5ddc39acd6833$export$fd9b17d87f4121d2; },
    get TransactionOrGasType () { return $4b58188d47aafe8d$export$65c64e46348ee3c1; },
    get WalletFilterTypes () { return $4f91c5f280efe242$export$a75605c67ea83a5a; },
    get WalletProviderName () { return $e768639828688ca3$export$2d7a51a18d87e21d; }
});

function $parcel$export(e, n, v, s) {
  Object.defineProperty(e, n, {get: v, set: s, enumerable: true, configurable: true});
}
const $d663162fd5a0853f$export$38a083d9fb5551ca = "0.22.0";
const $d663162fd5a0853f$export$83bf90b30cdfd29f = ()=>false;
const $d663162fd5a0853f$export$1169f5475725171b = ()=>$d663162fd5a0853f$export$38a083d9fb5551ca;


function $430e3eda76fa4d5f$export$46b1ae20f762ad4c(version) {
    const defaultPackageVersion = ($d663162fd5a0853f$export$1169f5475725171b)();
    if (version === undefined || version.major === undefined) return defaultPackageVersion;
    if (!Number.isInteger(version.major) || version.major < 0) return defaultPackageVersion;
    if (version.minor !== undefined && version.minor < 0) return defaultPackageVersion;
    if (version.patch !== undefined && version.patch < 0) return defaultPackageVersion;
    if (version.major === 0 && version.minor === undefined) return defaultPackageVersion;
    if (version.major === 0 && version.minor === 0 && version.patch === undefined) return defaultPackageVersion;
    if (version.major === 0 && version.minor === undefined && version.patch === undefined) return defaultPackageVersion;
    if (version.major === 0 && version.minor === 0 && version.patch === 0) return defaultPackageVersion;
    let validatedVersion = version.major.toString();
    if (version.minor === undefined) return validatedVersion;
    if (Number.isInteger(version.minor)) validatedVersion += `.${version.minor.toString()}`;
    if (version.patch === undefined) return validatedVersion;
    if (Number.isInteger(version.patch)) validatedVersion += `.${version.patch.toString()}`;
    if (version.prerelease === undefined || version.prerelease !== "alpha") return validatedVersion;
    if (version.prerelease === "alpha") validatedVersion += `-${version.prerelease}`;
    if (version.build === undefined) return validatedVersion;
    if (Number.isInteger(version.build) && version.build >= 0) validatedVersion += `.${version.build.toString()}`;
    return validatedVersion;
}
function $430e3eda76fa4d5f$export$af210a0808087845(config) {
    if (window === undefined) {
        // eslint-disable-next-line no-console
        console.error("missing window object: please run Checkout client side");
        return;
    }
    if (document === undefined) {
        // eslint-disable-next-line no-console
        console.error("missing document object: please run Checkout client side");
        return;
    }
    const checkoutWidgetJS = document.createElement("script");
    const validVersion = $430e3eda76fa4d5f$export$46b1ae20f762ad4c(config?.version);
    let cdnUrl = `https://cdn.jsdelivr.net/npm/@imtbl/sdk@${validVersion}/dist/browser/checkout.js`;
    if (($d663162fd5a0853f$export$83bf90b30cdfd29f)()) cdnUrl = "http://localhost:3000/lib/js/imtbl-checkout.js";
    checkoutWidgetJS.setAttribute("src", cdnUrl);
    document.head.appendChild(checkoutWidgetJS);
    window.ImtblCheckoutWidgetConfig = JSON.stringify(config);
}
function $430e3eda76fa4d5f$export$bf1548ba7e61c17f(config) {
    if (window === undefined) {
        // eslint-disable-next-line no-console
        console.error("missing document object: please run Checkout client side");
        return;
    }
    window.ImtblCheckoutWidgetConfig = JSON.stringify(config);
}


var $207ed853f11d19d5$exports = {};

$parcel$export($207ed853f11d19d5$exports, "IMTBLWidgetEvents", () => $207ed853f11d19d5$export$5a0ace85cae72d45);
var $207ed853f11d19d5$export$5a0ace85cae72d45;
(function(IMTBLWidgetEvents) {
    IMTBLWidgetEvents["IMTBL_CONNECT_WIDGET_EVENT"] = "imtbl-connect-widget";
    IMTBLWidgetEvents["IMTBL_WALLET_WIDGET_EVENT"] = "imtbl-wallet-widget";
    IMTBLWidgetEvents["IMTBL_SWAP_WIDGET_EVENT"] = "imtbl-swap-widget";
    IMTBLWidgetEvents["IMTBL_BRIDGE_WIDGET_EVENT"] = "imtbl-bridge-widget";
    IMTBLWidgetEvents["IMTBL_ONRAMP_WIDGET_EVENT"] = "imtbl-onramp-widget";
})($207ed853f11d19d5$export$5a0ace85cae72d45 || ($207ed853f11d19d5$export$5a0ace85cae72d45 = {}));


var $a85ecdbd885c58ad$exports = {};

$parcel$export($a85ecdbd885c58ad$exports, "ConnectEventType", () => $a85ecdbd885c58ad$export$e72e7f9969a47dd3);
var $a85ecdbd885c58ad$export$e72e7f9969a47dd3;
(function(ConnectEventType) {
    ConnectEventType["CLOSE_WIDGET"] = "close-widget";
    ConnectEventType["SUCCESS"] = "success";
    ConnectEventType["FAILURE"] = "failure";
})($a85ecdbd885c58ad$export$e72e7f9969a47dd3 || ($a85ecdbd885c58ad$export$e72e7f9969a47dd3 = {}));


var $77b6aac5c353d4a9$exports = {};

$parcel$export($77b6aac5c353d4a9$exports, "WalletEventType", () => $77b6aac5c353d4a9$export$d9be06b70b28c742);
var $77b6aac5c353d4a9$export$d9be06b70b28c742;
(function(WalletEventType) {
    WalletEventType["CLOSE_WIDGET"] = "close-widget";
    WalletEventType["NETWORK_SWITCH"] = "network-switch";
    WalletEventType["DISCONNECT_WALLET"] = "disconnect-wallet";
})($77b6aac5c353d4a9$export$d9be06b70b28c742 || ($77b6aac5c353d4a9$export$d9be06b70b28c742 = {}));


var $53d219e7f6bf0cd6$exports = {};

$parcel$export($53d219e7f6bf0cd6$exports, "SwapEventType", () => $53d219e7f6bf0cd6$export$140a49745ab55563);
/**
 * Enum representing possible Swap Widget event types.
 */ var $53d219e7f6bf0cd6$export$140a49745ab55563;
(function(SwapEventType) {
    SwapEventType["CLOSE_WIDGET"] = "close-widget";
    SwapEventType["SUCCESS"] = "success";
    SwapEventType["FAILURE"] = "failure";
    SwapEventType["REJECTED"] = "rejected";
})($53d219e7f6bf0cd6$export$140a49745ab55563 || ($53d219e7f6bf0cd6$export$140a49745ab55563 = {}));


var $15cc9e120aa6f3bf$exports = {};

$parcel$export($15cc9e120aa6f3bf$exports, "BridgeEventType", () => $15cc9e120aa6f3bf$export$d1bfa21f7c76447a);
/**
 * Enum of possible Bridge Widget event types.
 */ var $15cc9e120aa6f3bf$export$d1bfa21f7c76447a;
(function(BridgeEventType) {
    BridgeEventType["CLOSE_WIDGET"] = "close-widget";
    BridgeEventType["SUCCESS"] = "success";
    BridgeEventType["FAILURE"] = "failure";
})($15cc9e120aa6f3bf$export$d1bfa21f7c76447a || ($15cc9e120aa6f3bf$export$d1bfa21f7c76447a = {}));


var $ad06b030b1a3ba34$exports = {};

$parcel$export($ad06b030b1a3ba34$exports, "OrchestrationEventType", () => $ad06b030b1a3ba34$export$b80d2daf830437b9);
/**
 * Enum representing different types of orchestration events.
 */ var $ad06b030b1a3ba34$export$b80d2daf830437b9;
(function(OrchestrationEventType) {
    OrchestrationEventType["REQUEST_CONNECT"] = "request-connect";
    OrchestrationEventType["REQUEST_WALLET"] = "request-wallet";
    OrchestrationEventType["REQUEST_SWAP"] = "request-swap";
    OrchestrationEventType["REQUEST_BRIDGE"] = "request-bridge";
    OrchestrationEventType["REQUEST_ONRAMP"] = "request-onramp";
})($ad06b030b1a3ba34$export$b80d2daf830437b9 || ($ad06b030b1a3ba34$export$b80d2daf830437b9 = {}));


var $d882ddc5600b1284$exports = {};

$parcel$export($d882ddc5600b1284$exports, "OnRampEventType", () => $d882ddc5600b1284$export$66ec39c0924078d8);
/**
 * Enum of possible OnRamp Widget event types.
 */ var $d882ddc5600b1284$export$66ec39c0924078d8;
(function(OnRampEventType) {
    OnRampEventType["CLOSE_WIDGET"] = "close-widget";
    OnRampEventType["SUCCESS"] = "success";
    OnRampEventType["FAILURE"] = "failure";
})($d882ddc5600b1284$export$66ec39c0924078d8 || ($d882ddc5600b1284$export$66ec39c0924078d8 = {}));
/* eslint-disable @typescript-eslint/naming-convention */ 

var $045213b18e9f1f94$exports = {};

$parcel$export($045213b18e9f1f94$exports, "WidgetTheme", () => $045213b18e9f1f94$export$c88931fdc51854eb);
$parcel$export($045213b18e9f1f94$exports, "CheckoutWidgetTagNames", () => $045213b18e9f1f94$export$75be0f6af9650f2c);
/**
 * Enum representing the themes for the Checkout widgets.
 */ var $045213b18e9f1f94$export$c88931fdc51854eb;
(function(WidgetTheme) {
    WidgetTheme["LIGHT"] = "light";
    WidgetTheme["DARK"] = "dark";
})($045213b18e9f1f94$export$c88931fdc51854eb || ($045213b18e9f1f94$export$c88931fdc51854eb = {}));
var $045213b18e9f1f94$export$75be0f6af9650f2c;
(function(CheckoutWidgetTagNames) {
    CheckoutWidgetTagNames["CONNECT"] = "imtbl-connect";
    CheckoutWidgetTagNames["WALLET"] = "imtbl-wallet";
    CheckoutWidgetTagNames["SWAP"] = "imtbl-swap";
    CheckoutWidgetTagNames["BRIDGE"] = "imtbl-bridge";
    CheckoutWidgetTagNames["ONRAMP"] = "imtbl-onramp";
})($045213b18e9f1f94$export$75be0f6af9650f2c || ($045213b18e9f1f94$export$75be0f6af9650f2c = {}));


var $1f969328e5988c99$exports = {};

$parcel$export($1f969328e5988c99$exports, "BridgeReact", () => $1f969328e5988c99$export$30f61ebf204c69f6);


function $77ec335383336bdd$export$931068bc678f0d73(tagName, provider) {
    if (!provider) {
        // eslint-disable-next-line no-console
        console.error("no provider parsed");
        return;
    }
    if (window === undefined) {
        // eslint-disable-next-line no-console
        console.error("missing window object: please run Checkout client side");
        return;
    }
    let attempts = 0;
    const maxAttempts = 10;
    let timer;
    const attemptToSetProvider = ()=>{
        try {
            const elements = document.getElementsByTagName(tagName);
            const widget = elements[0];
            widget.setProvider(provider);
            window.clearInterval(timer);
        } catch (err) {
            attempts++;
            if (attempts >= maxAttempts) {
                window.clearInterval(timer);
                // eslint-disable-next-line no-console
                console.error("failed to set the provider");
            }
        }
    };
    timer = window.setInterval(attemptToSetProvider, 10);
    attemptToSetProvider();
}



function $b222a8f062090058$export$fae4199086a966a3(tagName, passport) {
    if (!passport) {
        // eslint-disable-next-line no-console
        console.error("no passport provided");
        return;
    }
    if (window === undefined) {
        // eslint-disable-next-line no-console
        console.error("missing window object: please run Checkout client side");
        return;
    }
    let attempts = 0;
    const maxAttempts = 10;
    let timer;
    const attemptToAddPassport = ()=>{
        try {
            const elements = document.getElementsByTagName(tagName);
            const widget = elements[0];
            widget.addPassportOption(passport);
            window.clearInterval(timer);
        } catch (err) {
            attempts++;
            if (attempts >= maxAttempts) {
                window.clearInterval(timer);
                // eslint-disable-next-line no-console
                console.error("failed to set the provider");
            }
        }
    };
    timer = window.setInterval(attemptToAddPassport, 10);
    attemptToAddPassport();
}


function $1f969328e5988c99$export$30f61ebf204c69f6(props) {
    const { walletProvider: walletProvider, fromContractAddress: fromContractAddress, amount: amount, provider: provider, passport: passport } = props;
    (useEffect)(()=>{
        if (provider) ($77ec335383336bdd$export$931068bc678f0d73)(($045213b18e9f1f94$export$75be0f6af9650f2c).BRIDGE, provider);
        if (passport) ($b222a8f062090058$export$fae4199086a966a3)(($045213b18e9f1f94$export$75be0f6af9650f2c).BRIDGE, passport);
    }, [
        provider,
        passport
    ]);
    const config = window.ImtblCheckoutWidgetConfig;
    return /*#__PURE__*/ (jsx)("imtbl-bridge", {
        widgetConfig: config,
        walletProvider: walletProvider,
        fromContractAddress: fromContractAddress ?? "",
        amount: amount ?? ""
    });
}


var $f2083cd30e2f5c56$exports = {};

$parcel$export($f2083cd30e2f5c56$exports, "ConnectReact", () => $f2083cd30e2f5c56$export$49d62957f420a1e2);




function $f2083cd30e2f5c56$export$49d62957f420a1e2({ passport: passport }) {
    const config = window.ImtblCheckoutWidgetConfig;
    (useEffect)(()=>{
        if (passport) ($b222a8f062090058$export$fae4199086a966a3)(($045213b18e9f1f94$export$75be0f6af9650f2c).CONNECT, passport);
    }, [
        passport
    ]);
    return /*#__PURE__*/ (jsx)("imtbl-connect", {
        widgetConfig: config
    });
}


var $a4fbb8e3a6aeff58$exports = {};

$parcel$export($a4fbb8e3a6aeff58$exports, "SwapReact", () => $a4fbb8e3a6aeff58$export$971e031379577f4);
/* eslint-disable max-len */ 




function $a4fbb8e3a6aeff58$export$971e031379577f4(props) {
    const { walletProvider: walletProvider, fromContractAddress: fromContractAddress, amount: amount, toContractAddress: toContractAddress, provider: provider, passport: passport } = props;
    (useEffect)(()=>{
        if (provider) ($77ec335383336bdd$export$931068bc678f0d73)(($045213b18e9f1f94$export$75be0f6af9650f2c).SWAP, provider);
        if (passport) ($b222a8f062090058$export$fae4199086a966a3)(($045213b18e9f1f94$export$75be0f6af9650f2c).SWAP, passport);
    }, [
        provider,
        passport
    ]);
    const config = window.ImtblCheckoutWidgetConfig;
    return /*#__PURE__*/ (jsx)("imtbl-swap", {
        widgetConfig: config,
        walletProvider: walletProvider,
        fromContractAddress: fromContractAddress ?? "",
        toContractAddress: toContractAddress ?? "",
        amount: amount ?? ""
    });
}


var $89d55ace0f8f1c07$exports = {};

$parcel$export($89d55ace0f8f1c07$exports, "WalletReact", () => $89d55ace0f8f1c07$export$ceaac94f34dba154);





function $89d55ace0f8f1c07$export$ceaac94f34dba154(props) {
    const { walletProvider: walletProvider, provider: provider, passport: passport } = props;
    (useEffect)(()=>{
        if (provider) ($77ec335383336bdd$export$931068bc678f0d73)(($045213b18e9f1f94$export$75be0f6af9650f2c).WALLET, provider);
        if (passport) ($b222a8f062090058$export$fae4199086a966a3)(($045213b18e9f1f94$export$75be0f6af9650f2c).WALLET, passport);
    }, [
        provider,
        passport
    ]);
    const config = window.ImtblCheckoutWidgetConfig;
    return /*#__PURE__*/ (jsx)("imtbl-wallet", {
        widgetConfig: config,
        walletProvider: walletProvider
    });
}


var $f94f63f2c041a04c$exports = {};

$parcel$export($f94f63f2c041a04c$exports, "OnRampReact", () => $f94f63f2c041a04c$export$9e363c61ea99bbb4);





function $f94f63f2c041a04c$export$9e363c61ea99bbb4(props) {
    const { walletProvider: walletProvider, amount: amount, provider: provider, passport: passport, contractAddress: contractAddress } = props;
    (useEffect)(()=>{
        if (provider) ($77ec335383336bdd$export$931068bc678f0d73)(($045213b18e9f1f94$export$75be0f6af9650f2c).ONRAMP, provider);
        if (passport) ($b222a8f062090058$export$fae4199086a966a3)(($045213b18e9f1f94$export$75be0f6af9650f2c).ONRAMP, passport);
    }, [
        provider,
        passport
    ]);
    const config = window.ImtblCheckoutWidgetConfig;
    return /*#__PURE__*/ (jsx)("imtbl-onramp", {
        widgetConfig: config,
        walletProvider: walletProvider,
        amount: amount ?? "",
        contractAddress: contractAddress ?? ""
    });
}

var checkout_widgets = /*#__PURE__*/Object.freeze({
    __proto__: null,
    get BridgeEventType () { return $15cc9e120aa6f3bf$export$d1bfa21f7c76447a; },
    BridgeReact: $1f969328e5988c99$export$30f61ebf204c69f6,
    get CheckoutWidgetTagNames () { return $045213b18e9f1f94$export$75be0f6af9650f2c; },
    CheckoutWidgets: $430e3eda76fa4d5f$export$af210a0808087845,
    get ConnectEventType () { return $a85ecdbd885c58ad$export$e72e7f9969a47dd3; },
    ConnectReact: $f2083cd30e2f5c56$export$49d62957f420a1e2,
    get IMTBLWidgetEvents () { return $207ed853f11d19d5$export$5a0ace85cae72d45; },
    get OnRampEventType () { return $d882ddc5600b1284$export$66ec39c0924078d8; },
    OnRampReact: $f94f63f2c041a04c$export$9e363c61ea99bbb4,
    get OrchestrationEventType () { return $ad06b030b1a3ba34$export$b80d2daf830437b9; },
    get SwapEventType () { return $53d219e7f6bf0cd6$export$140a49745ab55563; },
    SwapReact: $a4fbb8e3a6aeff58$export$971e031379577f4,
    UpdateConfig: $430e3eda76fa4d5f$export$bf1548ba7e61c17f,
    get WalletEventType () { return $77b6aac5c353d4a9$export$d9be06b70b28c742; },
    WalletReact: $89d55ace0f8f1c07$export$ceaac94f34dba154,
    get WidgetTheme () { return $045213b18e9f1f94$export$c88931fdc51854eb; }
});

export { blockchain_data as blockchainData, checkout_sdk as checkoutSdk, checkout_widgets as checkoutWidgets, config, immutablex_client as immutablexClient, orderbook, passport, provider };
