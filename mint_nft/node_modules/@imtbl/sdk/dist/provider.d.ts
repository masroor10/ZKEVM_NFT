import { ProviderConfiguration as ProviderConfiguration$1 } from 'config';

declare type Bytes = ArrayLike<number>;
declare type BytesLike = Bytes | string;
interface Hexable {
    toHexString(): string;
}

declare type BigNumberish = BigNumber | Bytes | bigint | string | number;
declare class BigNumber implements Hexable {
    readonly _hex: string;
    readonly _isBigNumber: boolean;
    constructor(constructorGuard: any, hex: string);
    fromTwos(value: number): BigNumber;
    toTwos(value: number): BigNumber;
    abs(): BigNumber;
    add(other: BigNumberish): BigNumber;
    sub(other: BigNumberish): BigNumber;
    div(other: BigNumberish): BigNumber;
    mul(other: BigNumberish): BigNumber;
    mod(other: BigNumberish): BigNumber;
    pow(other: BigNumberish): BigNumber;
    and(other: BigNumberish): BigNumber;
    or(other: BigNumberish): BigNumber;
    xor(other: BigNumberish): BigNumber;
    mask(value: number): BigNumber;
    shl(value: number): BigNumber;
    shr(value: number): BigNumber;
    eq(other: BigNumberish): boolean;
    lt(other: BigNumberish): boolean;
    lte(other: BigNumberish): boolean;
    gt(other: BigNumberish): boolean;
    gte(other: BigNumberish): boolean;
    isNegative(): boolean;
    isZero(): boolean;
    toNumber(): number;
    toBigInt(): bigint;
    toString(): string;
    toHexString(): string;
    toJSON(key?: string): any;
    static from(value: any): BigNumber;
    static isBigNumber(value: any): value is BigNumber;
}

declare type Deferrable<T> = {
    [K in keyof T]: T[K] | Promise<T[K]>;
};
declare class Description<T = any> {
    constructor(info: {
        [K in keyof T]: T[K];
    });
}

declare type Network = {
    name: string;
    chainId: number;
    ensAddress?: string;
    _defaultProvider?: (providers: any, options?: any) => any;
};

declare type AccessList = Array<{
    address: string;
    storageKeys: Array<string>;
}>;
declare type AccessListish = AccessList | Array<[string, Array<string>]> | Record<string, Array<string>>;
interface Transaction {
    hash?: string;
    to?: string;
    from?: string;
    nonce: number;
    gasLimit: BigNumber;
    gasPrice?: BigNumber;
    data: string;
    value: BigNumber;
    chainId: number;
    r?: string;
    s?: string;
    v?: number;
    type?: number | null;
    accessList?: AccessList;
    maxPriorityFeePerGas?: BigNumber;
    maxFeePerGas?: BigNumber;
}

interface OnceBlockable {
    once(eventName: "block", handler: () => void): void;
}

declare type TransactionRequest = {
    to?: string;
    from?: string;
    nonce?: BigNumberish;
    gasLimit?: BigNumberish;
    gasPrice?: BigNumberish;
    data?: BytesLike;
    value?: BigNumberish;
    chainId?: number;
    type?: number;
    accessList?: AccessListish;
    maxPriorityFeePerGas?: BigNumberish;
    maxFeePerGas?: BigNumberish;
    customData?: Record<string, any>;
    ccipReadEnabled?: boolean;
};
interface TransactionResponse extends Transaction {
    hash: string;
    blockNumber?: number;
    blockHash?: string;
    timestamp?: number;
    confirmations: number;
    from: string;
    raw?: string;
    wait: (confirmations?: number) => Promise<TransactionReceipt>;
}
declare type BlockTag = string | number;
interface _Block {
    hash: string;
    parentHash: string;
    number: number;
    timestamp: number;
    nonce: string;
    difficulty: number;
    _difficulty: BigNumber;
    gasLimit: BigNumber;
    gasUsed: BigNumber;
    miner: string;
    extraData: string;
    baseFeePerGas?: null | BigNumber;
}
interface Block extends _Block {
    transactions: Array<string>;
}
interface BlockWithTransactions extends _Block {
    transactions: Array<TransactionResponse>;
}
interface Log {
    blockNumber: number;
    blockHash: string;
    transactionIndex: number;
    removed: boolean;
    address: string;
    data: string;
    topics: Array<string>;
    transactionHash: string;
    logIndex: number;
}
interface TransactionReceipt {
    to: string;
    from: string;
    contractAddress: string;
    transactionIndex: number;
    root?: string;
    gasUsed: BigNumber;
    logsBloom: string;
    blockHash: string;
    transactionHash: string;
    logs: Array<Log>;
    blockNumber: number;
    confirmations: number;
    cumulativeGasUsed: BigNumber;
    effectiveGasPrice: BigNumber;
    byzantium: boolean;
    type: number;
    status?: number;
}
interface FeeData {
    lastBaseFeePerGas: null | BigNumber;
    maxFeePerGas: null | BigNumber;
    maxPriorityFeePerGas: null | BigNumber;
    gasPrice: null | BigNumber;
}
interface EventFilter {
    address?: string;
    topics?: Array<string | Array<string> | null>;
}
interface Filter extends EventFilter {
    fromBlock?: BlockTag;
    toBlock?: BlockTag;
}
declare abstract class ForkEvent extends Description {
    readonly expiry: number;
    readonly _isForkEvent?: boolean;
    static isForkEvent(value: any): value is ForkEvent;
}
declare type EventType = string | Array<string | Array<string>> | EventFilter | ForkEvent;
declare type Listener = (...args: Array<any>) => void;
declare abstract class Provider implements OnceBlockable {
    abstract getNetwork(): Promise<Network>;
    abstract getBlockNumber(): Promise<number>;
    abstract getGasPrice(): Promise<BigNumber>;
    getFeeData(): Promise<FeeData>;
    abstract getBalance(addressOrName: string | Promise<string>, blockTag?: BlockTag | Promise<BlockTag>): Promise<BigNumber>;
    abstract getTransactionCount(addressOrName: string | Promise<string>, blockTag?: BlockTag | Promise<BlockTag>): Promise<number>;
    abstract getCode(addressOrName: string | Promise<string>, blockTag?: BlockTag | Promise<BlockTag>): Promise<string>;
    abstract getStorageAt(addressOrName: string | Promise<string>, position: BigNumberish | Promise<BigNumberish>, blockTag?: BlockTag | Promise<BlockTag>): Promise<string>;
    abstract sendTransaction(signedTransaction: string | Promise<string>): Promise<TransactionResponse>;
    abstract call(transaction: Deferrable<TransactionRequest>, blockTag?: BlockTag | Promise<BlockTag>): Promise<string>;
    abstract estimateGas(transaction: Deferrable<TransactionRequest>): Promise<BigNumber>;
    abstract getBlock(blockHashOrBlockTag: BlockTag | string | Promise<BlockTag | string>): Promise<Block>;
    abstract getBlockWithTransactions(blockHashOrBlockTag: BlockTag | string | Promise<BlockTag | string>): Promise<BlockWithTransactions>;
    abstract getTransaction(transactionHash: string): Promise<TransactionResponse>;
    abstract getTransactionReceipt(transactionHash: string): Promise<TransactionReceipt>;
    abstract getLogs(filter: Filter): Promise<Array<Log>>;
    abstract resolveName(name: string | Promise<string>): Promise<null | string>;
    abstract lookupAddress(address: string | Promise<string>): Promise<null | string>;
    abstract on(eventName: EventType, listener: Listener): Provider;
    abstract once(eventName: EventType, listener: Listener): Provider;
    abstract emit(eventName: EventType, ...args: Array<any>): boolean;
    abstract listenerCount(eventName?: EventType): number;
    abstract listeners(eventName?: EventType): Array<Listener>;
    abstract off(eventName: EventType, listener?: Listener): Provider;
    abstract removeAllListeners(eventName?: EventType): Provider;
    addListener(eventName: EventType, listener: Listener): Provider;
    removeListener(eventName: EventType, listener: Listener): Provider;
    abstract waitForTransaction(transactionHash: string, confirmations?: number, timeout?: number): Promise<TransactionReceipt>;
    readonly _isProvider: boolean;
    constructor();
    static isProvider(value: any): value is Provider;
}

declare abstract class Signer {
    readonly provider?: Provider;
    abstract getAddress(): Promise<string>;
    abstract signMessage(message: Bytes | string): Promise<string>;
    abstract signTransaction(transaction: Deferrable<TransactionRequest>): Promise<string>;
    abstract connect(provider: Provider): Signer;
    readonly _isSigner: boolean;
    constructor();
    getBalance(blockTag?: BlockTag): Promise<BigNumber>;
    getTransactionCount(blockTag?: BlockTag): Promise<number>;
    estimateGas(transaction: Deferrable<TransactionRequest>): Promise<BigNumber>;
    call(transaction: Deferrable<TransactionRequest>, blockTag?: BlockTag): Promise<string>;
    sendTransaction(transaction: Deferrable<TransactionRequest>): Promise<TransactionResponse>;
    getChainId(): Promise<number>;
    getGasPrice(): Promise<BigNumber>;
    getFeeData(): Promise<FeeData>;
    resolveName(name: string): Promise<string>;
    checkTransaction(transaction: Deferrable<TransactionRequest>): Deferrable<TransactionRequest>;
    populateTransaction(transaction: Deferrable<TransactionRequest>): Promise<TransactionRequest>;
    _checkProvider(operation?: string): void;
    static isSigner(value: any): value is Signer;
}

/**
 * An abstraction of a Stark account, which can be used to sign messages and transactions on StarkEx to execute state changing operations
 */
interface StarkSigner {
    /**
     * Signs the prefixed-message
     * @params message - this must be a UTF8-message
     * @example "0x1234"
     * @returns the signed prefixed-message
     */
    signMessage(message: string): Promise<string>;
    /**
     * Get the Signer address
     * @returns the Signer's checksum address
     */
    getAddress(): string | Promise<string>;
}

/**
 * An ERC20 token
 */
interface ERC20Token {
    type: 'ERC20';
    tokenAddress: string;
}
/**
 * An ERC721 token
 */
interface ERC721Token {
    type: 'ERC721';
    tokenId: string;
    tokenAddress: string;
}
/**
 * An ETH token
 */
interface ETHToken {
    type: 'ETH';
}
/**
 * An amount of ETH token of unit Wei
 */
interface ETHAmount extends ETHToken {
    /**
     * An amount in unit Wei
     */
    amount: string;
}
/**
 * The token details and amount of ERC20 token units
 */
interface ERC20Amount extends ERC20Token {
    /**
     * An amount in units for the given ERC20 token
     */
    amount: string;
}
/**
 * Union type that represents all token types
 */
declare type AnyToken = ETHToken | ERC721Token | ERC20Token;
/**
 * Union type that represents all token type amounts
 */
declare type TokenAmount = ETHAmount | ERC20Amount | ERC721Token;
/**
 * Union type that represents exchange token type amounts
 */
declare type ExchangeTokenAmount = ETHAmount | ERC20Amount;

/**
 * Immutable X API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 3.0
 * Contact: support@immutable.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
interface ConfigurationParameters {
    apiKey?: string | Promise<string> | ((name: string) => string) | ((name: string) => Promise<string>);
    username?: string;
    password?: string;
    accessToken?: string | Promise<string> | ((name?: string, scopes?: string[]) => string) | ((name?: string, scopes?: string[]) => Promise<string>);
    basePath?: string;
    baseOptions?: any;
    formDataCtor?: new () => any;
}
declare class Configuration {
    /**
     * parameter for apiKey security
     * @param name security name
     * @memberof Configuration
     */
    apiKey?: string | Promise<string> | ((name: string) => string) | ((name: string) => Promise<string>);
    /**
     * parameter for basic security
     *
     * @type {string}
     * @memberof Configuration
     */
    username?: string;
    /**
     * parameter for basic security
     *
     * @type {string}
     * @memberof Configuration
     */
    password?: string;
    /**
     * parameter for oauth2 security
     * @param name security name
     * @param scopes oauth2 scope
     * @memberof Configuration
     */
    accessToken?: string | Promise<string> | ((name?: string, scopes?: string[]) => string) | ((name?: string, scopes?: string[]) => Promise<string>);
    /**
     * override base path
     *
     * @type {string}
     * @memberof Configuration
     */
    basePath?: string;
    /**
     * base options for axios calls
     *
     * @type {any}
     * @memberof Configuration
     */
    baseOptions?: any;
    /**
     * The FormData constructor that will be used to create multipart form data
     * requests. You can inject this here so that execution environments that
     * do not support the FormData class can still run the generated client.
     *
     * @type {new () => FormData}
     */
    formDataCtor?: new () => any;
    constructor(param?: ConfigurationParameters);
    /**
     * Check if the given MIME is a JSON MIME.
     * JSON MIME examples:
     *   application/json
     *   application/json; charset=UTF8
     *   APPLICATION/JSON
     *   application/vnd.company+json
     * @param mime - MIME (Multipurpose Internet Mail Extensions)
     * @return True if the given MIME is JSON, false otherwise.
     */
    isJsonMime(mime: string): boolean;
}

/**
 * Immutable X API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 3.0
 * Contact: support@immutable.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
/**
 *
 * @export
 * @interface CancelOrderResponse
 */
interface CancelOrderResponse {
    /**
     * ID of the cancelled order
     * @type {number}
     * @memberof CancelOrderResponse
     */
    'order_id': number;
    /**
     * New status of the order
     * @type {string}
     * @memberof CancelOrderResponse
     */
    'status': string;
}

/**
 * Immutable X API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 3.0
 * Contact: support@immutable.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
/**
 *
 * @export
 * @interface FeeEntry
 */
interface FeeEntry {
    /**
     *
     * @type {string}
     * @memberof FeeEntry
     */
    'address'?: string;
    /**
     *
     * @type {number}
     * @memberof FeeEntry
     */
    'fee_percentage'?: number;
}

/**
 * Immutable X API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 3.0
 * Contact: support@immutable.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
/**
 *
 * @export
 * @interface CreateOrderResponse
 */
interface CreateOrderResponse {
    /**
     * ID of the created order
     * @type {number}
     * @memberof CreateOrderResponse
     */
    'order_id': number;
    /**
     * Request ID as a reference for an asynchronous order creation request
     * @type {string}
     * @memberof CreateOrderResponse
     */
    'request_id'?: string;
    /**
     * Status of the created order
     * @type {string}
     * @memberof CreateOrderResponse
     */
    'status': string;
    /**
     * Timestamp of the created order
     * @type {number}
     * @memberof CreateOrderResponse
     */
    'time': number;
}

/**
 * Immutable X API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 3.0
 * Contact: support@immutable.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
/**
 *
 * @export
 * @interface CreateTradeResponse
 */
interface CreateTradeResponse {
    /**
     * Request ID as a reference for an asynchronous trade creation request
     * @type {string}
     * @memberof CreateTradeResponse
     */
    'request_id'?: string;
    /**
     * Current status of trade
     * @type {string}
     * @memberof CreateTradeResponse
     */
    'status': string;
    /**
     * ID of trade within Immutable X
     * @type {number}
     * @memberof CreateTradeResponse
     */
    'trade_id': number;
}

/**
 * Immutable X API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 3.0
 * Contact: support@immutable.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
/**
 *
 * @export
 * @interface CreateTransferResponse
 */
interface CreateTransferResponse {
    /**
     * List of transfer IDs
     * @type {Array<number>}
     * @memberof CreateTransferResponse
     */
    'transfer_ids': Array<number>;
}

/**
 * Immutable X API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 3.0
 * Contact: support@immutable.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
/**
 *
 * @export
 * @interface CreateTransferResponseV1
 */
interface CreateTransferResponseV1 {
    /**
     * [deprecated] Sent signature
     * @type {string}
     * @memberof CreateTransferResponseV1
     */
    'sent_signature': string;
    /**
     * [deprecated] The status of transfer
     * @type {string}
     * @memberof CreateTransferResponseV1
     */
    'status': string;
    /**
     * [deprecated] Time of the transfer
     * @type {number}
     * @memberof CreateTransferResponseV1
     */
    'time': number;
    /**
     * ID of the transfer
     * @type {number}
     * @memberof CreateTransferResponseV1
     */
    'transfer_id': number;
}

/**
 * Immutable X API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 3.0
 * Contact: support@immutable.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
/**
 *
 * @export
 * @interface CreateWithdrawalResponse
 */
interface CreateWithdrawalResponse {
    /**
     * Status of the withdrawal
     * @type {string}
     * @memberof CreateWithdrawalResponse
     */
    'status': string;
    /**
     * Time of the withdrawal
     * @type {number}
     * @memberof CreateWithdrawalResponse
     */
    'time': number;
    /**
     * ID of the withdrawal
     * @type {number}
     * @memberof CreateWithdrawalResponse
     */
    'withdrawal_id': number;
}

/**
 * Immutable X API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 3.0
 * Contact: support@immutable.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
/**
 *
 * @export
 * @interface GetSignableCancelOrderRequest
 */
interface GetSignableCancelOrderRequest {
    /**
     * ID of the order to be cancelled
     * @type {number}
     * @memberof GetSignableCancelOrderRequest
     */
    'order_id': number;
}

/**
 * Immutable X API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 3.0
 * Contact: support@immutable.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

/**
 *
 * @export
 * @interface GetSignableTradeRequest
 */
interface GetSignableTradeRequest {
    /**
     * ExpirationTimestamp in Unix time in hours. Note: will be rounded down to the nearest hour
     * @type {number}
     * @memberof GetSignableTradeRequest
     */
    'expiration_timestamp'?: number;
    /**
     * Inclusion of either maker or taker fees
     * @type {Array<FeeEntry>}
     * @memberof GetSignableTradeRequest
     */
    'fees'?: Array<FeeEntry>;
    /**
     * The ID of the maker order involved
     * @type {number}
     * @memberof GetSignableTradeRequest
     */
    'order_id': number;
    /**
     * Ethereum address of the submitting user
     * @type {string}
     * @memberof GetSignableTradeRequest
     */
    'user': string;
}

/**
 * Immutable X API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 3.0
 * Contact: support@immutable.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
/**
 *
 * @export
 * @interface RegisterUserResponse
 */
interface RegisterUserResponse {
    /**
     * Immutable signature authorising registration
     * @type {string}
     * @memberof RegisterUserResponse
     */
    'tx_hash': string;
}

/**
 * Parameter required to create an Order
 */
interface UnsignedOrderRequest {
    /**
     * The amount of tokens that will be bought for this order
     */
    buy: TokenAmount;
    /**
     * The amount of tokens that will be sold for this order
     */
    sell: TokenAmount;
    /**
     * ExpirationTimestamp in Unix time. Note: will be rounded down to the nearest hour
     */
    expiration_timestamp?: number;
    /**
     * Inclusion of either maker or taker fees
     */
    fees?: Array<FeeEntry>;
}
/**
 * Parameter required to create a Transfer
 */
declare type UnsignedTransferRequest = TokenAmount & {
    /**
     * Ethereum address of the receiving user
     */
    receiver: string;
};
/**
 * Parameter required to create a Transfer
 */
declare type UnsignedExchangeTransferRequest = ExchangeTokenAmount & {
    /**
     * Ethereum address of the receiving user
     */
    receiver: string;
    /**
     * Exchange transaction ID
     */
    transactionID: string;
};

/**
 * Parameter required to create a batchNftTransfer
 */
interface NftTransferDetails {
    /**
     * Ethereum address of the receiving user
     */
    receiver: string;
    /**
     * The token ID
     */
    tokenId: string;
    /**
     * The token contract address
     */
    tokenAddress: string;
}

/**
 * The configuration for the Ethereum network
 */
interface EthConfiguration {
    coreContractAddress: string;
    registrationContractAddress: string;
    chainID: number;
}
/**
 * The configuration for the ImmutableX client
 */
interface ImmutableXConfiguration {
    /**
     * The configuration for the API client
     */
    apiConfiguration: Configuration;
    /**
     * The configuration for the Ethereum network
     */
    ethConfiguration: EthConfiguration;
}

interface IMXProvider {
    /**
     * Get the Signer address
     *
     * @return {Promise<string>} Returns a promise that resolves with the signer's address
     */
    getAddress(): Promise<string>;
    /**
     * Register a User to Immutable X if they are not already registered
     *
     * @return {Promise<RegisterUserResponse>} Returns a promise that resolves with the user registration response
     */
    registerOffchain(): Promise<RegisterUserResponse>;
    /**
     * Checks if a User is registered on-chain
     *
     * @return {Promise<boolean>} Returns a promise that resolves with true if the User is registered, false otherwise
     */
    isRegisteredOnchain(): Promise<boolean>;
    /**
     * Create an Order
     *
     * @param {UnsignedOrderRequest} request The unsigned order request to create an order
     * @return {Promise<CreateOrderResponse>} Returns a promise that resolves with the created Order
     */
    createOrder(request: UnsignedOrderRequest): Promise<CreateOrderResponse>;
    /**
     * Cancel an Order
     *
     * @param {GetSignableCancelOrderRequest} request The signable cancel order request
     * @return {Promise<CancelOrderResponse>} Returns a promise that resolves with the cancelled Order
     */
    cancelOrder(request: GetSignableCancelOrderRequest): Promise<CancelOrderResponse>;
    /**
     * Create a Trade
     *
     * @param {GetSignableTradeRequest} request The signable trade request
     * @return {Promise<CreateTradeResponse>} Returns a promise that resolves with the created Trade
     */
    createTrade(request: GetSignableTradeRequest): Promise<CreateTradeResponse>;
    /**
     * Create a new Transfer request
     *
     * @param {UnsignedTransferRequest} request The unsigned transfer request
     * @return {Promise<CreateTransferResponseV1>} Returns a promise that resolves with the created Transfer
     */
    transfer(request: UnsignedTransferRequest): Promise<CreateTransferResponseV1>;
    /**
     * Create a batch of NFT transfer requests
     *
     * @param {Array<NftTransferDetails>} request An array of NFT transfer details
     * @return {Promise<CreateTransferResponse>} Resolves a promise that resolves with the list of Transfer IDs
     */
    batchNftTransfer(request: Array<NftTransferDetails>): Promise<CreateTransferResponse>;
    /**
     * Create a new Exchange transaction
     *
     * @param {UnsignedExchangeTransferRequest} request The unsigned exchange transfer request
     * @return {Promise<CreateTransferResponseV1>} Returns a promise that resolves with the created Exchange Transaction
     */
    exchangeTransfer(request: UnsignedExchangeTransferRequest): Promise<CreateTransferResponseV1>;
    /**
     * Deposit either ETH, ERC20 or ERC721 tokens
     *
     * @param {TokenAmount} request The token type amount in its corresponding unit
     * @return {Promise<TransactionResponse>} Returns a promise that resolves with the transaction
     */
    deposit(deposit: TokenAmount): Promise<TransactionResponse>;
    /**
     * Create a Withdrawal
     *
     * @param {TokenAmount} request The token type amount in its corresponding unit
     * @return {Promise<CreateWithdrawalResponse>} Returns a promise that resolves with the created Withdrawal
     */
    prepareWithdrawal(request: TokenAmount): Promise<CreateWithdrawalResponse>;
    /**
     * Completes a Withdrawal
     *
     * @param {string} starkPublicKey The stark public key
     * @param {AnyToken} token The token to withdraw
     * @return {Promise<TransactionResponse>} Returns a promise that resolves with the transaction
     */
    completeWithdrawal(starkPublicKey: string, token: AnyToken): Promise<TransactionResponse>;
}

declare class GenericIMXProvider implements IMXProvider {
    private readonly config;
    private readonly signers;
    constructor(config: ProviderConfiguration$1, ethSigner: Signer, starkSigner: StarkSigner);
    getAddress(): Promise<string>;
    registerOffchain(): Promise<RegisterUserResponse>;
    batchNftTransfer(request: Array<NftTransferDetails>): Promise<CreateTransferResponse>;
    cancelOrder(request: GetSignableCancelOrderRequest): Promise<CancelOrderResponse>;
    completeWithdrawal(starkPublicKey: string, token: AnyToken): Promise<TransactionResponse>;
    createOrder(request: UnsignedOrderRequest): Promise<CreateOrderResponse>;
    createTrade(request: GetSignableTradeRequest): Promise<CreateTradeResponse>;
    deposit(tokenAmount: TokenAmount): Promise<TransactionResponse>;
    exchangeTransfer(request: UnsignedExchangeTransferRequest): Promise<CreateTransferResponseV1>;
    isRegisteredOnchain(): Promise<boolean>;
    prepareWithdrawal(request: TokenAmount): Promise<CreateWithdrawalResponse>;
    transfer(request: UnsignedTransferRequest): Promise<CreateTransferResponseV1>;
}

declare class MetaMaskIMXProvider extends GenericIMXProvider {
    private static imxSigner;
    static connect(config: ProviderConfiguration$1): Promise<MetaMaskIMXProvider>;
    static disconnect(): Promise<void>;
    static signMessage(message: string): Promise<string>;
}

declare enum Environment {
    PRODUCTION = "production",
    SANDBOX = "sandbox"
}
declare class ImmutableConfiguration {
    readonly environment: Environment;
    readonly apiKey?: string;
    constructor(options: {
        environment: Environment;
        apiKey?: string;
    });
}
interface ModuleConfiguration<T> {
    baseConfig: ImmutableConfiguration;
    overrides?: T;
}

interface ProviderOverrides {
    immutableXConfig: ImmutableXConfiguration;
}
interface ProviderModuleConfiguration extends ModuleConfiguration<ProviderOverrides> {
}
declare class ProviderConfiguration {
    readonly immutableXConfig: ImmutableXConfiguration;
    readonly baseConfig: ImmutableConfiguration;
    constructor({ baseConfig, overrides }: ProviderModuleConfiguration);
}

export { GenericIMXProvider, IMXProvider, MetaMaskIMXProvider, ProviderConfiguration };
