"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ERC721Client = void 0;
const typechain_types_1 = require("../typechain-types");
class ERC721Client {
    constructor(contractAddress) {
        const factory = new typechain_types_1.ImmutableERC721__factory();
        this.contract = factory.attach(contractAddress);
    }
    /**
     * Read functions
     */
    /**
     * @returns the DEFAULT_ADMIN_ROLE as a string.
     */
    async DEFAULT_ADMIN_ROLE(provider, overrides = {}) {
        return await this.contract.connect(provider).DEFAULT_ADMIN_ROLE(overrides);
    }
    /**
     * Returns the domain separator used in the encoding of the signature for permits, as defined by EIP-712
     * @return the bytes32 domain separator
     */
    async DOMAIN_SEPARATOR(provider, overrides) {
        return await this.contract.connect(provider).DOMAIN_SEPARATOR(overrides);
    }
    /**
     * @returns the MINTER_ROLE as a string.
     */
    async MINTER_ROLE(provider, overrides = {}) {
        return await this.contract.connect(provider).MINTER_ROLE(overrides);
    }
    /**
     * @returns the balance of an address as a BigNumber.
     */
    async balanceOf(provider, owner, overrides = {}) {
        return await this.contract.connect(provider).balanceOf(owner, overrides);
    }
    /**
     * @returns the baseURI as a string.
     */
    async baseURI(provider, overrides = {}) {
        return await this.contract.connect(provider).baseURI(overrides);
    }
    /**
     * @returns the contractURI as a string.
     */
    async contractURI(provider, overrides = {}) {
        return await this.contract.connect(provider).contractURI(overrides);
    }
    /**
     * @dev returns the fields and values that describe the domain separator used by this contract for EIP-712
     * signature.
     */
    async eip712Domain(provider, overrides) {
        return await this.contract.eip712Domain(overrides);
    }
    /**
     * @returns admin addresses as an array of strings.
     */
    async getAdmins(provider, overrides = {}) {
        return await this.contract.connect(provider).getAdmins(overrides);
    }
    /**
     * @returns the approved address for a token ID, or zero if no address set.
     */
    async getApproved(provider, tokenId, overrides = {}) {
        return await this.contract.connect(provider).getApproved(tokenId, overrides);
    }
    /**
     * @returns the role admin address.
     */
    async getRoleAdmin(provider, role, overrides = {}) {
        return await this.contract.connect(provider).getRoleAdmin(role, overrides);
    }
    /**
     * @returns the role member address at a particular index.
     */
    async getRoleMember(provider, role, index, overrides = {}) {
        return await this.contract.connect(provider).getRoleMember(role, index, overrides);
    }
    /**
     * @returns the role member count as a BigNumber.
     */
    async getRoleMemberCount(provider, role, overrides = {}) {
        return await this.contract.connect(provider).getRoleMemberCount(role, overrides);
    }
    /**
     * @returns a boolean for whether an account has a particular role.
     */
    async hasRole(provider, role, account, overrides = {}) {
        return await this.contract.connect(provider).hasRole(role, account, overrides);
    }
    /**
     * @returns a booolean that tells whether an operator is approved by a given owner.
     */
    async isApprovedForAll(provider, owner, operator, overrides = {}) {
        return await this.contract.connect(provider).isApprovedForAll(owner, operator, overrides);
    }
    /**
     * @returns the name of the contract as a string.
     */
    async name(provider, overrides = {}) {
        return await this.contract.connect(provider).name(overrides);
    }
    /**
     * @returns the owner address of a particular tokenId.
     */
    async ownerOf(provider, tokenId, overrides = {}) {
        return await this.contract.connect(provider).ownerOf(tokenId, overrides);
    }
    /**
     * Returns the current nonce of a given token ID.
     * @param tokenId The ID of the token for which to retrieve the nonce.
     * @return Current nonce of the given token.
     */
    async nonces(provider, tokenId, overrides) {
        return await this.contract.connect(provider).nonces(tokenId, overrides);
    }
    /**
     * @returns the operator allowlist as a string.
     */
    async operatorAllowlist(provider, overrides = {}) {
        return await this.contract.connect(provider).operatorAllowlist(overrides);
    }
    /**
     * @returns the royalty information for a particular tokenId.
     */
    async royaltyInfo(provider, _tokenId, _salePrice, overrides = {}) {
        return await this.contract.connect(provider).royaltyInfo(_tokenId, _salePrice, overrides);
    }
    /**
     * @returns the symbol of the contract as a string.
     */
    async symbol(provider, overrides = {}) {
        return await this.contract.connect(provider).symbol(overrides);
    }
    /**
     * @returns the Uniform Resource Identifier (URI) for tokenId token.
     */
    async tokenURI(provider, tokenId, overrides = {}) {
        return await this.contract.connect(provider).tokenURI(tokenId, overrides);
    }
    /**
     * @returns returns the total amount of tokens stored by the contract.
     */
    async totalSupply(provider, overrides = {}) {
        return await this.contract.connect(provider).totalSupply(overrides);
    }
    /**
     * Write functions
     */
    /**
     * @returns a populated transaction for the approve contract function
     */
    async populateApprove(to, tokenId, overrides = {}) {
        return await this.contract.populateTransaction.approve(to, tokenId, overrides);
    }
    /**
     * Function to approve by way of owner signature
     * @param spender the address to approve
     * @param tokenId the index of the NFT to approve the spender on
     * @param deadline a timestamp expiry for the permit
     * @param sig a traditional or EIP-2098 signature
     */
    async populatePermit(spender, tokenId, deadline, sig, overrides = {}) {
        return await this.contract.populateTransaction.permit(spender, tokenId, deadline, sig, overrides);
    }
    /**
     * @returns a populated transaction for the burn contract function
     */
    async populateBurn(tokenId, overrides = {}) {
        return await this.contract.populateTransaction.burn(tokenId, overrides);
    }
    /**
     * @returns a populated transaction for the batch burn contract function
     */
    async populateBurnBatch(tokenIds, overrides = {}) {
        return await this.contract.populateTransaction.burnBatch(tokenIds, overrides);
    }
    /**
     * @returns a populated transaction for the safe burn contract function
     */
    async populateSafeBurn(owner, tokenId, overrides = {}) {
        return await this.contract.populateTransaction.safeBurn(owner, tokenId, overrides);
    }
    /**
     * @returns a populated transaction for the safe burn batch contract function
     */
    async populateSafeBurnBatch(burns, overrides = {}) {
        return await this.contract.populateTransaction.safeBurnBatch(burns, overrides);
    }
    /**
     * @returns a populated transaction for the grantMinterRole contract function
     */
    async populateGrantMinterRole(user, overrides = {}) {
        return await this.contract.populateTransaction.grantMinterRole(user, overrides);
    }
    /**
     * @returns a populated transaction for the grantRole contract function
     */
    async populateGrantRole(role, account, overrides = {}) {
        return await this.contract.populateTransaction.grantRole(role, account, overrides);
    }
    /**
     * @returns a populated transaction for the mint by ID contract function
     */
    async populateMint(to, tokenId, overrides = {}) {
        return await this.contract.populateTransaction.mint(to, tokenId, overrides);
    }
    /**
     * @returns a populated transaction for the safe mint by ID contract function
     */
    async populateSafeMint(to, tokenId, overrides = {}) {
        return await this.contract.populateTransaction.safeMint(to, tokenId, overrides);
    }
    /**
     * @returns a populated transaction for the mint by quantity contract function
     */
    async populateMintByQuantity(to, quantity, overrides = {}) {
        return await this.contract.populateTransaction.mintByQuantity(to, quantity, overrides);
    }
    /**
     * @returns a populated transaction for the safe mint by quantity contract function
     */
    async populateSafeMintByQuantity(to, quantity, overrides = {}) {
        return await this.contract.populateTransaction.safeMintByQuantity(to, quantity, overrides);
    }
    /**
     * @returns a populated transaction for the batch mint by quantity contract function
     */
    async populateMintBatchByQuantity(mints, overrides = {}) {
        return await this.contract.populateTransaction.mintBatchByQuantity(mints, overrides);
    }
    /**
     * @returns a populated transaction for the batch safe mint by quantity contract function
     */
    async populateSafeMintBatchByQuantity(mints, overrides = {}) {
        return await this.contract.populateTransaction.safeMintBatchByQuantity(mints, overrides);
    }
    /**
     * @returns a populated transaction for the batch mint by ID to multiple recipients contract function
     */
    async populateMintBatch(mints, overrides = {}) {
        return await this.contract.populateTransaction.mintBatch(mints, overrides);
    }
    /**
     * @returns a populated transaction for the batch safe mint by ID to multiple recipients contract function
     */
    async populateSafeMintBatch(mints, overrides = {}) {
        return await this.contract.populateTransaction.safeMintBatch(mints, overrides);
    }
    /**
     * @returns a populated transaction for the renounceRole contract function
     */
    async populateRenounceRole(role, account, overrides = {}) {
        return await this.contract.populateTransaction.renounceRole(role, account, overrides);
    }
    /**
     * @returns a populated transaction for the revokeMinterRole contract function
     */
    async populateRevokeMinterRole(user, overrides = {}) {
        return await this.contract.populateTransaction.revokeMinterRole(user, overrides);
    }
    /**
     * @returns a populated transaction for the revokeRole contract function
     */
    async populateRevokeRole(role, account, overrides = {}) {
        return await this.contract.populateTransaction.revokeRole(role, account, overrides);
    }
    /**
     * @returns a populated transaction for the batch save transfer from function
     */
    async populateSafeTransferFromBatch(transfers, overrides = {}) {
        return await this.contract.populateTransaction.safeTransferFromBatch(transfers, overrides);
    }
    /**
     * @returns a populated transaction for the safeTransferFrom(address,address,uint256) contract function
     */
    async "populateSafeTransferFrom(address,address,uint256)"(from, to, tokenId, overrides = {}) {
        return await this.contract.populateTransaction["safeTransferFrom(address,address,uint256)"](from, to, tokenId, overrides);
    }
    /**
     * @returns a populated transaction for the safeTransferFrom(address,address,uint256,bytes) contract function
     */
    async "populateSafeTransferFrom(address,address,uint256,bytes)"(from, to, tokenId, data, overrides = {}) {
        return await this.contract.populateTransaction["safeTransferFrom(address,address,uint256,bytes)"](from, to, tokenId, data, overrides);
    }
    /**
     * @returns a populated transaction for the setApprovalForAll contract function
     */
    async populateSetApprovalForAll(operator, approved, overrides = {}) {
        return await this.contract.populateTransaction.setApprovalForAll(operator, approved, overrides);
    }
    /**
     * @returns a populated transaction for the setBaseURI contract function
     */
    async populateSetBaseURI(baseURI_, overrides = {}) {
        return await this.contract.populateTransaction.setBaseURI(baseURI_, overrides);
    }
    /**
     * @returns a populated transaction for the setContractURI contract function
     */
    async populateSetContractURI(_contractURI, overrides = {}) {
        return await this.contract.populateTransaction.setContractURI(_contractURI, overrides);
    }
    /**
     * @returns a populated transaction for the setDefaultRoyaltyReceiver contract function
     */
    async populateSetDefaultRoyaltyReceiver(receiver, feeNumerator, overrides = {}) {
        return await this.contract.populateTransaction.setDefaultRoyaltyReceiver(receiver, feeNumerator, overrides);
    }
    /**
     * @returns a populated transaction for the setNFTRoyaltyReceiver contract function
     */
    async populateSetNFTRoyaltyReceiver(tokenId, receiver, feeNumerator, overrides = {}) {
        return await this.contract.populateTransaction.setNFTRoyaltyReceiver(tokenId, receiver, feeNumerator, overrides);
    }
    /**
     * @returns a populated transaction for the setNFTRoyaltyReceiverBatch contract function
     */
    async populateSetNFTRoyaltyReceiverBatch(tokenIds, receiver, feeNumerator, overrides = {}) {
        return await this.contract.populateTransaction.setNFTRoyaltyReceiverBatch(tokenIds, receiver, feeNumerator, overrides);
    }
    /**
     * @returns a populated transaction for the setOperatorAllowlistRegistry contract function
     */
    async populateSetOperatorAllowlistRegistry(_operatorAllowlist, overrides = {}) {
        return await this.contract.populateTransaction.setOperatorAllowlistRegistry(_operatorAllowlist, overrides);
    }
}
exports.ERC721Client = ERC721Client;
