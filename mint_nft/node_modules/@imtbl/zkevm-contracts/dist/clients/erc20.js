"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ERC20Client = void 0;
const ERC20__factory_1 = require("../typechain-types/factories/@openzeppelin/contracts/token/ERC20/ERC20__factory");
class ERC20Client {
    constructor(contractAddress) {
        const factory = new ERC20__factory_1.ERC20__factory();
        this.contract = factory.attach(contractAddress);
    }
    /**
     * @returns a promise that resolves with a BigNumber that represents the amount of tokens in existence
     */
    async totalSupply(provider, overrides = {}) {
        return this.contract.connect(provider).totalSupply(overrides);
    }
    /**
     * @returns a promise that resolves with a BigNumber that represents the amount of tokens owned by account
     */
    async balanceOf(provider, account, overrides = {}) {
        return this.contract.connect(provider).balanceOf(account, overrides);
    }
    /**
     * @returns a promise that resolves with a BigNumber that represents the remaining number of tokens that spender will be allowed to spend on behalf of owner through transferFrom
     */
    async allowance(provider, owner, spender, overrides = {}) {
        return this.contract.connect(provider).allowance(owner, spender, overrides);
    }
    /**
     * @returns a promise that resolves with a populated transaction
     */
    async populateTransfer(to, amount, overrides) {
        return this.contract.populateTransaction.transfer(to, amount, overrides);
    }
    /**
     * @returns a promise that resolves with a populated transaction
     */
    async populateApprove(spender, amount, overrides = {}) {
        return this.contract.populateTransaction.approve(spender, amount, overrides);
    }
    /**
     * @returns a promise that resolves with a populated transaction
     */
    async populateTransferFrom(from, to, amount, overrides = {}) {
        return this.contract.populateTransaction.transferFrom(from, to, amount, overrides);
    }
}
exports.ERC20Client = ERC20Client;
