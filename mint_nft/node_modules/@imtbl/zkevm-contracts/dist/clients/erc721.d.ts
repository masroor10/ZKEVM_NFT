import type { BigNumber, BigNumberish, BytesLike, CallOverrides, Overrides, PopulatedTransaction } from "ethers";
import type { Provider } from "@ethersproject/providers";
import { ERC721Hybrid } from "../typechain-types/contracts/token/erc721/preset/ImmutableERC721";
import { PromiseOrValue } from "../typechain-types/common";
export type Mint = ERC721Hybrid.MintStruct;
export type IDMint = ERC721Hybrid.IDMintStruct;
export type TransferRequest = ERC721Hybrid.TransferRequestStruct;
export type IDBurn = ERC721Hybrid.IDBurnStruct;
export declare class ERC721Client {
    private readonly contract;
    constructor(contractAddress: string);
    /**
     * Read functions
     */
    /**
     * @returns the DEFAULT_ADMIN_ROLE as a string.
     */
    DEFAULT_ADMIN_ROLE(provider: Provider, overrides?: CallOverrides): Promise<string>;
    /**
     * Returns the domain separator used in the encoding of the signature for permits, as defined by EIP-712
     * @return the bytes32 domain separator
     */
    DOMAIN_SEPARATOR(provider: Provider, overrides?: CallOverrides): Promise<string>;
    /**
     * @returns the MINTER_ROLE as a string.
     */
    MINTER_ROLE(provider: Provider, overrides?: CallOverrides): Promise<string>;
    /**
     * @returns the balance of an address as a BigNumber.
     */
    balanceOf(provider: Provider, owner: PromiseOrValue<string>, overrides?: CallOverrides): Promise<BigNumber>;
    /**
     * @returns the baseURI as a string.
     */
    baseURI(provider: Provider, overrides?: CallOverrides): Promise<string>;
    /**
     * @returns the contractURI as a string.
     */
    contractURI(provider: Provider, overrides?: CallOverrides): Promise<string>;
    /**
     * @dev returns the fields and values that describe the domain separator used by this contract for EIP-712
     * signature.
     */
    eip712Domain(provider: Provider, overrides?: CallOverrides): Promise<[
        string,
        string,
        string,
        BigNumber,
        string,
        string,
        BigNumber[]
    ] & {
        fields: string;
        name: string;
        version: string;
        chainId: BigNumber;
        verifyingContract: string;
        salt: string;
        extensions: BigNumber[];
    }>;
    /**
     * @returns admin addresses as an array of strings.
     */
    getAdmins(provider: Provider, overrides?: CallOverrides): Promise<string[]>;
    /**
     * @returns the approved address for a token ID, or zero if no address set.
     */
    getApproved(provider: Provider, tokenId: PromiseOrValue<BigNumberish>, overrides?: CallOverrides): Promise<string>;
    /**
     * @returns the role admin address.
     */
    getRoleAdmin(provider: Provider, role: PromiseOrValue<BytesLike>, overrides?: CallOverrides): Promise<string>;
    /**
     * @returns the role member address at a particular index.
     */
    getRoleMember(provider: Provider, role: PromiseOrValue<BytesLike>, index: PromiseOrValue<BigNumberish>, overrides?: CallOverrides): Promise<string>;
    /**
     * @returns the role member count as a BigNumber.
     */
    getRoleMemberCount(provider: Provider, role: PromiseOrValue<BytesLike>, overrides?: CallOverrides): Promise<BigNumber>;
    /**
     * @returns a boolean for whether an account has a particular role.
     */
    hasRole(provider: Provider, role: PromiseOrValue<BytesLike>, account: PromiseOrValue<string>, overrides?: CallOverrides): Promise<boolean>;
    /**
     * @returns a booolean that tells whether an operator is approved by a given owner.
     */
    isApprovedForAll(provider: Provider, owner: PromiseOrValue<string>, operator: PromiseOrValue<string>, overrides?: CallOverrides): Promise<boolean>;
    /**
     * @returns the name of the contract as a string.
     */
    name(provider: Provider, overrides?: CallOverrides): Promise<string>;
    /**
     * @returns the owner address of a particular tokenId.
     */
    ownerOf(provider: Provider, tokenId: PromiseOrValue<BigNumberish>, overrides?: CallOverrides): Promise<string>;
    /**
     * Returns the current nonce of a given token ID.
     * @param tokenId The ID of the token for which to retrieve the nonce.
     * @return Current nonce of the given token.
     */
    nonces(provider: Provider, tokenId: PromiseOrValue<BigNumberish>, overrides?: CallOverrides): Promise<BigNumber>;
    /**
     * @returns the operator allowlist as a string.
     */
    operatorAllowlist(provider: Provider, overrides?: CallOverrides): Promise<string>;
    /**
     * @returns the royalty information for a particular tokenId.
     */
    royaltyInfo(provider: Provider, _tokenId: PromiseOrValue<BigNumberish>, _salePrice: PromiseOrValue<BigNumberish>, overrides?: CallOverrides): Promise<[string, BigNumber]>;
    /**
     * @returns the symbol of the contract as a string.
     */
    symbol(provider: Provider, overrides?: CallOverrides): Promise<string>;
    /**
     * @returns the Uniform Resource Identifier (URI) for tokenId token.
     */
    tokenURI(provider: Provider, tokenId: PromiseOrValue<BigNumberish>, overrides?: CallOverrides): Promise<string>;
    /**
     * @returns returns the total amount of tokens stored by the contract.
     */
    totalSupply(provider: Provider, overrides?: CallOverrides): Promise<BigNumber>;
    /**
     * Write functions
     */
    /**
     * @returns a populated transaction for the approve contract function
     */
    populateApprove(to: PromiseOrValue<string>, tokenId: PromiseOrValue<BigNumberish>, overrides?: Overrides & {
        from?: PromiseOrValue<string>;
    }): Promise<PopulatedTransaction>;
    /**
     * Function to approve by way of owner signature
     * @param spender the address to approve
     * @param tokenId the index of the NFT to approve the spender on
     * @param deadline a timestamp expiry for the permit
     * @param sig a traditional or EIP-2098 signature
     */
    populatePermit(spender: PromiseOrValue<string>, tokenId: PromiseOrValue<BigNumberish>, deadline: PromiseOrValue<BigNumberish>, sig: PromiseOrValue<BytesLike>, overrides?: CallOverrides): Promise<PopulatedTransaction>;
    /**
     * @returns a populated transaction for the burn contract function
     */
    populateBurn(tokenId: PromiseOrValue<BigNumberish>, overrides?: Overrides & {
        from?: PromiseOrValue<string>;
    }): Promise<PopulatedTransaction>;
    /**
     * @returns a populated transaction for the batch burn contract function
     */
    populateBurnBatch(tokenIds: PromiseOrValue<BigNumberish>[], overrides?: Overrides & {
        from?: PromiseOrValue<string>;
    }): Promise<PopulatedTransaction>;
    /**
     * @returns a populated transaction for the safe burn contract function
     */
    populateSafeBurn(owner: PromiseOrValue<string>, tokenId: PromiseOrValue<BigNumberish>, overrides?: Overrides & {
        from?: PromiseOrValue<string>;
    }): Promise<PopulatedTransaction>;
    /**
     * @returns a populated transaction for the safe burn batch contract function
     */
    populateSafeBurnBatch(burns: IDBurn[], overrides?: Overrides & {
        from?: PromiseOrValue<string>;
    }): Promise<PopulatedTransaction>;
    /**
     * @returns a populated transaction for the grantMinterRole contract function
     */
    populateGrantMinterRole(user: PromiseOrValue<string>, overrides?: Overrides & {
        from?: PromiseOrValue<string>;
    }): Promise<PopulatedTransaction>;
    /**
     * @returns a populated transaction for the grantRole contract function
     */
    populateGrantRole(role: PromiseOrValue<BytesLike>, account: PromiseOrValue<string>, overrides?: Overrides & {
        from?: PromiseOrValue<string>;
    }): Promise<PopulatedTransaction>;
    /**
     * @returns a populated transaction for the mint by ID contract function
     */
    populateMint(to: PromiseOrValue<string>, tokenId: PromiseOrValue<BigNumberish>, overrides?: Overrides & {
        from?: PromiseOrValue<string>;
    }): Promise<PopulatedTransaction>;
    /**
     * @returns a populated transaction for the safe mint by ID contract function
     */
    populateSafeMint(to: PromiseOrValue<string>, tokenId: PromiseOrValue<BigNumberish>, overrides?: Overrides & {
        from?: PromiseOrValue<string>;
    }): Promise<PopulatedTransaction>;
    /**
     * @returns a populated transaction for the mint by quantity contract function
     */
    populateMintByQuantity(to: PromiseOrValue<string>, quantity: PromiseOrValue<BigNumberish>, overrides?: Overrides & {
        from?: PromiseOrValue<string>;
    }): Promise<PopulatedTransaction>;
    /**
     * @returns a populated transaction for the safe mint by quantity contract function
     */
    populateSafeMintByQuantity(to: PromiseOrValue<string>, quantity: PromiseOrValue<BigNumberish>, overrides?: Overrides & {
        from?: PromiseOrValue<string>;
    }): Promise<PopulatedTransaction>;
    /**
     * @returns a populated transaction for the batch mint by quantity contract function
     */
    populateMintBatchByQuantity(mints: Mint[], overrides?: Overrides & {
        from?: PromiseOrValue<string>;
    }): Promise<PopulatedTransaction>;
    /**
     * @returns a populated transaction for the batch safe mint by quantity contract function
     */
    populateSafeMintBatchByQuantity(mints: Mint[], overrides?: Overrides & {
        from?: PromiseOrValue<string>;
    }): Promise<PopulatedTransaction>;
    /**
     * @returns a populated transaction for the batch mint by ID to multiple recipients contract function
     */
    populateMintBatch(mints: IDMint[], overrides?: Overrides & {
        from?: PromiseOrValue<string>;
    }): Promise<PopulatedTransaction>;
    /**
     * @returns a populated transaction for the batch safe mint by ID to multiple recipients contract function
     */
    populateSafeMintBatch(mints: IDMint[], overrides?: Overrides & {
        from?: PromiseOrValue<string>;
    }): Promise<PopulatedTransaction>;
    /**
     * @returns a populated transaction for the renounceRole contract function
     */
    populateRenounceRole(role: PromiseOrValue<BytesLike>, account: PromiseOrValue<string>, overrides?: Overrides & {
        from?: PromiseOrValue<string>;
    }): Promise<PopulatedTransaction>;
    /**
     * @returns a populated transaction for the revokeMinterRole contract function
     */
    populateRevokeMinterRole(user: PromiseOrValue<string>, overrides?: Overrides & {
        from?: PromiseOrValue<string>;
    }): Promise<PopulatedTransaction>;
    /**
     * @returns a populated transaction for the revokeRole contract function
     */
    populateRevokeRole(role: PromiseOrValue<BytesLike>, account: PromiseOrValue<string>, overrides?: Overrides & {
        from?: PromiseOrValue<string>;
    }): Promise<PopulatedTransaction>;
    /**
     * @returns a populated transaction for the batch save transfer from function
     */
    populateSafeTransferFromBatch(transfers: TransferRequest, overrides?: Overrides & {
        from?: PromiseOrValue<string>;
    }): Promise<PopulatedTransaction>;
    /**
     * @returns a populated transaction for the safeTransferFrom(address,address,uint256) contract function
     */
    "populateSafeTransferFrom(address,address,uint256)"(from: PromiseOrValue<string>, to: PromiseOrValue<string>, tokenId: PromiseOrValue<BigNumberish>, overrides?: Overrides & {
        from?: PromiseOrValue<string>;
    }): Promise<PopulatedTransaction>;
    /**
     * @returns a populated transaction for the safeTransferFrom(address,address,uint256,bytes) contract function
     */
    "populateSafeTransferFrom(address,address,uint256,bytes)"(from: PromiseOrValue<string>, to: PromiseOrValue<string>, tokenId: PromiseOrValue<BigNumberish>, data: PromiseOrValue<BytesLike>, overrides?: Overrides & {
        from?: PromiseOrValue<string>;
    }): Promise<PopulatedTransaction>;
    /**
     * @returns a populated transaction for the setApprovalForAll contract function
     */
    populateSetApprovalForAll(operator: PromiseOrValue<string>, approved: PromiseOrValue<boolean>, overrides?: Overrides & {
        from?: PromiseOrValue<string>;
    }): Promise<PopulatedTransaction>;
    /**
     * @returns a populated transaction for the setBaseURI contract function
     */
    populateSetBaseURI(baseURI_: PromiseOrValue<string>, overrides?: Overrides & {
        from?: PromiseOrValue<string>;
    }): Promise<PopulatedTransaction>;
    /**
     * @returns a populated transaction for the setContractURI contract function
     */
    populateSetContractURI(_contractURI: PromiseOrValue<string>, overrides?: Overrides & {
        from?: PromiseOrValue<string>;
    }): Promise<PopulatedTransaction>;
    /**
     * @returns a populated transaction for the setDefaultRoyaltyReceiver contract function
     */
    populateSetDefaultRoyaltyReceiver(receiver: PromiseOrValue<string>, feeNumerator: PromiseOrValue<BigNumberish>, overrides?: Overrides & {
        from?: PromiseOrValue<string>;
    }): Promise<PopulatedTransaction>;
    /**
     * @returns a populated transaction for the setNFTRoyaltyReceiver contract function
     */
    populateSetNFTRoyaltyReceiver(tokenId: PromiseOrValue<BigNumberish>, receiver: PromiseOrValue<string>, feeNumerator: PromiseOrValue<BigNumberish>, overrides?: Overrides & {
        from?: PromiseOrValue<string>;
    }): Promise<PopulatedTransaction>;
    /**
     * @returns a populated transaction for the setNFTRoyaltyReceiverBatch contract function
     */
    populateSetNFTRoyaltyReceiverBatch(tokenIds: PromiseOrValue<BigNumberish>[], receiver: PromiseOrValue<string>, feeNumerator: PromiseOrValue<BigNumberish>, overrides?: Overrides & {
        from?: PromiseOrValue<string>;
    }): Promise<PopulatedTransaction>;
    /**
     * @returns a populated transaction for the setOperatorAllowlistRegistry contract function
     */
    populateSetOperatorAllowlistRegistry(_operatorAllowlist: PromiseOrValue<string>, overrides?: Overrides & {
        from?: PromiseOrValue<string>;
    }): Promise<PopulatedTransaction>;
}
